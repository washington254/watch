// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/webgi/dist/examples/runtime/bundle.m.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompressedTexture = exports.Compress = exports.CombinedPostPlugin = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClearcoatTintPlugin = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.ChromaticAberrationPlugin = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CapsuleBufferGeometry = exports.CanvasTexture = exports.CanvasSnipperPlugin = exports.CanvasSnipper = exports.CanvasRecorderPlugin = exports.CanvasRecorder = exports.CameraViewPlugin = exports.CameraView = exports.CameraUiPlugin = exports.CameraHelper = exports.CameraController = exports.Camera = exports.Cache = exports.CSS3DRendererPlugin = exports.CSGPluginBase = exports.CSGPluginBVH = exports.CSGPluginBSP = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxSelectionWidget = exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3B = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BloomPlugin = exports.BlobLoader = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BaseRenderer = exports.BaseGroundPlugin = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.AsyncZlib = exports.AsyncZipDeflate = exports.AsyncUnzlib = exports.AsyncUnzipInflate = exports.AsyncInflate = exports.AsyncGzip = exports.AsyncGunzip = exports.AsyncDeflate = exports.AsyncDecompress = exports.AsyncCompress = exports.AssetManagerPlugin = exports.AssetManagerBasicPopupPlugin = exports.AssetImporter = exports.AssetExporterPlugin = exports.AssetExporter = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnisotropyPlugin = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AmbientLightProbe = exports.AmbientLight2 = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.AddBlendPass = exports.AViewerPlugin = exports.ARTouchInputHelper = exports.ARPlugin = exports.ARPlacementBox = exports.AMaterialManager = exports.ACESFilmicToneMapping = void 0;
exports.GBufferPlugin = exports.FullScreenPlugin = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = exports.FrameFadePlugin = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FirstPersonControlsPlugin = exports.FirstPersonControls2 = exports.FilmicGrainPlugin = exports.FileLoader = exports.FSShadowMaterial = exports.FBXLoadPlugin = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EncodeUTF8 = exports.EllipseCurve3D = exports.EllipseCurve = exports.EffectComposer2 = exports.EdgesGeometry = exports.EasingFunctions = exports.EXRLoadPlugin = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DropzonePlugin = exports.Dropzone = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight2 = exports.DirectionalLight = exports.DiamondPlugin = exports.DiamondMaterial = exports.DeviceOrientationControlsPlugin = exports.DeviceOrientationControls2 = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthOfFieldPlugin = exports.DepthOfFieldPass = exports.DepthFormat = exports.Deflate = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.Decompress = exports.DecodeUTF8 = exports.DebugPlugin = exports.DataUtils = exports.DataUrlLoader = exports.DataTextureLoader = exports.DataTexture3D = exports.DataTexture2DArray = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Damper = exports.DRACOLoader2 = exports.DECAY_MILLISECONDS = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBumpMapPlugin = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeNormalsCaptureHelper = exports.CubeCamera = exports.ContactShadowGroundPlugin = exports.ConeGeometry = exports.ConeBufferGeometry = exports.CompressedTextureLoader = void 0;
exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LineSegments = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightsUiPlugin = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.LUTPlugin = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.KTXLoadPlugin = exports.KTX2LoadPlugin = exports.KHR_TEXTURE_BASISU = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.Inflate = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.Importer = exports.ImmediateRenderObject = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HierarchyUiPlugin = exports.HemisphereLightProbe = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.HDRiGroundPlugin = exports.Gzip = exports.Gunzip = exports.Group = exports.GroundPlugin = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GenericFilterPlugin = exports.GenericBlendTexturePass = exports.GammaCorrectionPlugin = exports.GammaCorrectionExtension = exports.GLTFWriter2 = exports.GLTFMeshOptPlugin = exports.GLTFMaterialsLightMapExtensionName = exports.GLTFMaterialsDisplacementMapExtensionName = exports.GLTFMaterialsBumpMapExtensionName = exports.GLTFMaterialsAlphaMapExtensionName = exports.GLTFLoader2 = exports.GLTFExporter2 = exports.GLTFDracoExporter = exports.GLTFDracoExportPlugin = exports.GLTFAnimationPlugin = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = void 0;
exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.ProgressivePlugin = exports.PresetLibraryPlugin = exports.PositionalAudio = exports.PopmotionPlugin = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointerLockControlsPlugin = exports.PointerLockControls2 = exports.PointLightHelper = exports.PointLight2 = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PickingPlugin = exports.PerspectiveCamera = exports.Path = exports.ParallaxMappingPlugin = exports.PMREMGeneratorPlugin = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OrbitControls3 = exports.OrbitControls2 = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectRotationPlugin = exports.ObjectProcessorMap = exports.ObjectPicker = exports.ObjectLoader2 = exports.ObjectLoader = exports.Object3DModel = exports.Object3D = exports.ObjMtlLoadPlugin = exports.OBJLoader2 = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalCaptureMaterial = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoiseBumpMaterialPlugin = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MultiFilterPlugin = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial2 = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial2 = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.MaterialPreviewGenerator = exports.MaterialManager = exports.MaterialLoader = exports.MaterialLibraryPlugin = exports.MaterialLibraryBasePlugin = exports.MaterialExtender = exports.MaterialConfiguratorPlugin = exports.MaterialConfiguratorBasePlugin = exports.Material = exports.MTLLoader2 = exports.MOUSE = void 0;
exports.SphereBufferGeometry = exports.Sphere = exports.Source = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.SimpleViewerUi = exports.SimpleTextPlugin = exports.SimpleTextExporter = exports.SimpleJSONLoader = exports.SimpleJSONExporter = exports.SimpleEventDispatcher = exports.SimpleDataSource = exports.SimpleBackgroundEnvUiPlugin = exports.SimpleAssetList = exports.ShortType = exports.ShapeUtils = exports.ShapeTubeExtrudePlugin = exports.ShapePath = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.Shape = exports.ShadowMaterial = exports.ShadowMapBaker = exports.ShaderPass2 = exports.ShaderMaterialEncodingSupport = exports.ShaderMaterial2 = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.SelectionWidget = exports.SceneLoopPlugin = exports.SceneCamerasUiPlugin = exports.Scene = exports.STLLoadPlugin = exports.SSRPlugin = exports.SSGIPlugin = exports.SSContactShadows = exports.SSAOPlugin = exports.SRGBColorSpace = exports.SETTLING_TIME = exports.RootScene = exports.RingGeometry = exports.RingBufferGeometry = exports.Rhino3dmLoader2 = exports.Rhino3dmLoadPlugin = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.RendererUiPlugin = exports.ReinhardToneMapping = exports.Reflector2 = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RandomizedDirectionalLightPlugin = exports.RandomizedDirectionalLight = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding_ = exports.RGBM16Encoding = exports.RGBFormat = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = void 0;
exports.ZipPassThrough = exports.ZipLoader = exports.ZipDeflate = exports.Zip = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WindowiseDialogPlugin = exports.WebGiViewerElement = exports.WebGLUtils = exports.WebGLRenderer = exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.WebGL1Renderer = exports.VignettePlugin = exports.ViewerState = exports.ViewerApp = exports.VideoTexture = exports.VelocityBufferPlugin = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.Unzlib = exports.UnzipPassThrough = exports.UnzipInflate = exports.Unzip = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.UniformsGroup = exports.Uniform = exports.Uncharted2Tonemapping = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TweakpaneWrapper = exports.TweakpaneUiPlugin = exports.TubeShapeGeometry = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TransformControls2 = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TonemapPlugin = exports.ThreeMaterialLoader = exports.ThinFilmLayerPlugin = exports.TextureLoader = exports.Texture = exports.TextSVGOptions = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TemporalAAPlugin = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SwitchNodePlugin = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight2 = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereSelectionWidget = exports.SphereGeometry = void 0;
exports.embedUrlRefs = exports.easeOut = exports.easeInOut = exports.easeIn = exports.downloadFile = exports.downloadBlob = exports.distance = exports.diamondMaterialPropList = exports.detectOverflow = exports.deserializers = exports.deserializeObject = exports.degreesToRadians = exports.deflateSync = exports.deflate = exports.deepAccessObject = exports.decompressSync = exports.decompress = exports.decay = exports.dataTextureFromVec4 = exports.dataTextureFromColor = exports.cubicBezier = exports.css = exports.csgOperations = exports.createStyles = exports.createScriptFromURL = exports.createRenderTargetKey = exports.createPopperLite = exports.createPopperBase = exports.createPopper = exports.createImage = exports.createIFrameCSS3DObject = exports.createExpoIn = exports.createDiv = exports.createCanvasElement = exports.createBackIn = exports.createAttractor = exports.createAnticipate = exports.copyTextureUserData = exports.copyProps = exports.copyObject3DUserData = exports.copyMaterialUserData = exports.computeStyles = exports.computeScreenSpaceBoundingBox = exports.computeOffsetMatrix = exports.computeGeometrySize = exports.computeGeometryCenter = exports.computeEigenVectors = exports.computeAverageGeometryNormal = exports.compressSync = exports.compress = exports.combineDofShader = exports.clippingParents = exports.clamp = exports.circOut = exports.circInOut = exports.circIn = exports.cRGBMToLinear = exports.cLinearToRGBM = exports.buildCSGMeshBVH = exports.buildCSGMeshBSP = exports.bounceOut = exports.bounceInOut = exports.bounceIn = exports.bottom = exports.blobToDataURL = exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basicMaterialPropList = exports.basePlacements = exports.backOut = exports.backInOut = exports.backIn = exports.autoScaleObject3D = exports.autoCenterObject3D = exports.auto = exports.attractExpo = exports.attract = exports.arrow = exports.applyStyles = exports.applyOffset = exports.anticipate = exports.animateTarget = exports.animateSet = exports.animatePromise = exports.animateObject = exports.animateAsync = exports.animate = exports.angle = exports.afterWrite = exports.afterRead = exports.afterMain = exports.addZipLoader = exports.addRGBELoader = exports.addGLTFLoader = exports.addGLTFExporter = exports.addDracoLoader = exports.addBasePlugins = exports._SRGBAFormat = exports.Zlib = void 0;
exports.setMeshGeometry = exports.serializers = exports.serializeObject = exports.serialize = exports.serializable = exports.safeSetProperty = exports.sRGBEncoding = exports.rotateDuplicatedMesh = exports.right = exports.reverseEasing = exports.replaceAll = exports.removeDuplicateGeometries = exports.reference = exports.read = exports.radiansToDegrees = exports.progress = exports.processViewer = exports.preventOverflow = exports.popperOffsets = exports.popperGenerator = exports.popper = exports.pointFromVector = exports.placements = exports.pipe = exports.physicalMaterialPropList = exports.pathJoin = exports.patchShaderEncodingSupport = exports.parseFileExtension = exports.onChange = exports.offset = exports.now = exports.modifierPhases = exports.mobileAndTabletCheck = exports.mixComplex = exports.mixColor = exports.mix = exports.mirrorEasing = exports.matDefine = exports.makeTextSvg = exports.makeSetterForAnimObject = exports.makeSetterFor = exports.makeSamplerUi = exports.makeFilter = exports.makeColorSvgCircle = exports.makeColorSvg = exports.main = exports.linear = exports.lerpAngle2 = exports.lerpAngle = exports.left = exports.keyframes = exports.isPropertyWritable = exports.isPoint3D = exports.isPoint = exports.isAnimatableType = exports.interpolate = exports.inflateSync = exports.inflate = exports.inertia = exports.includesAll = exports.imageUrlToImageData = exports.imageToCanvas = exports.imageBitmapToBase64 = exports.iTextureIgnoredUserData = exports.iModelIgnoredUserData = exports.iMaterialIgnoredUserData = exports.iGeometryIgnoredUserData = exports.htmlToSvg = exports.htmlToPng = exports.htmlToCanvas = exports.html = exports.hide = exports.gzipSync = exports.gzip = exports.gunzipSync = exports.gunzip = exports.glsl = exports.getUrlQueryParam = exports.getTextureEncodingFromMap = exports.getTextureDataType = exports.getTexelEncodingFunction = exports.getTexelEncoding = exports.getTexelDecodingFunction = exports.getTexelDecoding2 = exports.getTexelDecoding = exports.getPropertyDescriptor = exports.getOrCall = exports.getKeyByValue = exports.getFilenameFromPath = exports.getEncodingComponents = exports.generateUiFolder = exports.generateUiConfig = exports.fontFormatExtensionMap = exports.flip = exports.flattenUiConfig = exports.extractAnimationKey = exports.eventListeners = exports.escapeRegExp = exports.envMapBackground = exports.end = void 0;
exports.zlibSync = exports.zlib = exports.zipSync = exports.zip = exports.writeFile = exports.write = exports.wrap = exports.webgiObject3DExtrasExtension = exports.webgiMaterialExtrasExtension = exports.webgiLightExtrasExtension = exports.viewport = exports.viewerGLTFExtension = exports.verifyPermission = exports.velocityPerSecond = exports.velocityPerFrame = exports.variationPlacements = exports.vRGBMToLinear = exports.vLinearToRGBM = exports.uploadFile = exports.unzlibSync = exports.unzlib = exports.unzipSync = exports.unzip = exports.uniform = exports.uiVector = exports.uiToggle = exports.uiSlider = exports.uiMonitor = exports.uiInput = exports.uiImage = exports.uiFolder = exports.uiDropdown = exports.uiConfig = exports.uiColor = exports.uiButton = exports.top = exports.toTitleCase = exports.toIndexedGeometry = exports.toDecimal = exports.timeout = exports.syncAnimSetUi = exports.svgUrl = exports.svgToPng = exports.svgToCanvas = exports.strToU8 = exports.strFromU8 = exports.steps = exports.start = exports.standardMaterialPropList = exports.spring = exports.sphericalFromObject = exports.snapObject = exports.snap = exports.smoothFrame = exports.smooth = exports.slerp = exports.shaderReplaceString = exports.setupSandboxWebGiEditor = exports.setupObject3dModel = exports.setupIModel = exports.setupCoreWebGiViewer = exports.setUrlQueryParam = exports.setThreeRendererMode = exports.setMeshMaterial = void 0;
/*! For license information please see bundle.m.js.LICENSE.txt */
var __webpackgi_modules__ = {
    798: function (e, t, r) {
      var n = r(352),
        i = r.n(n)()(function (e) {
          return e[1];
        });
      i.push([e.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);color:#fff;background-blend-mode:luminosity;background-color:#28223CAA;padding:1.5rem;font-size:1rem;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-webkit-max-content;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", ""]), t.Z = i;
    },
    898: function (e, t, r) {
      var n = r(352),
        i = r.n(n)()(function (e) {
          return e[1];
        });
      i.push([e.id, ':root{--tp-blade-unit-size: 24px;--tp-element-border-radius: 0.25rem;--tp-base-background-color: #28223C;--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);--tp-button-background-color: hsla(230, 10%, 80%, 1.00);--tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);--tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);--tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);--tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);--tp-container-background-color: hsla(230, 25%, 16%, 0.65);--tp-container-background-color-active: hsla(230, 25%, 31%, 0.65);--tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);--tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);--tp-container-foreground-color: hsl(240, 10%, 92%);--tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);--tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);--tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);--tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);--tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);--tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);--tp-label-foreground-color: #E4E2ED;--tp-font-family: "Inter"}.tp-fldv{margin-top:.25rem;margin-bottom:.25rem;background-blend-mode:luminosity;position:relative}.tp-fldv .tp-fldv{margin-top:.5rem;margin-bottom:.5rem}.tp-fldv .tp-brkv{background-color:rgba(32,32,50,.85)}.tp-fldv .tp-fldv .tp-brkv{background-color:rgba(32,32,50,.25) !important}.tp-fldv-expanded>.tp-fldv_b{background-color:rgba(32,32,50,.8) !important}.tp-fldv_b{height:calc(var(--bld-us)*1.5 + 4px) !important;font-size:.85rem !important}.tp-fldv_b+.tp-brkv .tp-fldv_b{height:calc(var(--bld-us)*1.1 + 4px) !important;font-size:.65rem !important}.tp-lblv_l{font-size:.7rem !important;font-weight:400 !important;flex-grow:1 !important;flex-basis:20% !important}.tp-lblv_v{flex-grow:1 !important;flex-basis:50% !important}.tp-txtv_i{font-size:.7rem !important;font-weight:400 !important}.tp-fldv_t{font-weight:400 !important;padding-left:1.5rem !important}.tp-fldv_m{right:auto !important;left:.75rem;opacity:1 !important}.pluginOptionsButton{position:absolute;right:0;top:.75rem;padding-left:.5rem;padding-right:.5rem;height:-webkit-min-content;height:-moz-min-content;height:min-content;background:transparent;color:#eee;border:none}', ""]), t.Z = i;
    },
    513: function (e, t, r) {
      var n = r(352),
        i = r.n(n)()(function (e) {
          return e[1];
        });
      i.push([e.id, ".wwise-perspective{perspective:1000px;position:fixed;left:0;top:0;width:100vw;height:100vh}.wwise-wrapper{position:fixed;width:0;height:0;font-weight:400}.wwise-wrapper.v-center{top:50%}.wwise-wrapper.h-center{left:50%}.wwise-wrapper.left{left:0}.wwise-wrapper.right{right:0}.wwise-wrapper.top{top:0}.wwise-wrapper.bottom{bottom:0}.wwise *.preset{color:#fafafa}.wwise *.preset.ok{background:rgba(45,193,80,.95)}.wwise *.preset.error{background:rgba(190,17,51,.95)}.wwise *.preset.info{background:rgba(40,34,60,.95)}.wwise *.preset.caution{background:rgba(239,128,0,.95)}.wwise-no-scroll{position:relative;overflow:hidden}.wwise-overlay{position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(50,50,50,.5)}.wwise{position:absolute;left:0;top:0;display:flex;flex-direction:column;border-radius:5px;box-shadow:1px 1px 10px rgba(150,150,150,.5);box-sizing:border-box}.wwise.no-radius{border-radius:0}.wwise *{box-sizing:border-box}.wwise .clear{clear:both}.wwise>.content{padding:0;margin:0;flex-grow:1;border-radius:0 0 4px 4px;background:#fff;color:#333;box-shadow:0 1px 3px rgba(200,200,200,.5) inset}.wwise>.content.no-topbar{border-radius:4px;box-shadow:none}.wwise.no-radius>.content,.wwise.no-radius>.content.no-topbar{border-radius:0}.wwise .modal>.main{width:90vw;max-width:400px;border-radius:4px 4px 0 0;text-align:center;padding-bottom:10px;color:#fff}.wwise .modal>.main .icon{display:block;margin:0 auto;fill:#fff;width:100px}.wwise .modal>.main .title{font-size:30px}.wwise .modal>.main .text{margin:10px 0;font-weight:300;font-size:16px}.wwise .modal>.main.no-op{border-radius:4px}.wwise .modal>.main.ok{background:#2dc150}.wwise .modal>.main.error{background:#be1133}.wwise .modal>.main.info{background:#28223c}.wwise .modal>.main.caution{background:#ef8000}.wwise .modal>.operation .button-wrapper{text-align:center;margin:30px 0 20px 0}.wwise .modal>.operation .button{display:inline-block;line-height:18px;padding:8px 10px;margin:0 15px;line-height:18px;width:100px;border-radius:4px;border:1px solid #eee;box-shadow:1px 1px 3px rgba(220,220,220,.8);color:#555;transition:all ease .2s}.wwise .modal>.operation .button:hover{background:#f5f5f5;cursor:pointer}.wwise .modal>.operation .button.main{color:#fff}.wwise .modal>.operation.ok .main{background:#2dc150}.wwise .modal>.operation.ok .main:hover{background:#23983f}.wwise .modal>.operation.error .main{background:#be1133}.wwise .modal>.operation.error .main:hover{background:#8f0d26}.wwise .modal>.operation.info .main{background:#28223c}.wwise .modal>.operation.info .main:hover{background:#12101b}.wwise .modal>.operation.caution .main{background:#ef8000}.wwise .modal>.operation.caution .main:hover{background:#bc6500}.wwise .input-wrapper{margin:15px auto -15px auto}.wwise .input-wrapper .input{display:block;margin:0 auto;width:95%;max-width:300px;outline:none;border:none;background:#f3f3f3;padding:15px;font-size:16px;border-radius:5px}.wwise .input-wrapper .error{width:95%;text-align:center;margin-top:10px;color:red}div:has(>.wwise-wrapper){position:absolute !important}.wwise-wrapper{position:absolute !important}.wwise .modal>.main{padding-top:10px}", ""]), t.Z = i;
    },
    476: function (e) {
      var t;
      t = function () {
        return function (e) {
          var t = {};
          function r(n) {
            if (t[n]) return t[n].exports;
            var i = t[n] = {
              i: n,
              l: !1,
              exports: {}
            };
            return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
          }
          return r.m = e, r.c = t, r.i = function (e) {
            return e;
          }, r.d = function (e, t, n) {
            r.o(e, t) || Object.defineProperty(e, t, {
              configurable: !1,
              enumerable: !0,
              get: n
            });
          }, r.n = function (e) {
            var t = e && e.__esModule ? function () {
              return e.default;
            } : function () {
              return e;
            };
            return r.d(t, "a", t), t;
          }, r.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }, r.p = "", r(r.s = 5);
        }([function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          });
          var n = {
            convertToObject: function (e) {
              var t = e.substring(e.indexOf("{") + 1).trim().slice(0, -1),
                r = {};
              return t.split(";").map(function (e) {
                if (e = e.trim()) {
                  var t = e.split(":");
                  r[t[0].trim()] = t[1].trim();
                }
              }), r;
            },
            getFromSheets: function (e) {
              var t = document.styleSheets;
              for (var r in t) {
                var i = null;
                try {
                  i = t[r].rules || t[r].cssRules;
                } catch (e) {}
                if (i) for (var s in i) if (i[s].selectorText && -1 != i[s].selectorText.split(",").indexOf(e)) return i[s].cssText ? n.convertToObject(i[s].cssText) : n.convertToObject(i[s].style.cssText);
              }
              return {};
            },
            getPropertyDefault: function (e) {
              return "timing-function" == e ? "ease" : "iteration-count" == e ? 1 : "direction" == e ? "normal" : "fill-mode" == e ? "none" : null;
            }
          };
          t.default = n;
        }, function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          });
          var n = {
            generateId: function () {
              for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = 0; r < 8; ++r) e += t.charAt(Math.floor(Math.random() * t.length));
              return e;
            },
            frameToString: function (e) {
              var t = "";
              for (var r in e) t += r + ":" + e[r] + ";";
              return t;
            },
            convertTimeToMs: function (e) {
              if (!e) return 0;
              if ("number" == typeof e) return e;
              var t = parseFloat(e);
              return -1 != e.indexOf("ms") ? t : 1e3 * t;
            },
            prefixes: ["", "-webkit-", "-moz-", "-o-"]
          };
          t.default = n;
        }, function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          });
          var n,
            i = (n = r(0)) && n.__esModule ? n : {
              default: n
            };
          t.default = function e(t, r) {
            if (function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, e), this.styles = "string" == typeof t ? i.default.getFromSheets(t) : t, "string" == typeof r) {
              var n = i.default.getFromSheets(r);
              for (var s in this.options = {}, n) this.options[s.replace("animation-", "")] = n[s];
            } else this.options = "number" == typeof r ? {
              duration: r
            } : r;
          };
        }, function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          });
          var n = function () {
              function e(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var n = t[r];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
              }
              return function (t, r, n) {
                return r && e(t.prototype, r), n && e(t, n), t;
              };
            }(),
            i = a(r(4)),
            s = a(r(1)),
            o = a(r(0));
          function a(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var l = function () {
            function e(t, r, n, i) {
              if (function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
              }(this, e), t.constructor === Array ? this.doms = t : this.doms = [t], r.constructor === Array ? this.frames = r : this.frames = [r], this.options = {
                startFrom: 0,
                pauseAt: [],
                prefix: !1,
                count: 1,
                clear: !0,
                applyOnEnd: !1,
                instant: !1
              }, null != n && null != n) if ("boolean" == typeof n) this.options.instant = n;else if ("number" == typeof n) this.options.count = n, "boolean" == typeof i && (this.options.instant = i);else for (var o in n) "pauseAt" == o && n.pauseAt.constructor !== Array ? this.options[o] = [n[o]] : this.options[o] = n[o];
              for (var a in this.promiseSupported = "undefined" != typeof Promise && -1 !== Promise.toString().indexOf("[native code]"), this.countRemainder = [], this.animations = [], this.styleDoms = [], this.superSets = [], this.eventHandler = [], this.options.prefix ? this.prefixes = s.default.prefixes : this.prefixes = [""], t) this.countRemainder[a] = this.options.count - 1;
              this.options.instant && this.play();
            }
            return n(e, [{
              key: "play",
              value: function () {
                var e = this;
                for (var t in this.clear(), this.promiseSupported && (this.promise = new Promise(function (t) {
                  e.promiseResolve = t;
                })), this.doms) {
                  var r = this.makeAnimation(this.doms[t]);
                  this.animations[t] = r.names, this.styleDoms[t] = r.styleDom, this.superSets[t] = this.makeSuperSet(this.doms[t], this.animations[t]), this.playAnimation(this.doms[t], this.superSets[t]), this.eventHandler[t] = this.handleAnimationEnd.bind(this, t), this.doms[t].addEventListener("animationend", this.eventHandler[t]);
                }
                if (this.promiseSupported) return this.promise;
              }
            }, {
              key: "clear",
              value: function (e) {
                if (!e) {
                  for (var t in this.doms) this.clear(t);
                  return this.animationEnded = 0, this.promise = void 0, void (this.promiseResolve = void 0);
                }
                var r = this.styleDoms[e];
                for (var n in r && r.parentNode && r.parentNode.removeChild(r), this.superSets[e]) for (var i in this.prefixes) this.doms[e].style[this.prefixes[i] + "animation-" + n] = null;
                for (var s in this.prefixes) this.doms[e].style[this.prefixes[s] + "animation-play-state"] = null;
                this.doms[e].removeEventListener("animationend", this.eventHandler[e]), this.countRemainder[e] = this.options.count - 1;
              }
            }, {
              key: "replay",
              value: function (e) {
                var t = this.doms[e],
                  r = t.cloneNode(!0);
                t.parentNode.replaceChild(r, t), this.doms[e].removeEventListener("animationend", this.eventHandler[e]), this.doms[e] = r, this.doms[e].addEventListener("animationend", this.eventHandler[e]);
              }
            }, {
              key: "pause",
              value: function () {
                for (var e in this.doms) this.pauseDom(this.doms[e]);
              }
            }, {
              key: "resume",
              value: function () {
                for (var e in this.doms) this.resumeDom(this.doms[e]);
              }
            }, {
              key: "getPromise",
              value: function () {
                return this.promise;
              }
            }, {
              key: "handleAnimationEnd",
              value: function (e, t) {
                var r = t.animationName,
                  n = r.substring(r.lastIndexOf("-") + 1);
                this.options.pauseAt.includes(parseInt(n)) && this.pauseDom(this.doms[e]), n == this.frames.length && (-1 == this.countRemainder[e] ? this.replay(e) : this.countRemainder[e] > 0 ? (this.countRemainder[e]--, this.replay(e)) : (this.options.applyOnEnd && this.applyOnEnd(e), this.animationEnded++, this.animationEnded == this.doms.length && (this.promiseSupported && this.promiseResolve(), this.options.clear && this.clear())));
              }
            }, {
              key: "pauseDom",
              value: function (e) {
                for (var t in this.prefixes) e.style[this.prefixes[t] + "animation-play-state"] = "paused";
              }
            }, {
              key: "resumeDom",
              value: function (e) {
                for (var t in this.prefixes) e.style[this.prefixes[t] + "animation-play-state"] = "running";
              }
            }, {
              key: "applyOnEnd",
              value: function (e) {
                var t = this.newFrames[this.frames.length];
                for (var r in t) this.doms[e].style[r] = t[r];
              }
            }, {
              key: "makeAnimation",
              value: function (e) {
                var t = {},
                  r = [],
                  n = {};
                for (var s in this.frames) for (var o in r.push(this.frames[s].styles), r[s]) n[o] = !0;
                var a = window.getComputedStyle(e);
                for (var l in n) t[l] = a[l];
                r.unshift(t);
                for (var c = [r[0]], u = 1; u < r.length; ++u) {
                  var h = JSON.parse(JSON.stringify(c[u - 1]));
                  for (var p in r[u]) h[p] = r[u][p];
                  c.push(h);
                }
                return this.newFrames = c, i.default.make(c, this.prefixes);
              }
            }, {
              key: "makeSuperSet",
              value: function (e, t) {
                var r = 0,
                  n = {};
                for (var i in this.frames) for (var a in this.frames[i].options) n[a] = "";
                n.name = "", n.duration = "", n.delay = "";
                for (var l = 0; l < this.frames.length; ++l) {
                  if (l) for (var c in n) n[c] += ",";
                  var u = s.default.convertTimeToMs(this.frames[l].options.duration),
                    h = s.default.convertTimeToMs(this.frames[l].options.delay);
                  for (var p in l < this.options.startFrom && (u = 0, h = 0), n.name += t[l], n.duration += u + "ms", n.delay += r + h + "ms", n) "name" != p && "duration" != p && "delay" != p && (n[p] += this.frames[l].options[p] ? this.frames[l].options[p] : o.default.getPropertyDefault(p));
                  var d = this.frames[l].options["iteration-count"];
                  r += u * parseInt(d || 1) + h;
                }
                return n;
              }
            }, {
              key: "playAnimation",
              value: function (e, t) {
                for (var r in t) for (var n in this.prefixes) e.style[this.prefixes[n] + "animation-" + r] = t[r];
                this.options.pauseAt.includes(0) && this.pauseDom(e);
              }
            }]), e;
          }();
          t.default = l;
        }, function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          });
          var n,
            i = (n = r(1)) && n.__esModule ? n : {
              default: n
            },
            s = {
              make: function (e, t) {
                for (var r = [], n = "", o = "atr-" + i.default.generateId(), a = document.createElement("style"), l = 0; l < e.length - 1; ++l) r.push(o + "-" + (l + 1)), n += s.makeFromTwoFrames(e[l], e[l + 1], r[l], t);
                return a.innerHTML = n, a.class = "foo", document.getElementsByTagName("head")[0].appendChild(a), {
                  names: r,
                  styleDom: a
                };
              },
              makeFromTwoFrames: function (e, t, r, n) {
                var s = "";
                for (var o in n) s += "@" + n[o] + "keyframes " + r + " {", s += "0%", s += "{" + i.default.frameToString(e) + "}", s += "100%", s += "{" + i.default.frameToString(t) + "}", s += "}";
                return s;
              }
            };
          t.default = s;
        }, function (e, t, r) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.Queue = t.Frame = void 0;
          var n = s(r(2)),
            i = s(r(3));
          function s(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          t.Frame = n.default, t.Queue = i.default;
        }]);
      }, e.exports = t();
    },
    352: function (e) {
      e.exports = function (e) {
        var t = [];
        return t.toString = function () {
          return this.map(function (t) {
            var r = e(t);
            return t[2] ? "@media ".concat(t[2], " {").concat(r, "}") : r;
          }).join("");
        }, t.i = function (e, r, n) {
          "string" == typeof e && (e = [[null, e, ""]]);
          var i = {};
          if (n) for (var s = 0; s < this.length; s++) {
            var o = this[s][0];
            null != o && (i[o] = !0);
          }
          for (var a = 0; a < e.length; a++) {
            var l = [].concat(e[a]);
            n && i[l[0]] || (r && (l[2] ? l[2] = "".concat(r, " and ").concat(l[2]) : l[2] = r), t.push(l));
          }
        }, t;
      };
    },
    388: function (e) {
      e.exports = function e(t, r, n) {
        function i(o, a) {
          if (!r[o]) {
            if (!t[o]) {
              if (s) return s(o, !0);
              throw new Error("Cannot find module '" + o + "'");
            }
            var l = r[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function (e) {
              return i(t[o][1][e] || e);
            }, l, l.exports, e, t, r, n);
          }
          return r[o].exports;
        }
        for (var s = void 0, o = 0; o < n.length; o++) i(n[o]);
        return i;
      }({
        1: [function (e, t, r) {
          (function (n, i, s, o, a, l, c, u, h) {
            var p = e("crypto");
            function d(e, t) {
              return function (e, t) {
                var r;
                if (void 0 === (r = "passthrough" !== t.algorithm ? p.createHash(t.algorithm) : new A()).write && (r.write = r.update, r.end = r.update), v(t, r).dispatch(e), r.update || r.end(""), r.digest) return r.digest("buffer" === t.encoding ? void 0 : t.encoding);
                var n = r.read();
                return "buffer" !== t.encoding ? n.toString(t.encoding) : n;
              }(e, t = _(e, t));
            }
            (r = t.exports = d).sha1 = function (e) {
              return d(e);
            }, r.keys = function (e) {
              return d(e, {
                excludeValues: !0,
                algorithm: "sha1",
                encoding: "hex"
              });
            }, r.MD5 = function (e) {
              return d(e, {
                algorithm: "md5",
                encoding: "hex"
              });
            }, r.keysMD5 = function (e) {
              return d(e, {
                algorithm: "md5",
                encoding: "hex",
                excludeValues: !0
              });
            };
            var f = p.getHashes ? p.getHashes().slice() : ["sha1", "md5"];
            f.push("passthrough");
            var m = ["buffer", "hex", "binary", "base64"];
            function _(e, t) {
              t = t || {};
              var r = {};
              if (r.algorithm = t.algorithm || "sha1", r.encoding = t.encoding || "hex", r.excludeValues = !!t.excludeValues, r.algorithm = r.algorithm.toLowerCase(), r.encoding = r.encoding.toLowerCase(), r.ignoreUnknown = !0 === t.ignoreUnknown, r.respectType = !1 !== t.respectType, r.respectFunctionNames = !1 !== t.respectFunctionNames, r.respectFunctionProperties = !1 !== t.respectFunctionProperties, r.unorderedArrays = !0 === t.unorderedArrays, r.unorderedSets = !1 !== t.unorderedSets, r.unorderedObjects = !1 !== t.unorderedObjects, r.replacer = t.replacer || void 0, r.excludeKeys = t.excludeKeys || void 0, void 0 === e) throw new Error("Object argument required.");
              for (var n = 0; n < f.length; ++n) f[n].toLowerCase() === r.algorithm.toLowerCase() && (r.algorithm = f[n]);
              if (-1 === f.indexOf(r.algorithm)) throw new Error('Algorithm "' + r.algorithm + '"  not supported. supported values: ' + f.join(", "));
              if (-1 === m.indexOf(r.encoding) && "passthrough" !== r.algorithm) throw new Error('Encoding "' + r.encoding + '"  not supported. supported values: ' + m.join(", "));
              return r;
            }
            function g(e) {
              if ("function" == typeof e) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e));
            }
            function v(e, t, r) {
              function n(e) {
                return t.update ? t.update(e, "utf8") : t.write(e, "utf8");
              }
              return r = r || [], {
                dispatch: function (t) {
                  return e.replacer && (t = e.replacer(t)), this["_" + (null === t ? "null" : typeof t)](t);
                },
                _object: function (t) {
                  var i,
                    o = Object.prototype.toString.call(t),
                    a = /\[object (.*)\]/i.exec(o);
                  if (a = (a = a ? a[1] : "unknown:[" + o + "]").toLowerCase(), 0 <= (i = r.indexOf(t))) return this.dispatch("[CIRCULAR:" + i + "]");
                  if (r.push(t), void 0 !== s && s.isBuffer && s.isBuffer(t)) return n("buffer:"), n(t);
                  if ("object" === a || "function" === a || "asyncfunction" === a) {
                    var l = Object.keys(t);
                    e.unorderedObjects && (l = l.sort()), !1 === e.respectType || g(t) || l.splice(0, 0, "prototype", "__proto__", "constructor"), e.excludeKeys && (l = l.filter(function (t) {
                      return !e.excludeKeys(t);
                    })), n("object:" + l.length + ":");
                    var c = this;
                    return l.forEach(function (r) {
                      c.dispatch(r), n(":"), e.excludeValues || c.dispatch(t[r]), n(",");
                    });
                  }
                  if (!this["_" + a]) {
                    if (e.ignoreUnknown) return n("[" + a + "]");
                    throw new Error('Unknown object type "' + a + '"');
                  }
                  this["_" + a](t);
                },
                _array: function (t, i) {
                  i = void 0 !== i ? i : !1 !== e.unorderedArrays;
                  var s = this;
                  if (n("array:" + t.length + ":"), !i || t.length <= 1) return t.forEach(function (e) {
                    return s.dispatch(e);
                  });
                  var o = [],
                    a = t.map(function (t) {
                      var n = new A(),
                        i = r.slice();
                      return v(e, n, i).dispatch(t), o = o.concat(i.slice(r.length)), n.read().toString();
                    });
                  return r = r.concat(o), a.sort(), this._array(a, !1);
                },
                _date: function (e) {
                  return n("date:" + e.toJSON());
                },
                _symbol: function (e) {
                  return n("symbol:" + e.toString());
                },
                _error: function (e) {
                  return n("error:" + e.toString());
                },
                _boolean: function (e) {
                  return n("bool:" + e.toString());
                },
                _string: function (e) {
                  n("string:" + e.length + ":"), n(e.toString());
                },
                _function: function (t) {
                  n("fn:"), g(t) ? this.dispatch("[native]") : this.dispatch(t.toString()), !1 !== e.respectFunctionNames && this.dispatch("function-name:" + String(t.name)), e.respectFunctionProperties && this._object(t);
                },
                _number: function (e) {
                  return n("number:" + e.toString());
                },
                _xml: function (e) {
                  return n("xml:" + e.toString());
                },
                _null: function () {
                  return n("Null");
                },
                _undefined: function () {
                  return n("Undefined");
                },
                _regexp: function (e) {
                  return n("regex:" + e.toString());
                },
                _uint8array: function (e) {
                  return n("uint8array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _uint8clampedarray: function (e) {
                  return n("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _int8array: function (e) {
                  return n("uint8array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _uint16array: function (e) {
                  return n("uint16array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _int16array: function (e) {
                  return n("uint16array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _uint32array: function (e) {
                  return n("uint32array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _int32array: function (e) {
                  return n("uint32array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _float32array: function (e) {
                  return n("float32array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _float64array: function (e) {
                  return n("float64array:"), this.dispatch(Array.prototype.slice.call(e));
                },
                _arraybuffer: function (e) {
                  return n("arraybuffer:"), this.dispatch(new Uint8Array(e));
                },
                _url: function (e) {
                  return n("url:" + e.toString());
                },
                _map: function (t) {
                  n("map:");
                  var r = Array.from(t);
                  return this._array(r, !1 !== e.unorderedSets);
                },
                _set: function (t) {
                  n("set:");
                  var r = Array.from(t);
                  return this._array(r, !1 !== e.unorderedSets);
                },
                _file: function (e) {
                  return n("file:"), this.dispatch([e.name, e.size, e.type, e.lastModfied]);
                },
                _blob: function () {
                  if (e.ignoreUnknown) return n("[blob]");
                  throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
                },
                _domwindow: function () {
                  return n("domwindow");
                },
                _bigint: function (e) {
                  return n("bigint:" + e.toString());
                },
                _process: function () {
                  return n("process");
                },
                _timer: function () {
                  return n("timer");
                },
                _pipe: function () {
                  return n("pipe");
                },
                _tcp: function () {
                  return n("tcp");
                },
                _udp: function () {
                  return n("udp");
                },
                _tty: function () {
                  return n("tty");
                },
                _statwatcher: function () {
                  return n("statwatcher");
                },
                _securecontext: function () {
                  return n("securecontext");
                },
                _connection: function () {
                  return n("connection");
                },
                _zlib: function () {
                  return n("zlib");
                },
                _context: function () {
                  return n("context");
                },
                _nodescript: function () {
                  return n("nodescript");
                },
                _httpparser: function () {
                  return n("httpparser");
                },
                _dataview: function () {
                  return n("dataview");
                },
                _signal: function () {
                  return n("signal");
                },
                _fsevent: function () {
                  return n("fsevent");
                },
                _tlswrap: function () {
                  return n("tlswrap");
                }
              };
            }
            function A() {
              return {
                buf: "",
                write: function (e) {
                  this.buf += e;
                },
                end: function (e) {
                  this.buf += e;
                },
                read: function () {
                  return this.buf;
                }
              };
            }
            r.writeToStream = function (e, t, r) {
              return void 0 === r && (r = t, t = {}), v(t = _(e, t), r).dispatch(e);
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
        }, {
          buffer: 3,
          crypto: 5,
          lYpoI2: 10
        }],
        2: [function (e, t, r) {
          (function (e, t, n, i, s, o, a, l, c) {
            !function (e) {
              var t = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                r = "+".charCodeAt(0),
                n = "/".charCodeAt(0),
                i = "0".charCodeAt(0),
                s = "a".charCodeAt(0),
                o = "A".charCodeAt(0),
                a = "-".charCodeAt(0),
                l = "_".charCodeAt(0);
              function c(e) {
                var t = e.charCodeAt(0);
                return t === r || t === a ? 62 : t === n || t === l ? 63 : t < i ? -1 : t < i + 10 ? t - i + 26 + 26 : t < o + 26 ? t - o : t < s + 26 ? t - s + 26 : void 0;
              }
              e.toByteArray = function (e) {
                var r, n;
                if (0 < e.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
                var i = e.length,
                  s = "=" === e.charAt(i - 2) ? 2 : "=" === e.charAt(i - 1) ? 1 : 0,
                  o = new t(3 * e.length / 4 - s),
                  a = 0 < s ? e.length - 4 : e.length,
                  l = 0;
                function u(e) {
                  o[l++] = e;
                }
                for (r = 0; r < a; r += 4, 0) u((16711680 & (n = c(e.charAt(r)) << 18 | c(e.charAt(r + 1)) << 12 | c(e.charAt(r + 2)) << 6 | c(e.charAt(r + 3)))) >> 16), u((65280 & n) >> 8), u(255 & n);
                return 2 == s ? u(255 & (n = c(e.charAt(r)) << 2 | c(e.charAt(r + 1)) >> 4)) : 1 == s && (u((n = c(e.charAt(r)) << 10 | c(e.charAt(r + 1)) << 4 | c(e.charAt(r + 2)) >> 2) >> 8 & 255), u(255 & n)), o;
              }, e.fromByteArray = function (e) {
                var t,
                  r,
                  n,
                  i,
                  s = e.length % 3,
                  o = "";
                function a(e) {
                  return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e);
                }
                for (t = 0, n = e.length - s; t < n; t += 3) o += a((i = r = (e[t] << 16) + (e[t + 1] << 8) + e[t + 2]) >> 18 & 63) + a(i >> 12 & 63) + a(i >> 6 & 63) + a(63 & i);
                switch (s) {
                  case 1:
                    o += a((r = e[e.length - 1]) >> 2), o += a(r << 4 & 63), o += "==";
                    break;
                  case 2:
                    o += a((r = (e[e.length - 2] << 8) + e[e.length - 1]) >> 10), o += a(r >> 4 & 63), o += a(r << 2 & 63), o += "=";
                }
                return o;
              };
            }(void 0 === r ? this.base64js = {} : r);
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
        }, {
          buffer: 3,
          lYpoI2: 10
        }],
        3: [function (e, t, r) {
          (function (t, n, i, s, o, a, l, c, u) {
            var h = e("base64-js"),
              p = e("ieee754");
            function i(e, t, r) {
              if (!(this instanceof i)) return new i(e, t, r);
              var n,
                s,
                o,
                a,
                l,
                c = typeof e;
              if ("base64" === t && "string" == c) for (e = (n = e).trim ? n.trim() : n.replace(/^\s+|\s+$/g, ""); e.length % 4 != 0;) e += "=";
              if ("number" == c) s = M(e);else if ("string" == c) s = i.byteLength(e, t);else {
                if ("object" != c) throw new Error("First argument needs to be a number, array or string.");
                s = M(e.length);
              }
              if (i._useTypedArrays ? o = i._augment(new Uint8Array(s)) : ((o = this).length = s, o._isBuffer = !0), i._useTypedArrays && "number" == typeof e.byteLength) o._set(e);else if (T(l = e) || i.isBuffer(l) || l && "object" == typeof l && "number" == typeof l.length) for (a = 0; a < s; a++) i.isBuffer(e) ? o[a] = e.readUInt8(a) : o[a] = e[a];else if ("string" == c) o.write(e, 0, t);else if ("number" == c && !i._useTypedArrays && !r) for (a = 0; a < s; a++) o[a] = 0;
              return o;
            }
            function d(e, t, r, n) {
              n || (F("boolean" == typeof r, "missing or invalid endian"), F(null != t, "missing offset"), F(t + 1 < e.length, "Trying to read beyond buffer length"));
              var i,
                s = e.length;
              if (!(s <= t)) return r ? (i = e[t], t + 1 < s && (i |= e[t + 1] << 8)) : (i = e[t] << 8, t + 1 < s && (i |= e[t + 1])), i;
            }
            function f(e, t, r, n) {
              n || (F("boolean" == typeof r, "missing or invalid endian"), F(null != t, "missing offset"), F(t + 3 < e.length, "Trying to read beyond buffer length"));
              var i,
                s = e.length;
              if (!(s <= t)) return r ? (t + 2 < s && (i = e[t + 2] << 16), t + 1 < s && (i |= e[t + 1] << 8), i |= e[t], t + 3 < s && (i += e[t + 3] << 24 >>> 0)) : (t + 1 < s && (i = e[t + 1] << 16), t + 2 < s && (i |= e[t + 2] << 8), t + 3 < s && (i |= e[t + 3]), i += e[t] << 24 >>> 0), i;
            }
            function m(e, t, r, n) {
              if (n || (F("boolean" == typeof r, "missing or invalid endian"), F(null != t, "missing offset"), F(t + 1 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
                var i = d(e, t, r, !0);
                return 32768 & i ? -1 * (65535 - i + 1) : i;
              }
            }
            function _(e, t, r, n) {
              if (n || (F("boolean" == typeof r, "missing or invalid endian"), F(null != t, "missing offset"), F(t + 3 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
                var i = f(e, t, r, !0);
                return 2147483648 & i ? -1 * (4294967295 - i + 1) : i;
              }
            }
            function g(e, t, r, n) {
              return n || (F("boolean" == typeof r, "missing or invalid endian"), F(t + 3 < e.length, "Trying to read beyond buffer length")), p.read(e, t, r, 23, 4);
            }
            function v(e, t, r, n) {
              return n || (F("boolean" == typeof r, "missing or invalid endian"), F(t + 7 < e.length, "Trying to read beyond buffer length")), p.read(e, t, r, 52, 8);
            }
            function A(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 1 < e.length, "trying to write beyond buffer length"), R(t, 65535));
              var s = e.length;
              if (!(s <= r)) for (var o = 0, a = Math.min(s - r, 2); o < a; o++) e[r + o] = (t & 255 << 8 * (n ? o : 1 - o)) >>> 8 * (n ? o : 1 - o);
            }
            function b(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 3 < e.length, "trying to write beyond buffer length"), R(t, 4294967295));
              var s = e.length;
              if (!(s <= r)) for (var o = 0, a = Math.min(s - r, 4); o < a; o++) e[r + o] = t >>> 8 * (n ? o : 3 - o) & 255;
            }
            function y(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 1 < e.length, "Trying to write beyond buffer length"), L(t, 32767, -32768)), e.length <= r || A(e, 0 <= t ? t : 65535 + t + 1, r, n, i);
            }
            function x(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 3 < e.length, "Trying to write beyond buffer length"), L(t, 2147483647, -2147483648)), e.length <= r || b(e, 0 <= t ? t : 4294967295 + t + 1, r, n, i);
            }
            function w(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 3 < e.length, "Trying to write beyond buffer length"), O(t, 34028234663852886e22, -34028234663852886e22)), e.length <= r || p.write(e, t, r, n, 23, 4);
            }
            function E(e, t, r, n, i) {
              i || (F(null != t, "missing value"), F("boolean" == typeof n, "missing or invalid endian"), F(null != r, "missing offset"), F(r + 7 < e.length, "Trying to write beyond buffer length"), O(t, 17976931348623157e292, -17976931348623157e292)), e.length <= r || p.write(e, t, r, n, 52, 8);
            }
            r.Buffer = i, r.SlowBuffer = i, r.INSPECT_MAX_BYTES = 50, i.poolSize = 8192, i._useTypedArrays = function () {
              try {
                var e = new ArrayBuffer(0),
                  t = new Uint8Array(e);
                return t.foo = function () {
                  return 42;
                }, 42 === t.foo() && "function" == typeof t.subarray;
              } catch (e) {
                return !1;
              }
            }(), i.isEncoding = function (e) {
              switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "raw":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }, i.isBuffer = function (e) {
              return !(null == e || !e._isBuffer);
            }, i.byteLength = function (e, t) {
              var r;
              switch (e += "", t || "utf8") {
                case "hex":
                  r = e.length / 2;
                  break;
                case "utf8":
                case "utf-8":
                  r = k(e).length;
                  break;
                case "ascii":
                case "binary":
                case "raw":
                  r = e.length;
                  break;
                case "base64":
                  r = D(e).length;
                  break;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  r = 2 * e.length;
                  break;
                default:
                  throw new Error("Unknown encoding");
              }
              return r;
            }, i.concat = function (e, t) {
              if (F(T(e), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e.length) return new i(0);
              if (1 === e.length) return e[0];
              if ("number" != typeof t) for (s = t = 0; s < e.length; s++) t += e[s].length;
              for (var r = new i(t), n = 0, s = 0; s < e.length; s++) {
                var o = e[s];
                o.copy(r, n), n += o.length;
              }
              return r;
            }, i.prototype.write = function (e, t, r, n) {
              var s;
              isFinite(t) ? isFinite(r) || (n = r, r = void 0) : (s = n, n = t, t = r, r = s), t = Number(t) || 0;
              var o,
                a,
                l,
                c,
                u,
                h,
                p,
                d = this.length - t;
              switch ((!r || d < (r = Number(r))) && (r = d), n = String(n || "utf8").toLowerCase()) {
                case "hex":
                  o = function (e, t, r, n) {
                    r = Number(r) || 0;
                    var s = e.length - r;
                    (!n || s < (n = Number(n))) && (n = s);
                    var o = t.length;
                    F(o % 2 == 0, "Invalid hex string"), o / 2 < n && (n = o / 2);
                    for (var a = 0; a < n; a++) {
                      var l = parseInt(t.substr(2 * a, 2), 16);
                      F(!isNaN(l), "Invalid hex string"), e[r + a] = l;
                    }
                    return i._charsWritten = 2 * a, a;
                  }(this, e, t, r);
                  break;
                case "utf8":
                case "utf-8":
                  this, u = e, h = t, p = r, o = i._charsWritten = P(k(u), this, h, p);
                  break;
                case "ascii":
                case "binary":
                  o = function (e, t, r, n) {
                    return i._charsWritten = P(function (e) {
                      for (var t = [], r = 0; r < e.length; r++) t.push(255 & e.charCodeAt(r));
                      return t;
                    }(t), e, r, n);
                  }(this, e, t, r);
                  break;
                case "base64":
                  this, a = e, l = t, c = r, o = i._charsWritten = P(D(a), this, l, c);
                  break;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  o = function (e, t, r, n) {
                    return i._charsWritten = P(function (e) {
                      for (var t, r, n, i = [], s = 0; s < e.length; s++) r = (t = e.charCodeAt(s)) >> 8, n = t % 256, i.push(n), i.push(r);
                      return i;
                    }(t), e, r, n);
                  }(this, e, t, r);
                  break;
                default:
                  throw new Error("Unknown encoding");
              }
              return o;
            }, i.prototype.toString = function (e, t, r) {
              var n,
                i,
                s,
                o,
                a = this;
              if (e = String(e || "utf8").toLowerCase(), t = Number(t) || 0, (r = void 0 !== r ? Number(r) : r = a.length) === t) return "";
              switch (e) {
                case "hex":
                  n = function (e, t, r) {
                    var n = e.length;
                    (!t || t < 0) && (t = 0), (!r || r < 0 || n < r) && (r = n);
                    for (var i = "", s = t; s < r; s++) i += I(e[s]);
                    return i;
                  }(a, t, r);
                  break;
                case "utf8":
                case "utf-8":
                  n = function (e, t, r) {
                    var n = "",
                      i = "";
                    r = Math.min(e.length, r);
                    for (var s = t; s < r; s++) e[s] <= 127 ? (n += B(i) + String.fromCharCode(e[s]), i = "") : i += "%" + e[s].toString(16);
                    return n + B(i);
                  }(a, t, r);
                  break;
                case "ascii":
                case "binary":
                  n = function (e, t, r) {
                    var n = "";
                    r = Math.min(e.length, r);
                    for (var i = t; i < r; i++) n += String.fromCharCode(e[i]);
                    return n;
                  }(a, t, r);
                  break;
                case "base64":
                  i = a, o = r, n = 0 === (s = t) && o === i.length ? h.fromByteArray(i) : h.fromByteArray(i.slice(s, o));
                  break;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  n = function (e, t, r) {
                    for (var n = e.slice(t, r), i = "", s = 0; s < n.length; s += 2) i += String.fromCharCode(n[s] + 256 * n[s + 1]);
                    return i;
                  }(a, t, r);
                  break;
                default:
                  throw new Error("Unknown encoding");
              }
              return n;
            }, i.prototype.toJSON = function () {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            }, i.prototype.copy = function (e, t, r, n) {
              if (r = r || 0, n || 0 === n || (n = this.length), t = t || 0, n !== r && 0 !== e.length && 0 !== this.length) {
                F(r <= n, "sourceEnd < sourceStart"), F(0 <= t && t < e.length, "targetStart out of bounds"), F(0 <= r && r < this.length, "sourceStart out of bounds"), F(0 <= n && n <= this.length, "sourceEnd out of bounds"), n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
                var s = n - r;
                if (s < 100 || !i._useTypedArrays) for (var o = 0; o < s; o++) e[o + t] = this[o + r];else e._set(this.subarray(r, r + s), t);
              }
            }, i.prototype.slice = function (e, t) {
              var r = this.length;
              if (e = C(e, r, 0), t = C(t, r, r), i._useTypedArrays) return i._augment(this.subarray(e, t));
              for (var n = t - e, s = new i(n, void 0, !0), o = 0; o < n; o++) s[o] = this[o + e];
              return s;
            }, i.prototype.get = function (e) {
              return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e);
            }, i.prototype.set = function (e, t) {
              return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e, t);
            }, i.prototype.readUInt8 = function (e, t) {
              if (t || (F(null != e, "missing offset"), F(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return this[e];
            }, i.prototype.readUInt16LE = function (e, t) {
              return d(this, e, !0, t);
            }, i.prototype.readUInt16BE = function (e, t) {
              return d(this, e, !1, t);
            }, i.prototype.readUInt32LE = function (e, t) {
              return f(this, e, !0, t);
            }, i.prototype.readUInt32BE = function (e, t) {
              return f(this, e, !1, t);
            }, i.prototype.readInt8 = function (e, t) {
              if (t || (F(null != e, "missing offset"), F(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
            }, i.prototype.readInt16LE = function (e, t) {
              return m(this, e, !0, t);
            }, i.prototype.readInt16BE = function (e, t) {
              return m(this, e, !1, t);
            }, i.prototype.readInt32LE = function (e, t) {
              return _(this, e, !0, t);
            }, i.prototype.readInt32BE = function (e, t) {
              return _(this, e, !1, t);
            }, i.prototype.readFloatLE = function (e, t) {
              return g(this, e, !0, t);
            }, i.prototype.readFloatBE = function (e, t) {
              return g(this, e, !1, t);
            }, i.prototype.readDoubleLE = function (e, t) {
              return v(this, e, !0, t);
            }, i.prototype.readDoubleBE = function (e, t) {
              return v(this, e, !1, t);
            }, i.prototype.writeUInt8 = function (e, t, r) {
              r || (F(null != e, "missing value"), F(null != t, "missing offset"), F(t < this.length, "trying to write beyond buffer length"), R(e, 255)), t >= this.length || (this[t] = e);
            }, i.prototype.writeUInt16LE = function (e, t, r) {
              A(this, e, t, !0, r);
            }, i.prototype.writeUInt16BE = function (e, t, r) {
              A(this, e, t, !1, r);
            }, i.prototype.writeUInt32LE = function (e, t, r) {
              b(this, e, t, !0, r);
            }, i.prototype.writeUInt32BE = function (e, t, r) {
              b(this, e, t, !1, r);
            }, i.prototype.writeInt8 = function (e, t, r) {
              r || (F(null != e, "missing value"), F(null != t, "missing offset"), F(t < this.length, "Trying to write beyond buffer length"), L(e, 127, -128)), t >= this.length || (0 <= e ? this.writeUInt8(e, t, r) : this.writeUInt8(255 + e + 1, t, r));
            }, i.prototype.writeInt16LE = function (e, t, r) {
              y(this, e, t, !0, r);
            }, i.prototype.writeInt16BE = function (e, t, r) {
              y(this, e, t, !1, r);
            }, i.prototype.writeInt32LE = function (e, t, r) {
              x(this, e, t, !0, r);
            }, i.prototype.writeInt32BE = function (e, t, r) {
              x(this, e, t, !1, r);
            }, i.prototype.writeFloatLE = function (e, t, r) {
              w(this, e, t, !0, r);
            }, i.prototype.writeFloatBE = function (e, t, r) {
              w(this, e, t, !1, r);
            }, i.prototype.writeDoubleLE = function (e, t, r) {
              E(this, e, t, !0, r);
            }, i.prototype.writeDoubleBE = function (e, t, r) {
              E(this, e, t, !1, r);
            }, i.prototype.fill = function (e, t, r) {
              if (e = e || 0, t = t || 0, r = r || this.length, "string" == typeof e && (e = e.charCodeAt(0)), F("number" == typeof e && !isNaN(e), "value is not a number"), F(t <= r, "end < start"), r !== t && 0 !== this.length) {
                F(0 <= t && t < this.length, "start out of bounds"), F(0 <= r && r <= this.length, "end out of bounds");
                for (var n = t; n < r; n++) this[n] = e;
              }
            }, i.prototype.inspect = function () {
              for (var e = [], t = this.length, n = 0; n < t; n++) if (e[n] = I(this[n]), n === r.INSPECT_MAX_BYTES) {
                e[n + 1] = "...";
                break;
              }
              return "<Buffer " + e.join(" ") + ">";
            }, i.prototype.toArrayBuffer = function () {
              if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
              if (i._useTypedArrays) return new i(this).buffer;
              for (var e = new Uint8Array(this.length), t = 0, r = e.length; t < r; t += 1) e[t] = this[t];
              return e.buffer;
            };
            var S = i.prototype;
            function C(e, t, r) {
              return "number" != typeof e ? r : t <= (e = ~~e) ? t : 0 <= e || 0 <= (e += t) ? e : 0;
            }
            function M(e) {
              return (e = ~~Math.ceil(+e)) < 0 ? 0 : e;
            }
            function T(e) {
              return (Array.isArray || function (e) {
                return "[object Array]" === Object.prototype.toString.call(e);
              })(e);
            }
            function I(e) {
              return e < 16 ? "0" + e.toString(16) : e.toString(16);
            }
            function k(e) {
              for (var t = [], r = 0; r < e.length; r++) {
                var n = e.charCodeAt(r);
                if (n <= 127) t.push(e.charCodeAt(r));else {
                  var i = r;
                  55296 <= n && n <= 57343 && r++;
                  for (var s = encodeURIComponent(e.slice(i, r + 1)).substr(1).split("%"), o = 0; o < s.length; o++) t.push(parseInt(s[o], 16));
                }
              }
              return t;
            }
            function D(e) {
              return h.toByteArray(e);
            }
            function P(e, t, r, n) {
              for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); i++) t[i + r] = e[i];
              return i;
            }
            function B(e) {
              try {
                return decodeURIComponent(e);
              } catch (e) {
                return String.fromCharCode(65533);
              }
            }
            function R(e, t) {
              F("number" == typeof e, "cannot write a non-number as a number"), F(0 <= e, "specified a negative value for writing an unsigned value"), F(e <= t, "value is larger than maximum value for type"), F(Math.floor(e) === e, "value has a fractional component");
            }
            function L(e, t, r) {
              F("number" == typeof e, "cannot write a non-number as a number"), F(e <= t, "value larger than maximum allowed value"), F(r <= e, "value smaller than minimum allowed value"), F(Math.floor(e) === e, "value has a fractional component");
            }
            function O(e, t, r) {
              F("number" == typeof e, "cannot write a non-number as a number"), F(e <= t, "value larger than maximum allowed value"), F(r <= e, "value smaller than minimum allowed value");
            }
            function F(e, t) {
              if (!e) throw new Error(t || "Failed assertion");
            }
            i._augment = function (e) {
              return e._isBuffer = !0, e._get = e.get, e._set = e.set, e.get = S.get, e.set = S.set, e.write = S.write, e.toString = S.toString, e.toLocaleString = S.toString, e.toJSON = S.toJSON, e.copy = S.copy, e.slice = S.slice, e.readUInt8 = S.readUInt8, e.readUInt16LE = S.readUInt16LE, e.readUInt16BE = S.readUInt16BE, e.readUInt32LE = S.readUInt32LE, e.readUInt32BE = S.readUInt32BE, e.readInt8 = S.readInt8, e.readInt16LE = S.readInt16LE, e.readInt16BE = S.readInt16BE, e.readInt32LE = S.readInt32LE, e.readInt32BE = S.readInt32BE, e.readFloatLE = S.readFloatLE, e.readFloatBE = S.readFloatBE, e.readDoubleLE = S.readDoubleLE, e.readDoubleBE = S.readDoubleBE, e.writeUInt8 = S.writeUInt8, e.writeUInt16LE = S.writeUInt16LE, e.writeUInt16BE = S.writeUInt16BE, e.writeUInt32LE = S.writeUInt32LE, e.writeUInt32BE = S.writeUInt32BE, e.writeInt8 = S.writeInt8, e.writeInt16LE = S.writeInt16LE, e.writeInt16BE = S.writeInt16BE, e.writeInt32LE = S.writeInt32LE, e.writeInt32BE = S.writeInt32BE, e.writeFloatLE = S.writeFloatLE, e.writeFloatBE = S.writeFloatBE, e.writeDoubleLE = S.writeDoubleLE, e.writeDoubleBE = S.writeDoubleBE, e.fill = S.fill, e.inspect = S.inspect, e.toArrayBuffer = S.toArrayBuffer, e;
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
        }, {
          "base64-js": 2,
          buffer: 3,
          ieee754: 11,
          lYpoI2: 10
        }],
        4: [function (e, t, r) {
          (function (r, n, i, s, o, a, l, c, u) {
            i = e("buffer").Buffer;
            var h = new i(4);
            h.fill(0), t.exports = {
              hash: function (e, t, r, n) {
                return i.isBuffer(e) || (e = new i(e)), function (e, t, r) {
                  for (var n = new i(t), s = r ? n.writeInt32BE : n.writeInt32LE, o = 0; o < e.length; o++) s.call(n, e[o], 4 * o, !0);
                  return n;
                }(t(function (e, t) {
                  var r;
                  e.length % 4 != 0 && (r = e.length + (4 - e.length % 4), e = i.concat([e, h], r));
                  for (var n = [], s = t ? e.readInt32BE : e.readInt32LE, o = 0; o < e.length; o += 4) n.push(s.call(e, o));
                  return n;
                }(e, n), 8 * e.length), r, n);
              }
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          buffer: 3,
          lYpoI2: 10
        }],
        5: [function (e, t, r) {
          (function (t, n, i, s, o, a, l, c, u) {
            i = e("buffer").Buffer;
            var h = e("./sha"),
              p = e("./sha256"),
              d = e("./rng"),
              f = {
                sha1: h,
                sha256: p,
                md5: e("./md5")
              },
              m = 64,
              _ = new i(m);
            function g(e, t) {
              var r = f[e = e || "sha1"],
                n = [];
              return r || v("algorithm:", e, "is not yet supported"), {
                update: function (e) {
                  return i.isBuffer(e) || (e = new i(e)), n.push(e), e.length, this;
                },
                digest: function (e) {
                  var s = i.concat(n),
                    o = t ? function (e, t, r) {
                      i.isBuffer(t) || (t = new i(t)), i.isBuffer(r) || (r = new i(r)), t.length > m ? t = e(t) : t.length < m && (t = i.concat([t, _], m));
                      for (var n = new i(m), s = new i(m), o = 0; o < m; o++) n[o] = 54 ^ t[o], s[o] = 92 ^ t[o];
                      var a = e(i.concat([n, r]));
                      return e(i.concat([s, a]));
                    }(r, t, s) : r(s);
                  return n = null, e ? o.toString(e) : o;
                }
              };
            }
            function v() {
              var e = [].slice.call(arguments).join(" ");
              throw new Error([e, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
            }
            _.fill(0), r.createHash = function (e) {
              return g(e);
            }, r.createHmac = g, r.randomBytes = function (e, t) {
              if (!t || !t.call) return new i(d(e));
              try {
                t.call(this, void 0, new i(d(e)));
              } catch (e) {
                t(e);
              }
            }, function (e, t) {
              for (var r in e) t(e[r]);
            }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function (e) {
              r[e] = function () {
                v("sorry,", e, "is not implemented yet");
              };
            });
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          "./md5": 6,
          "./rng": 7,
          "./sha": 8,
          "./sha256": 9,
          buffer: 3,
          lYpoI2: 10
        }],
        6: [function (e, t, r) {
          (function (r, n, i, s, o, a, l, c, u) {
            var h = e("./helpers");
            function p(e, t) {
              e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
              for (var r = 1732584193, n = -271733879, i = -1732584194, s = 271733878, o = 0; o < e.length; o += 16) {
                var a = r,
                  l = n,
                  c = i,
                  u = s;
                r = f(r, n, i, s, e[o + 0], 7, -680876936), s = f(s, r, n, i, e[o + 1], 12, -389564586), i = f(i, s, r, n, e[o + 2], 17, 606105819), n = f(n, i, s, r, e[o + 3], 22, -1044525330), r = f(r, n, i, s, e[o + 4], 7, -176418897), s = f(s, r, n, i, e[o + 5], 12, 1200080426), i = f(i, s, r, n, e[o + 6], 17, -1473231341), n = f(n, i, s, r, e[o + 7], 22, -45705983), r = f(r, n, i, s, e[o + 8], 7, 1770035416), s = f(s, r, n, i, e[o + 9], 12, -1958414417), i = f(i, s, r, n, e[o + 10], 17, -42063), n = f(n, i, s, r, e[o + 11], 22, -1990404162), r = f(r, n, i, s, e[o + 12], 7, 1804603682), s = f(s, r, n, i, e[o + 13], 12, -40341101), i = f(i, s, r, n, e[o + 14], 17, -1502002290), r = m(r, n = f(n, i, s, r, e[o + 15], 22, 1236535329), i, s, e[o + 1], 5, -165796510), s = m(s, r, n, i, e[o + 6], 9, -1069501632), i = m(i, s, r, n, e[o + 11], 14, 643717713), n = m(n, i, s, r, e[o + 0], 20, -373897302), r = m(r, n, i, s, e[o + 5], 5, -701558691), s = m(s, r, n, i, e[o + 10], 9, 38016083), i = m(i, s, r, n, e[o + 15], 14, -660478335), n = m(n, i, s, r, e[o + 4], 20, -405537848), r = m(r, n, i, s, e[o + 9], 5, 568446438), s = m(s, r, n, i, e[o + 14], 9, -1019803690), i = m(i, s, r, n, e[o + 3], 14, -187363961), n = m(n, i, s, r, e[o + 8], 20, 1163531501), r = m(r, n, i, s, e[o + 13], 5, -1444681467), s = m(s, r, n, i, e[o + 2], 9, -51403784), i = m(i, s, r, n, e[o + 7], 14, 1735328473), r = _(r, n = m(n, i, s, r, e[o + 12], 20, -1926607734), i, s, e[o + 5], 4, -378558), s = _(s, r, n, i, e[o + 8], 11, -2022574463), i = _(i, s, r, n, e[o + 11], 16, 1839030562), n = _(n, i, s, r, e[o + 14], 23, -35309556), r = _(r, n, i, s, e[o + 1], 4, -1530992060), s = _(s, r, n, i, e[o + 4], 11, 1272893353), i = _(i, s, r, n, e[o + 7], 16, -155497632), n = _(n, i, s, r, e[o + 10], 23, -1094730640), r = _(r, n, i, s, e[o + 13], 4, 681279174), s = _(s, r, n, i, e[o + 0], 11, -358537222), i = _(i, s, r, n, e[o + 3], 16, -722521979), n = _(n, i, s, r, e[o + 6], 23, 76029189), r = _(r, n, i, s, e[o + 9], 4, -640364487), s = _(s, r, n, i, e[o + 12], 11, -421815835), i = _(i, s, r, n, e[o + 15], 16, 530742520), r = g(r, n = _(n, i, s, r, e[o + 2], 23, -995338651), i, s, e[o + 0], 6, -198630844), s = g(s, r, n, i, e[o + 7], 10, 1126891415), i = g(i, s, r, n, e[o + 14], 15, -1416354905), n = g(n, i, s, r, e[o + 5], 21, -57434055), r = g(r, n, i, s, e[o + 12], 6, 1700485571), s = g(s, r, n, i, e[o + 3], 10, -1894986606), i = g(i, s, r, n, e[o + 10], 15, -1051523), n = g(n, i, s, r, e[o + 1], 21, -2054922799), r = g(r, n, i, s, e[o + 8], 6, 1873313359), s = g(s, r, n, i, e[o + 15], 10, -30611744), i = g(i, s, r, n, e[o + 6], 15, -1560198380), n = g(n, i, s, r, e[o + 13], 21, 1309151649), r = g(r, n, i, s, e[o + 4], 6, -145523070), s = g(s, r, n, i, e[o + 11], 10, -1120210379), i = g(i, s, r, n, e[o + 2], 15, 718787259), n = g(n, i, s, r, e[o + 9], 21, -343485551), r = v(r, a), n = v(n, l), i = v(i, c), s = v(s, u);
              }
              return Array(r, n, i, s);
            }
            function d(e, t, r, n, i, s) {
              return v((o = v(v(t, e), v(n, s))) << (a = i) | o >>> 32 - a, r);
              var o, a;
            }
            function f(e, t, r, n, i, s, o) {
              return d(t & r | ~t & n, e, t, i, s, o);
            }
            function m(e, t, r, n, i, s, o) {
              return d(t & n | r & ~n, e, t, i, s, o);
            }
            function _(e, t, r, n, i, s, o) {
              return d(t ^ r ^ n, e, t, i, s, o);
            }
            function g(e, t, r, n, i, s, o) {
              return d(r ^ (t | ~n), e, t, i, s, o);
            }
            function v(e, t) {
              var r = (65535 & e) + (65535 & t);
              return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r;
            }
            t.exports = function (e) {
              return h.hash(e, p, 16);
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          "./helpers": 4,
          buffer: 3,
          lYpoI2: 10
        }],
        7: [function (e, t, r) {
          (function (e, r, n, i, s, o, a, l, c) {
            var u;
            u = function (e) {
              for (var t, r = new Array(e), n = 0; n < e; n++) 0 == (3 & n) && (t = 4294967296 * Math.random()), r[n] = t >>> ((3 & n) << 3) & 255;
              return r;
            }, t.exports = u;
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          buffer: 3,
          lYpoI2: 10
        }],
        8: [function (e, t, r) {
          (function (r, n, i, s, o, a, l, c, u) {
            var h = e("./helpers");
            function p(e, t) {
              e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
              for (var r, n, i, s, o, a = Array(80), l = 1732584193, c = -271733879, u = -1732584194, h = 271733878, p = -1009589776, m = 0; m < e.length; m += 16) {
                for (var _ = l, g = c, v = u, A = h, b = p, y = 0; y < 80; y++) {
                  a[y] = y < 16 ? e[m + y] : f(a[y - 3] ^ a[y - 8] ^ a[y - 14] ^ a[y - 16], 1);
                  var x = d(d(f(l, 5), (i = c, s = u, o = h, (n = y) < 20 ? i & s | ~i & o : !(n < 40) && n < 60 ? i & s | i & o | s & o : i ^ s ^ o)), d(d(p, a[y]), (r = y) < 20 ? 1518500249 : r < 40 ? 1859775393 : r < 60 ? -1894007588 : -899497514));
                  p = h, h = u, u = f(c, 30), c = l, l = x;
                }
                l = d(l, _), c = d(c, g), u = d(u, v), h = d(h, A), p = d(p, b);
              }
              return Array(l, c, u, h, p);
            }
            function d(e, t) {
              var r = (65535 & e) + (65535 & t);
              return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r;
            }
            function f(e, t) {
              return e << t | e >>> 32 - t;
            }
            t.exports = function (e) {
              return h.hash(e, p, 20, !0);
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          "./helpers": 4,
          buffer: 3,
          lYpoI2: 10
        }],
        9: [function (e, t, r) {
          (function (r, n, i, s, o, a, l, c, u) {
            function h(e, t) {
              var r = (65535 & e) + (65535 & t);
              return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r;
            }
            function p(e, t) {
              return e >>> t | e << 32 - t;
            }
            function d(e, t) {
              var r,
                n,
                i,
                s,
                o,
                a,
                l,
                c,
                u,
                d,
                f = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
                m = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
                _ = new Array(64);
              e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
              for (var g, v, A, b, y, x, w, E, S = 0; S < e.length; S += 16) {
                r = m[0], n = m[1], i = m[2], s = m[3], o = m[4], a = m[5], l = m[6], c = m[7];
                for (var C = 0; C < 64; C++) _[C] = C < 16 ? e[C + S] : h(h(h(p(E = _[C - 2], 17) ^ p(E, 19) ^ E >>> 10, _[C - 7]), p(w = _[C - 15], 7) ^ p(w, 18) ^ w >>> 3), _[C - 16]), u = h(h(h(h(c, p(x = o, 6) ^ p(x, 11) ^ p(x, 25)), (y = o) & a ^ ~y & l), f[C]), _[C]), d = h(p(b = r, 2) ^ p(b, 13) ^ p(b, 22), (g = r) & (v = n) ^ g & (A = i) ^ v & A), c = l, l = a, a = o, o = h(s, u), s = i, i = n, n = r, r = h(u, d);
                m[0] = h(r, m[0]), m[1] = h(n, m[1]), m[2] = h(i, m[2]), m[3] = h(s, m[3]), m[4] = h(o, m[4]), m[5] = h(a, m[5]), m[6] = h(l, m[6]), m[7] = h(c, m[7]);
              }
              return m;
            }
            var f = e("./helpers");
            t.exports = function (e) {
              return f.hash(e, d, 32, !0);
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
        }, {
          "./helpers": 4,
          buffer: 3,
          lYpoI2: 10
        }],
        10: [function (e, t, r) {
          (function (e, r, n, i, s, o, a, l, c) {
            function u() {}
            (e = t.exports = {}).nextTick = function () {
              var e = "undefined" != typeof window && window.setImmediate,
                t = "undefined" != typeof window && window.postMessage && window.addEventListener;
              if (e) return function (e) {
                return window.setImmediate(e);
              };
              if (t) {
                var r = [];
                return window.addEventListener("message", function (e) {
                  var t = e.source;
                  t !== window && null !== t || "process-tick" !== e.data || (e.stopPropagation(), 0 < r.length && r.shift()());
                }, !0), function (e) {
                  r.push(e), window.postMessage("process-tick", "*");
                };
              }
              return function (e) {
                setTimeout(e, 0);
              };
            }(), e.title = "browser", e.browser = !0, e.env = {}, e.argv = [], e.on = u, e.addListener = u, e.once = u, e.off = u, e.removeListener = u, e.removeAllListeners = u, e.emit = u, e.binding = function (e) {
              throw new Error("process.binding is not supported");
            }, e.cwd = function () {
              return "/";
            }, e.chdir = function (e) {
              throw new Error("process.chdir is not supported");
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
        }, {
          buffer: 3,
          lYpoI2: 10
        }],
        11: [function (e, t, r) {
          (function (e, t, n, i, s, o, a, l, c) {
            r.read = function (e, t, r, n, i) {
              var s,
                o,
                a = 8 * i - n - 1,
                l = (1 << a) - 1,
                c = l >> 1,
                u = -7,
                h = r ? i - 1 : 0,
                p = r ? -1 : 1,
                d = e[t + h];
              for (h += p, s = d & (1 << -u) - 1, d >>= -u, u += a; 0 < u; s = 256 * s + e[t + h], h += p, u -= 8);
              for (o = s & (1 << -u) - 1, s >>= -u, u += n; 0 < u; o = 256 * o + e[t + h], h += p, u -= 8);
              if (0 === s) s = 1 - c;else {
                if (s === l) return o ? NaN : 1 / 0 * (d ? -1 : 1);
                o += Math.pow(2, n), s -= c;
              }
              return (d ? -1 : 1) * o * Math.pow(2, s - n);
            }, r.write = function (e, t, r, n, i, s) {
              var o,
                a,
                l,
                c = 8 * s - i - 1,
                u = (1 << c) - 1,
                h = u >> 1,
                p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                d = n ? 0 : s - 1,
                f = n ? 1 : -1,
                m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
              for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), 2 <= (t += 1 <= o + h ? p / l : p * Math.pow(2, 1 - h)) * l && (o++, l /= 2), u <= o + h ? (a = 0, o = u) : 1 <= o + h ? (a = (t * l - 1) * Math.pow(2, i), o += h) : (a = t * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); 8 <= i; e[r + d] = 255 & a, d += f, a /= 256, i -= 8);
              for (o = o << i | a, c += i; 0 < c; e[r + d] = 255 & o, d += f, o /= 256, c -= 8);
              e[r + d - f] |= 128 * m;
            };
          }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
        }, {
          buffer: 3,
          lYpoI2: 10
        }]
      }, {}, [1])(1);
    },
    654: function (e) {
      var t = function () {
        function e(e) {
          return l(e, c(a(u(e.length), e), 1 / e.length));
        }
        function t(e) {
          return a(h(e), e);
        }
        function r(e, t) {
          return c(e, t ? 1 / (e.length - 1) : 1 / e.length);
        }
        function n(e) {
          var t = function (e) {
            var t,
              r = Math.pow(2, -52),
              n = 1e-64 / r,
              i = 0,
              s = 0,
              o = 0,
              a = 0,
              l = 0,
              c = p(e),
              u = c.length,
              h = c[0].length;
            if (u < h) throw "Need more rows than columns";
            var d = new Array(h),
              f = new Array(h);
            for (s = 0; s < h; s++) d[s] = f[s] = 0;
            var m = function e(t, r, n) {
              void 0 === n && (n = 0);
              var i,
                s = t[n],
                o = Array(s);
              if (n === t.length - 1) {
                for (i = s - 2; i >= 0; i -= 2) o[i + 1] = r, o[i] = r;
                return -1 === i && (o[0] = r), o;
              }
              for (i = s - 1; i >= 0; i--) o[i] = e(t, r, n + 1);
              return o;
            }([h, h], 0);
            function _(e, t) {
              return (e = Math.abs(e)) > (t = Math.abs(t)) ? e * Math.sqrt(1 + t * t / e / e) : 0 == t ? e : t * Math.sqrt(1 + e * e / t / t);
            }
            var g = 0,
              v = 0,
              A = 0,
              b = 0,
              y = 0,
              x = 0,
              w = 0;
            for (s = 0; s < h; s++) {
              for (d[s] = v, w = 0, l = s + 1, o = s; o < u; o++) w += c[o][s] * c[o][s];
              if (w <= n) v = 0;else for (g = c[s][s], v = Math.sqrt(w), g >= 0 && (v = -v), A = g * v - w, c[s][s] = g - v, o = l; o < h; o++) {
                for (w = 0, a = s; a < u; a++) w += c[a][s] * c[a][o];
                for (g = w / A, a = s; a < u; a++) c[a][o] += g * c[a][s];
              }
              for (f[s] = v, w = 0, o = l; o < h; o++) w += c[s][o] * c[s][o];
              if (w <= n) v = 0;else {
                for (g = c[s][s + 1], v = Math.sqrt(w), g >= 0 && (v = -v), A = g * v - w, c[s][s + 1] = g - v, o = l; o < h; o++) d[o] = c[s][o] / A;
                for (o = l; o < u; o++) {
                  for (w = 0, a = l; a < h; a++) w += c[o][a] * c[s][a];
                  for (a = l; a < h; a++) c[o][a] += w * d[a];
                }
              }
              (y = Math.abs(f[s]) + Math.abs(d[s])) > b && (b = y);
            }
            for (s = h - 1; -1 != s; s += -1) {
              if (0 != v) {
                for (A = v * c[s][s + 1], o = l; o < h; o++) m[o][s] = c[s][o] / A;
                for (o = l; o < h; o++) {
                  for (w = 0, a = l; a < h; a++) w += c[s][a] * m[a][o];
                  for (a = l; a < h; a++) m[a][o] += w * m[a][s];
                }
              }
              for (o = l; o < h; o++) m[s][o] = 0, m[o][s] = 0;
              m[s][s] = 1, v = d[s], l = s;
            }
            for (s = h - 1; -1 != s; s += -1) {
              for (l = s + 1, v = f[s], o = l; o < h; o++) c[s][o] = 0;
              if (0 != v) {
                for (A = c[s][s] * v, o = l; o < h; o++) {
                  for (w = 0, a = l; a < u; a++) w += c[a][s] * c[a][o];
                  for (g = w / A, a = s; a < u; a++) c[a][o] += g * c[a][s];
                }
                for (o = s; o < u; o++) c[o][s] = c[o][s] / v;
              } else for (o = s; o < u; o++) c[o][s] = 0;
              c[s][s] += 1;
            }
            for (r *= b, a = h - 1; -1 != a; a += -1) for (var E = 0; E < 50; E++) {
              var S = !1;
              for (l = a; -1 != l; l += -1) {
                if (Math.abs(d[l]) <= r) {
                  S = !0;
                  break;
                }
                if (Math.abs(f[l - 1]) <= r) break;
              }
              if (!S) {
                i = 0, w = 1;
                var C = l - 1;
                for (s = l; s < a + 1 && (g = w * d[s], d[s] = i * d[s], !(Math.abs(g) <= r)); s++) for (A = _(g, v = f[s]), f[s] = A, i = v / A, w = -g / A, o = 0; o < u; o++) y = c[o][C], x = c[o][s], c[o][C] = y * i + x * w, c[o][s] = -y * w + x * i;
              }
              if (x = f[a], l == a) {
                if (x < 0) for (f[a] = -x, o = 0; o < h; o++) m[o][a] = -m[o][a];
                break;
              }
              if (E >= 49) throw "Error: no convergence.";
              for (b = f[l], v = _(g = (((y = f[a - 1]) - x) * (y + x) + ((v = d[a - 1]) - (A = d[a])) * (v + A)) / (2 * A * y), 1), g = g < 0 ? ((b - x) * (b + x) + A * (y / (g - v) - A)) / b : ((b - x) * (b + x) + A * (y / (g + v) - A)) / b, i = 1, w = 1, s = l + 1; s < a + 1; s++) {
                for (v = d[s], y = f[s], A = w * v, v *= i, x = _(g, A), d[s - 1] = x, g = b * (i = g / x) + v * (w = A / x), v = -b * w + v * i, A = y * w, y *= i, o = 0; o < h; o++) b = m[o][s - 1], x = m[o][s], m[o][s - 1] = b * i + x * w, m[o][s] = -b * w + x * i;
                for (x = _(g, A), f[s - 1] = x, g = (i = g / x) * v + (w = A / x) * y, b = -w * v + i * y, o = 0; o < u; o++) y = c[o][s - 1], x = c[o][s], c[o][s - 1] = y * i + x * w, c[o][s] = -y * w + x * i;
              }
              d[l] = 0, d[a] = g, f[a] = b;
            }
            for (s = 0; s < f.length; s++) f[s] < r && (f[s] = 0);
            for (s = 0; s < h; s++) for (o = s - 1; o >= 0; o--) if (f[o] < f[s]) {
              for (i = f[o], f[o] = f[s], f[s] = i, a = 0; a < c.length; a++) t = c[a][s], c[a][s] = c[a][o], c[a][o] = t;
              for (a = 0; a < m.length; a++) t = m[a][s], m[a][s] = m[a][o], m[a][o] = t;
              s = o;
            }
            return {
              U: c,
              S: f,
              V: m
            };
          }(e);
          console.log(t);
          var r = t.U;
          return t.S.map(function (e, t) {
            var n = {};
            return n.eigenvalue = e, n.vector = r.map(function (e, r) {
              return -1 * e[t];
            }), n;
          });
        }
        function i(t, ...r) {
          var n = r.map(function (e) {
              return e.vector;
            }),
            i = a(n, h(e(t))),
            s = c(a(u(t.length), t), -1 / t.length);
          return {
            adjustedData: i,
            formattedAdjustedData: o(i, 2),
            avgData: s,
            selectedVectors: n
          };
        }
        function s(i) {
          return n(r(t(e(i)), !1));
        }
        function o(e, t) {
          var r = Math.pow(10, t || 2);
          return e.map(function (e, t) {
            return e.map(function (e) {
              return Math.round(e * r) / r;
            });
          });
        }
        function a(e, t) {
          if (!(e[0] && t[0] && e.length && t.length)) throw new Error("Both A and B should be matrices");
          if (t.length !== e[0].length) throw new Error("Columns in A should be the same as the number of rows in B");
          for (var r = [], n = 0; n < e.length; n++) {
            r[n] = [];
            for (var i = 0; i < t[0].length; i++) for (var s = 0; s < e[0].length; s++) r[n][i] = r[n][i] ? r[n][i] + e[n][s] * t[s][i] : e[n][s] * t[s][i];
          }
          return r;
        }
        function l(e, t) {
          if (e.length !== t.length || e[0].length !== t[0].length) throw new Error("Both A and B should have the same dimensions");
          for (var r = [], n = 0; n < e.length; n++) {
            r[n] = [];
            for (var i = 0; i < t[0].length; i++) r[n][i] = e[n][i] - t[n][i];
          }
          return r;
        }
        function c(e, t) {
          for (var r = [], n = 0; n < e.length; n++) {
            r[n] = [];
            for (var i = 0; i < e[0].length; i++) r[n][i] = e[n][i] * t;
          }
          return r;
        }
        function u(e) {
          for (var t = [], r = 0; r < e; r++) {
            t[r] = [];
            for (var n = 0; n < e; n++) t[r][n] = 1;
          }
          return t;
        }
        function h(e) {
          return p(e)[0].map(function (t, r) {
            return e.map(function (e) {
              return e[r];
            });
          });
        }
        function p(e) {
          var t = JSON.stringify(e);
          return JSON.parse(t);
        }
        return {
          computeDeviationScores: t,
          computeDeviationMatrix: e,
          computeSVD: n,
          computePercentageExplained: function (e, ...t) {
            var r = e.map(function (e) {
              return e.eigenvalue;
            }).reduce(function (e, t) {
              return e + t;
            });
            return t.map(function (e) {
              return e.eigenvalue;
            }).reduce(function (e, t) {
              return e + t;
            }) / r;
          },
          computeOriginalData: function (e, t, r) {
            var n = l(h(a(h(t), e)), r);
            return {
              originalData: n,
              formattedOriginalData: o(n, 2)
            };
          },
          computeVarianceCovariance: r,
          computeAdjustedData: i,
          getEigenVectors: s,
          analyseTopResult: function (e) {
            var t = s(e).sort(function (e, t) {
              return t.eigenvalue - e.eigenvalue;
            });
            return console.log("Sorted Vectors", t), i(e, t[0].vector);
          },
          transpose: h,
          multiply: a,
          clone: p,
          scale: c
        };
      }();
      e.exports = t;
    },
    701: function (e) {
      var t = [];
      function r(e) {
        for (var r = -1, n = 0; n < t.length; n++) if (t[n].identifier === e) {
          r = n;
          break;
        }
        return r;
      }
      function n(e, n) {
        for (var s = {}, o = [], a = 0; a < e.length; a++) {
          var l = e[a],
            c = n.base ? l[0] + n.base : l[0],
            u = s[c] || 0,
            h = "".concat(c, " ").concat(u);
          s[c] = u + 1;
          var p = r(h),
            d = {
              css: l[1],
              media: l[2],
              sourceMap: l[3],
              supports: l[4],
              layer: l[5]
            };
          if (-1 !== p) t[p].references++, t[p].updater(d);else {
            var f = i(d, n);
            n.byIndex = a, t.splice(a, 0, {
              identifier: h,
              updater: f,
              references: 1
            });
          }
          o.push(h);
        }
        return o;
      }
      function i(e, t) {
        var r = t.domAPI(t);
        return r.update(e), function (t) {
          if (t) {
            if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return;
            r.update(e = t);
          } else r.remove();
        };
      }
      e.exports = function (e, i) {
        var s = n(e = e || [], i = i || {});
        return function (e) {
          e = e || [];
          for (var o = 0; o < s.length; o++) {
            var a = r(s[o]);
            t[a].references--;
          }
          for (var l = n(e, i), c = 0; c < s.length; c++) {
            var u = r(s[c]);
            0 === t[u].references && (t[u].updater(), t.splice(u, 1));
          }
          s = l;
        };
      };
    },
    182: function (e) {
      e.exports = function (e) {
        var t = document.createElement("style");
        return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
      };
    },
    850: function (e, t, r) {
      e.exports = function (e) {
        var t = r.nc;
        t && e.setAttribute("nonce", t);
      };
    },
    236: function (e) {
      e.exports = function (e) {
        var t = e.insertStyleElement(e);
        return {
          update: function (r) {
            !function (e, t, r) {
              var n = "";
              r.supports && (n += "@supports (".concat(r.supports, ") {")), r.media && (n += "@media ".concat(r.media, " {"));
              var i = void 0 !== r.layer;
              i && (n += "@layer".concat(r.layer.length > 0 ? " ".concat(r.layer) : "", " {")), n += r.css, i && (n += "}"), r.media && (n += "}"), r.supports && (n += "}");
              var s = r.sourceMap;
              s && "undefined" != typeof btoa && (n += "\n/", n += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), n += "/"), t.styleTagTransform(n, e, t.options);
            }(t, e, r);
          },
          remove: function () {
            !function (e) {
              if (null === e.parentNode) return !1;
              e.parentNode.removeChild(e);
            }(t);
          }
        };
      };
    },
    213: function (e) {
      e.exports = function (e, t) {
        if (t.styleSheet) t.styleSheet.cssText = e;else {
          for (; t.firstChild;) t.removeChild(t.firstChild);
          t.appendChild(document.createTextNode(e));
        }
      };
    },
    1: function (e) {
      self, e.exports = function () {
        var e = {
            820: function (e, t, r) {
              var n = r(537),
                i = r.n(n),
                s = r(645),
                o = r.n(s)()(i());
              o.push([e.id, ".treejs {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.treejs *:after,\n.treejs *:before {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.treejs > .treejs-node {\n  padding-left: 0;\n}\n.treejs .treejs-nodes {\n  list-style: none;\n  padding-left: 18px;\n  margin: 0;\n  overflow: hidden;\n  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;\n  -o-transition: height 150ms ease-out, opacity 150ms ease-out;\n  transition: height 150ms ease-out, opacity 150ms ease-out;\n}\n.treejs .treejs-node {\n  cursor: pointer;\n  overflow: hidden;\n}\n.treejs .treejs-node.treejs-placeholder {\n  padding-left: 18px;\n}\n.treejs .treejs-switcher {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n  -webkit-transition: -webkit-transform 150ms ease-out;\n  transition: -webkit-transform 150ms ease-out;\n  -o-transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;\n}\n.treejs .treejs-switcher:before {\n  position: absolute;\n  top: 8px;\n  left: 6px;\n  display: block;\n  content: ' ';\n  border: 4px solid transparent;\n  border-top: 4px solid rgba(245, 245, 245, 0.7);\n  -webkit-transition: border-color 150ms;\n  -o-transition: border-color 150ms;\n  transition: border-color 150ms;\n}\n.treejs .treejs-switcher:hover:before {\n  border-top: 4px solid rgba(245, 245, 245, 0.96);\n}\n.treejs .treejs-node__close > .treejs-switcher {\n  -webkit-transform: rotate(-90deg);\n      -ms-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.treejs .treejs-node__close > .treejs-nodes {\n  height: 0;\n}\n.treejs .treejs-checkbox {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n}\n.treejs .treejs-checkbox:before {\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n  cursor: pointer;\n  position: absolute;\n  top: 2px;\n  content: ' ';\n  display: block;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #d9d9d9;\n  border-radius: 2px;\n}\n.treejs .treejs-checkbox:hover:before {\n  -webkit-box-shadow: 0 0 2px 1px #1890ff;\n          box-shadow: 0 0 2px 1px #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 4px;\n  left: 5px;\n  width: 5px;\n  height: 9px;\n  border: 2px solid #fff;\n  border-top: none;\n  border-left: none;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg);\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 9px;\n  left: 3px;\n  width: 10px;\n  height: 2px;\n  background-color: #fff;\n}\n.treejs .treejs-node__disabled {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.25);\n}\n.treejs .treejs-node__disabled .treejs-checkbox {\n  cursor: not-allowed;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:before {\n  cursor: not-allowed;\n  border-color: #d9d9d9 !important;\n  background-color: #f5f5f5 !important;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:hover:before {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-label {\n  vertical-align: middle;\n}\n", "", {
                version: 3,
                sources: ["webpack://./src/index.less"],
                names: [],
                mappings: "AAKA;EACE,8BAAA;UAAA,sBAAA;EACA,eAAA;EACA,kBAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA;AAJF;AAAA;;EAQI,8BAAA;UAAA,sBAAA;AAJJ;AAOE;EACE,eAAA;AALJ;AAPA;EAgBI,gBAAA;EACA,kBAAA;EACA,SAAA;EACA,gBAAA;EACA,iEAAA;EAAA,4DAAA;EAAA,yDAAA;AANJ;AAdA;EAwBI,eAAA;EACA,gBAAA;AAPJ;AASI;EACE,kBAAA;AAPN;AArBA;EAiCI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;EACA,oDAAA;EAAA,4CAAA;EAAA,uCAAA;EAAA,oCAAA;EAAA,sEAAA;AATJ;AAWI;EACE,kBAAA;EACA,QAAA;EACA,SAAA;EACA,cAAA;EACA,YAAA;EACA,6BAAA;EACA,8CAAA;EACA,sCAAA;EAAA,iCAAA;EAAA,8BAAA;AATN;AAWI;EACE,+CAAA;AATN;AA3CA;EAwDI,iCAAA;MAAA,6BAAA;UAAA,yBAAA;AAVJ;AA9CA;EA2DI,SAAA;AAVJ;AAjDA;EA+DI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;AAXJ;AAaI;EACE,4BAAA;EAAA,uBAAA;EAAA,oBAAA;EACA,eAAA;EACA,kBAAA;EACA,QAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,yBAAA;EACA,kBAAA;AAXN;AAaI;EACE,uCAAA;UAAA,+BAAA;AAXN;AAgBM;EACE,yBAAA;EACA,qBAAA;AAdR;AAgBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,sBAAA;EACA,gBAAA;EACA,iBAAA;EACA,gCAAA;MAAA,4BAAA;UAAA,wBAAA;AAdR;AAoBM;EACE,yBAAA;EACA,qBAAA;AAlBR;AAoBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,sBAAA;AAlBR;AAvGA;EA+HI,mBAAA;EACA,gCAAA;AArBJ;AA3GA;EAkIM,mBAAA;AApBN;AAqBM;EACE,mBAAA;EACA,gCAAA;EACA,oCAAA;AAnBR;AAqBM;EACE,mCAAA;UAAA,2BAAA;AAnBR;AAwBQ;EACE,qBAAA;AAtBV;AA4BQ;EACE,yBAAA;AA1BV;AAiCM;EACE,qBAAA;AA/BR;AAqCM;EACE,yBAAA;AAnCR;AAlIA;EA2KI,sBAAA;AAtCJ",
                sourcesContent: ["@color-disable: #d4d4d4;\n@bgcolor-disable: #f5f5f5;\n@greyborder: #d9d9d9;\n@bluebg: #1890ff;\n\n.treejs {\n  box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  user-select: none;\n\n  *:after,\n  *:before {\n    box-sizing: border-box;\n  }\n\n  & > .treejs-node {\n    padding-left: 0;\n  }\n\n  .treejs-nodes {\n    list-style: none;\n    padding-left: 18px;\n    margin: 0; //  for default ul...\n    overflow: hidden;\n    transition: height 150ms ease-out, opacity 150ms ease-out;\n  }\n\n  .treejs-node {\n    cursor: pointer;\n    overflow: hidden;\n\n    &.treejs-placeholder {\n      padding-left: 18px;\n    }\n  }\n\n  .treejs-switcher {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n    transition: transform 150ms ease-out;\n\n    &:before {\n      position: absolute;\n      top: 8px;\n      left: 6px;\n      display: block;\n      content: ' ';\n      border: 4px solid transparent;\n      border-top: 4px solid rgba(245, 245, 245, 0.7);\n      transition: border-color 150ms;\n    }\n    &:hover:before {\n      border-top: 4px solid rgba(245, 245, 245, 0.96);\n    }\n  }\n  .treejs-node__close > .treejs-switcher {\n    transform: rotate(-90deg);\n  }\n  .treejs-node__close > .treejs-nodes {\n    height: 0;\n  }\n\n  .treejs-checkbox {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n\n    &:before {\n      transition: all 0.3s;\n      cursor: pointer;\n      position: absolute;\n      top: 2px;\n      content: ' ';\n      display: block;\n      width: 16px;\n      height: 16px;\n      border: 1px solid @greyborder;\n      border-radius: 2px;\n    }\n    &:hover:before {\n      box-shadow: 0 0 2px 1px @bluebg;\n    }\n  }\n  .treejs-node__checked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 4px;\n        left: 5px;\n        width: 5px;\n        height: 9px;\n        border: 2px solid #fff;\n        border-top: none;\n        border-left: none;\n        transform: rotate(45deg);\n      }\n    }\n  }\n  .treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 9px;\n        left: 3px;\n        width: 10px;\n        height: 2px;\n        background-color: #fff;\n      }\n    }\n  }\n\n  .treejs-node__disabled {\n    cursor: not-allowed;\n    color: rgba(255, 255, 255, 0.25);\n    .treejs-checkbox {\n      cursor: not-allowed;\n      &:before {\n        cursor: not-allowed;\n        border-color: @greyborder !important;\n        background-color: @bgcolor-disable !important;\n      }\n      &:hover:before {\n        box-shadow: none !important;\n      }\n    }\n    .treejs-node__checked {\n      & > .treejs-checkbox {\n        &:after {\n          border-color: @greyborder;\n        }\n      }\n    }\n    .treejs-node__halfchecked {\n      & > .treejs-checkbox {\n        &:after {\n          background-color: @greyborder;\n        }\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__checked {\n    & > .treejs-checkbox {\n      &:after {\n        border-color: @greyborder;\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:after {\n        background-color: @greyborder;\n      }\n    }\n  }\n\n  .treejs-label {\n    vertical-align: middle;\n  }\n}\n"],
                sourceRoot: ""
              }]), t.Z = o;
            },
            645: function (e) {
              e.exports = function (e) {
                var t = [];
                return t.toString = function () {
                  return this.map(function (t) {
                    var r = "",
                      n = void 0 !== t[5];
                    return t[4] && (r += "@supports (".concat(t[4], ") {")), t[2] && (r += "@media ".concat(t[2], " {")), n && (r += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")), r += e(t), n && (r += "}"), t[2] && (r += "}"), t[4] && (r += "}"), r;
                  }).join("");
                }, t.i = function (e, r, n, i, s) {
                  "string" == typeof e && (e = [[null, e, void 0]]);
                  var o = {};
                  if (n) for (var a = 0; a < this.length; a++) {
                    var l = this[a][0];
                    null != l && (o[l] = !0);
                  }
                  for (var c = 0; c < e.length; c++) {
                    var u = [].concat(e[c]);
                    n && o[u[0]] || (void 0 !== s && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = s), r && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = r) : u[2] = r), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t.push(u));
                  }
                }, t;
              };
            },
            537: function (e) {
              e.exports = function (e) {
                var t = e[1],
                  r = e[3];
                if (!r) return t;
                if ("function" == typeof btoa) {
                  var n = btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
                    i = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n),
                    s = "/*# ".concat(i, " */"),
                    o = r.sources.map(function (e) {
                      return "/*# sourceURL=".concat(r.sourceRoot || "").concat(e, " */");
                    });
                  return [t].concat(o).concat([s]).join("\n");
                }
                return [t].join("\n");
              };
            },
            379: function (e) {
              var t = [];
              function r(e) {
                for (var r = -1, n = 0; n < t.length; n++) if (t[n].identifier === e) {
                  r = n;
                  break;
                }
                return r;
              }
              function n(e, n) {
                for (var s = {}, o = [], a = 0; a < e.length; a++) {
                  var l = e[a],
                    c = n.base ? l[0] + n.base : l[0],
                    u = s[c] || 0,
                    h = "".concat(c, " ").concat(u);
                  s[c] = u + 1;
                  var p = r(h),
                    d = {
                      css: l[1],
                      media: l[2],
                      sourceMap: l[3],
                      supports: l[4],
                      layer: l[5]
                    };
                  if (-1 !== p) t[p].references++, t[p].updater(d);else {
                    var f = i(d, n);
                    n.byIndex = a, t.splice(a, 0, {
                      identifier: h,
                      updater: f,
                      references: 1
                    });
                  }
                  o.push(h);
                }
                return o;
              }
              function i(e, t) {
                var r = t.domAPI(t);
                return r.update(e), function (t) {
                  if (t) {
                    if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return;
                    r.update(e = t);
                  } else r.remove();
                };
              }
              e.exports = function (e, i) {
                var s = n(e = e || [], i = i || {});
                return function (e) {
                  e = e || [];
                  for (var o = 0; o < s.length; o++) {
                    var a = r(s[o]);
                    t[a].references--;
                  }
                  for (var l = n(e, i), c = 0; c < s.length; c++) {
                    var u = r(s[c]);
                    0 === t[u].references && (t[u].updater(), t.splice(u, 1));
                  }
                  s = l;
                };
              };
            },
            216: function (e) {
              e.exports = function (e) {
                var t = document.createElement("style");
                return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
              };
            },
            636: function (e, t, r) {
              e.exports = function (e) {
                var t = r.nc;
                t && e.setAttribute("nonce", t);
              };
            },
            795: function (e) {
              e.exports = function (e) {
                var t = e.insertStyleElement(e);
                return {
                  update: function (r) {
                    !function (e, t, r) {
                      var n = "";
                      r.supports && (n += "@supports (".concat(r.supports, ") {")), r.media && (n += "@media ".concat(r.media, " {"));
                      var i = void 0 !== r.layer;
                      i && (n += "@layer".concat(r.layer.length > 0 ? " ".concat(r.layer) : "", " {")), n += r.css, i && (n += "}"), r.media && (n += "}"), r.supports && (n += "}");
                      var s = r.sourceMap;
                      s && "undefined" != typeof btoa && (n += "\n/", n += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), n += "/"), t.styleTagTransform(n, e, t.options);
                    }(t, e, r);
                  },
                  remove: function () {
                    !function (e) {
                      if (null === e.parentNode) return !1;
                      e.parentNode.removeChild(e);
                    }(t);
                  }
                };
              };
            },
            589: function (e) {
              e.exports = function (e, t) {
                if (t.styleSheet) t.styleSheet.cssText = e;else {
                  for (; t.firstChild;) t.removeChild(t.firstChild);
                  t.appendChild(document.createTextNode(e));
                }
              };
            }
          },
          t = {};
        function r(n) {
          var i = t[n];
          if (void 0 !== i) return i.exports;
          var s = t[n] = {
            id: n,
            exports: {}
          };
          return e[n](s, s.exports, r), s.exports;
        }
        r.n = function (e) {
          var t = e && e.__esModule ? function () {
            return e.default;
          } : function () {
            return e;
          };
          return r.d(t, {
            a: t
          }), t;
        }, r.d = function (e, t) {
          for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
            enumerable: !0,
            get: t[n]
          });
        }, r.o = function (e, t) {
          return Object.prototype.hasOwnProperty.call(e, t);
        }, r.nc = void 0;
        var n = {};
        return function () {
          r.d(n, {
            default: function () {
              return T;
            }
          });
          var e = r(379),
            t = r.n(e),
            i = r(795),
            s = r.n(i),
            o = r(636),
            a = r.n(o),
            l = r(216),
            c = r.n(l),
            u = r(589),
            h = r.n(u),
            p = r(820),
            d = {};
          p.Z && p.Z.locals && (d.locals = p.Z.locals);
          var f,
            m = 0,
            _ = {};
          _.styleTagTransform = h(), _.setAttributes = a(), _.insert = function (e, t) {
            (t.target || document.head).appendChild(e);
          }, _.domAPI = s(), _.insertStyleElement = c(), d.use = function (e) {
            return _.options = e || {}, m++ || (f = t()(p.Z, _)), d;
          }, d.unuse = function () {
            m > 0 && ! --m && (f(), f = null);
          };
          var g = d;
          function v(e, t) {
            return function (e) {
              if (Array.isArray(e)) return e;
            }(e) || function (e, t) {
              var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
              if (null != r) {
                var n,
                  i,
                  s = [],
                  o = !0,
                  a = !1;
                try {
                  for (r = r.call(e); !(o = (n = r.next()).done) && (s.push(n.value), !t || s.length !== t); o = !0);
                } catch (e) {
                  a = !0, i = e;
                } finally {
                  try {
                    o || null == r.return || r.return();
                  } finally {
                    if (a) throw i;
                  }
                }
                return s;
              }
            }(e, t) || function (e, t) {
              if (e) {
                if ("string" == typeof e) return A(e, t);
                var r = Object.prototype.toString.call(e).slice(8, -1);
                return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? A(e, t) : void 0;
              }
            }(e, t) || function () {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function A(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
            return n;
          }
          function b(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
              })), r.push.apply(r, n);
            }
            return r;
          }
          function y(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2 ? b(Object(r), !0).forEach(function (t) {
                x(e, t, r[t]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : b(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
              });
            }
            return e;
          }
          function x(e, t, r) {
            return t in e ? Object.defineProperty(e, t, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }) : e[t] = r, e;
          }
          function w(e, t) {
            for (var r = 0; r < t.length; r++) {
              var n = t[r];
              n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
            }
          }
          function E(e) {
            var t = {};
            return e.reduce(function (e, r) {
              return t[r] || (t[r] = !0, e.push(r)), e;
            }, []);
          }
          function S(e, t) {
            requestAnimationFrame(function () {
              t.enter(), requestAnimationFrame(function () {
                t.active(), setTimeout(function () {
                  t.leave();
                }, e);
              });
            });
          }
          function C(e, t) {
            try {
              var r = e.liElementsById[t.parent.id];
              r.classList.contains("treejs-node__close") || r.getElementsByClassName("treejs-switcher")[0].click();
            } catch (e) {
              return;
            }
            Object.prototype.hasOwnProperty.call(t, "parent") && C(e, t.parent);
          }
          function M(e, t) {
            var r = e.liElementsById[t.id];
            r.classList.contains("treejs-node__close") && r.getElementsByClassName("treejs-switcher")[0].click(), Object.prototype.hasOwnProperty.call(t, "children") && t.children.forEach(function (t) {
              return M(e, t);
            });
          }
          var T = function () {
            function e(t, r) {
              !function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
              }(this, e), g.use({
                target: "string" == typeof this.container ? document.querySelector(this.container) : this.container
              }), this.treeNodes = [], this.nodesById = {}, this.leafNodesById = {}, this.liElementsById = {}, this.willUpdateNodesById = {}, this.container = t, this.options = Object.assign({
                values: [],
                disables: [],
                loaded: null,
                closeDepth: null
              }, r), Object.defineProperties(this, {
                values: {
                  get: function () {
                    return this.getValues();
                  },
                  set: function (e) {
                    this.setValues(E(e));
                  }
                },
                disables: {
                  get: function () {
                    return this.getDisables();
                  },
                  set: function (e) {
                    this.setDisables(E(e));
                  }
                },
                selectedNodes: {
                  get: function () {
                    var e = [],
                      t = this.nodesById;
                    return Object.keys(t).forEach(function (r) {
                      if (Object.prototype.hasOwnProperty.call(t, r) && (1 === t[r].status || 2 === t[r].status)) {
                        var n = y({}, t[r]);
                        delete n.parent, delete n.children, e.push(n);
                      }
                    }), e;
                  }
                },
                disabledNodes: {
                  get: function () {
                    var e = [],
                      t = this.nodesById;
                    return Object.keys(t).forEach(function (r) {
                      if (Object.prototype.hasOwnProperty.call(t, r) && t[r].disabled) {
                        var n = y({}, t[r]);
                        delete n.parent, e.push(n);
                      }
                    }), e;
                  }
                }
              }), this.init(this.options.data);
            }
            var t, r, n;
            return t = e, n = [{
              key: "onSwitcherClick",
              value: function (e) {
                var t = e.parentNode,
                  r = t.lastChild,
                  n = r.scrollHeight;
                t.classList.contains("treejs-node__close") ? S(150, {
                  enter: function () {
                    r.style.height = 0, r.style.opacity = 0;
                  },
                  active: function () {
                    r.style.height = "".concat(n, "px"), r.style.opacity = 1;
                  },
                  leave: function () {
                    r.style.height = "", r.style.opacity = "", t.classList.remove("treejs-node__close");
                  }
                }) : S(150, {
                  enter: function () {
                    r.style.height = "".concat(n, "px"), r.style.opacity = 1;
                  },
                  active: function () {
                    r.style.height = 0, r.style.opacity = 0;
                  },
                  leave: function () {
                    r.style.height = "", r.style.opacity = "", t.classList.add("treejs-node__close");
                  }
                });
              }
            }, {
              key: "parseTreeData",
              value: function (e) {
                var t,
                  r = (t = e, JSON.parse(JSON.stringify(t))),
                  n = {},
                  i = {},
                  s = [],
                  o = [];
                return function e(t, r) {
                  t.forEach(function (t) {
                    n[t.id] = t, t.checked && s.push(t.id), t.disabled && o.push(t.id), r && (t.parent = r), t.children && t.children.length ? e(t.children, t) : i[t.id] = t;
                  });
                }(r), {
                  treeNodes: r,
                  nodesById: n,
                  leafNodesById: i,
                  defaultValues: s,
                  defaultDisables: o
                };
              }
            }, {
              key: "createRootEle",
              value: function () {
                var e = document.createElement("div");
                return e.classList.add("treejs"), e;
              }
            }, {
              key: "createUlEle",
              value: function () {
                var e = document.createElement("ul");
                return e.classList.add("treejs-nodes"), e;
              }
            }, {
              key: "createLiEle",
              value: function (e, t) {
                var r = document.createElement("li");
                if (r.classList.add("treejs-node"), t && r.classList.add("treejs-node__close"), e.children && e.children.length) {
                  var n = document.createElement("span");
                  n.classList.add("treejs-switcher"), r.appendChild(n);
                } else r.classList.add("treejs-placeholder");
                var i = document.createElement("span");
                i.classList.add("treejs-checkbox"), r.appendChild(i);
                var s = document.createElement("span");
                s.classList.add("treejs-label");
                var o = document.createTextNode(e.text);
                return s.appendChild(o), r.appendChild(s), r.nodeId = e.id, r;
              }
            }], (r = [{
              key: "init",
              value: function (t) {
                var r = e.parseTreeData(t),
                  n = r.treeNodes,
                  i = r.nodesById,
                  s = r.leafNodesById,
                  o = r.defaultValues,
                  a = r.defaultDisables;
                this.treeNodes = n, this.nodesById = i, this.leafNodesById = s, this.render(this.treeNodes);
                var l = this.options,
                  c = l.values,
                  u = l.disables,
                  h = l.loaded;
                c && c.length ? this.setValues(c) : o && o.length && this.setValues(o), u && u.length ? this.setDisables(u) : a && a.length && this.setDisables(a), "function" == typeof h && h.call(this);
              }
            }, {
              key: "render",
              value: function (t) {
                var r = e.createRootEle();
                r.appendChild(this.buildTree(t, 0)), this.bindEvent(r);
                var n = "string" == typeof this.container ? document.querySelector(this.container) : this.container;
                !function (e) {
                  for (; e.firstChild;) e.removeChild(e.firstChild);
                }(n), n.appendChild(r);
              }
            }, {
              key: "buildTree",
              value: function (t, r) {
                var n = this,
                  i = e.createUlEle();
                return t && t.length && t.forEach(function (t) {
                  var s = e.createLiEle(t, r === n.options.closeDepth - 1);
                  n.liElementsById[t.id] = s;
                  var o = null;
                  t.children && t.children.length && (o = n.buildTree(t.children, r + 1)), o && s.appendChild(o), i.appendChild(s);
                }), i;
              }
            }, {
              key: "bindEvent",
              value: function (t) {
                var r = this;
                t.addEventListener("click", function (t) {
                  var n = t.target;
                  "SPAN" === n.nodeName && n.classList.contains("treejs-checkbox") ? r.onItemClick(n.parentNode.nodeId) : "SPAN" === n.nodeName && n.classList.contains("treejs-label") ? r.onItemLabelClick(n.parentNode.nodeId) : "LI" === n.nodeName && n.classList.contains("treejs-node") ? r.onItemClick(n.nodeId) : "SPAN" === n.nodeName && n.classList.contains("treejs-switcher") && e.onSwitcherClick(n);
                }, !1);
              }
            }, {
              key: "onItemClick",
              value: function (e) {
                var t = this.nodesById[e],
                  r = this.options.onChange;
                t.disabled || (this.setValue(e), this.updateLiElements()), r && r.call(this);
              }
            }, {
              key: "onItemLabelClick",
              value: function (e) {
                var t = this.options.onItemLabelClick;
                t && t.call(this, e);
              }
            }, {
              key: "setValue",
              value: function (e) {
                var t = this.nodesById[e];
                if (t) {
                  var r = t.status,
                    n = 1 === r || 2 === r ? 0 : 2;
                  t.status = n, this.markWillUpdateNode(t), this.walkUp(t, "status"), this.walkDown(t, "status");
                }
              }
            }, {
              key: "getValues",
              value: function () {
                var e = this,
                  t = [];
                return Object.keys(this.leafNodesById).forEach(function (r) {
                  Object.prototype.hasOwnProperty.call(e.leafNodesById, r) && (1 !== e.leafNodesById[r].status && 2 !== e.leafNodesById[r].status || t.push(r));
                }), t;
              }
            }, {
              key: "setValues",
              value: function (e) {
                var t = this;
                this.emptyNodesCheckStatus(), e.forEach(function (e) {
                  t.setValue(e);
                }), this.updateLiElements();
                var r = this.options.onChange;
                r && r.call(this);
              }
            }, {
              key: "setDisable",
              value: function (e) {
                var t = this.nodesById[e];
                t && (t.disabled || (t.disabled = !0, this.markWillUpdateNode(t), this.walkUp(t, "disabled"), this.walkDown(t, "disabled")));
              }
            }, {
              key: "getDisables",
              value: function () {
                var e = this,
                  t = [];
                return Object.keys(this.leafNodesById).forEach(function (r) {
                  Object.prototype.hasOwnProperty.call(e.leafNodesById, r) && e.leafNodesById[r].disabled && t.push(r);
                }), t;
              }
            }, {
              key: "setDisables",
              value: function (e) {
                var t = this;
                this.emptyNodesDisable(), e.forEach(function (e) {
                  t.setDisable(e);
                }), this.updateLiElements();
              }
            }, {
              key: "emptyNodesCheckStatus",
              value: function () {
                this.willUpdateNodesById = this.getSelectedNodesById(), Object.values(this.willUpdateNodesById).forEach(function (e) {
                  e.disabled || (e.status = 0);
                });
              }
            }, {
              key: "emptyNodesDisable",
              value: function () {
                this.willUpdateNodesById = this.getDisabledNodesById(), Object.values(this.willUpdateNodesById).forEach(function (e) {
                  e.disabled = !1;
                });
              }
            }, {
              key: "getSelectedNodesById",
              value: function () {
                return Object.entries(this.nodesById).reduce(function (e, t) {
                  var r = v(t, 2),
                    n = r[0],
                    i = r[1];
                  return 1 !== i.status && 2 !== i.status || (e[n] = i), e;
                }, {});
              }
            }, {
              key: "getDisabledNodesById",
              value: function () {
                return Object.entries(this.nodesById).reduce(function (e, t) {
                  var r = v(t, 2),
                    n = r[0],
                    i = r[1];
                  return i.disabled && (e[n] = i), e;
                }, {});
              }
            }, {
              key: "updateLiElements",
              value: function () {
                var e = this;
                Object.values(this.willUpdateNodesById).forEach(function (t) {
                  e.updateLiElement(t);
                }), this.willUpdateNodesById = {};
              }
            }, {
              key: "markWillUpdateNode",
              value: function (e) {
                this.willUpdateNodesById[e.id] = e;
              }
            }, {
              key: "walkUp",
              value: function (e, t) {
                var r = e.parent;
                if (r) {
                  if ("status" === t) {
                    var n,
                      i = r.children.reduce(function (e, t) {
                        return Number.isNaN(t.status) ? e : e + t.status;
                      }, 0);
                    if (n = i ? i === 2 * r.children.length ? 2 : 1 : 0, r.status === n) return;
                    r.status = n;
                  } else {
                    var s = r.children.reduce(function (e, t) {
                      return e && t.disabled;
                    }, !0);
                    if (r.disabled === s) return;
                    r.disabled = s;
                  }
                  this.markWillUpdateNode(r), this.walkUp(r, t);
                }
              }
            }, {
              key: "walkDown",
              value: function (e, t) {
                var r = this;
                e.children && e.children.length && e.children.forEach(function (n) {
                  "status" === t && n.disabled || (n[t] = e[t], r.markWillUpdateNode(n), r.walkDown(n, t));
                });
              }
            }, {
              key: "updateLiElement",
              value: function (e) {
                var t = this.liElementsById[e.id].classList;
                switch (e.status) {
                  case 0:
                    t.remove("treejs-node__halfchecked", "treejs-node__checked");
                    break;
                  case 1:
                    t.remove("treejs-node__checked"), t.add("treejs-node__halfchecked");
                    break;
                  case 2:
                    t.remove("treejs-node__halfchecked"), t.add("treejs-node__checked");
                }
                switch (e.disabled) {
                  case !0:
                    t.contains("treejs-node__disabled") || t.add("treejs-node__disabled");
                    break;
                  case !1:
                    t.contains("treejs-node__disabled") && t.remove("treejs-node__disabled");
                }
              }
            }, {
              key: "collapseAll",
              value: function () {
                var e = this;
                Object.keys(this.leafNodesById).forEach(function (t) {
                  var r = e.leafNodesById[t];
                  C(e, r);
                });
              }
            }, {
              key: "expandAll",
              value: function () {
                M(this, this.treeNodes[0]);
              }
            }]) && w(t.prototype, r), n && w(t, n), Object.defineProperty(t, "prototype", {
              writable: !1
            }), e;
          }();
        }(), n.default;
      }();
    },
    819: function (e, t) {
      !function (e) {
        const t = "tp";
        function r(e) {
          return t => r => {
            if (!t && void 0 === r) return {
              succeeded: !1,
              value: void 0
            };
            if (t && void 0 === r) return {
              succeeded: !0,
              value: void 0
            };
            const n = e(r);
            return void 0 !== n ? {
              succeeded: !0,
              value: n
            } : {
              succeeded: !1,
              value: void 0
            };
          };
        }
        function n(e) {
          return {
            custom: t => r(t)(e),
            boolean: r(e => "boolean" == typeof e ? e : void 0)(e),
            number: r(e => "number" == typeof e ? e : void 0)(e),
            string: r(e => "string" == typeof e ? e : void 0)(e),
            function: r(e => "function" == typeof e ? e : void 0)(e),
            constant: t => r(e => e === t ? t : void 0)(e),
            raw: r(e => e)(e),
            object: t => r(e => {
              if (null !== (r = e) && "object" == typeof r) return function (e, t) {
                return Object.keys(t).reduce((r, n) => {
                  if (void 0 === r) return;
                  const i = (0, t[n])(e[n]);
                  return i.succeeded ? Object.assign(Object.assign({}, r), {
                    [n]: i.value
                  }) : void 0;
                }, {});
              }(e, t);
              var r;
            })(e),
            array: t => r(e => {
              if (Array.isArray(e)) return r = t, e.reduce((e, t) => {
                if (void 0 === e) return;
                const n = r(t);
                return n.succeeded && void 0 !== n.value ? [...e, n.value] : void 0;
              }, []);
              var r;
            })(e)
          };
        }
        const i = {
          optional: n(!0),
          required: n(!1)
        };
        function s(e, t, r, n) {
          return new (r || (r = Promise))(function (i, s) {
            function o(e) {
              try {
                l(n.next(e));
              } catch (e) {
                s(e);
              }
            }
            function a(e) {
              try {
                l(n.throw(e));
              } catch (e) {
                s(e);
              }
            }
            function l(e) {
              var t;
              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {
                e(t);
              })).then(o, a);
            }
            l((n = n.apply(e, t || [])).next());
          });
        }
        function o(e) {
          return s(this, void 0, void 0, function* () {
            const t = new Image();
            return t.crossOrigin = "anonymous", new Promise((r, n) => {
              t.src = e, t.onload = () => {
                r(t);
              }, t.onerror = n;
            });
          });
        }
        const a = (l = "img", (e, r) => [t, "-", l, "v", e ? `_${e}` : "", r ? `-${r}` : ""].join(""));
        var l;
        class c {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(a()), t.viewProps.bindClassModifiers(this.element), this.input = e.createElement("input"), this.input.classList.add(a("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", t.extensions.join(",")), this.image_ = e.createElement("img"), this.image_.classList.add(a("image")), this.image_.classList.add(a(`image_${t.imageFit}`)), this.image_.crossOrigin = "anonymous", this.image_.onclick = e => {
              t.clickCallback ? t.clickCallback(e, this.input) : this.input.click();
            }, this.element.classList.add(a("area_root")), this.element.appendChild(this.image_), this.element.appendChild(this.input);
          }
          changeImage(e) {
            this.image_.src = e;
          }
          changeDraggingState(e) {
            const t = this.element;
            e ? null == t || t.classList.add(a("area_dragging")) : null == t || t.classList.remove(a("area_dragging"));
          }
        }
        let u = null;
        class h {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.view = new c(e, {
              viewProps: this.viewProps,
              extensions: t.extensions,
              imageFit: t.imageFit,
              clickCallback: t.clickCallback
            }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose(() => {
              this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave);
            }), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange();
          }
          onFile(e) {
            const t = (null == e ? void 0 : e.target).files;
            if (!t || !t.length) return;
            const r = t[0];
            this.setValue(r);
          }
          onDrop(e) {
            return s(this, void 0, void 0, function* () {
              e.preventDefault();
              try {
                const {
                    dataTransfer: t
                  } = e,
                  r = null == t ? void 0 : t.files[0];
                if (r) this.setValue(r);else {
                  const e = null == t ? void 0 : t.getData("url");
                  if (!e) throw new Error("No url");
                  this.setValue(e);
                }
              } catch (e) {
                console.error("Could not parse the dropped image", e);
              } finally {
                this.view.changeDraggingState(!1);
              }
            });
          }
          onDragOver(e) {
            e.preventDefault(), this.view.changeDraggingState(!0);
          }
          onDragLeave() {
            this.view.changeDraggingState(!1);
          }
          handleImage(e) {
            return s(this, void 0, void 0, function* () {
              e instanceof HTMLImageElement ? this.updateImage(e.src) : "string" != typeof e && e ? yield this.setValue(e) : ("placeholder" !== e && e || (e = (yield this.handlePlaceholderImage()).src), this.updateImage(e));
            });
          }
          updateImage(e) {
            this.view.changeImage(e);
          }
          setValue(e) {
            return s(this, void 0, void 0, function* () {
              if (e instanceof HTMLImageElement) this.value.setRawValue(e);else if (e instanceof File) {
                const t = URL.createObjectURL(e) + "#" + e.name;
                e.src = t;
                const r = yield o(t).catch(() => {});
                this.value.setRawValue(r || e);
              } else e ? this.value.setRawValue(yield o(e)) : this.value.setRawValue(yield this.handlePlaceholderImage());
            });
          }
          handleValueChange() {
            this.handleImage(this.value.rawValue);
          }
          handlePlaceholderImage() {
            return s(this, void 0, void 0, function* () {
              return u || (u = yield function () {
                const e = document.createElement("canvas");
                e.width = 320, e.height = 50;
                const t = e.getContext("2d");
                return t.fillStyle = "#00000004", t.fillRect(0, 0, e.width, e.height), t.fillStyle = "#eee", t.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace', t.textAlign = "center", t.textBaseline = "middle", t.fillText("No image", .5 * e.width, .5 * e.height), new Promise(t => {
                  e.toBlob(e => {
                    const r = new Image();
                    r.src = URL.createObjectURL(e), r.isPlaceholder = !0, r.onload = () => {
                      t(r);
                    };
                  });
                });
              }()), u;
            });
          }
        }
        const p = [".jpg", ".png", ".gif"],
          d = {
            id: "input-image",
            type: "input",
            css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us) * 3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us) * 3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:0.6}",
            accept(e, t) {
              if (!(e instanceof HTMLImageElement || "string" == typeof e)) return null;
              const r = i,
                n = function (e, t) {
                  const r = i.required.object(t)(e);
                  return r.succeeded ? r.value : void 0;
                }(t, {
                  view: r.required.constant("input-image"),
                  acceptUrl: r.optional.boolean,
                  clickCallback: r.optional.function,
                  imageFit: r.optional.custom(e => "contain" === e || "cover" === e ? e : void 0),
                  extensions: r.optional.array(r.required.string)
                });
              return n ? {
                initialValue: e,
                params: n
              } : null;
            },
            binding: {
              reader: e => e => void 0 !== e.src ? "" === e.src ? "placeholder" : e.src : e,
              writer: e => (e, t) => {
                e.write(t);
              }
            },
            controller(e) {
              var t, r;
              return new h(e.document, {
                value: e.value,
                imageFit: null !== (t = e.params.imageFit) && void 0 !== t ? t : "cover",
                clickCallback: e.params.clickCallback,
                viewProps: e.viewProps,
                extensions: null !== (r = e.params.extensions) && void 0 !== r ? r : p
              });
            }
          };
        e.plugin = d, Object.defineProperty(e, "__esModule", {
          value: !0
        });
      }(t);
    },
    665: function (e, t) {
      !function (e) {
        class t {
          constructor(e) {
            this.controller_ = e;
          }
          get disabled() {
            return this.controller_.viewProps.get("disabled");
          }
          set disabled(e) {
            this.controller_.viewProps.set("disabled", e);
          }
          get hidden() {
            return this.controller_.viewProps.get("hidden");
          }
          set hidden(e) {
            this.controller_.viewProps.set("hidden", e);
          }
          dispose() {
            this.controller_.viewProps.set("disposed", !0);
          }
        }
        class r {
          constructor(e) {
            this.target = e;
          }
        }
        class n extends r {
          constructor(e, t, r, n) {
            super(e), this.value = t, this.presetKey = r, this.last = null == n || n;
          }
        }
        class i extends r {
          constructor(e, t, r) {
            super(e), this.value = t, this.presetKey = r;
          }
        }
        class s extends r {
          constructor(e, t) {
            super(e), this.expanded = t;
          }
        }
        function o(e) {
          return null == e;
        }
        function a(e, t) {
          if (e.length !== t.length) return !1;
          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
          return !0;
        }
        const l = {
          alreadydisposed: () => "View has been already disposed",
          invalidparams: e => `Invalid parameters for '${e.name}'`,
          nomatchingcontroller: e => `No matching controller for '${e.key}'`,
          nomatchingview: e => `No matching view for '${JSON.stringify(e.params)}'`,
          notbindable: () => "Value is not bindable",
          propertynotfound: e => `Property '${e.name}' not found`,
          shouldneverhappen: () => "This error should never happen"
        };
        class c {
          constructor(e) {
            var t;
            this.message = null !== (t = l[e.type](e.context)) && void 0 !== t ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
          }
          static alreadyDisposed() {
            return new c({
              type: "alreadydisposed"
            });
          }
          static notBindable() {
            return new c({
              type: "notbindable"
            });
          }
          static propertyNotFound(e) {
            return new c({
              type: "propertynotfound",
              context: {
                name: e
              }
            });
          }
          static shouldNeverHappen() {
            return new c({
              type: "shouldneverhappen"
            });
          }
        }
        class u {
          constructor(e, t, r) {
            this.obj_ = e, this.key_ = t, this.presetKey_ = null != r ? r : t;
          }
          static isBindable(e) {
            return null !== e && "object" == typeof e;
          }
          get key() {
            return this.key_;
          }
          get presetKey() {
            return this.presetKey_;
          }
          read() {
            return this.obj_[this.key_];
          }
          write(e) {
            this.obj_[this.key_] = e;
          }
          writeProperty(e, t) {
            const r = this.read();
            if (!u.isBindable(r)) throw c.notBindable();
            if (!(e in r)) throw c.propertyNotFound(e);
            r[e] = t;
          }
        }
        class h extends t {
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          get title() {
            var e;
            return null !== (e = this.controller_.valueController.props.get("title")) && void 0 !== e ? e : "";
          }
          set title(e) {
            this.controller_.valueController.props.set("title", e);
          }
          on(e, t) {
            const n = t.bind(this);
            return this.controller_.valueController.emitter.on(e, () => {
              n(new r(this));
            }), this;
          }
        }
        class p {
          constructor() {
            this.observers_ = {};
          }
          on(e, t) {
            let r = this.observers_[e];
            return r || (r = this.observers_[e] = []), r.push({
              handler: t
            }), this;
          }
          off(e, t) {
            const r = this.observers_[e];
            return r && (this.observers_[e] = r.filter(e => e.handler !== t)), this;
          }
          emit(e, t) {
            const r = this.observers_[e];
            r && r.forEach(e => {
              e.handler(t);
            });
          }
        }
        const d = "tp";
        function f(e) {
          return (t, r) => [d, "-", e, "v", t ? `_${t}` : "", r ? `-${r}` : ""].join("");
        }
        function m(e) {
          return e.rawValue;
        }
        function _(e, t) {
          var r, n;
          e.emitter.on("change", (r = m, n = t, e => n(r(e)))), t(e.rawValue);
        }
        function g(e, t, r) {
          _(e.value(t), r);
        }
        function v(e, t) {
          return r => {
            !function (e, t, r) {
              r ? e.classList.add(t) : e.classList.remove(t);
            }(e, t, r);
          };
        }
        function A(e, t) {
          _(e, e => {
            t.textContent = null != e ? e : "";
          });
        }
        const b = f("btn");
        class y {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(b()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("button");
            r.classList.add(b("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r;
            const n = e.createElement("div");
            n.classList.add(b("t")), A(t.props.value("title"), n), this.buttonElement.appendChild(n);
          }
        }
        class x {
          constructor(e, t) {
            this.emitter = new p(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new y(e, {
              props: this.props,
              viewProps: this.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class w {
          constructor(e, t) {
            var r;
            this.constraint_ = null == t ? void 0 : t.constraint, this.equals_ = null !== (r = null == t ? void 0 : t.equals) && void 0 !== r ? r : (e, t) => e === t, this.emitter = new p(), this.rawValue_ = e;
          }
          get constraint() {
            return this.constraint_;
          }
          get rawValue() {
            return this.rawValue_;
          }
          set rawValue(e) {
            this.setRawValue(e, {
              forceEmit: !1,
              last: !0
            });
          }
          setRawValue(e, t) {
            const r = null != t ? t : {
                forceEmit: !1,
                last: !0
              },
              n = this.constraint_ ? this.constraint_.constrain(e) : e;
            (!this.equals_(this.rawValue_, n) || r.forceEmit) && (this.emitter.emit("beforechange", {
              sender: this
            }), this.rawValue_ = n, this.emitter.emit("change", {
              options: r,
              rawValue: n,
              sender: this
            }));
          }
        }
        class E {
          constructor(e) {
            this.emitter = new p(), this.value_ = e;
          }
          get rawValue() {
            return this.value_;
          }
          set rawValue(e) {
            this.setRawValue(e, {
              forceEmit: !1,
              last: !0
            });
          }
          setRawValue(e, t) {
            const r = null != t ? t : {
              forceEmit: !1,
              last: !0
            };
            (this.value_ !== e || r.forceEmit) && (this.emitter.emit("beforechange", {
              sender: this
            }), this.value_ = e, this.emitter.emit("change", {
              options: r,
              rawValue: this.value_,
              sender: this
            }));
          }
        }
        function S(e, t) {
          const r = null == t ? void 0 : t.constraint,
            n = null == t ? void 0 : t.equals;
          return r || n ? new w(e, t) : new E(e);
        }
        class C {
          constructor(e) {
            this.emitter = new p(), this.valMap_ = e;
            for (const e in this.valMap_) this.valMap_[e].emitter.on("change", () => {
              this.emitter.emit("change", {
                key: e,
                sender: this
              });
            });
          }
          static createCore(e) {
            return Object.keys(e).reduce((t, r) => Object.assign(t, {
              [r]: S(e[r])
            }), {});
          }
          static fromObject(e) {
            const t = this.createCore(e);
            return new C(t);
          }
          get(e) {
            return this.valMap_[e].rawValue;
          }
          set(e, t) {
            this.valMap_[e].rawValue = t;
          }
          value(e) {
            return this.valMap_[e];
          }
        }
        function M(e) {
          return t => r => {
            if (!t && void 0 === r) return {
              succeeded: !1,
              value: void 0
            };
            if (t && void 0 === r) return {
              succeeded: !0,
              value: void 0
            };
            const n = e(r);
            return void 0 !== n ? {
              succeeded: !0,
              value: n
            } : {
              succeeded: !1,
              value: void 0
            };
          };
        }
        function T(e) {
          return {
            custom: t => M(t)(e),
            boolean: M(e => "boolean" == typeof e ? e : void 0)(e),
            number: M(e => "number" == typeof e ? e : void 0)(e),
            string: M(e => "string" == typeof e ? e : void 0)(e),
            function: M(e => "function" == typeof e ? e : void 0)(e),
            constant: t => M(e => e === t ? t : void 0)(e),
            raw: M(e => e)(e),
            object: t => M(e => {
              if (null !== (r = e) && "object" == typeof r) return function (e, t) {
                return Object.keys(t).reduce((r, n) => {
                  if (void 0 === r) return;
                  const i = (0, t[n])(e[n]);
                  return i.succeeded ? Object.assign(Object.assign({}, r), {
                    [n]: i.value
                  }) : void 0;
                }, {});
              }(e, t);
              var r;
            })(e),
            array: t => M(e => {
              if (Array.isArray(e)) return r = t, e.reduce((e, t) => {
                if (void 0 === e) return;
                const n = r(t);
                return n.succeeded && void 0 !== n.value ? [...e, n.value] : void 0;
              }, []);
              var r;
            })(e)
          };
        }
        const I = {
          optional: T(!0),
          required: T(!1)
        };
        function k(e, t) {
          const r = I.required.object(t)(e);
          return r.succeeded ? r.value : void 0;
        }
        const D = f(""),
          P = {
            veryfirst: "vfst",
            first: "fst",
            last: "lst",
            verylast: "vlst"
          };
        class B {
          constructor(e) {
            this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
            const t = this.view.element;
            this.blade.value("positions").emitter.on("change", () => {
              ["veryfirst", "first", "last", "verylast"].forEach(e => {
                t.classList.remove(D(void 0, P[e]));
              }), this.blade.get("positions").forEach(e => {
                t.classList.add(D(void 0, P[e]));
              });
            }), this.viewProps.handleDispose(() => {
              !function (e) {
                e && e.parentElement && e.parentElement.removeChild(e);
              }(t);
            });
          }
          get parent() {
            return this.parent_;
          }
        }
        const R = "http://www.w3.org/2000/svg";
        function L(e) {
          e.offsetHeight;
        }
        function O(e) {
          return void 0 !== e.ontouchstart;
        }
        function F() {
          return new Function("return this")().document;
        }
        const U = {
          check: '<path d="M2 8l4 4l8 -8"/>',
          dropdown: '<path d="M5 7h6l-3 3 z"/>',
          p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
        };
        function N(e, t) {
          const r = e.createElementNS(R, "svg");
          return r.innerHTML = U[t], r;
        }
        function j(e, t, r) {
          e.insertBefore(t, e.children[r]);
        }
        function z(e) {
          e.parentElement && e.parentElement.removeChild(e);
        }
        function G(e) {
          for (; e.children.length > 0;) e.removeChild(e.children[0]);
        }
        function V(e) {
          return e.relatedTarget ? e.relatedTarget : "explicitOriginalTarget" in e ? e.explicitOriginalTarget : null;
        }
        const Q = f("lbl");
        class H {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Q()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("div");
            r.classList.add(Q("l")), g(t.props, "label", t => {
              o(t) ? this.element.classList.add(Q(void 0, "nol")) : (this.element.classList.remove(Q(void 0, "nol")), function (e) {
                for (; e.childNodes.length > 0;) e.removeChild(e.childNodes[0]);
              }(r), r.appendChild(function (e, t) {
                const r = e.createDocumentFragment();
                return t.split("\n").map(t => e.createTextNode(t)).forEach((t, n) => {
                  n > 0 && r.appendChild(e.createElement("br")), r.appendChild(t);
                }), r;
              }(e, t)));
            }), this.element.appendChild(r), this.labelElement = r;
            const n = e.createElement("div");
            n.classList.add(Q("v")), this.element.appendChild(n), this.valueElement = n;
          }
        }
        class W extends B {
          constructor(e, t) {
            const r = t.valueController.viewProps;
            super(Object.assign(Object.assign({}, t), {
              view: new H(e, {
                props: t.props,
                viewProps: r
              }),
              viewProps: r
            })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        const q = {
          id: "button",
          type: "blade",
          accept(e) {
            const t = I,
              r = k(e, {
                title: t.required.string,
                view: t.required.constant("button"),
                label: t.optional.string
              });
            return r ? {
              params: r
            } : null;
          },
          controller: e => new W(e.document, {
            blade: e.blade,
            props: C.fromObject({
              label: e.params.label
            }),
            valueController: new x(e.document, {
              props: C.fromObject({
                title: e.params.title
              }),
              viewProps: e.viewProps
            })
          }),
          api: e => e.controller instanceof W && e.controller.valueController instanceof x ? new h(e.controller) : null
        };
        class X extends B {
          constructor(e) {
            super(e), this.value = e.value;
          }
        }
        function Y() {
          return new C({
            positions: S([], {
              equals: a
            })
          });
        }
        class K extends C {
          constructor(e) {
            super(e);
          }
          static create(e) {
            const t = {
                completed: !0,
                expanded: e,
                expandedHeight: null,
                shouldFixHeight: !1,
                temporaryExpanded: null
              },
              r = C.createCore(t);
            return new K(r);
          }
          get styleExpanded() {
            var e;
            return null !== (e = this.get("temporaryExpanded")) && void 0 !== e ? e : this.get("expanded");
          }
          get styleHeight() {
            if (!this.styleExpanded) return "0";
            const e = this.get("expandedHeight");
            return this.get("shouldFixHeight") && !o(e) ? `${e}px` : "auto";
          }
          bindExpandedClass(e, t) {
            const r = () => {
              this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
            };
            g(this, "expanded", r), g(this, "temporaryExpanded", r);
          }
          cleanUpTransition() {
            this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
          }
        }
        function J(e, t) {
          t.style.height = e.styleHeight;
        }
        function Z(e, t) {
          e.value("expanded").emitter.on("beforechange", () => {
            e.set("completed", !1), o(e.get("expandedHeight")) && e.set("expandedHeight", function (e, t) {
              let r = 0;
              return function (e, t) {
                const r = e.style.transition;
                e.style.transition = "none", t(), e.style.transition = r;
              }(t, () => {
                e.set("expandedHeight", null), e.set("temporaryExpanded", !0), L(t), r = t.clientHeight, e.set("temporaryExpanded", null), L(t);
              }), r;
            }(e, t)), e.set("shouldFixHeight", !0), L(t);
          }), e.emitter.on("change", () => {
            J(e, t);
          }), J(e, t), t.addEventListener("transitionend", t => {
            "height" === t.propertyName && e.cleanUpTransition();
          });
        }
        class $ extends t {
          constructor(e, t) {
            super(e), this.rackApi_ = t;
          }
        }
        class ee {
          constructor(e) {
            this.emitter = new p(), this.items_ = [], this.cache_ = new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
          }
          get items() {
            return this.items_;
          }
          allItems() {
            return Array.from(this.cache_);
          }
          find(e) {
            for (const t of this.allItems()) if (e(t)) return t;
            return null;
          }
          includes(e) {
            return this.cache_.has(e);
          }
          add(e, t) {
            if (this.includes(e)) throw c.shouldNeverHappen();
            const r = void 0 !== t ? t : this.items_.length;
            this.items_.splice(r, 0, e), this.cache_.add(e);
            const n = this.extract_(e);
            n && (n.emitter.on("add", this.onSubListAdd_), n.emitter.on("remove", this.onSubListRemove_), n.allItems().forEach(e => {
              this.cache_.add(e);
            })), this.emitter.emit("add", {
              index: r,
              item: e,
              root: this,
              target: this
            });
          }
          remove(e) {
            const t = this.items_.indexOf(e);
            if (t < 0) return;
            this.items_.splice(t, 1), this.cache_.delete(e);
            const r = this.extract_(e);
            r && (r.emitter.off("add", this.onSubListAdd_), r.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
              index: t,
              item: e,
              root: this,
              target: this
            });
          }
          onSubListAdd_(e) {
            this.cache_.add(e.item), this.emitter.emit("add", {
              index: e.index,
              item: e.item,
              root: this,
              target: e.target
            });
          }
          onSubListRemove_(e) {
            this.cache_.delete(e.item), this.emitter.emit("remove", {
              index: e.index,
              item: e.item,
              root: this,
              target: e.target
            });
          }
        }
        class te extends t {
          constructor(e) {
            super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new p(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingChange_(e) {
            const t = e.sender.target.read();
            this.emitter_.emit("change", {
              event: new n(this, t, this.controller_.binding.target.presetKey, e.options.last)
            });
          }
        }
        class re extends W {
          constructor(e, t) {
            super(e, t), this.binding = t.binding;
          }
        }
        class ne extends t {
          constructor(e) {
            super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new p(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingUpdate_(e) {
            const t = e.sender.target.read();
            this.emitter_.emit("update", {
              event: new i(this, t, this.controller_.binding.target.presetKey)
            });
          }
        }
        class ie extends W {
          constructor(e, t) {
            super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
              this.binding.dispose();
            });
          }
        }
        function se(e) {
          return e instanceof le ? e.apiSet_ : e instanceof $ ? e.rackApi_.apiSet_ : null;
        }
        function oe(e, t) {
          const r = e.find(e => e.controller_ === t);
          if (!r) throw c.shouldNeverHappen();
          return r;
        }
        function ae(e, t, r) {
          if (!u.isBindable(e)) throw c.notBindable();
          return new u(e, t, r);
        }
        class le extends t {
          constructor(e, t) {
            super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new p(), this.apiSet_ = new ee(se), this.pool_ = t;
            const r = this.controller_.rack;
            r.emitter.on("add", this.onRackAdd_), r.emitter.on("remove", this.onRackRemove_), r.emitter.on("inputchange", this.onRackInputChange_), r.emitter.on("monitorupdate", this.onRackMonitorUpdate_), r.children.forEach(e => {
              this.setUpApi_(e);
            });
          }
          get children() {
            return this.controller_.rack.children.map(e => oe(this.apiSet_, e));
          }
          addInput(e, t, r) {
            const n = r || {},
              i = this.controller_.view.element.ownerDocument,
              s = this.pool_.createInput(i, ae(e, t, n.presetKey), n),
              o = new te(s);
            return this.add(o, n.index);
          }
          addMonitor(e, t, r) {
            const n = r || {},
              i = this.controller_.view.element.ownerDocument,
              s = this.pool_.createMonitor(i, ae(e, t), n),
              o = new ne(s);
            return this.add(o, n.index);
          }
          addFolder(e) {
            return function (e, t) {
              return e.addBlade(Object.assign(Object.assign({}, t), {
                view: "folder"
              }));
            }(this, e);
          }
          addButton(e) {
            return function (e, t) {
              return e.addBlade(Object.assign(Object.assign({}, t), {
                view: "button"
              }));
            }(this, e);
          }
          addSeparator(e) {
            return function (e, t) {
              const r = t || {};
              return e.addBlade(Object.assign(Object.assign({}, r), {
                view: "separator"
              }));
            }(this, e);
          }
          addTab(e) {
            return function (e, t) {
              return e.addBlade(Object.assign(Object.assign({}, t), {
                view: "tab"
              }));
            }(this, e);
          }
          add(e, t) {
            this.controller_.rack.add(e.controller_, t);
            const r = this.apiSet_.find(t => t.controller_ === e.controller_);
            return r && this.apiSet_.remove(r), this.apiSet_.add(e), e;
          }
          remove(e) {
            this.controller_.rack.remove(e.controller_);
          }
          addBlade(e) {
            const t = this.controller_.view.element.ownerDocument,
              r = this.pool_.createBlade(t, e),
              n = this.pool_.createBladeApi(r);
            return this.add(n, e.index);
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
          setUpApi_(e) {
            this.apiSet_.find(t => t.controller_ === e) || this.apiSet_.add(this.pool_.createBladeApi(e));
          }
          onRackAdd_(e) {
            this.setUpApi_(e.bladeController);
          }
          onRackRemove_(e) {
            if (e.isRoot) {
              const t = oe(this.apiSet_, e.bladeController);
              this.apiSet_.remove(t);
            }
          }
          onRackInputChange_(e) {
            const t = e.bladeController;
            if (t instanceof re) {
              const r = oe(this.apiSet_, t),
                i = t.binding;
              this.emitter_.emit("change", {
                event: new n(r, i.target.read(), i.target.presetKey, e.options.last)
              });
            } else if (t instanceof X) {
              const r = oe(this.apiSet_, t);
              this.emitter_.emit("change", {
                event: new n(r, t.value.rawValue, void 0, e.options.last)
              });
            }
          }
          onRackMonitorUpdate_(e) {
            if (!(e.bladeController instanceof ie)) throw c.shouldNeverHappen();
            const t = oe(this.apiSet_, e.bladeController),
              r = e.bladeController.binding;
            this.emitter_.emit("update", {
              event: new i(t, r.target.read(), r.target.presetKey)
            });
          }
        }
        class ce extends $ {
          constructor(e, t) {
            super(e, new le(e.rackController, t)), this.emitter_ = new p(), this.controller_.foldable.value("expanded").emitter.on("change", e => {
              this.emitter_.emit("fold", {
                event: new s(this, e.sender.rawValue)
              });
            }), this.rackApi_.on("change", e => {
              this.emitter_.emit("change", {
                event: e
              });
            }), this.rackApi_.on("update", e => {
              this.emitter_.emit("update", {
                event: e
              });
            });
          }
          get expanded() {
            return this.controller_.foldable.get("expanded");
          }
          set expanded(e) {
            this.controller_.foldable.set("expanded", e);
          }
          get title() {
            return this.controller_.props.get("title");
          }
          set title(e) {
            this.controller_.props.set("title", e);
          }
          get children() {
            return this.rackApi_.children;
          }
          addInput(e, t, r) {
            return this.rackApi_.addInput(e, t, r);
          }
          addMonitor(e, t, r) {
            return this.rackApi_.addMonitor(e, t, r);
          }
          addFolder(e) {
            return this.rackApi_.addFolder(e);
          }
          addButton(e) {
            return this.rackApi_.addButton(e);
          }
          addSeparator(e) {
            return this.rackApi_.addSeparator(e);
          }
          addTab(e) {
            return this.rackApi_.addTab(e);
          }
          add(e, t) {
            return this.rackApi_.add(e, t);
          }
          remove(e) {
            this.rackApi_.remove(e);
          }
          addBlade(e) {
            return this.rackApi_.addBlade(e);
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
        }
        class ue extends B {
          constructor(e) {
            super({
              blade: e.blade,
              view: e.view,
              viewProps: e.rackController.viewProps
            }), this.rackController = e.rackController;
          }
        }
        class he {
          constructor(e, t) {
            const r = f(t.viewName);
            this.element = e.createElement("div"), this.element.classList.add(r()), t.viewProps.bindClassModifiers(this.element);
          }
        }
        function pe(e) {
          return e instanceof me ? e.rack : e instanceof ue ? e.rackController.rack : null;
        }
        function de(e) {
          const t = pe(e);
          return t ? t.bcSet_ : null;
        }
        class fe {
          constructor(e) {
            var t;
            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new p(), this.blade_ = null != e ? e : null, null === (t = this.blade_) || void 0 === t || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new ee(de), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
          }
          get children() {
            return this.bcSet_.items;
          }
          add(e, t) {
            e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t);
          }
          remove(e) {
            e.parent_ = null, this.bcSet_.remove(e);
          }
          find(e) {
            return this.bcSet_.allItems().filter(t => t instanceof e);
          }
          onSetAdd_(e) {
            this.updatePositions_();
            const t = e.target === e.root;
            if (this.emitter.emit("add", {
              bladeController: e.item,
              index: e.index,
              isRoot: t,
              sender: this
            }), !t) return;
            const r = e.item;
            if (r.viewProps.emitter.on("change", this.onChildViewPropsChange_), r.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), r.viewProps.handleDispose(this.onChildDispose_), r instanceof re) r.binding.emitter.on("change", this.onChildInputChange_);else if (r instanceof ie) r.binding.emitter.on("update", this.onChildMonitorUpdate_);else if (r instanceof X) r.value.emitter.on("change", this.onChildValueChange_);else {
              const e = pe(r);
              if (e) {
                const t = e.emitter;
                t.on("layout", this.onDescendantLayout_), t.on("inputchange", this.onDescendantInputChange_), t.on("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          onSetRemove_(e) {
            this.updatePositions_();
            const t = e.target === e.root;
            if (this.emitter.emit("remove", {
              bladeController: e.item,
              isRoot: t,
              sender: this
            }), !t) return;
            const r = e.item;
            if (r instanceof re) r.binding.emitter.off("change", this.onChildInputChange_);else if (r instanceof ie) r.binding.emitter.off("update", this.onChildMonitorUpdate_);else if (r instanceof X) r.value.emitter.off("change", this.onChildValueChange_);else {
              const e = pe(r);
              if (e) {
                const t = e.emitter;
                t.off("layout", this.onDescendantLayout_), t.off("inputchange", this.onDescendantInputChange_), t.off("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          updatePositions_() {
            const e = this.bcSet_.items.filter(e => !e.viewProps.get("hidden")),
              t = e[0],
              r = e[e.length - 1];
            this.bcSet_.items.forEach(e => {
              const n = [];
              e === t && (n.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || n.push("veryfirst")), e === r && (n.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || n.push("verylast")), e.blade.set("positions", n);
            });
          }
          onChildPositionsChange_() {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildViewPropsChange_(e) {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildDispose_() {
            this.bcSet_.items.filter(e => e.viewProps.get("disposed")).forEach(e => {
              this.bcSet_.remove(e);
            });
          }
          onChildInputChange_(e) {
            const t = function (e, t) {
              for (let r = 0; r < e.length; r++) {
                const n = e[r];
                if (n instanceof re && n.binding === t) return n;
              }
              return null;
            }(this.find(re), e.sender);
            if (!t) throw c.shouldNeverHappen();
            this.emitter.emit("inputchange", {
              bladeController: t,
              options: e.options,
              sender: this
            });
          }
          onChildMonitorUpdate_(e) {
            const t = function (e, t) {
              for (let r = 0; r < e.length; r++) {
                const n = e[r];
                if (n instanceof ie && n.binding === t) return n;
              }
              return null;
            }(this.find(ie), e.sender);
            if (!t) throw c.shouldNeverHappen();
            this.emitter.emit("monitorupdate", {
              bladeController: t,
              sender: this
            });
          }
          onChildValueChange_(e) {
            const t = function (e, t) {
              for (let r = 0; r < e.length; r++) {
                const n = e[r];
                if (n instanceof X && n.value === t) return n;
              }
              return null;
            }(this.find(X), e.sender);
            if (!t) throw c.shouldNeverHappen();
            this.emitter.emit("inputchange", {
              bladeController: t,
              options: e.options,
              sender: this
            });
          }
          onDescendantLayout_(e) {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onDescendantInputChange_(e) {
            this.emitter.emit("inputchange", {
              bladeController: e.bladeController,
              options: e.options,
              sender: this
            });
          }
          onDescendantMonitorUpdate_(e) {
            this.emitter.emit("monitorupdate", {
              bladeController: e.bladeController,
              sender: this
            });
          }
          onBladePositionsChange_() {
            this.updatePositions_();
          }
        }
        class me extends B {
          constructor(e, t) {
            super(Object.assign(Object.assign({}, t), {
              view: new he(e, {
                viewName: "brk",
                viewProps: t.viewProps
              })
            })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
            const r = new fe(t.root ? void 0 : t.blade);
            r.emitter.on("add", this.onRackAdd_), r.emitter.on("remove", this.onRackRemove_), this.rack = r, this.viewProps.handleDispose(() => {
              for (let e = this.rack.children.length - 1; e >= 0; e--) this.rack.children[e].viewProps.set("disposed", !0);
            });
          }
          onRackAdd_(e) {
            e.isRoot && j(this.view.element, e.bladeController.view.element, e.index);
          }
          onRackRemove_(e) {
            e.isRoot && z(e.bladeController.view.element);
          }
        }
        const _e = f("cnt");
        class ge {
          constructor(e, t) {
            this.className_ = f(t.viewName || "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), _e()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), g(this.foldable_, "completed", v(this.element, this.className_(void 0, "cpl")));
            const r = e.createElement("button");
            r.classList.add(this.className_("b")), g(t.props, "title", e => {
              o(e) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
            }), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r;
            const n = e.createElement("div");
            n.classList.add(this.className_("t")), A(t.props.value("title"), n), this.buttonElement.appendChild(n), this.titleElement = n;
            const i = e.createElement("div");
            i.classList.add(this.className_("m")), this.buttonElement.appendChild(i);
            const s = t.containerElement;
            s.classList.add(this.className_("c")), this.element.appendChild(s), this.containerElement = s;
          }
        }
        class ve extends ue {
          constructor(e, t) {
            var r;
            const n = K.create(null === (r = t.expanded) || void 0 === r || r),
              i = new me(e, {
                blade: t.blade,
                root: t.root,
                viewProps: t.viewProps
              });
            super(Object.assign(Object.assign({}, t), {
              rackController: i,
              view: new ge(e, {
                containerElement: i.view.element,
                foldable: n,
                props: t.props,
                viewName: t.root ? "rot" : void 0,
                viewProps: t.viewProps
              })
            })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = n, Z(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
              this.foldable.cleanUpTransition();
            }), this.rackController.rack.emitter.on("remove", () => {
              this.foldable.cleanUpTransition();
            }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
          }
          get document() {
            return this.view.element.ownerDocument;
          }
          onTitleClick_() {
            this.foldable.set("expanded", !this.foldable.get("expanded"));
          }
        }
        const Ae = {
          id: "folder",
          type: "blade",
          accept(e) {
            const t = I,
              r = k(e, {
                title: t.required.string,
                view: t.required.constant("folder"),
                expanded: t.optional.boolean
              });
            return r ? {
              params: r
            } : null;
          },
          controller: e => new ve(e.document, {
            blade: e.blade,
            expanded: e.params.expanded,
            props: C.fromObject({
              title: e.params.title
            }),
            viewProps: e.viewProps
          }),
          api: e => e.controller instanceof ve ? new ce(e.controller, e.pool) : null
        };
        class be extends X {
          constructor(e, t) {
            const r = t.valueController.viewProps;
            super(Object.assign(Object.assign({}, t), {
              value: t.valueController.value,
              view: new H(e, {
                props: t.props,
                viewProps: r
              }),
              viewProps: r
            })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        class ye extends t {}
        const xe = f("spr");
        class we {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(xe()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("hr");
            r.classList.add(xe("r")), this.element.appendChild(r);
          }
        }
        class Ee extends B {
          constructor(e, t) {
            super(Object.assign(Object.assign({}, t), {
              view: new we(e, {
                viewProps: t.viewProps
              })
            }));
          }
        }
        const Se = {
            id: "separator",
            type: "blade",
            accept(e) {
              const t = k(e, {
                view: I.required.constant("separator")
              });
              return t ? {
                params: t
              } : null;
            },
            controller: e => new Ee(e.document, {
              blade: e.blade,
              viewProps: e.viewProps
            }),
            api: e => e.controller instanceof Ee ? new ye(e.controller) : null
          },
          Ce = f("");
        function Me(e, t) {
          return v(e, Ce(void 0, t));
        }
        class Te extends C {
          constructor(e) {
            super(e);
          }
          static create(e) {
            var t, r;
            const n = null != e ? e : {},
              i = {
                disabled: null !== (t = n.disabled) && void 0 !== t && t,
                disposed: !1,
                hidden: null !== (r = n.hidden) && void 0 !== r && r
              },
              s = C.createCore(i);
            return new Te(s);
          }
          bindClassModifiers(e) {
            g(this, "disabled", Me(e, "disabled")), g(this, "hidden", Me(e, "hidden"));
          }
          bindDisabled(e) {
            g(this, "disabled", t => {
              e.disabled = t;
            });
          }
          bindTabIndex(e) {
            g(this, "disabled", t => {
              e.tabIndex = t ? -1 : 0;
            });
          }
          handleDispose(e) {
            this.value("disposed").emitter.on("change", t => {
              t && e();
            });
          }
        }
        const Ie = f("tbi");
        class ke {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Ie()), t.viewProps.bindClassModifiers(this.element), g(t.props, "selected", e => {
              e ? this.element.classList.add(Ie(void 0, "sel")) : this.element.classList.remove(Ie(void 0, "sel"));
            });
            const r = e.createElement("button");
            r.classList.add(Ie("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r;
            const n = e.createElement("div");
            n.classList.add(Ie("t")), A(t.props.value("title"), n), this.buttonElement.appendChild(n), this.titleElement = n;
          }
        }
        class De {
          constructor(e, t) {
            this.emitter = new p(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new ke(e, {
              props: t.props,
              viewProps: t.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class Pe {
          constructor(e, t) {
            this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new De(e, {
              props: t.itemProps,
              viewProps: Te.create()
            }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new me(e, {
              blade: Y(),
              viewProps: Te.create()
            }), this.props = t.props, g(this.props, "selected", e => {
              this.itemController.props.set("selected", e), this.contentController.viewProps.set("hidden", !e);
            });
          }
          get itemController() {
            return this.ic_;
          }
          get contentController() {
            return this.cc_;
          }
          onItemClick_() {
            this.props.set("selected", !0);
          }
        }
        class Be {
          constructor(e, t) {
            this.controller_ = e, this.rackApi_ = t;
          }
          get title() {
            var e;
            return null !== (e = this.controller_.itemController.props.get("title")) && void 0 !== e ? e : "";
          }
          set title(e) {
            this.controller_.itemController.props.set("title", e);
          }
          get selected() {
            return this.controller_.props.get("selected");
          }
          set selected(e) {
            this.controller_.props.set("selected", e);
          }
          get children() {
            return this.rackApi_.children;
          }
          addButton(e) {
            return this.rackApi_.addButton(e);
          }
          addFolder(e) {
            return this.rackApi_.addFolder(e);
          }
          addSeparator(e) {
            return this.rackApi_.addSeparator(e);
          }
          addTab(e) {
            return this.rackApi_.addTab(e);
          }
          add(e, t) {
            this.rackApi_.add(e, t);
          }
          remove(e) {
            this.rackApi_.remove(e);
          }
          addInput(e, t, r) {
            return this.rackApi_.addInput(e, t, r);
          }
          addMonitor(e, t, r) {
            return this.rackApi_.addMonitor(e, t, r);
          }
          addBlade(e) {
            return this.rackApi_.addBlade(e);
          }
        }
        class Re extends $ {
          constructor(e, t) {
            super(e, new le(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.emitter_ = new p(), this.pageApiMap_ = new Map(), this.rackApi_.on("change", e => {
              this.emitter_.emit("change", {
                event: e
              });
            }), this.rackApi_.on("update", e => {
              this.emitter_.emit("update", {
                event: e
              });
            }), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach(e => {
              this.setUpPageApi_(e);
            });
          }
          get pages() {
            return this.controller_.pageSet.items.map(e => {
              const t = this.pageApiMap_.get(e);
              if (!t) throw c.shouldNeverHappen();
              return t;
            });
          }
          addPage(e) {
            const t = this.controller_.view.element.ownerDocument,
              r = new Pe(t, {
                itemProps: C.fromObject({
                  selected: !1,
                  title: e.title
                }),
                props: C.fromObject({
                  selected: !1
                })
              });
            this.controller_.add(r, e.index);
            const n = this.pageApiMap_.get(r);
            if (!n) throw c.shouldNeverHappen();
            return n;
          }
          removePage(e) {
            this.controller_.remove(e);
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
          setUpPageApi_(e) {
            const t = this.rackApi_.apiSet_.find(t => t.controller_ === e.contentController);
            if (!t) throw c.shouldNeverHappen();
            const r = new Be(e, t);
            this.pageApiMap_.set(e, r);
          }
          onPageAdd_(e) {
            this.setUpPageApi_(e.item);
          }
          onPageRemove_(e) {
            if (!this.pageApiMap_.get(e.item)) throw c.shouldNeverHappen();
            this.pageApiMap_.delete(e.item);
          }
        }
        const Le = f("tab");
        class Oe {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Le(), _e()), t.viewProps.bindClassModifiers(this.element), _(t.empty, v(this.element, Le(void 0, "nop")));
            const r = e.createElement("div");
            r.classList.add(Le("i")), this.element.appendChild(r), this.itemsElement = r;
            const n = t.contentsElement;
            n.classList.add(Le("c")), this.element.appendChild(n), this.contentsElement = n;
          }
        }
        class Fe extends ue {
          constructor(e, t) {
            const r = new me(e, {
                blade: t.blade,
                viewProps: t.viewProps
              }),
              n = S(!0);
            super({
              blade: t.blade,
              rackController: r,
              view: new Oe(e, {
                contentsElement: r.view.element,
                empty: n,
                viewProps: t.viewProps
              })
            }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this), this.pageSet_ = new ee(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.empty_ = n, this.applyPages_();
          }
          get pageSet() {
            return this.pageSet_;
          }
          add(e, t) {
            this.pageSet_.add(e, null != t ? t : this.pageSet_.items.length);
          }
          remove(e) {
            this.pageSet_.remove(this.pageSet_.items[e]);
          }
          applyPages_() {
            this.keepSelection_(), this.empty_.rawValue = 0 === this.pageSet_.items.length;
          }
          onPageAdd_(e) {
            const t = e.item;
            j(this.view.itemsElement, t.itemController.view.element, e.index), this.rackController.rack.add(t.contentController, e.index), t.props.value("selected").emitter.on("change", this.onPageSelectedChange_), this.applyPages_();
          }
          onPageRemove_(e) {
            const t = e.item;
            z(t.itemController.view.element), this.rackController.rack.remove(t.contentController), t.props.value("selected").emitter.off("change", this.onPageSelectedChange_), this.applyPages_();
          }
          keepSelection_() {
            if (0 === this.pageSet_.items.length) return;
            const e = this.pageSet_.items.findIndex(e => e.props.get("selected"));
            e < 0 ? this.pageSet_.items.forEach((e, t) => {
              e.props.set("selected", 0 === t);
            }) : this.pageSet_.items.forEach((t, r) => {
              t.props.set("selected", r === e);
            });
          }
          onPageSelectedChange_(e) {
            if (e.rawValue) {
              const t = this.pageSet_.items.findIndex(t => t.props.value("selected") === e.sender);
              this.pageSet_.items.forEach((e, r) => {
                e.props.set("selected", r === t);
              });
            } else this.keepSelection_();
          }
        }
        const Ue = {
          id: "tab",
          type: "blade",
          accept(e) {
            const t = I,
              r = k(e, {
                pages: t.required.array(t.required.object({
                  title: t.required.string
                })),
                view: t.required.constant("tab")
              });
            return r && 0 !== r.pages.length ? {
              params: r
            } : null;
          },
          controller(e) {
            const t = new Fe(e.document, {
              blade: e.blade,
              viewProps: e.viewProps
            });
            return e.params.pages.forEach(r => {
              const n = new Pe(e.document, {
                itemProps: C.fromObject({
                  selected: !1,
                  title: r.title
                }),
                props: C.fromObject({
                  selected: !1
                })
              });
              t.add(n);
            }), t;
          },
          api: e => e.controller instanceof Fe ? new Re(e.controller, e.pool) : null
        };
        class Ne {
          constructor() {
            this.disabled = !1, this.emitter = new p();
          }
          dispose() {}
          tick() {
            this.disabled || this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class je {
          constructor(e, t) {
            this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new p(), this.interval_ = t, this.setTimer_();
          }
          get disabled() {
            return this.disabled_;
          }
          set disabled(e) {
            this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
          }
          dispose() {
            this.clearTimer_();
          }
          clearTimer_() {
            if (null === this.timerId_) return;
            const e = this.doc_.defaultView;
            e && e.clearInterval(this.timerId_), this.timerId_ = null;
          }
          setTimer_() {
            if (this.clearTimer_(), this.interval_ <= 0) return;
            const e = this.doc_.defaultView;
            e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
          }
          onTick_() {
            this.disabled_ || this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class ze {
          constructor(e) {
            this.constraints = e;
          }
          constrain(e) {
            return this.constraints.reduce((e, t) => t.constrain(e), e);
          }
        }
        function Ge(e, t) {
          if (e instanceof t) return e;
          if (e instanceof ze) {
            const r = e.constraints.reduce((e, r) => e || (r instanceof t ? r : null), null);
            if (r) return r;
          }
          return null;
        }
        class Ve {
          constructor(e) {
            this.options = e;
          }
          constrain(e) {
            const t = this.options;
            return 0 === t.length || t.filter(t => t.value === e).length > 0 ? e : t[0].value;
          }
        }
        class Qe {
          constructor(e) {
            this.maxValue = e.max, this.minValue = e.min;
          }
          constrain(e) {
            let t = e;
            return o(this.minValue) || (t = Math.max(t, this.minValue)), o(this.maxValue) || (t = Math.min(t, this.maxValue)), t;
          }
        }
        class He {
          constructor(e) {
            this.step = e;
          }
          constrain(e) {
            return (e < 0 ? -Math.round(-e / this.step) : Math.round(e / this.step)) * this.step;
          }
        }
        const We = f("lst");
        class qe {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(We()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("select");
            r.classList.add(We("s")), g(this.props_, "options", t => {
              G(r), t.forEach((t, n) => {
                const i = e.createElement("option");
                i.dataset.index = String(n), i.textContent = t.text, i.value = String(t.value), r.appendChild(i);
              });
            }), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.selectElement = r;
            const n = e.createElement("div");
            n.classList.add(We("m")), n.appendChild(N(e, "dropdown")), this.element.appendChild(n), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_();
          }
          update_() {
            this.selectElement.value = String(this.value_.rawValue);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class Xe {
          constructor(e, t) {
            this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new qe(e, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
          }
          onSelectChange_(e) {
            const t = e.currentTarget.selectedOptions.item(0);
            if (!t) return;
            const r = Number(t.dataset.index);
            this.value.rawValue = this.props.get("options")[r].value;
          }
        }
        const Ye = f("pop");
        class Ke {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Ye()), t.viewProps.bindClassModifiers(this.element), _(t.shows, v(this.element, Ye(void 0, "v")));
          }
        }
        class Je {
          constructor(e, t) {
            this.shows = S(!1), this.viewProps = t.viewProps, this.view = new Ke(e, {
              shows: this.shows,
              viewProps: this.viewProps
            });
          }
        }
        const Ze = f("txt");
        class $e {
          constructor(e, t) {
            this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Ze()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
            const r = e.createElement("input");
            r.classList.add(Ze("i")), r.type = "text", t.viewProps.bindDisabled(r), this.element.appendChild(r), this.inputElement = r, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
          }
          refresh() {
            const e = this.props_.get("formatter");
            this.inputElement.value = e(this.value_.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class et {
          constructor(e, t) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new $e(e, {
              props: t.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(e) {
            const t = e.currentTarget.value,
              r = this.parser_(t);
            o(r) || (this.value.rawValue = r), this.view.refresh();
          }
        }
        function tt(e) {
          return "false" !== e && !!e;
        }
        function rt(e) {
          return function (e) {
            return String(e);
          }(e);
        }
        class nt {
          constructor(e) {
            this.text = e;
          }
          evaluate() {
            return Number(this.text);
          }
          toString() {
            return this.text;
          }
        }
        const it = {
          "**": (e, t) => Math.pow(e, t),
          "*": (e, t) => e * t,
          "/": (e, t) => e / t,
          "%": (e, t) => e % t,
          "+": (e, t) => e + t,
          "-": (e, t) => e - t,
          "<<": (e, t) => e << t,
          ">>": (e, t) => e >> t,
          ">>>": (e, t) => e >>> t,
          "&": (e, t) => e & t,
          "^": (e, t) => e ^ t,
          "|": (e, t) => e | t
        };
        class st {
          constructor(e, t, r) {
            this.left = t, this.operator = e, this.right = r;
          }
          evaluate() {
            const e = it[this.operator];
            if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
            return e(this.left.evaluate(), this.right.evaluate());
          }
          toString() {
            return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
          }
        }
        const ot = {
          "+": e => e,
          "-": e => -e,
          "~": e => ~e
        };
        class at {
          constructor(e, t) {
            this.operator = e, this.expression = t;
          }
          evaluate() {
            const e = ot[this.operator];
            if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
            return e(this.expression.evaluate());
          }
          toString() {
            return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
          }
        }
        function lt(e) {
          return (t, r) => {
            for (let n = 0; n < e.length; n++) {
              const i = e[n](t, r);
              if ("" !== i) return i;
            }
            return "";
          };
        }
        function ct(e, t) {
          var r;
          const n = e.substr(t).match(/^\s+/);
          return null !== (r = n && n[0]) && void 0 !== r ? r : "";
        }
        function ut(e, t) {
          var r;
          const n = e.substr(t).match(/^[0-9]+/);
          return null !== (r = n && n[0]) && void 0 !== r ? r : "";
        }
        function ht(e, t) {
          const r = e.substr(t, 1);
          if (t += 1, "e" !== r.toLowerCase()) return "";
          const n = function (e, t) {
            const r = ut(e, t);
            if ("" !== r) return r;
            const n = e.substr(t, 1);
            if ("-" !== n && "+" !== n) return "";
            const i = ut(e, t += 1);
            return "" === i ? "" : n + i;
          }(e, t);
          return "" === n ? "" : r + n;
        }
        function pt(e, t) {
          const r = e.substr(t, 1);
          if ("0" === r) return r;
          const n = function (e, t) {
            const r = e.substr(t, 1);
            return r.match(/^[1-9]$/) ? r : "";
          }(e, t);
          return t += n.length, "" === n ? "" : n + ut(e, t);
        }
        const dt = lt([function (e, t) {
          const r = pt(e, t);
          if (t += r.length, "" === r) return "";
          const n = e.substr(t, 1);
          if (t += n.length, "." !== n) return "";
          const i = ut(e, t);
          return r + n + i + ht(e, t += i.length);
        }, function (e, t) {
          const r = e.substr(t, 1);
          if (t += r.length, "." !== r) return "";
          const n = ut(e, t);
          return t += n.length, "" === n ? "" : r + n + ht(e, t);
        }, function (e, t) {
          const r = pt(e, t);
          return t += r.length, "" === r ? "" : r + ht(e, t);
        }]);
        const ft = lt([function (e, t) {
            const r = e.substr(t, 2);
            if (t += r.length, "0b" !== r.toLowerCase()) return "";
            const n = function (e, t) {
              var r;
              const n = e.substr(t).match(/^[01]+/);
              return null !== (r = n && n[0]) && void 0 !== r ? r : "";
            }(e, t);
            return "" === n ? "" : r + n;
          }, function (e, t) {
            const r = e.substr(t, 2);
            if (t += r.length, "0o" !== r.toLowerCase()) return "";
            const n = function (e, t) {
              var r;
              const n = e.substr(t).match(/^[0-7]+/);
              return null !== (r = n && n[0]) && void 0 !== r ? r : "";
            }(e, t);
            return "" === n ? "" : r + n;
          }, function (e, t) {
            const r = e.substr(t, 2);
            if (t += r.length, "0x" !== r.toLowerCase()) return "";
            const n = function (e, t) {
              var r;
              const n = e.substr(t).match(/^[0-9a-f]+/i);
              return null !== (r = n && n[0]) && void 0 !== r ? r : "";
            }(e, t);
            return "" === n ? "" : r + n;
          }]),
          mt = lt([ft, dt]);
        function _t(e, t) {
          return function (e, t) {
            const r = mt(e, t);
            return t += r.length, "" === r ? null : {
              evaluable: new nt(r),
              cursor: t
            };
          }(e, t) || function (e, t) {
            const r = e.substr(t, 1);
            if (t += r.length, "(" !== r) return null;
            const n = At(e, t);
            if (!n) return null;
            t = n.cursor, t += ct(e, t).length;
            const i = e.substr(t, 1);
            return t += i.length, ")" !== i ? null : {
              evaluable: n.evaluable,
              cursor: t
            };
          }(e, t);
        }
        function gt(e, t, r) {
          r += ct(t, r).length;
          const n = e.filter(e => t.startsWith(e, r))[0];
          return n ? (r += n.length, {
            cursor: r += ct(t, r).length,
            operator: n
          }) : null;
        }
        const vt = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((e, t) => function (e, t) {
          return (r, n) => {
            const i = e(r, n);
            if (!i) return null;
            n = i.cursor;
            let s = i.evaluable;
            for (;;) {
              const i = gt(t, r, n);
              if (!i) break;
              n = i.cursor;
              const o = e(r, n);
              if (!o) return null;
              n = o.cursor, s = new st(i.operator, s, o.evaluable);
            }
            return s ? {
              cursor: n,
              evaluable: s
            } : null;
          };
        }(e, t), function e(t, r) {
          const n = _t(t, r);
          if (n) return n;
          const i = t.substr(r, 1);
          if (r += i.length, "+" !== i && "-" !== i && "~" !== i) return null;
          const s = e(t, r);
          return s ? {
            cursor: r = s.cursor,
            evaluable: new at(i, s.evaluable)
          } : null;
        });
        function At(e, t) {
          return t += ct(e, t).length, vt(e, t);
        }
        function bt(e) {
          var t;
          const r = function (e) {
            const t = At(e, 0);
            return t ? t.cursor + ct(e, t.cursor).length !== e.length ? null : t.evaluable : null;
          }(e);
          return null !== (t = null == r ? void 0 : r.evaluate()) && void 0 !== t ? t : null;
        }
        function yt(e) {
          if ("number" == typeof e) return e;
          if ("string" == typeof e) {
            const t = bt(e);
            if (!o(t)) return t;
          }
          return 0;
        }
        function xt(e) {
          return String(e);
        }
        function wt(e) {
          return t => t.toFixed(Math.max(Math.min(e, 20), 0));
        }
        const Et = wt(0);
        function St(e) {
          return Et(e) + "%";
        }
        function Ct(e) {
          return String(e);
        }
        function Mt(e) {
          return e;
        }
        function Tt(e, t) {
          for (; e.length < t;) e.push(void 0);
        }
        function It(e) {
          const t = [];
          return Tt(t, e), S(t);
        }
        function kt(e) {
          const t = e.indexOf(void 0);
          return t < 0 ? e : e.slice(0, t);
        }
        function Dt({
          primary: e,
          secondary: t,
          forward: r,
          backward: n
        }) {
          let i = !1;
          function s(e) {
            i || (i = !0, e(), i = !1);
          }
          e.emitter.on("change", n => {
            s(() => {
              t.setRawValue(r(e, t), n.options);
            });
          }), t.emitter.on("change", i => {
            s(() => {
              e.setRawValue(n(e, t), i.options);
            }), s(() => {
              t.setRawValue(r(e, t), i.options);
            });
          }), s(() => {
            t.setRawValue(r(e, t), {
              forceEmit: !1,
              last: !0
            });
          });
        }
        function Pt(e, t) {
          const r = e * (t.altKey ? .1 : 1) * (t.shiftKey ? 10 : 1);
          return t.upKey ? +r : t.downKey ? -r : 0;
        }
        function Bt(e) {
          return {
            altKey: e.altKey,
            downKey: "ArrowDown" === e.key,
            shiftKey: e.shiftKey,
            upKey: "ArrowUp" === e.key
          };
        }
        function Rt(e) {
          return {
            altKey: e.altKey,
            downKey: "ArrowLeft" === e.key,
            shiftKey: e.shiftKey,
            upKey: "ArrowRight" === e.key
          };
        }
        function Lt(e) {
          return function (e) {
            return "ArrowUp" === e || "ArrowDown" === e;
          }(e) || "ArrowLeft" === e || "ArrowRight" === e;
        }
        function Ot(e, t) {
          const r = t.ownerDocument.defaultView,
            n = t.getBoundingClientRect();
          return {
            x: e.pageX - ((r && r.scrollX || 0) + n.left),
            y: e.pageY - ((r && r.scrollY || 0) + n.top)
          };
        }
        class Ft {
          constructor(e) {
            this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new p(), e.addEventListener("touchstart", this.onTouchStart_, {
              passive: !1
            }), e.addEventListener("touchmove", this.onTouchMove_, {
              passive: !0
            }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
          }
          computePosition_(e) {
            const t = this.elem_.getBoundingClientRect();
            return {
              bounds: {
                width: t.width,
                height: t.height
              },
              point: e ? {
                x: e.x,
                y: e.y
              } : null
            };
          }
          onMouseDown_(e) {
            var t;
            e.preventDefault(), null === (t = e.currentTarget) || void 0 === t || t.focus();
            const r = this.elem_.ownerDocument;
            r.addEventListener("mousemove", this.onDocumentMouseMove_), r.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
              altKey: e.altKey,
              data: this.computePosition_(Ot(e, this.elem_)),
              sender: this,
              shiftKey: e.shiftKey
            });
          }
          onDocumentMouseMove_(e) {
            this.emitter.emit("move", {
              altKey: e.altKey,
              data: this.computePosition_(Ot(e, this.elem_)),
              sender: this,
              shiftKey: e.shiftKey
            });
          }
          onDocumentMouseUp_(e) {
            const t = this.elem_.ownerDocument;
            t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
              altKey: e.altKey,
              data: this.computePosition_(Ot(e, this.elem_)),
              sender: this,
              shiftKey: e.shiftKey
            });
          }
          onTouchStart_(e) {
            e.preventDefault();
            const t = e.targetTouches.item(0),
              r = this.elem_.getBoundingClientRect();
            this.emitter.emit("down", {
              altKey: e.altKey,
              data: this.computePosition_(t ? {
                x: t.clientX - r.left,
                y: t.clientY - r.top
              } : void 0),
              sender: this,
              shiftKey: e.shiftKey
            }), this.lastTouch_ = t;
          }
          onTouchMove_(e) {
            const t = e.targetTouches.item(0),
              r = this.elem_.getBoundingClientRect();
            this.emitter.emit("move", {
              altKey: e.altKey,
              data: this.computePosition_(t ? {
                x: t.clientX - r.left,
                y: t.clientY - r.top
              } : void 0),
              sender: this,
              shiftKey: e.shiftKey
            }), this.lastTouch_ = t;
          }
          onTouchEnd_(e) {
            var t;
            const r = null !== (t = e.targetTouches.item(0)) && void 0 !== t ? t : this.lastTouch_,
              n = this.elem_.getBoundingClientRect();
            this.emitter.emit("up", {
              altKey: e.altKey,
              data: this.computePosition_(r ? {
                x: r.clientX - n.left,
                y: r.clientY - n.top
              } : void 0),
              sender: this,
              shiftKey: e.shiftKey
            });
          }
        }
        function Ut(e, t, r, n, i) {
          return n + (e - t) / (r - t) * (i - n);
        }
        function Nt(e) {
          return String(e.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
        }
        function jt(e, t, r) {
          return Math.min(Math.max(e, t), r);
        }
        function zt(e, t) {
          return (e % t + t) % t;
        }
        const Gt = f("txt");
        class Vt {
          constructor(e, t) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Gt(), Gt(void 0, "num")), t.arrayPosition && this.element.classList.add(Gt(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("input");
            r.classList.add(Gt("i")), r.type = "text", t.viewProps.bindDisabled(r), this.element.appendChild(r), this.inputElement = r, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Gt()), this.inputElement.classList.add(Gt("i"));
            const n = e.createElement("div");
            n.classList.add(Gt("k")), this.element.appendChild(n), this.knobElement = n;
            const i = e.createElementNS(R, "svg");
            i.classList.add(Gt("g")), this.knobElement.appendChild(i);
            const s = e.createElementNS(R, "path");
            s.classList.add(Gt("gb")), i.appendChild(s), this.guideBodyElem_ = s;
            const o = e.createElementNS(R, "path");
            o.classList.add(Gt("gh")), i.appendChild(o), this.guideHeadElem_ = o;
            const a = e.createElement("div");
            a.classList.add(f("tt")()), this.knobElement.appendChild(a), this.tooltipElem_ = a, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
          }
          onDraggingChange_(e) {
            if (null === e.rawValue) return void this.element.classList.remove(Gt(void 0, "drg"));
            this.element.classList.add(Gt(void 0, "drg"));
            const t = e.rawValue / this.props_.get("draggingScale"),
              r = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
              n = jt(-r, -4, 4);
            this.guideHeadElem_.setAttributeNS(null, "d", [`M ${r + n},0 L${r},4 L${r + n},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
            const i = this.props_.get("formatter");
            this.tooltipElem_.textContent = i(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
          }
          refresh() {
            const e = this.props_.get("formatter");
            this.inputElement.value = e(this.value.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class Qt {
          constructor(e, t) {
            this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = S(null), this.view = new Vt(e, {
              arrayPosition: t.arrayPosition,
              dragging: this.dragging_,
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
            const r = new Ft(this.view.knobElement);
            r.emitter.on("down", this.onPointerDown_), r.emitter.on("move", this.onPointerMove_), r.emitter.on("up", this.onPointerUp_);
          }
          onInputChange_(e) {
            const t = e.currentTarget.value,
              r = this.parser_(t);
            o(r) || (this.value.rawValue = r), this.view.refresh();
          }
          onInputKeyDown_(e) {
            const t = Pt(this.baseStep_, Bt(e));
            0 !== t && this.value.setRawValue(this.value.rawValue + t, {
              forceEmit: !1,
              last: !1
            });
          }
          onInputKeyUp_(e) {
            0 !== Pt(this.baseStep_, Bt(e)) && this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
          onPointerDown_() {
            this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
          }
          computeDraggingValue_(e) {
            if (!e.point) return null;
            const t = e.point.x - e.bounds.width / 2;
            return this.originRawValue_ + t * this.props.get("draggingScale");
          }
          onPointerMove_(e) {
            const t = this.computeDraggingValue_(e.data);
            null !== t && (this.value.setRawValue(t, {
              forceEmit: !1,
              last: !1
            }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
          }
          onPointerUp_(e) {
            const t = this.computeDraggingValue_(e.data);
            null !== t && (this.value.setRawValue(t, {
              forceEmit: !0,
              last: !0
            }), this.dragging_.rawValue = null);
          }
        }
        const Ht = f("sld");
        class Wt {
          constructor(e, t) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Ht()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("div");
            r.classList.add(Ht("t")), t.viewProps.bindTabIndex(r), this.element.appendChild(r), this.trackElement = r;
            const n = e.createElement("div");
            n.classList.add(Ht("k")), this.trackElement.appendChild(n), this.knobElement = n, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
          }
          update_() {
            const e = jt(Ut(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
            this.knobElement.style.width = `${e}%`;
          }
          onChange_() {
            this.update_();
          }
        }
        class qt {
          constructor(e, t) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new Wt(e, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Ft(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(e, t) {
            e.point && this.value.setRawValue(Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t);
          }
          onPointerDownOrMove_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerUp_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !0,
              last: !0
            });
          }
          onKeyDown_(e) {
            const t = Pt(this.baseStep_, Rt(e));
            0 !== t && this.value.setRawValue(this.value.rawValue + t, {
              forceEmit: !1,
              last: !1
            });
          }
          onKeyUp_(e) {
            0 !== Pt(this.baseStep_, Rt(e)) && this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
        }
        const Xt = f("sldtxt");
        class Yt {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Xt());
            const r = e.createElement("div");
            r.classList.add(Xt("s")), this.sliderView_ = t.sliderView, r.appendChild(this.sliderView_.element), this.element.appendChild(r);
            const n = e.createElement("div");
            n.classList.add(Xt("t")), this.textView_ = t.textView, n.appendChild(this.textView_.element), this.element.appendChild(n);
          }
        }
        class Kt {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new qt(e, {
              baseStep: t.baseStep,
              props: t.sliderProps,
              value: t.value,
              viewProps: this.viewProps
            }), this.textC_ = new Qt(e, {
              baseStep: t.baseStep,
              parser: t.parser,
              props: t.textProps,
              value: t.value,
              viewProps: t.viewProps
            }), this.view = new Yt(e, {
              sliderView: this.sliderC_.view,
              textView: this.textC_.view
            });
          }
          get sliderController() {
            return this.sliderC_;
          }
          get textController() {
            return this.textC_;
          }
        }
        function Jt(e, t) {
          e.write(t);
        }
        function Zt(e) {
          const t = I;
          return Array.isArray(e) ? t.required.array(t.required.object({
            text: t.required.string,
            value: t.required.raw
          }))(e).value : "object" == typeof e ? t.required.raw(e).value : void 0;
        }
        function $t(e) {
          if ("inline" === e || "popup" === e) return e;
        }
        function er(e) {
          const t = I;
          return t.required.object({
            max: t.optional.number,
            min: t.optional.number,
            step: t.optional.number
          })(e).value;
        }
        function tr(e) {
          if (Array.isArray(e)) return e;
          const t = [];
          return Object.keys(e).forEach(r => {
            t.push({
              text: r,
              value: e[r]
            });
          }), t;
        }
        function rr(e) {
          return o(e) ? null : new Ve(tr(e));
        }
        function nr(e) {
          const t = e ? Ge(e, Ve) : null;
          return t ? t.options : null;
        }
        function ir(e, t) {
          const r = e && Ge(e, He);
          return r ? Nt(r.step) : Math.max(Nt(t), 2);
        }
        function sr(e) {
          const t = function (e) {
            const t = e ? Ge(e, He) : null;
            return t ? t.step : null;
          }(e);
          return null != t ? t : 1;
        }
        function or(e, t) {
          var r;
          const n = e && Ge(e, He),
            i = Math.abs(null !== (r = null == n ? void 0 : n.step) && void 0 !== r ? r : t);
          return 0 === i ? .1 : Math.pow(10, Math.floor(Math.log10(i)) - 1);
        }
        const ar = f("ckb");
        class lr {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(ar()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("label");
            r.classList.add(ar("l")), this.element.appendChild(r);
            const n = e.createElement("input");
            n.classList.add(ar("i")), n.type = "checkbox", r.appendChild(n), this.inputElement = n, t.viewProps.bindDisabled(this.inputElement);
            const i = e.createElement("div");
            i.classList.add(ar("w")), r.appendChild(i);
            const s = N(e, "check");
            i.appendChild(s), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
          }
          update_() {
            this.inputElement.checked = this.value.rawValue;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class cr {
          constructor(e, t) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new lr(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(e) {
            const t = e.currentTarget;
            this.value.rawValue = t.checked;
          }
        }
        const ur = {
            id: "input-bool",
            type: "input",
            accept: (e, t) => {
              if ("boolean" != typeof e) return null;
              const r = k(t, {
                options: I.optional.custom(Zt)
              });
              return r ? {
                initialValue: e,
                params: r
              } : null;
            },
            binding: {
              reader: e => tt,
              constraint: e => function (e) {
                const t = [],
                  r = rr(e.options);
                return r && t.push(r), new ze(t);
              }(e.params),
              writer: e => Jt
            },
            controller: e => {
              var t;
              const r = e.document,
                n = e.value,
                i = e.constraint;
              return i && Ge(i, Ve) ? new Xe(r, {
                props: C.fromObject({
                  options: null !== (t = nr(i)) && void 0 !== t ? t : []
                }),
                value: n,
                viewProps: e.viewProps
              }) : new cr(r, {
                value: n,
                viewProps: e.viewProps
              });
            }
          },
          hr = f("col");
        class pr {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(hr()), t.foldable.bindExpandedClass(this.element, hr(void 0, "expanded")), g(t.foldable, "completed", v(this.element, hr(void 0, "cpl")));
            const r = e.createElement("div");
            r.classList.add(hr("h")), this.element.appendChild(r);
            const n = e.createElement("div");
            n.classList.add(hr("s")), r.appendChild(n), this.swatchElement = n;
            const i = e.createElement("div");
            if (i.classList.add(hr("t")), r.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
              const t = e.createElement("div");
              t.classList.add(hr("p")), this.element.appendChild(t), this.pickerElement = t;
            } else this.pickerElement = null;
          }
        }
        function dr(e, t, r) {
          const n = zt(e, 360),
            i = jt(t / 100, 0, 1),
            s = jt(r / 100, 0, 1),
            o = s * i,
            a = o * (1 - Math.abs(n / 60 % 2 - 1)),
            l = s - o;
          let c, u, h;
          return [c, u, h] = n >= 0 && n < 60 ? [o, a, 0] : n >= 60 && n < 120 ? [a, o, 0] : n >= 120 && n < 180 ? [0, o, a] : n >= 180 && n < 240 ? [0, a, o] : n >= 240 && n < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (h + l)];
        }
        function fr(e) {
          return [e[0], e[1], e[2]];
        }
        function mr(e, t) {
          return [e[0], e[1], e[2], t];
        }
        const _r = {
          hsl: {
            hsl: (e, t, r) => [e, t, r],
            hsv: function (e, t, r) {
              const n = r + t * (100 - Math.abs(2 * r - 100)) / 200;
              return [e, 0 !== n ? t * (100 - Math.abs(2 * r - 100)) / n : 0, r + t * (100 - Math.abs(2 * r - 100)) / 200];
            },
            rgb: function (e, t, r) {
              const n = (e % 360 + 360) % 360,
                i = jt(t / 100, 0, 1),
                s = jt(r / 100, 0, 1),
                o = (1 - Math.abs(2 * s - 1)) * i,
                a = o * (1 - Math.abs(n / 60 % 2 - 1)),
                l = s - o / 2;
              let c, u, h;
              return [c, u, h] = n >= 0 && n < 60 ? [o, a, 0] : n >= 60 && n < 120 ? [a, o, 0] : n >= 120 && n < 180 ? [0, o, a] : n >= 180 && n < 240 ? [0, a, o] : n >= 240 && n < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (h + l)];
            }
          },
          hsv: {
            hsl: function (e, t, r) {
              const n = 100 - Math.abs(r * (200 - t) / 100 - 100);
              return [e, 0 !== n ? t * r / n : 0, r * (200 - t) / 200];
            },
            hsv: (e, t, r) => [e, t, r],
            rgb: dr
          },
          rgb: {
            hsl: function (e, t, r) {
              const n = jt(e / 255, 0, 1),
                i = jt(t / 255, 0, 1),
                s = jt(r / 255, 0, 1),
                o = Math.max(n, i, s),
                a = Math.min(n, i, s),
                l = o - a;
              let c = 0,
                u = 0;
              const h = (a + o) / 2;
              return 0 !== l && (u = l / (1 - Math.abs(o + a - 1)), c = n === o ? (i - s) / l : i === o ? 2 + (s - n) / l : 4 + (n - i) / l, c = c / 6 + (c < 0 ? 1 : 0)), [360 * c, 100 * u, 100 * h];
            },
            hsv: function (e, t, r) {
              const n = jt(e / 255, 0, 1),
                i = jt(t / 255, 0, 1),
                s = jt(r / 255, 0, 1),
                o = Math.max(n, i, s),
                a = o - Math.min(n, i, s);
              let l;
              return l = 0 === a ? 0 : o === n ? ((i - s) / a % 6 + 6) % 6 * 60 : o === i ? 60 * ((s - n) / a + 2) : 60 * ((n - i) / a + 4), [l, 100 * (0 === o ? 0 : a / o), 100 * o];
            },
            rgb: (e, t, r) => [e, t, r]
          }
        };
        const gr = {
          hsl: e => {
            var t;
            return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
          },
          hsv: e => {
            var t;
            return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
          },
          rgb: e => {
            var t;
            return [jt(e[0], 0, 255), jt(e[1], 0, 255), jt(e[2], 0, 255), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
          }
        };
        function vr(e, t) {
          return "object" == typeof e && !o(e) && t in e && "number" == typeof e[t];
        }
        class Ar {
          constructor(e, t) {
            this.mode_ = t, this.comps_ = gr[t](e);
          }
          static black() {
            return new Ar([0, 0, 0], "rgb");
          }
          static fromObject(e) {
            const t = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
            return new Ar(t, "rgb");
          }
          static toRgbaObject(e) {
            return e.toRgbaObject();
          }
          static isRgbColorObject(e) {
            return vr(e, "r") && vr(e, "g") && vr(e, "b");
          }
          static isRgbaColorObject(e) {
            return this.isRgbColorObject(e) && vr(e, "a");
          }
          static isColorObject(e) {
            return this.isRgbColorObject(e);
          }
          static equals(e, t) {
            if (e.mode_ !== t.mode_) return !1;
            const r = e.comps_,
              n = t.comps_;
            for (let e = 0; e < r.length; e++) if (r[e] !== n[e]) return !1;
            return !0;
          }
          get mode() {
            return this.mode_;
          }
          getComponents(e) {
            return mr((t = fr(this.comps_), r = this.mode_, n = e || this.mode_, _r[r][n](...t)), this.comps_[3]);
            var t, r, n;
          }
          toRgbaObject() {
            const e = this.getComponents("rgb");
            return {
              r: e[0],
              g: e[1],
              b: e[2],
              a: e[3]
            };
          }
        }
        const br = f("colp");
        class yr {
          constructor(e, t) {
            this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(br());
            const r = e.createElement("div");
            r.classList.add(br("hsv"));
            const n = e.createElement("div");
            n.classList.add(br("sv")), this.svPaletteView_ = t.svPaletteView, n.appendChild(this.svPaletteView_.element), r.appendChild(n);
            const i = e.createElement("div");
            i.classList.add(br("h")), this.hPaletteView_ = t.hPaletteView, i.appendChild(this.hPaletteView_.element), r.appendChild(i), this.element.appendChild(r);
            const s = e.createElement("div");
            if (s.classList.add(br("rgb")), this.textView_ = t.textView, s.appendChild(this.textView_.element), this.element.appendChild(s), t.alphaViews) {
              this.alphaViews_ = {
                palette: t.alphaViews.palette,
                text: t.alphaViews.text
              };
              const r = e.createElement("div");
              r.classList.add(br("a"));
              const n = e.createElement("div");
              n.classList.add(br("ap")), n.appendChild(this.alphaViews_.palette.element), r.appendChild(n);
              const i = e.createElement("div");
              i.classList.add(br("at")), i.appendChild(this.alphaViews_.text.element), r.appendChild(i), this.element.appendChild(r);
            }
          }
          get allFocusableElements() {
            const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map(e => e.inputElement)];
            return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
          }
        }
        function xr(e) {
          const t = I;
          return k(e, {
            alpha: t.optional.boolean,
            expanded: t.optional.boolean,
            picker: t.optional.custom($t)
          });
        }
        function wr(e) {
          return e ? .1 : 1;
        }
        function Er(e, t) {
          const r = e.match(/^(.+)%$/);
          return r ? Math.min(.01 * parseFloat(r[1]) * t, t) : Math.min(parseFloat(e), t);
        }
        const Sr = {
          deg: e => e,
          grad: e => 360 * e / 400,
          rad: e => 360 * e / (2 * Math.PI),
          turn: e => 360 * e
        };
        function Cr(e) {
          const t = e.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
          if (!t) return parseFloat(e);
          const r = parseFloat(t[1]),
            n = t[2];
          return Sr[n](r);
        }
        const Mr = {
          "func.rgb": e => {
            const t = e.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!t) return null;
            const r = [Er(t[1], 255), Er(t[2], 255), Er(t[3], 255)];
            return isNaN(r[0]) || isNaN(r[1]) || isNaN(r[2]) ? null : new Ar(r, "rgb");
          },
          "func.rgba": e => {
            const t = e.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!t) return null;
            const r = [Er(t[1], 255), Er(t[2], 255), Er(t[3], 255), Er(t[4], 1)];
            return isNaN(r[0]) || isNaN(r[1]) || isNaN(r[2]) || isNaN(r[3]) ? null : new Ar(r, "rgb");
          },
          "func.hsl": e => {
            const t = e.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!t) return null;
            const r = [Cr(t[1]), Er(t[2], 100), Er(t[3], 100)];
            return isNaN(r[0]) || isNaN(r[1]) || isNaN(r[2]) ? null : new Ar(r, "hsl");
          },
          "func.hsla": e => {
            const t = e.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!t) return null;
            const r = [Cr(t[1]), Er(t[2], 100), Er(t[3], 100), Er(t[4], 1)];
            return isNaN(r[0]) || isNaN(r[1]) || isNaN(r[2]) || isNaN(r[3]) ? null : new Ar(r, "hsl");
          },
          "hex.rgb": e => {
            const t = e.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (t) return new Ar([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)], "rgb");
            const r = e.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            return r ? new Ar([parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16)], "rgb") : null;
          },
          "hex.rgba": e => {
            const t = e.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (t) return new Ar([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), Ut(parseInt(t[4] + t[4], 16), 0, 255, 0, 1)], "rgb");
            const r = e.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            return r ? new Ar([parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16), Ut(parseInt(r[4], 16), 0, 255, 0, 1)], "rgb") : null;
          }
        };
        function Tr(e) {
          return Object.keys(Mr).reduce((t, r) => t || ((0, Mr[r])(e) ? r : null), null);
        }
        const Ir = e => {
          const t = Tr(e);
          return t ? Mr[t](e) : null;
        };
        function kr(e) {
          return "func.hsla" === e || "func.rgba" === e || "hex.rgba" === e;
        }
        function Dr(e) {
          if ("string" == typeof e) {
            const t = Ir(e);
            if (t) return t;
          }
          return Ar.black();
        }
        function Pr(e) {
          const t = jt(Math.floor(e), 0, 255).toString(16);
          return 1 === t.length ? `0${t}` : t;
        }
        function Br(e, t = "#") {
          return `${t}${fr(e.getComponents("rgb")).map(Pr).join("")}`;
        }
        function Rr(e, t = "#") {
          const r = e.getComponents("rgb");
          return `${t}${[r[0], r[1], r[2], 255 * r[3]].map(Pr).join("")}`;
        }
        function Lr(e) {
          const t = wt(0);
          return `rgb(${fr(e.getComponents("rgb")).map(e => t(e)).join(", ")})`;
        }
        function Or(e) {
          const t = wt(2),
            r = wt(0);
          return `rgba(${e.getComponents("rgb").map((e, n) => (3 === n ? t : r)(e)).join(", ")})`;
        }
        const Fr = {
          "func.hsl": function (e) {
            const t = [wt(0), St, St];
            return `hsl(${fr(e.getComponents("hsl")).map((e, r) => t[r](e)).join(", ")})`;
          },
          "func.hsla": function (e) {
            const t = [wt(0), St, St, wt(2)];
            return `hsla(${e.getComponents("hsl").map((e, r) => t[r](e)).join(", ")})`;
          },
          "func.rgb": Lr,
          "func.rgba": Or,
          "hex.rgb": Br,
          "hex.rgba": Rr
        };
        function Ur(e) {
          return Fr[e];
        }
        const Nr = f("apl");
        class jr {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Nr()), t.viewProps.bindTabIndex(this.element);
            const r = e.createElement("div");
            r.classList.add(Nr("b")), this.element.appendChild(r);
            const n = e.createElement("div");
            n.classList.add(Nr("c")), r.appendChild(n), this.colorElem_ = n;
            const i = e.createElement("div");
            i.classList.add(Nr("m")), this.element.appendChild(i), this.markerElem_ = i;
            const s = e.createElement("div");
            s.classList.add(Nr("p")), this.markerElem_.appendChild(s), this.previewElem_ = s, this.update_();
          }
          update_() {
            const e = this.value.rawValue,
              t = e.getComponents("rgb"),
              r = new Ar([t[0], t[1], t[2], 0], "rgb"),
              n = new Ar([t[0], t[1], t[2], 255], "rgb"),
              i = ["to right", Or(r), Or(n)];
            this.colorElem_.style.background = `linear-gradient(${i.join(",")})`, this.previewElem_.style.backgroundColor = Or(e);
            const s = Ut(t[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${s}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class zr {
          constructor(e, t) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new jr(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(e, t) {
            if (!e.point) return;
            const r = e.point.x / e.bounds.width,
              n = this.value.rawValue,
              [i, s, o] = n.getComponents("hsv");
            this.value.setRawValue(new Ar([i, s, o, r], "hsv"), t);
          }
          onPointerDown_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerMove_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerUp_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !0,
              last: !0
            });
          }
          onKeyDown_(e) {
            const t = Pt(wr(!0), Rt(e));
            if (0 === t) return;
            const r = this.value.rawValue,
              [n, i, s, o] = r.getComponents("hsv");
            this.value.setRawValue(new Ar([n, i, s, o + t], "hsv"), {
              forceEmit: !1,
              last: !1
            });
          }
          onKeyUp_(e) {
            0 !== Pt(wr(!0), Rt(e)) && this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
        }
        const Gr = f("coltxt");
        class Vr {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Gr());
            const r = e.createElement("div");
            r.classList.add(Gr("m")), this.modeElem_ = function (e) {
              const t = e.createElement("select");
              return t.appendChild([{
                text: "RGB",
                value: "rgb"
              }, {
                text: "HSL",
                value: "hsl"
              }, {
                text: "HSV",
                value: "hsv"
              }].reduce((t, r) => {
                const n = e.createElement("option");
                return n.textContent = r.text, n.value = r.value, t.appendChild(n), t;
              }, e.createDocumentFragment())), t;
            }(e), this.modeElem_.classList.add(Gr("ms")), r.appendChild(this.modeSelectElement);
            const n = e.createElement("div");
            n.classList.add(Gr("mm")), n.appendChild(N(e, "dropdown")), r.appendChild(n), this.element.appendChild(r);
            const i = e.createElement("div");
            i.classList.add(Gr("w")), this.element.appendChild(i), this.textsElem_ = i, this.textViews_ = t.textViews, this.applyTextViews_(), _(t.colorMode, e => {
              this.modeElem_.value = e;
            });
          }
          get modeSelectElement() {
            return this.modeElem_;
          }
          get textViews() {
            return this.textViews_;
          }
          set textViews(e) {
            this.textViews_ = e, this.applyTextViews_();
          }
          applyTextViews_() {
            G(this.textsElem_);
            const e = this.element.ownerDocument;
            this.textViews_.forEach(t => {
              const r = e.createElement("div");
              r.classList.add(Gr("c")), r.appendChild(t.element), this.textsElem_.appendChild(r);
            });
          }
        }
        const Qr = wt(0),
          Hr = {
            rgb: () => new Qe({
              min: 0,
              max: 255
            }),
            hsl: e => new Qe(0 === e ? {
              min: 0,
              max: 360
            } : {
              min: 0,
              max: 100
            }),
            hsv: e => new Qe(0 === e ? {
              min: 0,
              max: 360
            } : {
              min: 0,
              max: 100
            })
          };
        function Wr(e, t, r) {
          return new Qt(e, {
            arrayPosition: 0 === r ? "fst" : 2 === r ? "lst" : "mid",
            baseStep: wr(!1),
            parser: t.parser,
            props: C.fromObject({
              draggingScale: 1,
              formatter: Qr
            }),
            value: S(0, {
              constraint: Hr[t.colorMode](r)
            }),
            viewProps: t.viewProps
          });
        }
        class qr {
          constructor(e, t) {
            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = S(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new Vr(e, {
              colorMode: this.colorMode,
              textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
            }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
          }
          createComponentControllers_(e) {
            const t = {
                colorMode: this.colorMode.rawValue,
                parser: this.parser_,
                viewProps: this.viewProps
              },
              r = [Wr(e, t, 0), Wr(e, t, 1), Wr(e, t, 2)];
            return r.forEach((e, t) => {
              Dt({
                primary: this.value,
                secondary: e.value,
                forward: e => e.rawValue.getComponents(this.colorMode.rawValue)[t],
                backward: (e, r) => {
                  const n = this.colorMode.rawValue,
                    i = e.rawValue.getComponents(n);
                  return i[t] = r.rawValue, new Ar(mr(fr(i), i[3]), n);
                }
              });
            }), r;
          }
          onModeSelectChange_(e) {
            const t = e.currentTarget;
            this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view];
          }
        }
        const Xr = f("hpl");
        class Yr {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Xr()), t.viewProps.bindTabIndex(this.element);
            const r = e.createElement("div");
            r.classList.add(Xr("c")), this.element.appendChild(r);
            const n = e.createElement("div");
            n.classList.add(Xr("m")), this.element.appendChild(n), this.markerElem_ = n, this.update_();
          }
          update_() {
            const e = this.value.rawValue,
              [t] = e.getComponents("hsv");
            this.markerElem_.style.backgroundColor = Lr(new Ar([t, 100, 100], "hsv"));
            const r = Ut(t, 0, 360, 0, 100);
            this.markerElem_.style.left = `${r}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class Kr {
          constructor(e, t) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Yr(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(e, t) {
            if (!e.point) return;
            const r = Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 359),
              n = this.value.rawValue,
              [, i, s, o] = n.getComponents("hsv");
            this.value.setRawValue(new Ar([r, i, s, o], "hsv"), t);
          }
          onPointerDown_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerMove_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerUp_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !0,
              last: !0
            });
          }
          onKeyDown_(e) {
            const t = Pt(wr(!1), Rt(e));
            if (0 === t) return;
            const r = this.value.rawValue,
              [n, i, s, o] = r.getComponents("hsv");
            this.value.setRawValue(new Ar([n + t, i, s, o], "hsv"), {
              forceEmit: !1,
              last: !1
            });
          }
          onKeyUp_(e) {
            0 !== Pt(wr(!1), Rt(e)) && this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
        }
        const Jr = f("svp");
        class Zr {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Jr()), t.viewProps.bindTabIndex(this.element);
            const r = e.createElement("canvas");
            r.height = 64, r.width = 64, r.classList.add(Jr("c")), this.element.appendChild(r), this.canvasElement = r;
            const n = e.createElement("div");
            n.classList.add(Jr("m")), this.element.appendChild(n), this.markerElem_ = n, this.update_();
          }
          update_() {
            const e = function (e) {
              const t = e.ownerDocument.defaultView;
              return t && "document" in t ? e.getContext("2d") : null;
            }(this.canvasElement);
            if (!e) return;
            const t = this.value.rawValue.getComponents("hsv"),
              r = this.canvasElement.width,
              n = this.canvasElement.height,
              i = e.getImageData(0, 0, r, n),
              s = i.data;
            for (let e = 0; e < n; e++) for (let i = 0; i < r; i++) {
              const o = Ut(i, 0, r, 0, 100),
                a = Ut(e, 0, n, 100, 0),
                l = dr(t[0], o, a),
                c = 4 * (e * r + i);
              s[c] = l[0], s[c + 1] = l[1], s[c + 2] = l[2], s[c + 3] = 255;
            }
            e.putImageData(i, 0, 0);
            const o = Ut(t[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${o}%`;
            const a = Ut(t[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${a}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class $r {
          constructor(e, t) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Zr(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(e, t) {
            if (!e.point) return;
            const r = Ut(e.point.x, 0, e.bounds.width, 0, 100),
              n = Ut(e.point.y, 0, e.bounds.height, 100, 0),
              [i,,, s] = this.value.rawValue.getComponents("hsv");
            this.value.setRawValue(new Ar([i, r, n, s], "hsv"), t);
          }
          onPointerDown_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerMove_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerUp_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !0,
              last: !0
            });
          }
          onKeyDown_(e) {
            Lt(e.key) && e.preventDefault();
            const [t, r, n, i] = this.value.rawValue.getComponents("hsv"),
              s = wr(!1),
              o = Pt(s, Rt(e)),
              a = Pt(s, Bt(e));
            0 === o && 0 === a || this.value.setRawValue(new Ar([t, r + o, n + a, i], "hsv"), {
              forceEmit: !1,
              last: !1
            });
          }
          onKeyUp_(e) {
            const t = wr(!1),
              r = Pt(t, Rt(e)),
              n = Pt(t, Bt(e));
            0 === r && 0 === n || this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
        }
        class en {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new Kr(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.svPaletteC_ = new $r(e, {
              value: this.value,
              viewProps: this.viewProps
            }), this.alphaIcs_ = t.supportsAlpha ? {
              palette: new zr(e, {
                value: this.value,
                viewProps: this.viewProps
              }),
              text: new Qt(e, {
                parser: bt,
                baseStep: .1,
                props: C.fromObject({
                  draggingScale: .01,
                  formatter: wt(2)
                }),
                value: S(0, {
                  constraint: new Qe({
                    min: 0,
                    max: 1
                  })
                }),
                viewProps: this.viewProps
              })
            } : null, this.alphaIcs_ && Dt({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: e => e.rawValue.getComponents()[3],
              backward: (e, t) => {
                const r = e.rawValue.getComponents();
                return r[3] = t.rawValue, new Ar(r, e.rawValue.mode);
              }
            }), this.textC_ = new qr(e, {
              parser: bt,
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new yr(e, {
              alphaViews: this.alphaIcs_ ? {
                palette: this.alphaIcs_.palette.view,
                text: this.alphaIcs_.text.view
              } : null,
              hPaletteView: this.hPaletteC_.view,
              supportsAlpha: t.supportsAlpha,
              svPaletteView: this.svPaletteC_.view,
              textView: this.textC_.view
            });
          }
          get textController() {
            return this.textC_;
          }
        }
        const tn = f("colsw");
        class rn {
          constructor(e, t) {
            this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(tn()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("div");
            r.classList.add(tn("sw")), this.element.appendChild(r), this.swatchElem_ = r;
            const n = e.createElement("button");
            n.classList.add(tn("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n, this.update_();
          }
          update_() {
            const e = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = Rr(e);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class nn {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.view = new rn(e, {
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        class sn {
          constructor(e, t) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = K.create(t.expanded), this.swatchC_ = new nn(e, {
              value: this.value,
              viewProps: this.viewProps
            });
            const r = this.swatchC_.view.buttonElement;
            r.addEventListener("blur", this.onButtonBlur_), r.addEventListener("click", this.onButtonClick_), this.textC_ = new et(e, {
              parser: t.parser,
              props: C.fromObject({
                formatter: t.formatter
              }),
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new pr(e, {
              foldable: this.foldable_,
              pickerLayout: t.pickerLayout
            }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
              viewProps: this.viewProps
            }) : null;
            const n = new en(e, {
              supportsAlpha: t.supportsAlpha,
              value: this.value,
              viewProps: this.viewProps
            });
            n.view.allFocusableElements.forEach(e => {
              e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_);
            }), this.pickerC_ = n, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(n.view.element), Dt({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: e => e.rawValue,
              backward: (e, t) => t.rawValue
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Z(this.foldable_, this.view.pickerElement));
          }
          get textController() {
            return this.textC_;
          }
          onButtonBlur_(e) {
            if (!this.popC_) return;
            const t = this.view.element,
              r = e.relatedTarget;
            r && t.contains(r) || (this.popC_.shows.rawValue = !1);
          }
          onButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
          }
          onPopupChildBlur_(e) {
            if (!this.popC_) return;
            const t = this.popC_.view.element,
              r = V(e);
            r && t.contains(r) || r && r === this.swatchC_.view.buttonElement && !O(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
          }
          onPopupChildKeydown_(e) {
            this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.swatchC_.view.buttonElement.focus();
          }
        }
        function on(e) {
          return Ar.isColorObject(e) ? Ar.fromObject(e) : Ar.black();
        }
        function an(e) {
          return fr(e.getComponents("rgb")).reduce((e, t) => e << 8 | 255 & Math.floor(t), 0);
        }
        function ln(e) {
          return e.getComponents("rgb").reduce((e, t, r) => e << 8 | 255 & Math.floor(3 === r ? 255 * t : t), 0) >>> 0;
        }
        function cn(e) {
          return "number" != typeof e ? Ar.black() : new Ar([(t = e) >> 16 & 255, t >> 8 & 255, 255 & t], "rgb");
          var t;
        }
        function un(e) {
          return "number" != typeof e ? Ar.black() : new Ar([(t = e) >> 24 & 255, t >> 16 & 255, t >> 8 & 255, Ut(255 & t, 0, 255, 0, 1)], "rgb");
          var t;
        }
        function hn(e, t) {
          const r = t.toRgbaObject();
          e.writeProperty("r", r.r), e.writeProperty("g", r.g), e.writeProperty("b", r.b), e.writeProperty("a", r.a);
        }
        function pn(e, t) {
          const r = t.toRgbaObject();
          e.writeProperty("r", r.r), e.writeProperty("g", r.g), e.writeProperty("b", r.b);
        }
        function dn(e) {
          return "alpha" in e && !0 === e.alpha;
        }
        function fn(e) {
          return e ? e => Rr(e, "0x") : e => Br(e, "0x");
        }
        const mn = {
          id: "input-color-number",
          type: "input",
          accept: (e, t) => {
            if ("number" != typeof e) return null;
            if (!("view" in t)) return null;
            if ("color" !== t.view) return null;
            const r = xr(t);
            return r ? {
              initialValue: e,
              params: r
            } : null;
          },
          binding: {
            reader: e => dn(e.params) ? un : cn,
            equals: Ar.equals,
            writer: e => function (e) {
              const t = e ? ln : an;
              return (e, r) => {
                Jt(e, t(r));
              };
            }(dn(e.params))
          },
          controller: e => {
            const t = dn(e.params),
              r = "expanded" in e.params ? e.params.expanded : void 0,
              n = "picker" in e.params ? e.params.picker : void 0;
            return new sn(e.document, {
              expanded: null != r && r,
              formatter: fn(t),
              parser: Ir,
              pickerLayout: null != n ? n : "popup",
              supportsAlpha: t,
              value: e.value,
              viewProps: e.viewProps
            });
          }
        };
        const _n = {
            id: "input-color-object",
            type: "input",
            accept: (e, t) => {
              if (!Ar.isColorObject(e)) return null;
              const r = xr(t);
              return r ? {
                initialValue: e,
                params: r
              } : null;
            },
            binding: {
              reader: e => on,
              equals: Ar.equals,
              writer: e => {
                return t = e.initialValue, Ar.isRgbaColorObject(t) ? hn : pn;
                var t;
              }
            },
            controller: e => {
              const t = Ar.isRgbaColorObject(e.initialValue),
                r = "expanded" in e.params ? e.params.expanded : void 0,
                n = "picker" in e.params ? e.params.picker : void 0,
                i = t ? Rr : Br;
              return new sn(e.document, {
                expanded: null != r && r,
                formatter: i,
                parser: Ir,
                pickerLayout: null != n ? n : "popup",
                supportsAlpha: t,
                value: e.value,
                viewProps: e.viewProps
              });
            }
          },
          gn = {
            id: "input-color-string",
            type: "input",
            accept: (e, t) => {
              if ("string" != typeof e) return null;
              if ("view" in t && "text" === t.view) return null;
              if (!Tr(e)) return null;
              const r = xr(t);
              return r ? {
                initialValue: e,
                params: r
              } : null;
            },
            binding: {
              reader: e => Dr,
              equals: Ar.equals,
              writer: e => {
                const t = Tr(e.initialValue);
                if (!t) throw c.shouldNeverHappen();
                return function (e) {
                  const t = Ur(e);
                  return (e, r) => {
                    Jt(e, t(r));
                  };
                }(t);
              }
            },
            controller: e => {
              const t = Tr(e.initialValue);
              if (!t) throw c.shouldNeverHappen();
              const r = Ur(t),
                n = "expanded" in e.params ? e.params.expanded : void 0,
                i = "picker" in e.params ? e.params.picker : void 0;
              return new sn(e.document, {
                expanded: null != n && n,
                formatter: r,
                parser: Ir,
                pickerLayout: null != i ? i : "popup",
                supportsAlpha: kr(t),
                value: e.value,
                viewProps: e.viewProps
              });
            }
          };
        class vn {
          constructor(e) {
            this.components = e.components, this.asm_ = e.assembly;
          }
          constrain(e) {
            const t = this.asm_.toComponents(e).map((e, t) => {
              var r, n;
              return null !== (n = null === (r = this.components[t]) || void 0 === r ? void 0 : r.constrain(e)) && void 0 !== n ? n : e;
            });
            return this.asm_.fromComponents(t);
          }
        }
        const An = f("pndtxt");
        class bn {
          constructor(e, t) {
            this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(An()), this.textViews.forEach(t => {
              const r = e.createElement("div");
              r.classList.add(An("a")), r.appendChild(t.element), this.element.appendChild(r);
            });
          }
        }
        class yn {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((r, n) => function (e, t, r) {
              return new Qt(e, {
                arrayPosition: 0 === r ? "fst" : r === t.axes.length - 1 ? "lst" : "mid",
                baseStep: t.axes[r].baseStep,
                parser: t.parser,
                props: t.axes[r].textProps,
                value: S(0, {
                  constraint: t.axes[r].constraint
                }),
                viewProps: t.viewProps
              });
            }(e, t, n)), this.acs_.forEach((e, r) => {
              Dt({
                primary: this.value,
                secondary: e.value,
                forward: e => t.assembly.toComponents(e.rawValue)[r],
                backward: (e, n) => {
                  const i = t.assembly.toComponents(e.rawValue);
                  return i[r] = n.rawValue, t.assembly.fromComponents(i);
                }
              });
            }), this.view = new bn(e, {
              textViews: this.acs_.map(e => e.view)
            });
          }
        }
        function xn(e) {
          const t = [],
            r = function (e) {
              return "step" in e && !o(e.step) ? new He(e.step) : null;
            }(e);
          r && t.push(r);
          const n = function (e) {
            return "max" in e && !o(e.max) || "min" in e && !o(e.min) ? new Qe({
              max: e.max,
              min: e.min
            }) : null;
          }(e);
          n && t.push(n);
          const i = rr(e.options);
          return i && t.push(i), new ze(t);
        }
        function wn(e) {
          const [t, r] = function (e) {
            const t = e ? Ge(e, Qe) : null;
            return t ? [t.minValue, t.maxValue] : [void 0, void 0];
          }(e);
          return [null != t ? t : 0, null != r ? r : 100];
        }
        const En = {
          id: "input-number",
          type: "input",
          accept: (e, t) => {
            if ("number" != typeof e) return null;
            const r = I,
              n = k(t, {
                format: r.optional.function,
                max: r.optional.number,
                min: r.optional.number,
                options: r.optional.custom(Zt),
                step: r.optional.number
              });
            return n ? {
              initialValue: e,
              params: n
            } : null;
          },
          binding: {
            reader: e => yt,
            constraint: e => xn(e.params),
            writer: e => Jt
          },
          controller: e => {
            var t, r;
            const n = e.value,
              i = e.constraint;
            if (i && Ge(i, Ve)) return new Xe(e.document, {
              props: C.fromObject({
                options: null !== (t = nr(i)) && void 0 !== t ? t : []
              }),
              value: n,
              viewProps: e.viewProps
            });
            const s = null !== (r = "format" in e.params ? e.params.format : void 0) && void 0 !== r ? r : wt(ir(i, n.rawValue));
            if (i && Ge(i, Qe)) {
              const [t, r] = wn(i);
              return new Kt(e.document, {
                baseStep: sr(i),
                parser: bt,
                sliderProps: C.fromObject({
                  maxValue: r,
                  minValue: t
                }),
                textProps: C.fromObject({
                  draggingScale: or(i, n.rawValue),
                  formatter: s
                }),
                value: n,
                viewProps: e.viewProps
              });
            }
            return new Qt(e.document, {
              baseStep: sr(i),
              parser: bt,
              props: C.fromObject({
                draggingScale: or(i, n.rawValue),
                formatter: s
              }),
              value: n,
              viewProps: e.viewProps
            });
          }
        };
        class Sn {
          constructor(e = 0, t = 0) {
            this.x = e, this.y = t;
          }
          getComponents() {
            return [this.x, this.y];
          }
          static isObject(e) {
            if (o(e)) return !1;
            const t = e.x,
              r = e.y;
            return "number" == typeof t && "number" == typeof r;
          }
          static equals(e, t) {
            return e.x === t.x && e.y === t.y;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y
            };
          }
        }
        const Cn = {
            toComponents: e => e.getComponents(),
            fromComponents: e => new Sn(...e)
          },
          Mn = f("p2d");
        class Tn {
          constructor(e, t) {
            this.element = e.createElement("div"), this.element.classList.add(Mn()), t.viewProps.bindClassModifiers(this.element), _(t.expanded, v(this.element, Mn(void 0, "expanded")));
            const r = e.createElement("div");
            r.classList.add(Mn("h")), this.element.appendChild(r);
            const n = e.createElement("button");
            n.classList.add(Mn("b")), n.appendChild(N(e, "p2dpad")), t.viewProps.bindDisabled(n), r.appendChild(n), this.buttonElement = n;
            const i = e.createElement("div");
            if (i.classList.add(Mn("t")), r.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
              const t = e.createElement("div");
              t.classList.add(Mn("p")), this.element.appendChild(t), this.pickerElement = t;
            } else this.pickerElement = null;
          }
        }
        const In = f("p2dp");
        class kn {
          constructor(e, t) {
            this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(In()), "popup" === t.layout && this.element.classList.add(In(void 0, "p"));
            const r = e.createElement("div");
            r.classList.add(In("p")), t.viewProps.bindTabIndex(r), this.element.appendChild(r), this.padElement = r;
            const n = e.createElementNS(R, "svg");
            n.classList.add(In("g")), this.padElement.appendChild(n), this.svgElem_ = n;
            const i = e.createElementNS(R, "line");
            i.classList.add(In("ax")), i.setAttributeNS(null, "x1", "0"), i.setAttributeNS(null, "y1", "50%"), i.setAttributeNS(null, "x2", "100%"), i.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(i);
            const s = e.createElementNS(R, "line");
            s.classList.add(In("ax")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "0"), s.setAttributeNS(null, "x2", "50%"), s.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s);
            const o = e.createElementNS(R, "line");
            o.classList.add(In("l")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o), this.lineElem_ = o;
            const a = e.createElement("div");
            a.classList.add(In("m")), this.padElement.appendChild(a), this.markerElem_ = a, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
          }
          get allFocusableElements() {
            return [this.padElement];
          }
          update_() {
            const [e, t] = this.value.rawValue.getComponents(),
              r = this.maxValue_,
              n = Ut(e, -r, +r, 0, 100),
              i = Ut(t, -r, +r, 0, 100),
              s = this.invertsY_ ? 100 - i : i;
            this.lineElem_.setAttributeNS(null, "x2", `${n}%`), this.lineElem_.setAttributeNS(null, "y2", `${s}%`), this.markerElem_.style.left = `${n}%`, this.markerElem_.style.top = `${s}%`;
          }
          onValueChange_() {
            this.update_();
          }
          onFoldableChange_() {
            this.update_();
          }
        }
        function Dn(e, t, r) {
          return [Pt(t[0], Rt(e)), Pt(t[1], Bt(e)) * (r ? 1 : -1)];
        }
        class Pn {
          constructor(e, t) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new kn(e, {
              invertsY: this.invertsY_,
              layout: t.layout,
              maxValue: this.maxValue_,
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Ft(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
          }
          handlePointerEvent_(e, t) {
            if (!e.point) return;
            const r = this.maxValue_,
              n = Ut(e.point.x, 0, e.bounds.width, -r, +r),
              i = Ut(this.invertsY_ ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -r, +r);
            this.value.setRawValue(new Sn(n, i), t);
          }
          onPointerDown_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerMove_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !1,
              last: !1
            });
          }
          onPointerUp_(e) {
            this.handlePointerEvent_(e.data, {
              forceEmit: !0,
              last: !0
            });
          }
          onPadKeyDown_(e) {
            Lt(e.key) && e.preventDefault();
            const [t, r] = Dn(e, this.baseSteps_, this.invertsY_);
            0 === t && 0 === r || this.value.setRawValue(new Sn(this.value.rawValue.x + t, this.value.rawValue.y + r), {
              forceEmit: !1,
              last: !1
            });
          }
          onPadKeyUp_(e) {
            const [t, r] = Dn(e, this.baseSteps_, this.invertsY_);
            0 === t && 0 === r || this.value.setRawValue(this.value.rawValue, {
              forceEmit: !0,
              last: !0
            });
          }
        }
        class Bn {
          constructor(e, t) {
            var r, n;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = K.create(t.expanded), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
              viewProps: this.viewProps
            }) : null;
            const i = new Pn(e, {
              baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
              invertsY: t.invertsY,
              layout: t.pickerLayout,
              maxValue: t.maxValue,
              value: this.value,
              viewProps: this.viewProps
            });
            i.view.allFocusableElements.forEach(e => {
              e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_);
            }), this.pickerC_ = i, this.textC_ = new yn(e, {
              assembly: Cn,
              axes: t.axes,
              parser: t.parser,
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new Tn(e, {
              expanded: this.foldable_.value("expanded"),
              pickerLayout: t.pickerLayout,
              viewProps: this.viewProps
            }), this.view.textElement.appendChild(this.textC_.view.element), null === (r = this.view.buttonElement) || void 0 === r || r.addEventListener("blur", this.onPadButtonBlur_), null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Dt({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: e => e.rawValue,
              backward: (e, t) => t.rawValue
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Z(this.foldable_, this.view.pickerElement));
          }
          onPadButtonBlur_(e) {
            if (!this.popC_) return;
            const t = this.view.element,
              r = e.relatedTarget;
            r && t.contains(r) || (this.popC_.shows.rawValue = !1);
          }
          onPadButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
          }
          onPopupChildBlur_(e) {
            if (!this.popC_) return;
            const t = this.popC_.view.element,
              r = V(e);
            r && t.contains(r) || r && r === this.view.buttonElement && !O(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
          }
          onPopupChildKeydown_(e) {
            this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.view.buttonElement.focus();
          }
        }
        function Rn(e) {
          return Sn.isObject(e) ? new Sn(e.x, e.y) : new Sn();
        }
        function Ln(e, t) {
          e.writeProperty("x", t.x), e.writeProperty("y", t.y);
        }
        function On(e) {
          if (!e) return;
          const t = [];
          return o(e.step) || t.push(new He(e.step)), o(e.max) && o(e.min) || t.push(new Qe({
            max: e.max,
            min: e.min
          })), new ze(t);
        }
        function Fn(e, t) {
          const r = e && Ge(e, Qe);
          if (r) return Math.max(Math.abs(r.minValue || 0), Math.abs(r.maxValue || 0));
          const n = sr(e);
          return Math.max(10 * Math.abs(n), 10 * Math.abs(t));
        }
        function Un(e, t) {
          const r = t instanceof vn ? t.components[0] : void 0,
            n = t instanceof vn ? t.components[1] : void 0,
            i = Fn(r, e.x),
            s = Fn(n, e.y);
          return Math.max(i, s);
        }
        function Nn(e, t) {
          return {
            baseStep: sr(t),
            constraint: t,
            textProps: C.fromObject({
              draggingScale: or(t, e),
              formatter: wt(ir(t, e))
            })
          };
        }
        function jn(e) {
          if (!("y" in e)) return !1;
          const t = e.y;
          return !!t && "inverted" in t && !!t.inverted;
        }
        const zn = {
          id: "input-point2d",
          type: "input",
          accept: (e, t) => {
            if (!Sn.isObject(e)) return null;
            const r = I,
              n = k(t, {
                expanded: r.optional.boolean,
                picker: r.optional.custom($t),
                x: r.optional.custom(er),
                y: r.optional.object({
                  inverted: r.optional.boolean,
                  max: r.optional.number,
                  min: r.optional.number,
                  step: r.optional.number
                })
              });
            return n ? {
              initialValue: e,
              params: n
            } : null;
          },
          binding: {
            reader: e => Rn,
            constraint: e => {
              return t = e.params, new vn({
                assembly: Cn,
                components: [On("x" in t ? t.x : void 0), On("y" in t ? t.y : void 0)]
              });
              var t;
            },
            equals: Sn.equals,
            writer: e => Ln
          },
          controller: e => {
            const t = e.document,
              r = e.value,
              n = e.constraint;
            if (!(n instanceof vn)) throw c.shouldNeverHappen();
            const i = "expanded" in e.params ? e.params.expanded : void 0,
              s = "picker" in e.params ? e.params.picker : void 0;
            return new Bn(t, {
              axes: [Nn(r.rawValue.x, n.components[0]), Nn(r.rawValue.y, n.components[1])],
              expanded: null != i && i,
              invertsY: jn(e.params),
              maxValue: Un(r.rawValue, n),
              parser: bt,
              pickerLayout: null != s ? s : "popup",
              value: r,
              viewProps: e.viewProps
            });
          }
        };
        class Gn {
          constructor(e = 0, t = 0, r = 0) {
            this.x = e, this.y = t, this.z = r;
          }
          getComponents() {
            return [this.x, this.y, this.z];
          }
          static isObject(e) {
            if (o(e)) return !1;
            const t = e.x,
              r = e.y,
              n = e.z;
            return "number" == typeof t && "number" == typeof r && "number" == typeof n;
          }
          static equals(e, t) {
            return e.x === t.x && e.y === t.y && e.z === t.z;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z
            };
          }
        }
        const Vn = {
          toComponents: e => e.getComponents(),
          fromComponents: e => new Gn(...e)
        };
        function Qn(e) {
          return Gn.isObject(e) ? new Gn(e.x, e.y, e.z) : new Gn();
        }
        function Hn(e, t) {
          e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z);
        }
        function Wn(e) {
          if (!e) return;
          const t = [];
          return o(e.step) || t.push(new He(e.step)), o(e.max) && o(e.min) || t.push(new Qe({
            max: e.max,
            min: e.min
          })), new ze(t);
        }
        function qn(e, t) {
          return {
            baseStep: sr(t),
            constraint: t,
            textProps: C.fromObject({
              draggingScale: or(t, e),
              formatter: wt(ir(t, e))
            })
          };
        }
        const Xn = {
          id: "input-point3d",
          type: "input",
          accept: (e, t) => {
            if (!Gn.isObject(e)) return null;
            const r = I,
              n = k(t, {
                x: r.optional.custom(er),
                y: r.optional.custom(er),
                z: r.optional.custom(er)
              });
            return n ? {
              initialValue: e,
              params: n
            } : null;
          },
          binding: {
            reader: e => Qn,
            constraint: e => {
              return t = e.params, new vn({
                assembly: Vn,
                components: [Wn("x" in t ? t.x : void 0), Wn("y" in t ? t.y : void 0), Wn("z" in t ? t.z : void 0)]
              });
              var t;
            },
            equals: Gn.equals,
            writer: e => Hn
          },
          controller: e => {
            const t = e.value,
              r = e.constraint;
            if (!(r instanceof vn)) throw c.shouldNeverHappen();
            return new yn(e.document, {
              assembly: Vn,
              axes: [qn(t.rawValue.x, r.components[0]), qn(t.rawValue.y, r.components[1]), qn(t.rawValue.z, r.components[2])],
              parser: bt,
              value: t,
              viewProps: e.viewProps
            });
          }
        };
        class Yn {
          constructor(e = 0, t = 0, r = 0, n = 0) {
            this.x = e, this.y = t, this.z = r, this.w = n;
          }
          getComponents() {
            return [this.x, this.y, this.z, this.w];
          }
          static isObject(e) {
            if (o(e)) return !1;
            const t = e.x,
              r = e.y,
              n = e.z,
              i = e.w;
            return "number" == typeof t && "number" == typeof r && "number" == typeof n && "number" == typeof i;
          }
          static equals(e, t) {
            return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w
            };
          }
        }
        const Kn = {
          toComponents: e => e.getComponents(),
          fromComponents: e => new Yn(...e)
        };
        function Jn(e) {
          return Yn.isObject(e) ? new Yn(e.x, e.y, e.z, e.w) : new Yn();
        }
        function Zn(e, t) {
          e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z), e.writeProperty("w", t.w);
        }
        function $n(e) {
          if (!e) return;
          const t = [];
          return o(e.step) || t.push(new He(e.step)), o(e.max) && o(e.min) || t.push(new Qe({
            max: e.max,
            min: e.min
          })), new ze(t);
        }
        const ei = {
          id: "input-point4d",
          type: "input",
          accept: (e, t) => {
            if (!Yn.isObject(e)) return null;
            const r = I,
              n = k(t, {
                x: r.optional.custom(er),
                y: r.optional.custom(er),
                z: r.optional.custom(er),
                w: r.optional.custom(er)
              });
            return n ? {
              initialValue: e,
              params: n
            } : null;
          },
          binding: {
            reader: e => Jn,
            constraint: e => {
              return t = e.params, new vn({
                assembly: Kn,
                components: [$n("x" in t ? t.x : void 0), $n("y" in t ? t.y : void 0), $n("z" in t ? t.z : void 0), $n("w" in t ? t.w : void 0)]
              });
              var t;
            },
            equals: Yn.equals,
            writer: e => Zn
          },
          controller: e => {
            const t = e.value,
              r = e.constraint;
            if (!(r instanceof vn)) throw c.shouldNeverHappen();
            return new yn(e.document, {
              assembly: Kn,
              axes: t.rawValue.getComponents().map((e, t) => {
                return n = e, {
                  baseStep: sr(i = r.components[t]),
                  constraint: i,
                  textProps: C.fromObject({
                    draggingScale: or(i, n),
                    formatter: wt(ir(i, n))
                  })
                };
                var n, i;
              }),
              parser: bt,
              value: t,
              viewProps: e.viewProps
            });
          }
        };
        const ti = {
            id: "input-string",
            type: "input",
            accept: (e, t) => {
              if ("string" != typeof e) return null;
              const r = k(t, {
                options: I.optional.custom(Zt)
              });
              return r ? {
                initialValue: e,
                params: r
              } : null;
            },
            binding: {
              reader: e => Ct,
              constraint: e => function (e) {
                const t = [],
                  r = rr(e.options);
                return r && t.push(r), new ze(t);
              }(e.params),
              writer: e => Jt
            },
            controller: e => {
              var t;
              const r = e.document,
                n = e.value,
                i = e.constraint;
              return i && Ge(i, Ve) ? new Xe(r, {
                props: C.fromObject({
                  options: null !== (t = nr(i)) && void 0 !== t ? t : []
                }),
                value: n,
                viewProps: e.viewProps
              }) : new et(r, {
                parser: e => e,
                props: C.fromObject({
                  formatter: Mt
                }),
                value: n,
                viewProps: e.viewProps
              });
            }
          },
          ri = {
            defaultInterval: 200,
            defaultLineCount: 3
          },
          ni = f("mll");
        class ii {
          constructor(e, t) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(ni()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("textarea");
            r.classList.add(ni("i")), r.style.height = `calc(var(--bld-us) * ${t.lineCount})`, r.readOnly = !0, t.viewProps.bindDisabled(r), this.element.appendChild(r), this.textareaElem_ = r, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
          }
          update_() {
            const e = this.textareaElem_,
              t = e.scrollTop === e.scrollHeight - e.clientHeight,
              r = [];
            this.value.rawValue.forEach(e => {
              void 0 !== e && r.push(this.formatter_(e));
            }), e.textContent = r.join("\n"), t && (e.scrollTop = e.scrollHeight);
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class si {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.view = new ii(e, {
              formatter: t.formatter,
              lineCount: t.lineCount,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const oi = f("sgl");
        class ai {
          constructor(e, t) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(oi()), t.viewProps.bindClassModifiers(this.element);
            const r = e.createElement("input");
            r.classList.add(oi("i")), r.readOnly = !0, r.type = "text", t.viewProps.bindDisabled(r), this.element.appendChild(r), this.inputElement = r, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
          }
          update_() {
            const e = this.value.rawValue,
              t = e[e.length - 1];
            this.inputElement.value = void 0 !== t ? this.formatter_(t) : "";
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class li {
          constructor(e, t) {
            this.value = t.value, this.viewProps = t.viewProps, this.view = new ai(e, {
              formatter: t.formatter,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const ci = {
          id: "monitor-bool",
          type: "monitor",
          accept: (e, t) => {
            if ("boolean" != typeof e) return null;
            const r = k(t, {
              lineCount: I.optional.number
            });
            return r ? {
              initialValue: e,
              params: r
            } : null;
          },
          binding: {
            reader: e => tt
          },
          controller: e => {
            var t;
            return 1 === e.value.rawValue.length ? new li(e.document, {
              formatter: rt,
              value: e.value,
              viewProps: e.viewProps
            }) : new si(e.document, {
              formatter: rt,
              lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ri.defaultLineCount,
              value: e.value,
              viewProps: e.viewProps
            });
          }
        };
        class ui {
          constructor() {
            this.emitter = new p(), this.index_ = -1;
          }
          get index() {
            return this.index_;
          }
          set index(e) {
            this.index_ !== e && (this.index_ = e, this.emitter.emit("change", {
              index: e,
              sender: this
            }));
          }
        }
        const hi = f("grl");
        class pi {
          constructor(e, t) {
            this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(hi()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.minValue_ = t.minValue, this.maxValue_ = t.maxValue, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
            const r = e.createElementNS(R, "svg");
            r.classList.add(hi("g")), r.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(r), this.svgElem_ = r;
            const n = e.createElementNS(R, "polyline");
            this.svgElem_.appendChild(n), this.lineElem_ = n;
            const i = e.createElement("div");
            i.classList.add(hi("t"), f("tt")()), this.element.appendChild(i), this.tooltipElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
          }
          get graphElement() {
            return this.svgElem_;
          }
          update_() {
            const e = this.svgElem_.getBoundingClientRect(),
              t = this.value.rawValue.length - 1,
              r = this.minValue_,
              n = this.maxValue_,
              i = [];
            this.value.rawValue.forEach((s, o) => {
              if (void 0 === s) return;
              const a = Ut(o, 0, t, 0, e.width),
                l = Ut(s, r, n, e.height, 0);
              i.push([a, l].join(","));
            }), this.lineElem_.setAttributeNS(null, "points", i.join(" "));
            const s = this.tooltipElem_,
              o = this.value.rawValue[this.cursor_.index];
            if (void 0 === o) return void s.classList.remove(hi("t", "a"));
            const a = Ut(this.cursor_.index, 0, t, 0, e.width),
              l = Ut(o, r, n, e.height, 0);
            s.style.left = `${a}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(o)}`, s.classList.contains(hi("t", "a")) || (s.classList.add(hi("t", "a"), hi("t", "in")), L(s), s.classList.remove(hi("t", "in")));
          }
          onValueUpdate_() {
            this.update_();
          }
          onCursorChange_() {
            this.update_();
          }
        }
        class di {
          constructor(e, t) {
            if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = new ui(), this.view = new pi(e, {
              cursor: this.cursor_,
              formatter: t.formatter,
              lineCount: t.lineCount,
              maxValue: t.maxValue,
              minValue: t.minValue,
              value: this.value,
              viewProps: this.viewProps
            }), O(e)) {
              const e = new Ft(this.view.element);
              e.emitter.on("down", this.onGraphPointerDown_), e.emitter.on("move", this.onGraphPointerMove_), e.emitter.on("up", this.onGraphPointerUp_);
            } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
          }
          onGraphMouseLeave_() {
            this.cursor_.index = -1;
          }
          onGraphMouseMove_(e) {
            const t = this.view.element.getBoundingClientRect();
            this.cursor_.index = Math.floor(Ut(e.offsetX, 0, t.width, 0, this.value.rawValue.length));
          }
          onGraphPointerDown_(e) {
            this.onGraphPointerMove_(e);
          }
          onGraphPointerMove_(e) {
            e.data.point ? this.cursor_.index = Math.floor(Ut(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.index = -1;
          }
          onGraphPointerUp_() {
            this.cursor_.index = -1;
          }
        }
        function fi(e) {
          return "format" in e && !o(e.format) ? e.format : wt(2);
        }
        function mi(e) {
          return "view" in e && "graph" === e.view;
        }
        const _i = {
            id: "monitor-number",
            type: "monitor",
            accept: (e, t) => {
              if ("number" != typeof e) return null;
              const r = I,
                n = k(t, {
                  format: r.optional.function,
                  lineCount: r.optional.number,
                  max: r.optional.number,
                  min: r.optional.number,
                  view: r.optional.string
                });
              return n ? {
                initialValue: e,
                params: n
              } : null;
            },
            binding: {
              defaultBufferSize: e => mi(e) ? 64 : 1,
              reader: e => yt
            },
            controller: e => mi(e.params) ? function (e) {
              var t, r, n;
              return new di(e.document, {
                formatter: fi(e.params),
                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ri.defaultLineCount,
                maxValue: null !== (r = "max" in e.params ? e.params.max : null) && void 0 !== r ? r : 100,
                minValue: null !== (n = "min" in e.params ? e.params.min : null) && void 0 !== n ? n : 0,
                value: e.value,
                viewProps: e.viewProps
              });
            }(e) : function (e) {
              var t;
              return 1 === e.value.rawValue.length ? new li(e.document, {
                formatter: fi(e.params),
                value: e.value,
                viewProps: e.viewProps
              }) : new si(e.document, {
                formatter: fi(e.params),
                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ri.defaultLineCount,
                value: e.value,
                viewProps: e.viewProps
              });
            }(e)
          },
          gi = {
            id: "monitor-string",
            type: "monitor",
            accept: (e, t) => {
              if ("string" != typeof e) return null;
              const r = I,
                n = k(t, {
                  lineCount: r.optional.number,
                  multiline: r.optional.boolean
                });
              return n ? {
                initialValue: e,
                params: n
              } : null;
            },
            binding: {
              reader: e => Ct
            },
            controller: e => {
              var t;
              const r = e.value;
              return r.rawValue.length > 1 || "multiline" in e.params && e.params.multiline ? new si(e.document, {
                formatter: Mt,
                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ri.defaultLineCount,
                value: r,
                viewProps: e.viewProps
              }) : new li(e.document, {
                formatter: Mt,
                value: r,
                viewProps: e.viewProps
              });
            }
          };
        class vi {
          constructor(e) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new p(), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read();
          }
          read() {
            const e = this.target.read();
            void 0 !== e && (this.value.rawValue = this.reader(e));
          }
          write_(e) {
            this.writer(this.target, e);
          }
          onValueChange_(e) {
            this.write_(e.rawValue), this.emitter.emit("change", {
              options: e.options,
              rawValue: e.rawValue,
              sender: this
            });
          }
        }
        class Ai {
          constructor(e) {
            this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new p(), this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
          }
          dispose() {
            this.ticker.dispose();
          }
          read() {
            const e = this.target.read();
            if (void 0 === e) return;
            const t = this.value.rawValue,
              r = this.reader_(e);
            this.value.rawValue = function (e, t) {
              const r = [...kt(e), t];
              return r.length > e.length ? r.splice(0, r.length - e.length) : Tt(r, e.length), r;
            }(t, r), this.emitter.emit("update", {
              rawValue: r,
              sender: this
            });
          }
          onTick_(e) {
            this.read();
          }
        }
        function bi(e, t) {
          return 0 === t ? new Ne() : new je(e, null != t ? t : ri.defaultInterval);
        }
        class yi {
          constructor() {
            this.pluginsMap_ = {
              blades: [],
              inputs: [],
              monitors: []
            };
          }
          getAll() {
            return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
          }
          register(e) {
            "blade" === e.type ? this.pluginsMap_.blades.unshift(e) : "input" === e.type ? this.pluginsMap_.inputs.unshift(e) : "monitor" === e.type && this.pluginsMap_.monitors.unshift(e);
          }
          createInput(e, t, r) {
            if (o(t.read())) throw new c({
              context: {
                key: t.key
              },
              type: "nomatchingcontroller"
            });
            const n = this.pluginsMap_.inputs.reduce((n, i) => n || function (e, t) {
              const r = e.accept(t.target.read(), t.params);
              if (o(r)) return null;
              const n = I,
                i = {
                  target: t.target,
                  initialValue: r.initialValue,
                  params: r.params
                },
                s = e.binding.reader(i),
                a = e.binding.constraint ? e.binding.constraint(i) : void 0,
                l = S(s(r.initialValue), {
                  constraint: a,
                  equals: e.binding.equals
                }),
                c = new vi({
                  reader: s,
                  target: t.target,
                  value: l,
                  writer: e.binding.writer(i)
                }),
                u = n.optional.boolean(t.params.disabled).value,
                h = n.optional.boolean(t.params.hidden).value,
                p = e.controller({
                  constraint: a,
                  document: t.document,
                  initialValue: r.initialValue,
                  params: r.params,
                  value: c.value,
                  viewProps: Te.create({
                    disabled: u,
                    hidden: h
                  })
                }),
                d = n.optional.string(t.params.label).value;
              return new re(t.document, {
                binding: c,
                blade: Y(),
                props: C.fromObject({
                  label: d || t.target.key
                }),
                valueController: p
              });
            }(i, {
              document: e,
              target: t,
              params: r
            }), null);
            if (n) return n;
            throw new c({
              context: {
                key: t.key
              },
              type: "nomatchingcontroller"
            });
          }
          createMonitor(e, t, r) {
            const n = this.pluginsMap_.monitors.reduce((n, i) => n || function (e, t) {
              var r, n, i;
              const s = I,
                a = e.accept(t.target.read(), t.params);
              if (o(a)) return null;
              const l = {
                  target: t.target,
                  initialValue: a.initialValue,
                  params: a.params
                },
                c = e.binding.reader(l),
                u = null !== (n = null !== (r = s.optional.number(t.params.bufferSize).value) && void 0 !== r ? r : e.binding.defaultBufferSize && e.binding.defaultBufferSize(a.params)) && void 0 !== n ? n : 1,
                h = s.optional.number(t.params.interval).value,
                p = new Ai({
                  reader: c,
                  target: t.target,
                  ticker: bi(t.document, h),
                  value: It(u)
                }),
                d = s.optional.boolean(t.params.disabled).value,
                f = s.optional.boolean(t.params.hidden).value,
                m = e.controller({
                  document: t.document,
                  params: a.params,
                  value: p.value,
                  viewProps: Te.create({
                    disabled: d,
                    hidden: f
                  })
                }),
                _ = null !== (i = s.optional.string(t.params.label).value) && void 0 !== i ? i : t.target.key;
              return new ie(t.document, {
                binding: p,
                blade: Y(),
                props: C.fromObject({
                  label: _
                }),
                valueController: m
              });
            }(i, {
              document: e,
              params: r,
              target: t
            }), null);
            if (n) return n;
            throw new c({
              context: {
                key: t.key
              },
              type: "nomatchingcontroller"
            });
          }
          createBlade(e, t) {
            const r = this.pluginsMap_.blades.reduce((r, n) => r || function (e, t) {
              const r = e.accept(t.params);
              if (!r) return null;
              const n = I.optional.boolean(t.params.disabled).value,
                i = I.optional.boolean(t.params.hidden).value;
              return e.controller({
                blade: Y(),
                document: t.document,
                params: Object.assign(Object.assign({}, r.params), {
                  disabled: n,
                  hidden: i
                }),
                viewProps: Te.create({
                  disabled: n,
                  hidden: i
                })
              });
            }(n, {
              document: e,
              params: t
            }), null);
            if (!r) throw new c({
              type: "nomatchingview",
              context: {
                params: t
              }
            });
            return r;
          }
          createBladeApi(e) {
            if (e instanceof re) return new te(e);
            if (e instanceof ie) return new ne(e);
            if (e instanceof me) return new le(e, this);
            const t = this.pluginsMap_.blades.reduce((t, r) => t || r.api({
              controller: e,
              pool: this
            }), null);
            if (!t) throw c.shouldNeverHappen();
            return t;
          }
        }
        class xi extends t {
          constructor(e) {
            super(e), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", e => {
              this.emitter_.emit("change", {
                event: new n(this, e.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          get options() {
            return this.controller_.valueController.props.get("options");
          }
          set options(e) {
            this.controller_.valueController.props.set("options", e);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(e) {
            this.controller_.valueController.value.rawValue = e;
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
        }
        class wi extends t {
          constructor(e) {
            super(e), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", e => {
              this.emitter_.emit("change", {
                event: new n(this, e.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          get maxValue() {
            return this.controller_.valueController.sliderController.props.get("maxValue");
          }
          set maxValue(e) {
            this.controller_.valueController.sliderController.props.set("maxValue", e);
          }
          get minValue() {
            return this.controller_.valueController.sliderController.props.get("minValue");
          }
          set minValue(e) {
            this.controller_.valueController.sliderController.props.set("minValue", e);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(e) {
            this.controller_.valueController.value.rawValue = e;
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
        }
        class Ei extends t {
          constructor(e) {
            super(e), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", e => {
              this.emitter_.emit("change", {
                event: new n(this, e.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(e) {
            this.controller_.props.set("label", e);
          }
          get formatter() {
            return this.controller_.valueController.props.get("formatter");
          }
          set formatter(e) {
            this.controller_.valueController.props.set("formatter", e);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(e) {
            this.controller_.valueController.value.rawValue = e;
          }
          on(e, t) {
            const r = t.bind(this);
            return this.emitter_.on(e, e => {
              r(e.event);
            }), this;
          }
        }
        const Si = {
          id: "list",
          type: "blade",
          accept(e) {
            const t = I,
              r = k(e, {
                options: t.required.custom(Zt),
                value: t.required.raw,
                view: t.required.constant("list"),
                label: t.optional.string
              });
            return r ? {
              params: r
            } : null;
          },
          controller(e) {
            const t = new Xe(e.document, {
              props: C.fromObject({
                options: tr(e.params.options)
              }),
              value: S(e.params.value),
              viewProps: e.viewProps
            });
            return new be(e.document, {
              blade: e.blade,
              props: C.fromObject({
                label: e.params.label
              }),
              valueController: t
            });
          },
          api: e => e.controller instanceof be && e.controller.valueController instanceof Xe ? new xi(e.controller) : null
        };
        class Ci extends ce {
          constructor(e, t) {
            super(e, t);
          }
          get element() {
            return this.controller_.view.element;
          }
          importPreset(e) {
            (function (e, t) {
              e.forEach(e => {
                const r = t[e.presetKey];
                void 0 !== r && e.write(r);
              });
            })(this.controller_.rackController.rack.find(re).map(e => e.binding.target), e), this.refresh();
          }
          exportPreset() {
            return this.controller_.rackController.rack.find(re).map(e => e.binding.target).reduce((e, t) => Object.assign(e, {
              [t.presetKey]: t.read()
            }), {});
          }
          refresh() {
            this.controller_.rackController.rack.find(re).forEach(e => {
              e.binding.read();
            }), this.controller_.rackController.rack.find(ie).forEach(e => {
              e.binding.read();
            });
          }
        }
        class Mi extends ve {
          constructor(e, t) {
            super(e, {
              expanded: t.expanded,
              blade: t.blade,
              props: t.props,
              root: !0,
              viewProps: t.viewProps
            });
          }
        }
        const Ti = {
            id: "slider",
            type: "blade",
            accept(e) {
              const t = I,
                r = k(e, {
                  max: t.required.number,
                  min: t.required.number,
                  view: t.required.constant("slider"),
                  format: t.optional.function,
                  label: t.optional.string,
                  value: t.optional.number
                });
              return r ? {
                params: r
              } : null;
            },
            controller(e) {
              var t, r;
              const n = null !== (t = e.params.value) && void 0 !== t ? t : 0,
                i = new Kt(e.document, {
                  baseStep: 1,
                  parser: bt,
                  sliderProps: C.fromObject({
                    maxValue: e.params.max,
                    minValue: e.params.min
                  }),
                  textProps: C.fromObject({
                    draggingScale: or(void 0, n),
                    formatter: null !== (r = e.params.format) && void 0 !== r ? r : xt
                  }),
                  value: S(n),
                  viewProps: e.viewProps
                });
              return new be(e.document, {
                blade: e.blade,
                props: C.fromObject({
                  label: e.params.label
                }),
                valueController: i
              });
            },
            api: e => e.controller instanceof be && e.controller.valueController instanceof Kt ? new wi(e.controller) : null
          },
          Ii = {
            id: "text",
            type: "blade",
            accept(e) {
              const t = I,
                r = k(e, {
                  parse: t.required.function,
                  value: t.required.raw,
                  view: t.required.constant("text"),
                  format: t.optional.function,
                  label: t.optional.string
                });
              return r ? {
                params: r
              } : null;
            },
            controller(e) {
              var t;
              const r = new et(e.document, {
                parser: e.params.parse,
                props: C.fromObject({
                  formatter: null !== (t = e.params.format) && void 0 !== t ? t : e => String(e)
                }),
                value: S(e.params.value),
                viewProps: e.viewProps
              });
              return new be(e.document, {
                blade: e.blade,
                props: C.fromObject({
                  label: e.params.label
                }),
                valueController: r
              });
            },
            api: e => e.controller instanceof be && e.controller.valueController instanceof et ? new Ei(e.controller) : null
          };
        function ki(e, t, r) {
          if (e.querySelector(`style[data-tp-style=${t}]`)) return;
          const n = e.createElement("style");
          n.dataset.tpStyle = t, n.textContent = r, e.head.appendChild(n);
        }
        const Di = new class {
          constructor(e) {
            const [t, r] = e.split("-"),
              n = t.split(".");
            this.major = parseInt(n[0], 10), this.minor = parseInt(n[1], 10), this.patch = parseInt(n[2], 10), this.prerelease = null != r ? r : null;
          }
          toString() {
            const e = [this.major, this.minor, this.patch].join(".");
            return null !== this.prerelease ? [e, this.prerelease].join("-") : e;
          }
        }("3.0.8");
        e.BladeApi = t, e.ButtonApi = h, e.FolderApi = ce, e.InputBindingApi = te, e.ListApi = xi, e.MonitorBindingApi = ne, e.Pane = class extends Ci {
          constructor(e) {
            var t;
            const r = e || {},
              n = null !== (t = r.document) && void 0 !== t ? t : F(),
              i = function () {
                const e = new yi();
                return [zn, Xn, ei, ti, En, gn, _n, mn, ur, ci, gi, _i, q, Ae, Se, Ue].forEach(t => {
                  e.register(t);
                }), e;
              }();
            super(new Mi(n, {
              expanded: r.expanded,
              blade: Y(),
              props: C.fromObject({
                title: r.title
              }),
              viewProps: Te.create()
            }), i), this.pool_ = i, this.containerElem_ = r.container || function (e) {
              const t = e.createElement("div");
              return t.classList.add(f("dfw")()), e.body && e.body.appendChild(t), t;
            }(n), this.containerElem_.appendChild(this.element), this.doc_ = n, this.usesDefaultWrapper_ = !r.container, this.setUpDefaultPlugins_();
          }
          get document() {
            if (!this.doc_) throw c.alreadyDisposed();
            return this.doc_;
          }
          dispose() {
            const e = this.containerElem_;
            if (!e) throw c.alreadyDisposed();
            if (this.usesDefaultWrapper_) {
              const t = e.parentElement;
              t && t.removeChild(e);
            }
            this.containerElem_ = null, this.doc_ = null, super.dispose();
          }
          registerPlugin(e) {
            ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach(e => {
              this.pool_.register(e), this.embedPluginStyle_(e);
            });
          }
          embedPluginStyle_(e) {
            e.css && ki(this.document, `plugin-${e.id}`, e.css);
          }
          setUpDefaultPlugins_() {
            ki(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach(e => {
              this.embedPluginStyle_(e);
            }), this.registerPlugin({
              plugins: [Ti, Si, Ue, Ii]
            });
          }
        }, e.SeparatorApi = ye, e.SliderApi = wi, e.TabApi = Re, e.TabPageApi = Be, e.TextApi = Ei, e.TpChangeEvent = n, e.VERSION = Di, Object.defineProperty(e, "__esModule", {
          value: !0
        });
      }(t);
    },
    23: function (__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
      __webpackgi_require__.d(__webpackgi_exports__, {
        Q: function () {
          return DRACOLoader2;
        }
      });
      var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(553),
        three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(988);
      class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__._ {
        constructor(e) {
          super(e), this.encoderPending = null, this.encoderConfig = {
            type: "js"
          }, this.setDecoderPath("https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/"), this.setDecoderConfig({
            type: "js"
          });
        }
        async loadAsync(e, t) {
          const r = await super.loadAsync(e, t);
          return r ? new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(r, new three__WEBPACK_IMPORTED_MODULE_1__.Wid()) : void 0;
        }
        preload(e = !0, t = !1) {
          return e && super.preload(), t && this.initEncoder(), this;
        }
        async initEncoder() {
          if (this.encoderPending) return this.encoderPending;
          const useJS = "object" != typeof WebAssembly || "js" === this.encoderConfig.type,
            librariesPending = [],
            libLoader = this._loadLibrary.bind(this);
          return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")), librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(librariesPending).then(libraries => {
            var _a;
            const jsContent = libraries[0];
            return useJS || (this.encoderConfig.wasmBinary = libraries[1]), null === (_a = eval(jsContent + "\nDracoEncoderModule;")) || void 0 === _a ? void 0 : _a();
          }), this.encoderPending;
        }
        async initDecoder() {
          var _a;
          await this._initDecoder();
          const jsContent = await fetch(this.workerSourceURL).then(async e => e.text()).then(e => {
            const t = e.indexOf("/* worker */");
            if (t < 1) throw new Error("unable to load decoder module");
            return e.substring(0, t - 1);
          });
          return null === (_a = eval(jsContent + "\nDracoDecoderModule;")) || void 0 === _a ? void 0 : _a();
        }
      }
    },
    87: function () {},
    263: function () {},
    988: function (e, t, r) {
      r.d(t, {
        $TI: function () {
          return Gp;
        },
        $V: function () {
          return qp;
        },
        $Vf: function () {
          return Hd;
        },
        $YQ: function () {
          return nl;
        },
        A5E: function () {
          return Rd;
        },
        AHu: function () {
          return Ld;
        },
        AXT: function () {
          return Dc;
        },
        Aip: function () {
          return $d;
        },
        B02: function () {
          return c;
        },
        BFQ: function () {
          return He;
        },
        BG$: function () {
          return ot;
        },
        BKK: function () {
          return Yd;
        },
        BVF: function () {
          return N;
        },
        BVQ: function () {
          return Gc;
        },
        BbS: function () {
          return yp;
        },
        Bf4: function () {
          return oe;
        },
        BtG: function () {
          return bs;
        },
        CJI: function () {
          return yi;
        },
        CN8: function () {
          return Fd;
        },
        CP7: function () {
          return al;
        },
        CaW: function () {
          return Je;
        },
        CdI: function () {
          return Z;
        },
        Cne: function () {
          return tf;
        },
        CtA: function () {
          return Ge;
        },
        CtF: function () {
          return vh;
        },
        D1R: function () {
          return Ae;
        },
        D9w: function () {
          return je;
        },
        DT1: function () {
          return Qd;
        },
        Djp: function () {
          return st;
        },
        DqL: function () {
          return Ch;
        },
        DvJ: function () {
          return hs;
        },
        E2K: function () {
          return Ve;
        },
        EB7: function () {
          return gc;
        },
        EJi: function () {
          return Qu;
        },
        EoG: function () {
          return J;
        },
        F5T: function () {
          return wi;
        },
        FDw: function () {
          return be;
        },
        FE5: function () {
          return Ou;
        },
        FIo: function () {
          return Gu;
        },
        FM8: function () {
          return kr;
        },
        FT0: function () {
          return Ku;
        },
        FUD: function () {
          return pt;
        },
        FvO: function () {
          return td;
        },
        GG6: function () {
          return ut;
        },
        GQ: function () {
          return Ed;
        },
        GUF: function () {
          return jt;
        },
        GVz: function () {
          return rn;
        },
        GZb: function () {
          return qd;
        },
        Gih: function () {
          return ht;
        },
        Gql: function () {
          return ep;
        },
        H$k: function () {
          return Ru;
        },
        HTd: function () {
          return de;
        },
        HW6: function () {
          return Zd;
        },
        HgB: function () {
          return cr;
        },
        HkE: function () {
          return $a;
        },
        Hmr: function () {
          return op;
        },
        Hw6: function () {
          return Yr;
        },
        Hy8: function () {
          return L;
        },
        Hyl: function () {
          return Ac;
        },
        IEO: function () {
          return zl;
        },
        IFH: function () {
          return St;
        },
        IKL: function () {
          return Wu;
        },
        ILR: function () {
          return qe;
        },
        IOt: function () {
          return Ot;
        },
        Ilk: function () {
          return Wr;
        },
        Inb: function () {
          return Bt;
        },
        Ir4: function () {
          return lr;
        },
        JOQ: function () {
          return Ss;
        },
        JQ4: function () {
          return Ce;
        },
        JUT: function () {
          return nn;
        },
        JWc: function () {
          return or;
        },
        KI_: function () {
          return Nt;
        },
        Kgo: function () {
          return qc;
        },
        KhW: function () {
          return k;
        },
        Kj0: function () {
          return cs;
        },
        Kz5: function () {
          return Se;
        },
        L5g: function () {
          return ef;
        },
        L5s: function () {
          return Zh;
        },
        LBq: function () {
          return Xp;
        },
        LSk: function () {
          return dr;
        },
        LY2: function () {
          return ee;
        },
        L_r: function () {
          return fr;
        },
        Lcc: function () {
          return nf;
        },
        LgE: function () {
          return Pt;
        },
        LgZ: function () {
          return B;
        },
        LsT: function () {
          return Ee;
        },
        Ltg: function () {
          return $r;
        },
        Lun: function () {
          return Xa;
        },
        M5h: function () {
          return y;
        },
        M6v: function () {
          return W;
        },
        M8C: function () {
          return Ir;
        },
        Mig: function () {
          return Wh;
        },
        MyG: function () {
          return Yt;
        },
        N$j: function () {
          return jl;
        },
        N4l: function () {
          return b;
        },
        NDo: function () {
          return Y;
        },
        NMF: function () {
          return bt;
        },
        NYV: function () {
          return at;
        },
        Ns1: function () {
          return q;
        },
        NwF: function () {
          return fh;
        },
        Ny0: function () {
          return bc;
        },
        O7d: function () {
          return Mu;
        },
        OAl: function () {
          return $t;
        },
        OM3: function () {
          return Fi;
        },
        OTo: function () {
          return Pe;
        },
        OdW: function () {
          return Ql;
        },
        OoA: function () {
          return ue;
        },
        Ox3: function () {
          return Hh;
        },
        PA7: function () {
          return Ft;
        },
        PMe: function () {
          return Uh;
        },
        Pa4: function () {
          return ln;
        },
        PeU: function () {
          return o;
        },
        Pnf: function () {
          return xt;
        },
        PpQ: function () {
          return Xr;
        },
        QM0: function () {
          return ar;
        },
        QRU: function () {
          return ip;
        },
        QZ1: function () {
          return sr;
        },
        QmN: function () {
          return s;
        },
        Qpg: function () {
          return hd;
        },
        R2R: function () {
          return uh;
        },
        REq: function () {
          return Xd;
        },
        RNb: function () {
          return Ti;
        },
        ROQ: function () {
          return vc;
        },
        RSm: function () {
          return qu;
        },
        Rki: function () {
          return bd;
        },
        RlZ: function () {
          return U;
        },
        RsA: function () {
          return i;
        },
        RvT: function () {
          return er;
        },
        S2y: function () {
          return l;
        },
        S3k: function () {
          return Mh;
        },
        S9g: function () {
          return Kn;
        },
        SJI: function () {
          return bp;
        },
        SPe: function () {
          return Kl;
        },
        SUY: function () {
          return fp;
        },
        Se2: function () {
          return j;
        },
        Sm8: function () {
          return M;
        },
        So8: function () {
          return lp;
        },
        SvJ: function () {
          return ft;
        },
        Syv: function () {
          return At;
        },
        T95: function () {
          return xe;
        },
        TOt: function () {
          return Zc;
        },
        TUj: function () {
          return Kp;
        },
        TUv: function () {
          return Nl;
        },
        T_1: function () {
          return Dd;
        },
        T_J: function () {
          return qt;
        },
        T__: function () {
          return yc;
        },
        T_f: function () {
          return qh;
        },
        TlE: function () {
          return Mi;
        },
        Tme: function () {
          return ui;
        },
        Tn7: function () {
          return zu;
        },
        TyD: function () {
          return he;
        },
        U7: function () {
          return Rc;
        },
        UCm: function () {
          return Be;
        },
        USm: function () {
          return Yn;
        },
        UY4: function () {
          return lc;
        },
        UZH: function () {
          return n;
        },
        Uk6: function () {
          return Uu;
        },
        UlW: function () {
          return Tt;
        },
        Uol: function () {
          return Wc;
        },
        V1s: function () {
          return _s;
        },
        V4E: function () {
          return Jd;
        },
        VLJ: function () {
          return pd;
        },
        VYz: function () {
          return Cp;
        },
        Vdb: function () {
          return O;
        },
        Vj0: function () {
          return Rs;
        },
        Vkp: function () {
          return Dr;
        },
        VzW: function () {
          return Me;
        },
        W2J: function () {
          return nr;
        },
        WMw: function () {
          return A;
        },
        WTc: function () {
          return Ii;
        },
        WXh: function () {
          return Fu;
        },
        Wbm: function () {
          return E;
        },
        WdD: function () {
          return Ps;
        },
        Wid: function () {
          return Vu;
        },
        Wjw: function () {
          return Wd;
        },
        Wl3: function () {
          return f;
        },
        Wpd: function () {
          return F;
        },
        Wqd: function () {
          return Nc;
        },
        WwZ: function () {
          return Mt;
        },
        Wzm: function () {
          return _c;
        },
        XZw: function () {
          return rf;
        },
        Xaj: function () {
          return x;
        },
        Xcj: function () {
          return Up;
        },
        XvJ: function () {
          return Lu;
        },
        Y8D: function () {
          return Le;
        },
        YBo: function () {
          return Xu;
        },
        YGz: function () {
          return $;
        },
        YKA: function () {
          return gt;
        },
        YLQ: function () {
          return pe;
        },
        YN5: function () {
          return jd;
        },
        YT8: function () {
          return Mc;
        },
        Ywn: function () {
          return sn;
        },
        Z6B: function () {
          return hr;
        },
        ZAu: function () {
          return el;
        },
        ZQ6: function () {
          return Lc;
        },
        ZRs: function () {
          return Qt;
        },
        ZZA: function () {
          return nh;
        },
        Zp0: function () {
          return Jh;
        },
        Zr5: function () {
          return z;
        },
        ZzF: function () {
          return hn;
        },
        Zzh: function () {
          return $p;
        },
        _12: function () {
          return Ds;
        },
        _3: function () {
          return Gd;
        },
        _AM: function () {
          return Xe;
        },
        _C8: function () {
          return ih;
        },
        _Li: function () {
          return m;
        },
        _MY: function () {
          return u;
        },
        _YM: function () {
          return ch;
        },
        _YX: function () {
          return sd;
        },
        _am: function () {
          return As;
        },
        _fP: function () {
          return an;
        },
        _iA: function () {
          return h;
        },
        _kC: function () {
          return Dh;
        },
        _lf: function () {
          return wt;
        },
        _sL: function () {
          return Et;
        },
        a$l: function () {
          return Oi;
        },
        aCh: function () {
          return Ut;
        },
        aH4: function () {
          return fe;
        },
        aLr: function () {
          return kn;
        },
        aNw: function () {
          return yh;
        },
        aVm: function () {
          return Di;
        },
        ad5: function () {
          return zt;
        },
        anP: function () {
          return Ys;
        },
        aq0: function () {
          return dd;
        },
        av9: function () {
          return ze;
        },
        b5g: function () {
          return ll;
        },
        bGH: function () {
          return w;
        },
        b_z: function () {
          return Hc;
        },
        bdR: function () {
          return v;
        },
        blk: function () {
          return ac;
        },
        bnF: function () {
          return $c;
        },
        brP: function () {
          return Ue;
        },
        bsb: function () {
          return mt;
        },
        c8b: function () {
          return T;
        },
        cBI: function () {
          return gd;
        },
        cBK: function () {
          return Th;
        },
        cJO: function () {
          return Iu;
        },
        cLu: function () {
          return Te;
        },
        cPb: function () {
          return gs;
        },
        cRx: function () {
          return Oe;
        },
        cU9: function () {
          return ah;
        },
        ce8: function () {
          return Vt;
        },
        cek: function () {
          return Vh;
        },
        cum: function () {
          return rr;
        },
        dSO: function () {
          return se;
        },
        dUE: function () {
          return hh;
        },
        dYG: function () {
          return sh;
        },
        dZ3: function () {
          return te;
        },
        dd2: function () {
          return en;
        },
        dj0: function () {
          return ir;
        },
        dpR: function () {
          return kh;
        },
        dwk: function () {
          return d;
        },
        e62: function () {
          return Li;
        },
        eD: function () {
          return V;
        },
        eMJ: function () {
          return Xt;
        },
        eaV: function () {
          return Ke;
        },
        ehD: function () {
          return _;
        },
        ejS: function () {
          return oc;
        },
        ekQ: function () {
          return et;
        },
        epp: function () {
          return Nr;
        },
        fHI: function () {
          return Qc;
        },
        fO1: function () {
          return mc;
        },
        fQA: function () {
          return wd;
        },
        fQK: function () {
          return Za;
        },
        fSK: function () {
          return R;
        },
        fY$: function () {
          return ne;
        },
        fto: function () {
          return Ze;
        },
        g8_: function () {
          return ae;
        },
        gH0: function () {
          return zp;
        },
        gSk: function () {
          return Ct;
        },
        g_z: function () {
          return Bc;
        },
        ghN: function () {
          return I;
        },
        gi4: function () {
          return it;
        },
        gti: function () {
          return Fc;
        },
        hEm: function () {
          return Ne;
        },
        hH6: function () {
          return Eh;
        },
        iAb: function () {
          return we;
        },
        iDF: function () {
          return Eu;
        },
        iKG: function () {
          return zs;
        },
        iLg: function () {
          return dh;
        },
        iMs: function () {
          return Qp;
        },
        iUV: function () {
          return Rp;
        },
        iWC: function () {
          return D;
        },
        iWj: function () {
          return Ts;
        },
        i_9: function () {
          return cp;
        },
        iiP: function () {
          return dt;
        },
        irR: function () {
          return ke;
        },
        j4z: function () {
          return tr;
        },
        j87: function () {
          return Bi;
        },
        jAl: function () {
          return _t;
        },
        jFi: function () {
          return g;
        },
        jZA: function () {
          return rt;
        },
        jfJ: function () {
          return Ht;
        },
        jwo: function () {
          return Jt;
        },
        jyi: function () {
          return Il;
        },
        jyz: function () {
          return ms;
        },
        k0A: function () {
          return Ie;
        },
        k74: function () {
          return P;
        },
        kB5: function () {
          return fl;
        },
        kFz: function () {
          return on;
        },
        kaV: function () {
          return Yu;
        },
        knz: function () {
          return Dt;
        },
        kqm: function () {
          return Mp;
        },
        ksN: function () {
          return Q;
        },
        l0P: function () {
          return $e;
        },
        l8J: function () {
          return ur;
        },
        lCJ: function () {
          return Ri;
        },
        lDi: function () {
          return Xh;
        },
        lLk: function () {
          return Ah;
        },
        lRF: function () {
          return qa;
        },
        lRj: function () {
          return ve;
        },
        lb7: function () {
          return Hl;
        },
        lfu: function () {
          return oh;
        },
        lk7: function () {
          return Yh;
        },
        m7l: function () {
          return _h;
        },
        mSO: function () {
          return Lt;
        },
        mTL: function () {
          return ap;
        },
        mXe: function () {
          return Oc;
        },
        m_w: function () {
          return Vd;
        },
        mzJ: function () {
          return Lp;
        },
        nls: function () {
          return Jl;
        },
        ntZ: function () {
          return p;
        },
        nvb: function () {
          return Nd;
        },
        o8S: function () {
          return Du;
        },
        oAp: function () {
          return ys;
        },
        oa8: function () {
          return Pu;
        },
        oqc: function () {
          return Wt;
        },
        p3g: function () {
          return tn;
        },
        p7A: function () {
          return Od;
        },
        p7y: function () {
          return zc;
        },
        pBf: function () {
          return mr;
        },
        pIN: function () {
          return yt;
        },
        pKu: function () {
          return ct;
        },
        pQR: function () {
          return ku;
        },
        ptH: function () {
          return tt;
        },
        qhX: function () {
          return X;
        },
        qkB: function () {
          return Fe;
        },
        qlB: function () {
          return Pi;
        },
        qyh: function () {
          return ge;
        },
        rAo: function () {
          return ki;
        },
        rBU: function () {
          return Bs;
        },
        rDY: function () {
          return fs;
        },
        rOj: function () {
          return S;
        },
        r_: function () {
          return C;
        },
        rnI: function () {
          return kt;
        },
        rpg: function () {
          return le;
        },
        s4_: function () {
          return $h;
        },
        sYA: function () {
          return Sh;
        },
        tEQ: function () {
          return bh;
        },
        tGC: function () {
          return Id;
        },
        tJx: function () {
          return Sd;
        },
        tUh: function () {
          return lh;
        },
        tf: function () {
          return Tp;
        },
        tm_: function () {
          return a;
        },
        trn: function () {
          return zd;
        },
        u37: function () {
          return dp;
        },
        u7G: function () {
          return Kh;
        },
        u9r: function () {
          return Hi;
        },
        uEv: function () {
          return vt;
        },
        uL9: function () {
          return K;
        },
        uWy: function () {
          return ce;
        },
        uXU: function () {
          return Kt;
        },
        ujx: function () {
          return Kd;
        },
        v3W: function () {
          return We;
        },
        v9Y: function () {
          return pr;
        },
        vBJ: function () {
          return Ei;
        },
        vCF: function () {
          return G;
        },
        vCx: function () {
          return Ye;
        },
        vZf: function () {
          return me;
        },
        vmT: function () {
          return Ph;
        },
        vpT: function () {
          return pl;
        },
        vxC: function () {
          return ie;
        },
        w$m: function () {
          return H;
        },
        wJv: function () {
          return De;
        },
        wem: function () {
          return _e;
        },
        wk1: function () {
          return Re;
        },
        woe: function () {
          return dc;
        },
        wuA: function () {
          return Qe;
        },
        x12: function () {
          return nc;
        },
        x5V: function () {
          return Gt;
        },
        xEZ: function () {
          return Zr;
        },
        xG9: function () {
          return ad;
        },
        xJs: function () {
          return lt;
        },
        xWb: function () {
          return Np;
        },
        xeV: function () {
          return ml;
        },
        xfE: function () {
          return re;
        },
        xo$: function () {
          return Bu;
        },
        xoR: function () {
          return Hu;
        },
        xsS: function () {
          return hl;
        },
        y$t: function () {
          return jc;
        },
        y2t: function () {
          return nt;
        },
        y8_: function () {
          return kd;
        },
        yC1: function () {
          return mh;
        },
        yGw: function () {
          return Nn;
        },
        ybr: function () {
          return ul;
        },
        yj7: function () {
          return Pc;
        },
        ylh: function () {
          return Vp;
        },
        yo9: function () {
          return cl;
        },
        yt0: function () {
          return Zt;
        },
        ywz: function () {
          return ye;
        },
        yxD: function () {
          return Ih;
        },
        z$h: function () {
          return It;
        },
        z81: function () {
          return Rt;
        },
        z8B: function () {
          return Bl;
        },
        zHn: function () {
          return Un;
        },
        zbs: function () {
          return ph;
        },
        zf8: function () {
          return Vc;
        },
        zob: function () {
          return Ud;
        }
      });
      const n = "144dev",
        i = {
          LEFT: 0,
          MIDDLE: 1,
          RIGHT: 2,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2
        },
        s = {
          ROTATE: 0,
          PAN: 1,
          DOLLY_PAN: 2,
          DOLLY_ROTATE: 3
        },
        o = 0,
        a = 1,
        l = 2,
        c = 3,
        u = 0,
        h = 1,
        p = 2,
        d = 3,
        f = 0,
        m = 1,
        _ = 2,
        g = 0,
        v = 1,
        A = 2,
        b = 3,
        y = 4,
        x = 5,
        w = 100,
        E = 101,
        S = 102,
        C = 103,
        M = 104,
        T = 200,
        I = 201,
        k = 202,
        D = 203,
        P = 204,
        B = 205,
        R = 206,
        L = 207,
        O = 208,
        F = 209,
        U = 210,
        N = 0,
        j = 1,
        z = 2,
        G = 3,
        V = 4,
        Q = 5,
        H = 6,
        W = 7,
        q = 0,
        X = 1,
        Y = 2,
        K = 0,
        J = 1,
        Z = 2,
        $ = 3,
        ee = 4,
        te = 5,
        re = 300,
        ne = 301,
        ie = 302,
        se = 303,
        oe = 304,
        ae = 306,
        le = 1e3,
        ce = 1001,
        ue = 1002,
        he = 1003,
        pe = 1004,
        de = 1004,
        fe = 1005,
        me = 1005,
        _e = 1006,
        ge = 1007,
        ve = 1007,
        Ae = 1008,
        be = 1008,
        ye = 1009,
        xe = 1010,
        we = 1011,
        Ee = 1012,
        Se = 1013,
        Ce = 1014,
        Me = 1015,
        Te = 1016,
        Ie = 1017,
        ke = 1018,
        De = 1020,
        Pe = 1021,
        Be = 1022,
        Re = 1023,
        Le = 1024,
        Oe = 1025,
        Fe = 1026,
        Ue = 1027,
        Ne = 1028,
        je = 1029,
        ze = 1030,
        Ge = 1031,
        Ve = 1033,
        Qe = 33776,
        He = 33777,
        We = 33778,
        qe = 33779,
        Xe = 35840,
        Ye = 35841,
        Ke = 35842,
        Je = 35843,
        Ze = 36196,
        $e = 37492,
        et = 37496,
        tt = 37808,
        rt = 37809,
        nt = 37810,
        it = 37811,
        st = 37812,
        ot = 37813,
        at = 37814,
        lt = 37815,
        ct = 37816,
        ut = 37817,
        ht = 37818,
        pt = 37819,
        dt = 37820,
        ft = 37821,
        mt = 36492,
        _t = 2200,
        gt = 2201,
        vt = 2202,
        At = 2300,
        bt = 2301,
        yt = 2302,
        xt = 2400,
        wt = 2401,
        Et = 2402,
        St = 2500,
        Ct = 2501,
        Mt = 0,
        Tt = 1,
        It = 2,
        kt = 3e3,
        Dt = 3001,
        Pt = 3004,
        Bt = 3005,
        Rt = 3200,
        Lt = 3201,
        Ot = 0,
        Ft = 1,
        Ut = "",
        Nt = "srgb",
        jt = "srgb-linear",
        zt = 0,
        Gt = 7680,
        Vt = 7681,
        Qt = 7682,
        Ht = 7683,
        Wt = 34055,
        qt = 34056,
        Xt = 5386,
        Yt = 512,
        Kt = 513,
        Jt = 514,
        Zt = 515,
        $t = 516,
        er = 517,
        tr = 518,
        rr = 519,
        nr = 35044,
        ir = 35048,
        sr = 35040,
        or = 35045,
        ar = 35049,
        lr = 35041,
        cr = 35046,
        ur = 35050,
        hr = 35042,
        pr = "100",
        dr = "300 es",
        fr = 1035;
      class mr {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const r = this._listeners;
          void 0 === r[e] && (r[e] = []), -1 === r[e].indexOf(t) && r[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const r = this._listeners;
          return void 0 !== r[e] && -1 !== r[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const r = this._listeners[e];
          if (void 0 !== r) {
            const e = r.indexOf(t);
            -1 !== e && r.splice(e, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
            e.target = this;
            const r = t.slice(0);
            for (let t = 0, n = r.length; t < n; t++) r[t].call(this, e);
            e.target = null;
          }
        }
      }
      const _r = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
      let gr = 1234567;
      const vr = Math.PI / 180,
        Ar = 180 / Math.PI;
      function br() {
        const e = 4294967295 * Math.random() | 0,
          t = 4294967295 * Math.random() | 0,
          r = 4294967295 * Math.random() | 0,
          n = 4294967295 * Math.random() | 0;
        return (_r[255 & e] + _r[e >> 8 & 255] + _r[e >> 16 & 255] + _r[e >> 24 & 255] + "-" + _r[255 & t] + _r[t >> 8 & 255] + "-" + _r[t >> 16 & 15 | 64] + _r[t >> 24 & 255] + "-" + _r[63 & r | 128] + _r[r >> 8 & 255] + "-" + _r[r >> 16 & 255] + _r[r >> 24 & 255] + _r[255 & n] + _r[n >> 8 & 255] + _r[n >> 16 & 255] + _r[n >> 24 & 255]).toLowerCase();
      }
      function yr(e, t, r) {
        return Math.max(t, Math.min(r, e));
      }
      function xr(e, t) {
        return (e % t + t) % t;
      }
      function wr(e, t, r) {
        return (1 - r) * e + r * t;
      }
      function Er(e) {
        return 0 == (e & e - 1) && 0 !== e;
      }
      function Sr(e) {
        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
      }
      function Cr(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
      }
      function Mr(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function Tr(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return Math.round(65535 * e);
          case Uint8Array:
            return Math.round(255 * e);
          case Int16Array:
            return Math.round(32767 * e);
          case Int8Array:
            return Math.round(127 * e);
          default:
            throw new Error("Invalid component type.");
        }
      }
      var Ir = Object.freeze({
        __proto__: null,
        DEG2RAD: vr,
        RAD2DEG: Ar,
        generateUUID: br,
        clamp: yr,
        euclideanModulo: xr,
        mapLinear: function (e, t, r, n, i) {
          return n + (e - t) * (i - n) / (r - t);
        },
        inverseLerp: function (e, t, r) {
          return e !== t ? (r - e) / (t - e) : 0;
        },
        lerp: wr,
        damp: function (e, t, r, n) {
          return wr(e, t, 1 - Math.exp(-r * n));
        },
        pingpong: function (e, t = 1) {
          return t - Math.abs(xr(e, 2 * t) - t);
        },
        smoothstep: function (e, t, r) {
          return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * (3 - 2 * e);
        },
        smootherstep: function (e, t, r) {
          return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * e * (e * (6 * e - 15) + 10);
        },
        randInt: function (e, t) {
          return e + Math.floor(Math.random() * (t - e + 1));
        },
        randFloat: function (e, t) {
          return e + Math.random() * (t - e);
        },
        randFloatSpread: function (e) {
          return e * (.5 - Math.random());
        },
        seededRandom: function (e) {
          void 0 !== e && (gr = e);
          let t = gr += 1831565813;
          return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296;
        },
        degToRad: function (e) {
          return e * vr;
        },
        radToDeg: function (e) {
          return e * Ar;
        },
        isPowerOfTwo: Er,
        ceilPowerOfTwo: Sr,
        floorPowerOfTwo: Cr,
        setQuaternionFromProperEuler: function (e, t, r, n, i) {
          const s = Math.cos,
            o = Math.sin,
            a = s(r / 2),
            l = o(r / 2),
            c = s((t + n) / 2),
            u = o((t + n) / 2),
            h = s((t - n) / 2),
            p = o((t - n) / 2),
            d = s((n - t) / 2),
            f = o((n - t) / 2);
          switch (i) {
            case "XYX":
              e.set(a * u, l * h, l * p, a * c);
              break;
            case "YZY":
              e.set(l * p, a * u, l * h, a * c);
              break;
            case "ZXZ":
              e.set(l * h, l * p, a * u, a * c);
              break;
            case "XZX":
              e.set(a * u, l * f, l * d, a * c);
              break;
            case "YXY":
              e.set(l * d, a * u, l * f, a * c);
              break;
            case "ZYZ":
              e.set(l * f, l * d, a * u, a * c);
              break;
            default:
              console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
          }
        },
        normalize: Tr,
        denormalize: Mr
      });
      class kr {
        constructor(e = 0, t = 0) {
          kr.prototype.isVector2 = !0, this.x = e, this.y = t;
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return this.x = e, this.y = t, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            r = this.y,
            n = e.elements;
          return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
        }
        clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
        }
        clampLength(e, t) {
          const r = this.length();
          return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            r = this.y - e.y;
          return t * t + r * r;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, r) {
          return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
          const r = Math.cos(t),
            n = Math.sin(t),
            i = this.x - e.x,
            s = this.y - e.y;
          return this.x = i * r - s * n + e.x, this.y = i * n + s * r + e.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Dr {
        constructor() {
          Dr.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        }
        set(e, t, r, n, i, s, o, a, l) {
          const c = this.elements;
          return c[0] = e, c[1] = n, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = r, c[7] = s, c[8] = l, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            r = e.elements;
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
        }
        extractBasis(e, t, r) {
          return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const r = e.elements,
            n = t.elements,
            i = this.elements,
            s = r[0],
            o = r[3],
            a = r[6],
            l = r[1],
            c = r[4],
            u = r[7],
            h = r[2],
            p = r[5],
            d = r[8],
            f = n[0],
            m = n[3],
            _ = n[6],
            g = n[1],
            v = n[4],
            A = n[7],
            b = n[2],
            y = n[5],
            x = n[8];
          return i[0] = s * f + o * g + a * b, i[3] = s * m + o * v + a * y, i[6] = s * _ + o * A + a * x, i[1] = l * f + c * g + u * b, i[4] = l * m + c * v + u * y, i[7] = l * _ + c * A + u * x, i[2] = h * f + p * g + d * b, i[5] = h * m + p * v + d * y, i[8] = h * _ + p * A + d * x, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            r = e[1],
            n = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8];
          return t * s * c - t * o * l - r * i * c + r * o * a + n * i * l - n * s * a;
        }
        invert() {
          const e = this.elements,
            t = e[0],
            r = e[1],
            n = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = c * s - o * l,
            h = o * a - c * i,
            p = l * i - s * a,
            d = t * u + r * h + n * p;
          if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / d;
          return e[0] = u * f, e[1] = (n * l - c * r) * f, e[2] = (o * r - n * s) * f, e[3] = h * f, e[4] = (c * t - n * a) * f, e[5] = (n * i - o * t) * f, e[6] = p * f, e[7] = (r * a - l * t) * f, e[8] = (s * t - r * i) * f, this;
        }
        transpose() {
          let e;
          const t = this.elements;
          return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, r, n, i, s, o) {
          const a = Math.cos(i),
            l = Math.sin(i);
          return this.set(r * a, r * l, -r * (a * s + l * o) + s + e, -n * l, n * a, -n * (-l * s + a * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
          const r = this.elements;
          return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
        }
        rotate(e) {
          const t = Math.cos(e),
            r = Math.sin(e),
            n = this.elements,
            i = n[0],
            s = n[3],
            o = n[6],
            a = n[1],
            l = n[4],
            c = n[7];
          return n[0] = t * i + r * a, n[3] = t * s + r * l, n[6] = t * o + r * c, n[1] = -r * i + t * a, n[4] = -r * s + t * l, n[7] = -r * o + t * c, this;
        }
        translate(e, t) {
          const r = this.elements;
          return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
        }
        equals(e) {
          const t = this.elements,
            r = e.elements;
          for (let e = 0; e < 9; e++) if (t[e] !== r[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const r = this.elements;
          return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function Pr(e) {
        for (let t = e.length - 1; t >= 0; --t) if (e[t] > 65535) return !0;
        return !1;
      }
      const Br = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
      };
      function Rr(e, t) {
        return new Br[e](t);
      }
      function Lr(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function Or(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
      }
      function Fr(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
      }
      const Ur = {
          [Nt]: {
            [jt]: Or
          },
          [jt]: {
            [Nt]: Fr
          }
        },
        Nr = {
          legacyMode: !0,
          get workingColorSpace() {
            return jt;
          },
          set workingColorSpace(e) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
          },
          convert: function (e, t, r) {
            if (this.legacyMode || t === r || !t || !r) return e;
            if (Ur[t] && void 0 !== Ur[t][r]) {
              const n = Ur[t][r];
              return e.r = n(e.r), e.g = n(e.g), e.b = n(e.b), e;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (e, t) {
            return this.convert(e, this.workingColorSpace, t);
          },
          toWorkingColorSpace: function (e, t) {
            return this.convert(e, t, this.workingColorSpace);
          }
        },
        jr = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        },
        zr = {
          r: 0,
          g: 0,
          b: 0
        },
        Gr = {
          h: 0,
          s: 0,
          l: 0
        },
        Vr = {
          h: 0,
          s: 0,
          l: 0
        };
      function Qr(e, t, r) {
        return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - r) : e;
      }
      function Hr(e, t) {
        return t.r = e.r, t.g = e.g, t.b = e.b, t;
      }
      class Wr {
        constructor(e, t, r) {
          return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === r ? this.set(e) : this.setRGB(e, t, r);
        }
        set(e) {
          return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
        }
        setScalar(e) {
          return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = Nt) {
          return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, Nr.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, r, n = jt) {
          return this.r = e, this.g = t, this.b = r, Nr.toWorkingColorSpace(this, n), this;
        }
        setHSL(e, t, r, n = jt) {
          if (e = xr(e, 1), t = yr(t, 0, 1), r = yr(r, 0, 1), 0 === t) this.r = this.g = this.b = r;else {
            const n = r <= .5 ? r * (1 + t) : r + t - r * t,
              i = 2 * r - n;
            this.r = Qr(i, n, e + 1 / 3), this.g = Qr(i, n, e), this.b = Qr(i, n, e - 1 / 3);
          }
          return Nr.toWorkingColorSpace(this, n), this;
        }
        setStyle(e, t = Nt) {
          function r(t) {
            void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
          }
          let n;
          if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let e;
            const i = n[1],
              s = n[2];
            switch (i) {
              case "rgb":
              case "rgba":
                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, Nr.toWorkingColorSpace(this, t), r(e[4]), this;
                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, Nr.toWorkingColorSpace(this, t), r(e[4]), this;
                break;
              case "hsl":
              case "hsla":
                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                  const n = parseFloat(e[1]) / 360,
                    i = parseFloat(e[2]) / 100,
                    s = parseFloat(e[3]) / 100;
                  return r(e[4]), this.setHSL(n, i, s, t);
                }
            }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const e = n[1],
              r = e.length;
            if (3 === r) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, Nr.toWorkingColorSpace(this, t), this;
            if (6 === r) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, Nr.toWorkingColorSpace(this, t), this;
          }
          return e && e.length > 0 ? this.setColorName(e, t) : this;
        }
        setColorName(e, t = Nt) {
          const r = jr[e.toLowerCase()];
          return void 0 !== r ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
          return this.r = Or(e.r), this.g = Or(e.g), this.b = Or(e.b), this;
        }
        copyLinearToSRGB(e) {
          return this.r = Fr(e.r), this.g = Fr(e.g), this.b = Fr(e.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Nt) {
          return Nr.fromWorkingColorSpace(Hr(this, zr), e), yr(255 * zr.r, 0, 255) << 16 ^ yr(255 * zr.g, 0, 255) << 8 ^ yr(255 * zr.b, 0, 255) << 0;
        }
        getHexString(e = Nt) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = jt) {
          Nr.fromWorkingColorSpace(Hr(this, zr), t);
          const r = zr.r,
            n = zr.g,
            i = zr.b,
            s = Math.max(r, n, i),
            o = Math.min(r, n, i);
          let a, l;
          const c = (o + s) / 2;
          if (o === s) a = 0, l = 0;else {
            const e = s - o;
            switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
              case r:
                a = (n - i) / e + (n < i ? 6 : 0);
                break;
              case n:
                a = (i - r) / e + 2;
                break;
              case i:
                a = (r - n) / e + 4;
            }
            a /= 6;
          }
          return e.h = a, e.s = l, e.l = c, e;
        }
        getRGB(e, t = jt) {
          return Nr.fromWorkingColorSpace(Hr(this, zr), t), e.r = zr.r, e.g = zr.g, e.b = zr.b, e;
        }
        getStyle(e = Nt) {
          return Nr.fromWorkingColorSpace(Hr(this, zr), e), e !== Nt ? `color(${e} ${zr.r} ${zr.g} ${zr.b})` : `rgb(${255 * zr.r | 0},${255 * zr.g | 0},${255 * zr.b | 0})`;
        }
        offsetHSL(e, t, r) {
          return this.getHSL(Gr), Gr.h += e, Gr.s += t, Gr.l += r, this.setHSL(Gr.h, Gr.s, Gr.l), this;
        }
        add(e) {
          return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
          return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
          return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
          return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
          return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
          return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
          return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, r) {
          return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
        }
        lerpHSL(e, t) {
          this.getHSL(Gr), e.getHSL(Vr);
          const r = wr(Gr.h, Vr.h, t),
            n = wr(Gr.s, Vr.s, t),
            i = wr(Gr.l, Vr.l, t);
          return this.setHSL(r, n, i), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
          return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      let qr;
      Wr.NAMES = jr;
      class Xr {
        static getDataURL(e, t = !1) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let r;
          if (e instanceof HTMLCanvasElement) r = e;else {
            void 0 === qr && (qr = Lr("canvas")), qr.width = e.width, qr.height = e.height;
            const t = qr.getContext("2d");
            e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), r = qr;
          }
          return !t && (r.width > 2048 || r.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), r.toDataURL("image/jpeg", .6)) : r.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
            const t = Lr("canvas");
            t.width = e.width, t.height = e.height;
            const r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const n = r.getImageData(0, 0, e.width, e.height),
              i = n.data;
            for (let e = 0; e < i.length; e++) i[e] = 255 * Or(i[e] / 255);
            return r.putImageData(n, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Or(t[e] / 255)) : t[e] = Or(t[e]);
            return {
              data: t,
              width: e.width,
              height: e.height
            };
          }
          return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
      }
      class Yr {
        constructor(e = null) {
          this.isSource = !0, this.uuid = br(), this.data = e, this.version = 0;
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const r = {
              uuid: this.uuid,
              url: ""
            },
            n = this.data;
          if (null !== n) {
            let e;
            if (Array.isArray(n)) {
              e = [];
              for (let t = 0, r = n.length; t < r; t++) n[t].isDataTexture ? e.push(Kr(n[t].image)) : e.push(Kr(n[t]));
            } else e = Kr(n);
            r.url = e;
          }
          return t || (e.images[this.uuid] = r), r;
        }
      }
      function Kr(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return Xr.getDataURL(e);
        if (e.data) {
          let t = [];
          try {
            t = Array.from(e.data);
          } catch (r) {
            r.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(r), t = e.data;
          }
          return {
            data: t,
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
          };
        }
        return console.warn("THREE.Texture: Unable to serialize Texture."), {};
      }
      let Jr = 0;
      class Zr extends mr {
        constructor(e = Zr.DEFAULT_IMAGE, t = Zr.DEFAULT_MAPPING, r = ce, n = ce, i = _e, s = Ae, o = Re, a = ye, l = 1, c = kt) {
          super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: Jr++
          }), this.uuid = br(), this.name = "", this.source = new Yr(e), this.mipmaps = [], this.mapping = t, this.wrapS = r, this.wrapT = n, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new kr(0, 0), this.repeat = new kr(1, 1), this.center = new kr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Dr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
          const r = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(e) {
          if (this.mapping !== re) return e;
          if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case le:
              e.x = e.x - Math.floor(e.x);
              break;
            case ce:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case ue:
              1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          }
          if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case le:
              e.y = e.y - Math.floor(e.y);
              break;
            case ce:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case ue:
              1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          !0 === e && (this.version++, this.source.needsUpdate = !0);
        }
      }
      Zr.DEFAULT_IMAGE = null, Zr.DEFAULT_MAPPING = re;
      class $r {
        constructor(e = 0, t = 0, r = 0, n = 1) {
          $r.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = n;
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, r, n) {
          return this.x = e, this.y = t, this.z = r, this.w = n, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setW(e) {
          return this.w = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
          const t = this.x,
            r = this.y,
            n = this.z,
            i = this.w,
            s = e.elements;
          return this.x = s[0] * t + s[4] * r + s[8] * n + s[12] * i, this.y = s[1] * t + s[5] * r + s[9] * n + s[13] * i, this.z = s[2] * t + s[6] * r + s[10] * n + s[14] * i, this.w = s[3] * t + s[7] * r + s[11] * n + s[15] * i, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, r, n, i;
          const s = .01,
            o = .1,
            a = e.elements,
            l = a[0],
            c = a[4],
            u = a[8],
            h = a[1],
            p = a[5],
            d = a[9],
            f = a[2],
            m = a[6],
            _ = a[10];
          if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(d - m) < s) {
            if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(d + m) < o && Math.abs(l + p + _ - 3) < o) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (l + 1) / 2,
              a = (p + 1) / 2,
              g = (_ + 1) / 2,
              v = (c + h) / 4,
              A = (u + f) / 4,
              b = (d + m) / 4;
            return e > a && e > g ? e < s ? (r = 0, n = .707106781, i = .707106781) : (r = Math.sqrt(e), n = v / r, i = A / r) : a > g ? a < s ? (r = .707106781, n = 0, i = .707106781) : (n = Math.sqrt(a), r = v / n, i = b / n) : g < s ? (r = .707106781, n = .707106781, i = 0) : (i = Math.sqrt(g), r = A / i, n = b / i), this.set(r, n, i, t), this;
          }
          let g = Math.sqrt((m - d) * (m - d) + (u - f) * (u - f) + (h - c) * (h - c));
          return Math.abs(g) < .001 && (g = 1), this.x = (m - d) / g, this.y = (u - f) / g, this.z = (h - c) / g, this.w = Math.acos((l + p + _ - 1) / 2), this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
        }
        clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
        }
        clampLength(e, t) {
          const r = this.length();
          return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, r) {
          return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class en extends mr {
        constructor(e, t, r = {}) {
          super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new $r(0, 0, e, t), this.scissorTest = !1, this.viewport = new $r(0, 0, e, t);
          const n = {
            width: e,
            height: t,
            depth: 1
          };
          this.texture = new Zr(n, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps, this.texture.internalFormat = void 0 !== r.internalFormat ? r.internalFormat : null, this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : _e, this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer, this.stencilBuffer = void 0 !== r.stencilBuffer && r.stencilBuffer, this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null, this.samples = void 0 !== r.samples ? r.samples : 0;
        }
        setSize(e, t, r = 1) {
          this.width === e && this.height === t && this.depth === r || (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
          const t = Object.assign({}, e.texture.image);
          return this.texture.source = new Yr(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class tn extends Zr {
        constructor(e = null, t = 1, r = 1, n = 1) {
          super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
          }, this.magFilter = he, this.minFilter = he, this.wrapR = ce, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
      }
      class rn extends en {
        constructor(e, t, r) {
          super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new tn(null, e, t, r), this.texture.isRenderTargetTexture = !0;
        }
      }
      class nn extends Zr {
        constructor(e = null, t = 1, r = 1, n = 1) {
          super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
          }, this.magFilter = he, this.minFilter = he, this.wrapR = ce, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
      }
      class sn extends en {
        constructor(e, t, r) {
          super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new nn(null, e, t, r), this.texture.isRenderTargetTexture = !0;
        }
      }
      class on extends en {
        constructor(e, t, r, n = {}) {
          super(e, t, n), this.isWebGLMultipleRenderTargets = !0;
          const i = this.texture;
          this.texture = [];
          for (let e = 0; e < r; e++) this.texture[e] = i.clone(), this.texture[e].isRenderTargetTexture = !0;
        }
        setSize(e, t, r = 1) {
          if (this.width !== e || this.height !== t || this.depth !== r) {
            this.width = e, this.height = t, this.depth = r;
            for (let n = 0, i = this.texture.length; n < i; n++) this.texture[n].image.width = e, this.texture[n].image.height = t, this.texture[n].image.depth = r;
            this.dispose();
          }
          return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
        }
        copy(e) {
          this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
          for (let t = 0, r = e.texture.length; t < r; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
          return this;
        }
      }
      class an {
        constructor(e = 0, t = 0, r = 0, n = 1) {
          this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = n;
        }
        static slerpFlat(e, t, r, n, i, s, o) {
          let a = r[n + 0],
            l = r[n + 1],
            c = r[n + 2],
            u = r[n + 3];
          const h = i[s + 0],
            p = i[s + 1],
            d = i[s + 2],
            f = i[s + 3];
          if (0 === o) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u);
          if (1 === o) return e[t + 0] = h, e[t + 1] = p, e[t + 2] = d, void (e[t + 3] = f);
          if (u !== f || a !== h || l !== p || c !== d) {
            let e = 1 - o;
            const t = a * h + l * p + c * d + u * f,
              r = t >= 0 ? 1 : -1,
              n = 1 - t * t;
            if (n > Number.EPSILON) {
              const i = Math.sqrt(n),
                s = Math.atan2(i, t * r);
              e = Math.sin(e * s) / i, o = Math.sin(o * s) / i;
            }
            const i = o * r;
            if (a = a * e + h * i, l = l * e + p * i, c = c * e + d * i, u = u * e + f * i, e === 1 - o) {
              const e = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
              a *= e, l *= e, c *= e, u *= e;
            }
          }
          e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u;
        }
        static multiplyQuaternionsFlat(e, t, r, n, i, s) {
          const o = r[n],
            a = r[n + 1],
            l = r[n + 2],
            c = r[n + 3],
            u = i[s],
            h = i[s + 1],
            p = i[s + 2],
            d = i[s + 3];
          return e[t] = o * d + c * u + a * p - l * h, e[t + 1] = a * d + c * h + l * u - o * p, e[t + 2] = l * d + c * p + o * h - a * u, e[t + 3] = c * d - o * u - a * h - l * p, e;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          this._w = e, this._onChangeCallback();
        }
        set(e, t, r, n) {
          return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t) {
          const r = e._x,
            n = e._y,
            i = e._z,
            s = e._order,
            o = Math.cos,
            a = Math.sin,
            l = o(r / 2),
            c = o(n / 2),
            u = o(i / 2),
            h = a(r / 2),
            p = a(n / 2),
            d = a(i / 2);
          switch (s) {
            case "XYZ":
              this._x = h * c * u + l * p * d, this._y = l * p * u - h * c * d, this._z = l * c * d + h * p * u, this._w = l * c * u - h * p * d;
              break;
            case "YXZ":
              this._x = h * c * u + l * p * d, this._y = l * p * u - h * c * d, this._z = l * c * d - h * p * u, this._w = l * c * u + h * p * d;
              break;
            case "ZXY":
              this._x = h * c * u - l * p * d, this._y = l * p * u + h * c * d, this._z = l * c * d + h * p * u, this._w = l * c * u - h * p * d;
              break;
            case "ZYX":
              this._x = h * c * u - l * p * d, this._y = l * p * u + h * c * d, this._z = l * c * d - h * p * u, this._w = l * c * u + h * p * d;
              break;
            case "YZX":
              this._x = h * c * u + l * p * d, this._y = l * p * u + h * c * d, this._z = l * c * d - h * p * u, this._w = l * c * u - h * p * d;
              break;
            case "XZY":
              this._x = h * c * u - l * p * d, this._y = l * p * u - h * c * d, this._z = l * c * d + h * p * u, this._w = l * c * u + h * p * d;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
          }
          return !1 !== t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const r = t / 2,
            n = Math.sin(r);
          return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            r = t[0],
            n = t[4],
            i = t[8],
            s = t[1],
            o = t[5],
            a = t[9],
            l = t[2],
            c = t[6],
            u = t[10],
            h = r + o + u;
          if (h > 0) {
            const e = .5 / Math.sqrt(h + 1);
            this._w = .25 / e, this._x = (c - a) * e, this._y = (i - l) * e, this._z = (s - n) * e;
          } else if (r > o && r > u) {
            const e = 2 * Math.sqrt(1 + r - o - u);
            this._w = (c - a) / e, this._x = .25 * e, this._y = (n + s) / e, this._z = (i + l) / e;
          } else if (o > u) {
            const e = 2 * Math.sqrt(1 + o - r - u);
            this._w = (i - l) / e, this._x = (n + s) / e, this._y = .25 * e, this._z = (a + c) / e;
          } else {
            const e = 2 * Math.sqrt(1 + u - r - o);
            this._w = (s - n) / e, this._x = (i + l) / e, this._y = (a + c) / e, this._z = .25 * e;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let r = e.dot(t) + 1;
          return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(yr(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const r = this.angleTo(e);
          if (0 === r) return this;
          const n = Math.min(1, t / r);
          return this.slerp(e, n), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const r = e._x,
            n = e._y,
            i = e._z,
            s = e._w,
            o = t._x,
            a = t._y,
            l = t._z,
            c = t._w;
          return this._x = r * c + s * o + n * l - i * a, this._y = n * c + s * a + i * o - r * l, this._z = i * c + s * l + r * a - n * o, this._w = s * c - r * o - n * a - i * l, this._onChangeCallback(), this;
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const r = this._x,
            n = this._y,
            i = this._z,
            s = this._w;
          let o = s * e._w + r * e._x + n * e._y + i * e._z;
          if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = r, this._y = n, this._z = i, this;
          const a = 1 - o * o;
          if (a <= Number.EPSILON) {
            const e = 1 - t;
            return this._w = e * s + t * this._w, this._x = e * r + t * this._x, this._y = e * n + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          const l = Math.sqrt(a),
            c = Math.atan2(l, o),
            u = Math.sin((1 - t) * c) / l,
            h = Math.sin(t * c) / l;
          return this._w = s * u + this._w * h, this._x = r * u + this._x * h, this._y = n * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, r) {
          return this.copy(e).slerp(t, r);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            r = Math.sqrt(e),
            n = 2 * Math.PI * Math.random(),
            i = 2 * Math.PI * Math.random();
          return this.set(t * Math.cos(n), r * Math.sin(i), r * Math.cos(i), t * Math.sin(n));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
          return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class ln {
        constructor(e = 0, t = 0, r = 0) {
          ln.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
        }
        set(e, t, r) {
          return void 0 === r && (r = this.z), this.x = e, this.y = t, this.z = r, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
          return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
          return this.applyQuaternion(un.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(un.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            r = this.y,
            n = this.z,
            i = e.elements;
          return this.x = i[0] * t + i[3] * r + i[6] * n, this.y = i[1] * t + i[4] * r + i[7] * n, this.z = i[2] * t + i[5] * r + i[8] * n, this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            r = this.y,
            n = this.z,
            i = e.elements,
            s = 1 / (i[3] * t + i[7] * r + i[11] * n + i[15]);
          return this.x = (i[0] * t + i[4] * r + i[8] * n + i[12]) * s, this.y = (i[1] * t + i[5] * r + i[9] * n + i[13]) * s, this.z = (i[2] * t + i[6] * r + i[10] * n + i[14]) * s, this;
        }
        applyQuaternion(e) {
          const t = this.x,
            r = this.y,
            n = this.z,
            i = e.x,
            s = e.y,
            o = e.z,
            a = e.w,
            l = a * t + s * n - o * r,
            c = a * r + o * t - i * n,
            u = a * n + i * r - s * t,
            h = -i * t - s * r - o * n;
          return this.x = l * a + h * -i + c * -o - u * -s, this.y = c * a + h * -s + u * -i - l * -o, this.z = u * a + h * -o + l * -s - c * -i, this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x,
            r = this.y,
            n = this.z,
            i = e.elements;
          return this.x = i[0] * t + i[4] * r + i[8] * n, this.y = i[1] * t + i[5] * r + i[9] * n, this.z = i[2] * t + i[6] * r + i[10] * n, this.normalize();
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
        }
        clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
        }
        clampLength(e, t) {
          const r = this.length();
          return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, r) {
          return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const r = e.x,
            n = e.y,
            i = e.z,
            s = t.x,
            o = t.y,
            a = t.z;
          return this.x = n * a - i * o, this.y = i * s - r * a, this.z = r * o - n * s, this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const r = e.dot(this) / t;
          return this.copy(e).multiplyScalar(r);
        }
        projectOnPlane(e) {
          return cn.copy(this).projectOnVector(e), this.sub(cn);
        }
        reflect(e) {
          return this.sub(cn.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const r = this.dot(e) / t;
          return Math.acos(yr(r, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            r = this.y - e.y,
            n = this.z - e.z;
          return t * t + r * r + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, r) {
          const n = Math.sin(t) * e;
          return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, r) {
          return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            r = this.setFromMatrixColumn(e, 1).length(),
            n = this.setFromMatrixColumn(e, 2).length();
          return this.x = t, this.y = r, this.z = n, this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const e = 2 * (Math.random() - .5),
            t = Math.random() * Math.PI * 2,
            r = Math.sqrt(1 - e ** 2);
          return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const cn = new ln(),
        un = new an();
      class hn {
        constructor(e = new ln(1 / 0, 1 / 0, 1 / 0), t = new ln(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            r = 1 / 0,
            n = 1 / 0,
            i = -1 / 0,
            s = -1 / 0,
            o = -1 / 0;
          for (let a = 0, l = e.length; a < l; a += 3) {
            const l = e[a],
              c = e[a + 1],
              u = e[a + 2];
            l < t && (t = l), c < r && (r = c), u < n && (n = u), l > i && (i = l), c > s && (s = c), u > o && (o = u);
          }
          return this.min.set(t, r, n), this.max.set(i, s, o), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            r = 1 / 0,
            n = 1 / 0,
            i = -1 / 0,
            s = -1 / 0,
            o = -1 / 0;
          for (let a = 0, l = e.count; a < l; a++) {
            const l = e.getX(a),
              c = e.getY(a),
              u = e.getZ(a);
            l < t && (t = l), c < r && (r = c), u < n && (n = u), l > i && (i = l), c > s && (s = c), u > o && (o = u);
          }
          return this.min.set(t, r, n), this.max.set(i, s, o), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const r = dn.copy(t).multiplyScalar(.5);
          return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const r = e.geometry;
          if (void 0 !== r) if (t && null != r.attributes && void 0 !== r.attributes.position) {
            const t = r.attributes.position;
            for (let r = 0, n = t.count; r < n; r++) dn.fromBufferAttribute(t, r).applyMatrix4(e.matrixWorld), this.expandByPoint(dn);
          } else null === r.boundingBox && r.computeBoundingBox(), fn.copy(r.boundingBox), fn.applyMatrix4(e.matrixWorld), this.union(fn);
          const n = e.children;
          for (let e = 0, r = n.length; e < r; e++) this.expandByObject(n[e], t);
          return this;
        }
        containsPoint(e) {
          return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
          return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
        }
        intersectsSphere(e) {
          return this.clampPoint(e.center, dn), dn.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t, r;
          return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(yn), xn.subVectors(this.max, yn), mn.subVectors(e.a, yn), _n.subVectors(e.b, yn), gn.subVectors(e.c, yn), vn.subVectors(_n, mn), An.subVectors(gn, _n), bn.subVectors(mn, gn);
          let t = [0, -vn.z, vn.y, 0, -An.z, An.y, 0, -bn.z, bn.y, vn.z, 0, -vn.x, An.z, 0, -An.x, bn.z, 0, -bn.x, -vn.y, vn.x, 0, -An.y, An.x, 0, -bn.y, bn.x, 0];
          return !!Sn(t, mn, _n, gn, xn) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Sn(t, mn, _n, gn, xn) && (wn.crossVectors(vn, An), t = [wn.x, wn.y, wn.z], Sn(t, mn, _n, gn, xn)));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return dn.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return this.getCenter(e.center), e.radius = .5 * this.getSize(dn).length(), e;
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty() || (pn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), pn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), pn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), pn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), pn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), pn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), pn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), pn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(pn)), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const pn = [new ln(), new ln(), new ln(), new ln(), new ln(), new ln(), new ln(), new ln()],
        dn = new ln(),
        fn = new hn(),
        mn = new ln(),
        _n = new ln(),
        gn = new ln(),
        vn = new ln(),
        An = new ln(),
        bn = new ln(),
        yn = new ln(),
        xn = new ln(),
        wn = new ln(),
        En = new ln();
      function Sn(e, t, r, n, i) {
        for (let s = 0, o = e.length - 3; s <= o; s += 3) {
          En.fromArray(e, s);
          const o = i.x * Math.abs(En.x) + i.y * Math.abs(En.y) + i.z * Math.abs(En.z),
            a = t.dot(En),
            l = r.dot(En),
            c = n.dot(En);
          if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
        }
        return !0;
      }
      const Cn = new hn(),
        Mn = new ln(),
        Tn = new ln(),
        In = new ln();
      class kn {
        constructor(e = new ln(), t = -1) {
          this.center = e, this.radius = t;
        }
        set(e, t) {
          return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
          const r = this.center;
          void 0 !== t ? r.copy(t) : Cn.setFromPoints(e).getCenter(r);
          let n = 0;
          for (let t = 0, i = e.length; t < i; t++) n = Math.max(n, r.distanceToSquared(e[t]));
          return this.radius = Math.sqrt(n), this;
        }
        copy(e) {
          return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const r = this.center.distanceToSquared(e);
          return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
          return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          In.subVectors(e, this.center);
          const t = In.lengthSq();
          if (t > this.radius * this.radius) {
            const e = Math.sqrt(t),
              r = .5 * (e - this.radius);
            this.center.add(In.multiplyScalar(r / e)), this.radius += r;
          }
          return this;
        }
        union(e) {
          return !0 === this.center.equals(e.center) ? Tn.set(0, 0, 1).multiplyScalar(e.radius) : Tn.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Mn.copy(e.center).add(Tn)), this.expandByPoint(Mn.copy(e.center).sub(Tn)), this;
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Dn = new ln(),
        Pn = new ln(),
        Bn = new ln(),
        Rn = new ln(),
        Ln = new ln(),
        On = new ln(),
        Fn = new ln();
      class Un {
        constructor(e = new ln(), t = new ln(0, 0, -1)) {
          this.origin = e, this.direction = t;
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, Dn)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const r = t.dot(this.direction);
          return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Dn.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (Dn.copy(this.direction).multiplyScalar(t).add(this.origin), Dn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, r, n) {
          Pn.copy(e).add(t).multiplyScalar(.5), Bn.copy(t).sub(e).normalize(), Rn.copy(this.origin).sub(Pn);
          const i = .5 * e.distanceTo(t),
            s = -this.direction.dot(Bn),
            o = Rn.dot(this.direction),
            a = -Rn.dot(Bn),
            l = Rn.lengthSq(),
            c = Math.abs(1 - s * s);
          let u, h, p, d;
          if (c > 0) {
            if (u = s * a - o, h = s * o - a, d = i * c, u >= 0) {
              if (h >= -d) {
                if (h <= d) {
                  const e = 1 / c;
                  u *= e, h *= e, p = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l;
                } else h = i, u = Math.max(0, -(s * h + o)), p = -u * u + h * (h + 2 * a) + l;
              } else h = -i, u = Math.max(0, -(s * h + o)), p = -u * u + h * (h + 2 * a) + l;
            } else h <= -d ? (u = Math.max(0, -(-s * i + o)), h = u > 0 ? -i : Math.min(Math.max(-i, -a), i), p = -u * u + h * (h + 2 * a) + l) : h <= d ? (u = 0, h = Math.min(Math.max(-i, -a), i), p = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * i + o)), h = u > 0 ? i : Math.min(Math.max(-i, -a), i), p = -u * u + h * (h + 2 * a) + l);
          } else h = s > 0 ? -i : i, u = Math.max(0, -(s * h + o)), p = -u * u + h * (h + 2 * a) + l;
          return r && r.copy(this.direction).multiplyScalar(u).add(this.origin), n && n.copy(Bn).multiplyScalar(h).add(Pn), p;
        }
        intersectSphere(e, t) {
          Dn.subVectors(e.center, this.origin);
          const r = Dn.dot(this.direction),
            n = Dn.dot(Dn) - r * r,
            i = e.radius * e.radius;
          if (n > i) return null;
          const s = Math.sqrt(i - n),
            o = r - s,
            a = r + s;
          return o < 0 && a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const r = -(this.origin.dot(e.normal) + e.constant) / t;
          return r >= 0 ? r : null;
        }
        intersectPlane(e, t) {
          const r = this.distanceToPlane(e);
          return null === r ? null : this.at(r, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let r, n, i, s, o, a;
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return l >= 0 ? (r = (e.min.x - h.x) * l, n = (e.max.x - h.x) * l) : (r = (e.max.x - h.x) * l, n = (e.min.x - h.x) * l), c >= 0 ? (i = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), r > s || i > n ? null : ((i > r || r != r) && (r = i), (s < n || n != n) && (n = s), u >= 0 ? (o = (e.min.z - h.z) * u, a = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, a = (e.min.z - h.z) * u), r > a || o > n ? null : ((o > r || r != r) && (r = o), (a < n || n != n) && (n = a), n < 0 ? null : this.at(r >= 0 ? r : n, t)));
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, Dn);
        }
        intersectTriangle(e, t, r, n, i) {
          Ln.subVectors(t, e), On.subVectors(r, e), Fn.crossVectors(Ln, On);
          let s,
            o = this.direction.dot(Fn);
          if (o > 0) {
            if (n) return null;
            s = 1;
          } else {
            if (!(o < 0)) return null;
            s = -1, o = -o;
          }
          Rn.subVectors(this.origin, e);
          const a = s * this.direction.dot(On.crossVectors(Rn, On));
          if (a < 0) return null;
          const l = s * this.direction.dot(Ln.cross(Rn));
          if (l < 0) return null;
          if (a + l > o) return null;
          const c = -s * Rn.dot(Fn);
          return c < 0 ? null : this.at(c / o, i);
        }
        applyMatrix4(e) {
          return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Nn {
        constructor() {
          Nn.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }
        set(e, t, r, n, i, s, o, a, l, c, u, h, p, d, f, m) {
          const _ = this.elements;
          return _[0] = e, _[4] = t, _[8] = r, _[12] = n, _[1] = i, _[5] = s, _[9] = o, _[13] = a, _[2] = l, _[6] = c, _[10] = u, _[14] = h, _[3] = p, _[7] = d, _[11] = f, _[15] = m, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Nn().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            r = e.elements;
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
        }
        copyPosition(e) {
          const t = this.elements,
            r = e.elements;
          return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, r) {
          return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, r) {
          return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
          const t = this.elements,
            r = e.elements,
            n = 1 / jn.setFromMatrixColumn(e, 0).length(),
            i = 1 / jn.setFromMatrixColumn(e, 1).length(),
            s = 1 / jn.setFromMatrixColumn(e, 2).length();
          return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * i, t[5] = r[5] * i, t[6] = r[6] * i, t[7] = 0, t[8] = r[8] * s, t[9] = r[9] * s, t[10] = r[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            r = e.x,
            n = e.y,
            i = e.z,
            s = Math.cos(r),
            o = Math.sin(r),
            a = Math.cos(n),
            l = Math.sin(n),
            c = Math.cos(i),
            u = Math.sin(i);
          if ("XYZ" === e.order) {
            const e = s * c,
              r = s * u,
              n = o * c,
              i = o * u;
            t[0] = a * c, t[4] = -a * u, t[8] = l, t[1] = r + n * l, t[5] = e - i * l, t[9] = -o * a, t[2] = i - e * l, t[6] = n + r * l, t[10] = s * a;
          } else if ("YXZ" === e.order) {
            const e = a * c,
              r = a * u,
              n = l * c,
              i = l * u;
            t[0] = e + i * o, t[4] = n * o - r, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -o, t[2] = r * o - n, t[6] = i + e * o, t[10] = s * a;
          } else if ("ZXY" === e.order) {
            const e = a * c,
              r = a * u,
              n = l * c,
              i = l * u;
            t[0] = e - i * o, t[4] = -s * u, t[8] = n + r * o, t[1] = r + n * o, t[5] = s * c, t[9] = i - e * o, t[2] = -s * l, t[6] = o, t[10] = s * a;
          } else if ("ZYX" === e.order) {
            const e = s * c,
              r = s * u,
              n = o * c,
              i = o * u;
            t[0] = a * c, t[4] = n * l - r, t[8] = e * l + i, t[1] = a * u, t[5] = i * l + e, t[9] = r * l - n, t[2] = -l, t[6] = o * a, t[10] = s * a;
          } else if ("YZX" === e.order) {
            const e = s * a,
              r = s * l,
              n = o * a,
              i = o * l;
            t[0] = a * c, t[4] = i - e * u, t[8] = n * u + r, t[1] = u, t[5] = s * c, t[9] = -o * c, t[2] = -l * c, t[6] = r * u + n, t[10] = e - i * u;
          } else if ("XZY" === e.order) {
            const e = s * a,
              r = s * l,
              n = o * a,
              i = o * l;
            t[0] = a * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = s * c, t[9] = r * u - n, t[2] = n * u - r, t[6] = o * c, t[10] = i * u + e;
          }
          return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Gn, e, Vn);
        }
        lookAt(e, t, r) {
          const n = this.elements;
          return Wn.subVectors(e, t), 0 === Wn.lengthSq() && (Wn.z = 1), Wn.normalize(), Qn.crossVectors(r, Wn), 0 === Qn.lengthSq() && (1 === Math.abs(r.z) ? Wn.x += 1e-4 : Wn.z += 1e-4, Wn.normalize(), Qn.crossVectors(r, Wn)), Qn.normalize(), Hn.crossVectors(Wn, Qn), n[0] = Qn.x, n[4] = Hn.x, n[8] = Wn.x, n[1] = Qn.y, n[5] = Hn.y, n[9] = Wn.y, n[2] = Qn.z, n[6] = Hn.z, n[10] = Wn.z, this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const r = e.elements,
            n = t.elements,
            i = this.elements,
            s = r[0],
            o = r[4],
            a = r[8],
            l = r[12],
            c = r[1],
            u = r[5],
            h = r[9],
            p = r[13],
            d = r[2],
            f = r[6],
            m = r[10],
            _ = r[14],
            g = r[3],
            v = r[7],
            A = r[11],
            b = r[15],
            y = n[0],
            x = n[4],
            w = n[8],
            E = n[12],
            S = n[1],
            C = n[5],
            M = n[9],
            T = n[13],
            I = n[2],
            k = n[6],
            D = n[10],
            P = n[14],
            B = n[3],
            R = n[7],
            L = n[11],
            O = n[15];
          return i[0] = s * y + o * S + a * I + l * B, i[4] = s * x + o * C + a * k + l * R, i[8] = s * w + o * M + a * D + l * L, i[12] = s * E + o * T + a * P + l * O, i[1] = c * y + u * S + h * I + p * B, i[5] = c * x + u * C + h * k + p * R, i[9] = c * w + u * M + h * D + p * L, i[13] = c * E + u * T + h * P + p * O, i[2] = d * y + f * S + m * I + _ * B, i[6] = d * x + f * C + m * k + _ * R, i[10] = d * w + f * M + m * D + _ * L, i[14] = d * E + f * T + m * P + _ * O, i[3] = g * y + v * S + A * I + b * B, i[7] = g * x + v * C + A * k + b * R, i[11] = g * w + v * M + A * D + b * L, i[15] = g * E + v * T + A * P + b * O, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            r = e[4],
            n = e[8],
            i = e[12],
            s = e[1],
            o = e[5],
            a = e[9],
            l = e[13],
            c = e[2],
            u = e[6],
            h = e[10],
            p = e[14];
          return e[3] * (+i * a * u - n * l * u - i * o * h + r * l * h + n * o * p - r * a * p) + e[7] * (+t * a * p - t * l * h + i * s * h - n * s * p + n * l * c - i * a * c) + e[11] * (+t * l * u - t * o * p - i * s * u + r * s * p + i * o * c - r * l * c) + e[15] * (-n * o * c - t * a * u + t * o * h + n * s * u - r * s * h + r * a * c);
        }
        transpose() {
          const e = this.elements;
          let t;
          return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, r) {
          const n = this.elements;
          return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
        }
        invert() {
          const e = this.elements,
            t = e[0],
            r = e[1],
            n = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            h = e[10],
            p = e[11],
            d = e[12],
            f = e[13],
            m = e[14],
            _ = e[15],
            g = u * m * l - f * h * l + f * a * p - o * m * p - u * a * _ + o * h * _,
            v = d * h * l - c * m * l - d * a * p + s * m * p + c * a * _ - s * h * _,
            A = c * f * l - d * u * l + d * o * p - s * f * p - c * o * _ + s * u * _,
            b = d * u * a - c * f * a - d * o * h + s * f * h + c * o * m - s * u * m,
            y = t * g + r * v + n * A + i * b;
          if (0 === y) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const x = 1 / y;
          return e[0] = g * x, e[1] = (f * h * i - u * m * i - f * n * p + r * m * p + u * n * _ - r * h * _) * x, e[2] = (o * m * i - f * a * i + f * n * l - r * m * l - o * n * _ + r * a * _) * x, e[3] = (u * a * i - o * h * i - u * n * l + r * h * l + o * n * p - r * a * p) * x, e[4] = v * x, e[5] = (c * m * i - d * h * i + d * n * p - t * m * p - c * n * _ + t * h * _) * x, e[6] = (d * a * i - s * m * i - d * n * l + t * m * l + s * n * _ - t * a * _) * x, e[7] = (s * h * i - c * a * i + c * n * l - t * h * l - s * n * p + t * a * p) * x, e[8] = A * x, e[9] = (d * u * i - c * f * i - d * r * p + t * f * p + c * r * _ - t * u * _) * x, e[10] = (s * f * i - d * o * i + d * r * l - t * f * l - s * r * _ + t * o * _) * x, e[11] = (c * o * i - s * u * i - c * r * l + t * u * l + s * r * p - t * o * p) * x, e[12] = b * x, e[13] = (c * f * n - d * u * n + d * r * h - t * f * h - c * r * m + t * u * m) * x, e[14] = (d * o * n - s * f * n - d * r * a + t * f * a + s * r * m - t * o * m) * x, e[15] = (s * u * n - c * o * n + c * r * a - t * u * a - s * r * h + t * o * h) * x, this;
        }
        scale(e) {
          const t = this.elements,
            r = e.x,
            n = e.y,
            i = e.z;
          return t[0] *= r, t[4] *= n, t[8] *= i, t[1] *= r, t[5] *= n, t[9] *= i, t[2] *= r, t[6] *= n, t[10] *= i, t[3] *= r, t[7] *= n, t[11] *= i, this;
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, r, n));
        }
        makeTranslation(e, t, r) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            r = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            r = Math.sin(e);
          return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            r = Math.sin(e);
          return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
          const r = Math.cos(t),
            n = Math.sin(t),
            i = 1 - r,
            s = e.x,
            o = e.y,
            a = e.z,
            l = i * s,
            c = i * o;
          return this.set(l * s + r, l * o - n * a, l * a + n * o, 0, l * o + n * a, c * o + r, c * a - n * s, 0, l * a - n * o, c * a + n * s, i * a * a + r, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, r) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, r, n, i, s) {
          return this.set(1, r, i, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, r) {
          const n = this.elements,
            i = t._x,
            s = t._y,
            o = t._z,
            a = t._w,
            l = i + i,
            c = s + s,
            u = o + o,
            h = i * l,
            p = i * c,
            d = i * u,
            f = s * c,
            m = s * u,
            _ = o * u,
            g = a * l,
            v = a * c,
            A = a * u,
            b = r.x,
            y = r.y,
            x = r.z;
          return n[0] = (1 - (f + _)) * b, n[1] = (p + A) * b, n[2] = (d - v) * b, n[3] = 0, n[4] = (p - A) * y, n[5] = (1 - (h + _)) * y, n[6] = (m + g) * y, n[7] = 0, n[8] = (d + v) * x, n[9] = (m - g) * x, n[10] = (1 - (h + f)) * x, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
        }
        decompose(e, t, r) {
          const n = this.elements;
          let i = jn.set(n[0], n[1], n[2]).length();
          const s = jn.set(n[4], n[5], n[6]).length(),
            o = jn.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (i = -i), e.x = n[12], e.y = n[13], e.z = n[14], zn.copy(this);
          const a = 1 / i,
            l = 1 / s,
            c = 1 / o;
          return zn.elements[0] *= a, zn.elements[1] *= a, zn.elements[2] *= a, zn.elements[4] *= l, zn.elements[5] *= l, zn.elements[6] *= l, zn.elements[8] *= c, zn.elements[9] *= c, zn.elements[10] *= c, t.setFromRotationMatrix(zn), r.x = i, r.y = s, r.z = o, this;
        }
        makePerspective(e, t, r, n, i, s) {
          const o = this.elements,
            a = 2 * i / (t - e),
            l = 2 * i / (r - n),
            c = (t + e) / (t - e),
            u = (r + n) / (r - n),
            h = -(s + i) / (s - i),
            p = -2 * s * i / (s - i);
          return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
        }
        makeOrthographic(e, t, r, n, i, s) {
          const o = this.elements,
            a = 1 / (t - e),
            l = 1 / (r - n),
            c = 1 / (s - i),
            u = (t + e) * a,
            h = (r + n) * l,
            p = (s + i) * c;
          return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
        }
        equals(e) {
          const t = this.elements,
            r = e.elements;
          for (let e = 0; e < 16; e++) if (t[e] !== r[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const r = this.elements;
          return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
        }
      }
      const jn = new ln(),
        zn = new Nn(),
        Gn = new ln(0, 0, 0),
        Vn = new ln(1, 1, 1),
        Qn = new ln(),
        Hn = new ln(),
        Wn = new ln(),
        qn = new Nn(),
        Xn = new an();
      class Yn {
        constructor(e = 0, t = 0, r = 0, n = Yn.DefaultOrder) {
          this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = n;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          this._order = e, this._onChangeCallback();
        }
        set(e, t, r, n = this._order) {
          return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, r = !0) {
          const n = e.elements,
            i = n[0],
            s = n[4],
            o = n[8],
            a = n[1],
            l = n[5],
            c = n[9],
            u = n[2],
            h = n[6],
            p = n[10];
          switch (t) {
            case "XYZ":
              this._y = Math.asin(yr(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(h, l), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-yr(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(yr(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, i));
              break;
            case "ZYX":
              this._y = Math.asin(-yr(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
              break;
            case "YZX":
              this._z = Math.asin(yr(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, p));
              break;
            case "XZY":
              this._z = Math.asin(-yr(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, p), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          return this._order = t, !0 === r && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, r) {
          return qn.makeRotationFromQuaternion(e), this.setFromRotationMatrix(qn, t, r);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Xn.setFromEuler(this), this.setFromQuaternion(Xn, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
        toVector3() {
          console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
        }
      }
      Yn.DefaultOrder = "XYZ", Yn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Kn {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e | 0;
        }
        disable(e) {
          this.mask &= ~(1 << e | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return 0 != (this.mask & e.mask);
        }
        isEnabled(e) {
          return 0 != (this.mask & (1 << e | 0));
        }
      }
      let Jn = 0;
      const Zn = new ln(),
        $n = new an(),
        ei = new Nn(),
        ti = new ln(),
        ri = new ln(),
        ni = new ln(),
        ii = new an(),
        si = new ln(1, 0, 0),
        oi = new ln(0, 1, 0),
        ai = new ln(0, 0, 1),
        li = {
          type: "added"
        },
        ci = {
          type: "removed"
        };
      class ui extends mr {
        constructor() {
          super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: Jn++
          }), this.uuid = br(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ui.DefaultUp.clone();
          const e = new ln(),
            t = new Yn(),
            r = new an(),
            n = new ln(1, 1, 1);
          t._onChange(function () {
            r.setFromEuler(t, !1);
          }), r._onChange(function () {
            t.setFromQuaternion(r, void 0, !1);
          }), Object.defineProperties(this, {
            position: {
              configurable: !0,
              enumerable: !0,
              value: e
            },
            rotation: {
              configurable: !0,
              enumerable: !0,
              value: t
            },
            quaternion: {
              configurable: !0,
              enumerable: !0,
              value: r
            },
            scale: {
              configurable: !0,
              enumerable: !0,
              value: n
            },
            modelViewMatrix: {
              value: new Nn()
            },
            normalMatrix: {
              value: new Dr()
            }
          }), this.matrix = new Nn(), this.matrixWorld = new Nn(), this.matrixAutoUpdate = ui.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ui.DefaultMatrixWorldAutoUpdate, this.layers = new Kn(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeRender(e, t, r, n, i, s) {
          this.dispatchEvent({
            type: "beforeRender",
            renderer: e,
            scene: t,
            camera: r,
            geometry: n,
            material: i,
            group: s
          });
        }
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return $n.setFromAxisAngle(e, t), this.quaternion.multiply($n), this;
        }
        rotateOnWorldAxis(e, t) {
          return $n.setFromAxisAngle(e, t), this.quaternion.premultiply($n), this;
        }
        rotateX(e) {
          return this.rotateOnAxis(si, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(oi, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(ai, e);
        }
        translateOnAxis(e, t) {
          return Zn.copy(e).applyQuaternion(this.quaternion), this.position.add(Zn.multiplyScalar(t)), this;
        }
        translateX(e) {
          return this.translateOnAxis(si, e);
        }
        translateY(e) {
          return this.translateOnAxis(oi, e);
        }
        translateZ(e) {
          return this.translateOnAxis(ai, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(ei.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, r) {
          e.isVector3 ? ti.copy(e) : ti.set(e, t, r);
          const n = this.parent;
          this.updateWorldMatrix(!0, !1), ri.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ei.lookAt(ri, ti, this.up) : ei.lookAt(ti, ri, this.up), this.quaternion.setFromRotationMatrix(ei), n && (ei.extractRotation(n.matrixWorld), $n.setFromRotationMatrix(ei), this.quaternion.premultiply($n.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(li)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
            return this;
          }
          const t = this.children.indexOf(e);
          return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(ci)), this;
        }
        removeFromParent() {
          const e = this.parent;
          return null !== e && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null, t.dispatchEvent(ci);
          }
          return this.children.length = 0, this;
        }
        attach(e) {
          return this.updateWorldMatrix(!0, !1), ei.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), ei.multiply(e.parent.matrixWorld)), e.applyMatrix4(ei), this.add(e), e.updateWorldMatrix(!1, !0), this;
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let r = 0, n = this.children.length; r < n; r++) {
            const n = this.children[r].getObjectByProperty(e, t);
            if (void 0 !== n) return n;
          }
        }
        getWorldPosition(e) {
          return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ri, e, ni), e;
        }
        getWorldScale(e) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ri, ii, e), e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let r = 0, n = t.length; r < n; r++) t[r].traverse(e);
        }
        traverseVisible(e) {
          if (!1 === this.visible) return;
          e(this);
          const t = this.children;
          for (let r = 0, n = t.length; r < n; r++) t[r].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          null !== t && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
          const t = this.children;
          for (let r = 0, n = t.length; r < n; r++) {
            const n = t[r];
            !0 !== n.matrixWorldAutoUpdate && !0 !== e || n.updateMatrixWorld(e);
          }
        }
        updateWorldMatrix(e, t) {
          const r = this.parent;
          if (!0 === e && null !== r && !0 === r.matrixWorldAutoUpdate && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
            const e = this.children;
            for (let t = 0, r = e.length; t < r; t++) {
              const r = e[t];
              !0 === r.matrixWorldAutoUpdate && r.updateWorldMatrix(!1, !0);
            }
          }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e,
            r = {};
          t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const n = {};
          function i(t, r) {
            return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)), r.uuid;
          }
          if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(e).uuid);else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = i(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
              const r = t.shapes;
              if (Array.isArray(r)) for (let t = 0, n = r.length; t < n; t++) {
                const n = r[t];
                i(e.shapes, n);
              } else i(e.shapes, r);
            }
          }
          if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
            const t = [];
            for (let r = 0, n = this.material.length; r < n; r++) t.push(i(e.materials, this.material[r]));
            n.material = t;
          } else n.material = i(e.materials, this.material);
          if (this.children.length > 0) {
            n.children = [];
            for (let t = 0; t < this.children.length; t++) n.children.push(this.children[t].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
              const r = this.animations[t];
              n.animations.push(i(e.animations, r));
            }
          }
          if (t) {
            const t = s(e.geometries),
              n = s(e.materials),
              i = s(e.textures),
              o = s(e.images),
              a = s(e.shapes),
              l = s(e.skeletons),
              c = s(e.animations),
              u = s(e.nodes);
            t.length > 0 && (r.geometries = t), n.length > 0 && (r.materials = n), i.length > 0 && (r.textures = i), o.length > 0 && (r.images = o), a.length > 0 && (r.shapes = a), l.length > 0 && (r.skeletons = l), c.length > 0 && (r.animations = c), u.length > 0 && (r.nodes = u);
          }
          return r.object = n, r;
          function s(e) {
            const t = [];
            for (const r in e) {
              const n = e[r];
              delete n.metadata, t.push(n);
            }
            return t;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = {};
          for (const [t, r] of Object.entries(e.userData)) this.userData[t] = !r || r && (r.isTexture || r.isObject3D) ? r : JSON.parse(JSON.stringify(r));
          if (!0 === t) for (let t = 0; t < e.children.length; t++) {
            const r = e.children[t];
            this.add(r.clone());
          }
          return this;
        }
      }
      ui.DefaultUp = new ln(0, 1, 0), ui.DefaultMatrixAutoUpdate = !0, ui.DefaultMatrixWorldAutoUpdate = !0;
      const hi = new ln(),
        pi = new ln(),
        di = new ln(),
        fi = new ln(),
        mi = new ln(),
        _i = new ln(),
        gi = new ln(),
        vi = new ln(),
        Ai = new ln(),
        bi = new ln();
      class yi {
        constructor(e = new ln(), t = new ln(), r = new ln()) {
          this.a = e, this.b = t, this.c = r;
        }
        static getNormal(e, t, r, n) {
          n.subVectors(r, t), hi.subVectors(e, t), n.cross(hi);
          const i = n.lengthSq();
          return i > 0 ? n.multiplyScalar(1 / Math.sqrt(i)) : n.set(0, 0, 0);
        }
        static getBarycoord(e, t, r, n, i) {
          hi.subVectors(n, t), pi.subVectors(r, t), di.subVectors(e, t);
          const s = hi.dot(hi),
            o = hi.dot(pi),
            a = hi.dot(di),
            l = pi.dot(pi),
            c = pi.dot(di),
            u = s * l - o * o;
          if (0 === u) return i.set(-2, -1, -1);
          const h = 1 / u,
            p = (l * a - o * c) * h,
            d = (s * c - o * a) * h;
          return i.set(1 - p - d, d, p);
        }
        static containsPoint(e, t, r, n) {
          return this.getBarycoord(e, t, r, n, fi), fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1;
        }
        static getUV(e, t, r, n, i, s, o, a) {
          return this.getBarycoord(e, t, r, n, fi), a.set(0, 0), a.addScaledVector(i, fi.x), a.addScaledVector(s, fi.y), a.addScaledVector(o, fi.z), a;
        }
        static isFrontFacing(e, t, r, n) {
          return hi.subVectors(r, t), pi.subVectors(e, t), hi.cross(pi).dot(n) < 0;
        }
        set(e, t, r) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
        }
        setFromPointsAndIndices(e, t, r, n) {
          return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
        }
        setFromAttributeAndIndices(e, t, r, n) {
          return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return hi.subVectors(this.c, this.b), pi.subVectors(this.a, this.b), .5 * hi.cross(pi).length();
        }
        getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return yi.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return yi.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, r, n, i) {
          return yi.getUV(e, this.a, this.b, this.c, t, r, n, i);
        }
        containsPoint(e) {
          return yi.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return yi.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const r = this.a,
            n = this.b,
            i = this.c;
          let s, o;
          mi.subVectors(n, r), _i.subVectors(i, r), vi.subVectors(e, r);
          const a = mi.dot(vi),
            l = _i.dot(vi);
          if (a <= 0 && l <= 0) return t.copy(r);
          Ai.subVectors(e, n);
          const c = mi.dot(Ai),
            u = _i.dot(Ai);
          if (c >= 0 && u <= c) return t.copy(n);
          const h = a * u - c * l;
          if (h <= 0 && a >= 0 && c <= 0) return s = a / (a - c), t.copy(r).addScaledVector(mi, s);
          bi.subVectors(e, i);
          const p = mi.dot(bi),
            d = _i.dot(bi);
          if (d >= 0 && p <= d) return t.copy(i);
          const f = p * l - a * d;
          if (f <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(r).addScaledVector(_i, o);
          const m = c * d - p * u;
          if (m <= 0 && u - c >= 0 && p - d >= 0) return gi.subVectors(i, n), o = (u - c) / (u - c + (p - d)), t.copy(n).addScaledVector(gi, o);
          const _ = 1 / (m + f + h);
          return s = f * _, o = h * _, t.copy(r).addScaledVector(mi, s).addScaledVector(_i, o);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let xi = 0;
      class wi extends mr {
        constructor() {
          super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: xi++
          }), this.uuid = br(), this.name = "", this.type = "Material", this.blending = v, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = P, this.blendDst = B, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = G, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = rr, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Gt, this.stencilZFail = Gt, this.stencilZPass = Gt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBuild() {}
        onBeforeRender() {}
        onAfterRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e) for (const t in e) {
            const r = e[t];
            if (void 0 === r) {
              console.warn("THREE.Material: '" + t + "' parameter is undefined.");
              continue;
            }
            const n = this[t];
            void 0 !== n && (n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r);
          }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = {
            textures: {},
            images: {}
          });
          const r = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          function n(e) {
            const t = [];
            for (const r in e) {
              const n = e[r];
              delete n.metadata, t.push(n);
            }
            return t;
          }
          if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), void 0 !== this.sheen && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (r.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (r.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (r.combine = this.combine)), void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (r.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (r.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (r.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (r.size = this.size), null !== this.shadowSide && (r.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (r.blending = this.blending), this.side !== f && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (r.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (r.flatShading = this.flatShading), !1 === this.visible && (r.visible = !1), !1 === this.toneMapped && (r.toneMapped = !1), !1 === this.fog && (r.fog = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), t) {
            const t = n(e.textures),
              i = n(e.images);
            t.length > 0 && (r.textures = t), i.length > 0 && (r.images = i);
          }
          return r;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let r = null;
          if (null !== t) {
            const e = t.length;
            r = new Array(e);
            for (let n = 0; n !== e; ++n) r[n] = t[n].clone();
          }
          this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = {};
          for (const [t, r] of Object.entries(e.userData)) this.userData[t] = !r || r && (r.isTexture || r.isObject3D) ? r : JSON.parse(JSON.stringify(r));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
      }
      class Ei extends wi {
        constructor(e) {
          super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Wr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      const Si = new ln(),
        Ci = new kr();
      class Mi {
        constructor(e, t, r) {
          if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === r, this.usage = nr, this.updateRange = {
            offset: 0,
            count: -1
          }, this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        copy(e) {
          return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
        }
        copyAt(e, t, r) {
          e *= this.itemSize, r *= t.itemSize;
          for (let n = 0, i = this.itemSize; n < i; n++) this.array[e + n] = t.array[r + n];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize) for (let t = 0, r = this.count; t < r; t++) Ci.fromBufferAttribute(this, t), Ci.applyMatrix3(e), this.setXY(t, Ci.x, Ci.y);else if (3 === this.itemSize) for (let t = 0, r = this.count; t < r; t++) Si.fromBufferAttribute(this, t), Si.applyMatrix3(e), this.setXYZ(t, Si.x, Si.y, Si.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, r = this.count; t < r; t++) Si.fromBufferAttribute(this, t), Si.applyMatrix4(e), this.setXYZ(t, Si.x, Si.y, Si.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, r = this.count; t < r; t++) Si.fromBufferAttribute(this, t), Si.applyNormalMatrix(e), this.setXYZ(t, Si.x, Si.y, Si.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, r = this.count; t < r; t++) Si.fromBufferAttribute(this, t), Si.transformDirection(e), this.setXYZ(t, Si.x, Si.y, Si.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, r) {
          return e *= this.itemSize, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
        }
        setXYZ(e, t, r, n) {
          return e *= this.itemSize, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array), n = Tr(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
        }
        setXYZW(e, t, r, n, i) {
          return e *= this.itemSize, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array), n = Tr(n, this.array), i = Tr(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = i, this;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return "" !== this.name && (e.name = this.name), this.usage !== nr && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e;
        }
        copyColorsArray() {
          console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
        }
        copyVector2sArray() {
          console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
        }
        copyVector3sArray() {
          console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
        }
        copyVector4sArray() {
          console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
        }
      }
      class Ti extends Mi {
        constructor(e, t, r) {
          super(new Int8Array(e), t, r);
        }
      }
      class Ii extends Mi {
        constructor(e, t, r) {
          super(new Uint8Array(e), t, r);
        }
      }
      class ki extends Mi {
        constructor(e, t, r) {
          super(new Uint8ClampedArray(e), t, r);
        }
      }
      class Di extends Mi {
        constructor(e, t, r) {
          super(new Int16Array(e), t, r);
        }
      }
      class Pi extends Mi {
        constructor(e, t, r) {
          super(new Uint16Array(e), t, r);
        }
      }
      class Bi extends Mi {
        constructor(e, t, r) {
          super(new Int32Array(e), t, r);
        }
      }
      class Ri extends Mi {
        constructor(e, t, r) {
          super(new Uint32Array(e), t, r);
        }
      }
      class Li extends Mi {
        constructor(e, t, r) {
          super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
        }
      }
      class Oi extends Mi {
        constructor(e, t, r) {
          super(new Float32Array(e), t, r);
        }
      }
      class Fi extends Mi {
        constructor(e, t, r) {
          super(new Float64Array(e), t, r);
        }
      }
      let Ui = 0;
      const Ni = new Nn(),
        ji = new ui(),
        zi = new ln(),
        Gi = new hn(),
        Vi = new hn(),
        Qi = new ln();
      class Hi extends mr {
        constructor() {
          super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: Ui++
          }), this.uuid = br(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return Array.isArray(e) ? this.index = new (Pr(e) ? Ri : Pi)(e, 1) : this.index = e, this;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, r = 0) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: r
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
          const r = this.attributes.normal;
          if (void 0 !== r) {
            const t = new Dr().getNormalMatrix(e);
            r.applyNormalMatrix(t), r.needsUpdate = !0;
          }
          const n = this.attributes.tangent;
          return void 0 !== n && (n.transformDirection(e), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
          return Ni.makeRotationFromQuaternion(e), this.applyMatrix4(Ni), this;
        }
        rotateX(e) {
          return Ni.makeRotationX(e), this.applyMatrix4(Ni), this;
        }
        rotateY(e) {
          return Ni.makeRotationY(e), this.applyMatrix4(Ni), this;
        }
        rotateZ(e) {
          return Ni.makeRotationZ(e), this.applyMatrix4(Ni), this;
        }
        translate(e, t, r) {
          return Ni.makeTranslation(e, t, r), this.applyMatrix4(Ni), this;
        }
        scale(e, t, r) {
          return Ni.makeScale(e, t, r), this.applyMatrix4(Ni), this;
        }
        lookAt(e) {
          return ji.lookAt(e), ji.updateMatrix(), this.applyMatrix4(ji.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(zi).negate(), this.translate(zi.x, zi.y, zi.z), this;
        }
        setFromPoints(e) {
          const t = [];
          for (let r = 0, n = e.length; r < n; r++) {
            const n = e[r];
            t.push(n.x, n.y, n.z || 0);
          }
          return this.setAttribute("position", new Oi(t, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new hn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ln(-1 / 0, -1 / 0, -1 / 0), new ln(1 / 0, 1 / 0, 1 / 0));
          if (void 0 !== e) {
            if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, r = t.length; e < r; e++) {
              const r = t[e];
              Gi.setFromBufferAttribute(r), this.morphTargetsRelative ? (Qi.addVectors(this.boundingBox.min, Gi.min), this.boundingBox.expandByPoint(Qi), Qi.addVectors(this.boundingBox.max, Gi.max), this.boundingBox.expandByPoint(Qi)) : (this.boundingBox.expandByPoint(Gi.min), this.boundingBox.expandByPoint(Gi.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new kn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ln(), 1 / 0);
          if (e) {
            const r = this.boundingSphere.center;
            if (Gi.setFromBufferAttribute(e), t) for (let e = 0, r = t.length; e < r; e++) {
              const r = t[e];
              Vi.setFromBufferAttribute(r), this.morphTargetsRelative ? (Qi.addVectors(Gi.min, Vi.min), Gi.expandByPoint(Qi), Qi.addVectors(Gi.max, Vi.max), Gi.expandByPoint(Qi)) : (Gi.expandByPoint(Vi.min), Gi.expandByPoint(Vi.max));
            }
            Gi.getCenter(r);
            let n = 0;
            for (let t = 0, i = e.count; t < i; t++) Qi.fromBufferAttribute(e, t), n = Math.max(n, r.distanceToSquared(Qi));
            if (t) for (let i = 0, s = t.length; i < s; i++) {
              const s = t[i],
                o = this.morphTargetsRelative;
              for (let t = 0, i = s.count; t < i; t++) Qi.fromBufferAttribute(s, t), o && (zi.fromBufferAttribute(e, t), Qi.add(zi)), n = Math.max(n, r.distanceToSquared(Qi));
            }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          const r = e.array,
            n = t.position.array,
            i = t.normal.array,
            s = t.uv.array,
            o = n.length / 3;
          !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Mi(new Float32Array(4 * o), 4));
          const a = this.getAttribute("tangent").array,
            l = [],
            c = [];
          for (let e = 0; e < o; e++) l[e] = new ln(), c[e] = new ln();
          const u = new ln(),
            h = new ln(),
            p = new ln(),
            d = new kr(),
            f = new kr(),
            m = new kr(),
            _ = new ln(),
            g = new ln();
          function v(e, t, r) {
            u.fromArray(n, 3 * e), h.fromArray(n, 3 * t), p.fromArray(n, 3 * r), d.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * r), h.sub(u), p.sub(u), f.sub(d), m.sub(d);
            const i = 1 / (f.x * m.y - m.x * f.y);
            isFinite(i) && (_.copy(h).multiplyScalar(m.y).addScaledVector(p, -f.y).multiplyScalar(i), g.copy(p).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i), l[e].add(_), l[t].add(_), l[r].add(_), c[e].add(g), c[t].add(g), c[r].add(g));
          }
          let A = this.groups;
          0 === A.length && (A = [{
            start: 0,
            count: r.length
          }]);
          for (let e = 0, t = A.length; e < t; ++e) {
            const t = A[e],
              n = t.start;
            for (let e = n, i = n + t.count; e < i; e += 3) v(r[e + 0], r[e + 1], r[e + 2]);
          }
          const b = new ln(),
            y = new ln(),
            x = new ln(),
            w = new ln();
          function E(e) {
            x.fromArray(i, 3 * e), w.copy(x);
            const t = l[e];
            b.copy(t), b.sub(x.multiplyScalar(x.dot(t))).normalize(), y.crossVectors(w, t);
            const r = y.dot(c[e]) < 0 ? -1 : 1;
            a[4 * e] = b.x, a[4 * e + 1] = b.y, a[4 * e + 2] = b.z, a[4 * e + 3] = r;
          }
          for (let e = 0, t = A.length; e < t; ++e) {
            const t = A[e],
              n = t.start;
            for (let e = n, i = n + t.count; e < i; e += 3) E(r[e + 0]), E(r[e + 1]), E(r[e + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let r = this.getAttribute("normal");
            if (void 0 === r) r = new Mi(new Float32Array(3 * t.count), 3), this.setAttribute("normal", r);else for (let e = 0, t = r.count; e < t; e++) r.setXYZ(e, 0, 0, 0);
            const n = new ln(),
              i = new ln(),
              s = new ln(),
              o = new ln(),
              a = new ln(),
              l = new ln(),
              c = new ln(),
              u = new ln();
            if (e) for (let h = 0, p = e.count; h < p; h += 3) {
              const p = e.getX(h + 0),
                d = e.getX(h + 1),
                f = e.getX(h + 2);
              n.fromBufferAttribute(t, p), i.fromBufferAttribute(t, d), s.fromBufferAttribute(t, f), c.subVectors(s, i), u.subVectors(n, i), c.cross(u), o.fromBufferAttribute(r, p), a.fromBufferAttribute(r, d), l.fromBufferAttribute(r, f), o.add(c), a.add(c), l.add(c), r.setXYZ(p, o.x, o.y, o.z), r.setXYZ(d, a.x, a.y, a.z), r.setXYZ(f, l.x, l.y, l.z);
            } else for (let e = 0, o = t.count; e < o; e += 3) n.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, i), u.subVectors(n, i), c.cross(u), r.setXYZ(e + 0, c.x, c.y, c.z), r.setXYZ(e + 1, c.x, c.y, c.z), r.setXYZ(e + 2, c.x, c.y, c.z);
            this.normalizeNormals(), r.needsUpdate = !0;
          }
        }
        merge() {
          return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, r = e.count; t < r; t++) Qi.fromBufferAttribute(e, t), Qi.normalize(), e.setXYZ(t, Qi.x, Qi.y, Qi.z);
        }
        toNonIndexed() {
          function e(e, t) {
            const r = e.array,
              n = e.itemSize,
              i = e.normalized,
              s = new r.constructor(t.length * n);
            let o = 0,
              a = 0;
            for (let i = 0, l = t.length; i < l; i++) {
              o = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * n;
              for (let e = 0; e < n; e++) s[a++] = r[o++];
            }
            return new Mi(s, n, i);
          }
          if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t = new Hi(),
            r = this.index.array,
            n = this.attributes;
          for (const i in n) {
            const s = e(n[i], r);
            t.setAttribute(i, s);
          }
          const i = this.morphAttributes;
          for (const n in i) {
            const s = [],
              o = i[n];
            for (let t = 0, n = o.length; t < n; t++) {
              const n = e(o[t], r);
              s.push(n);
            }
            t.morphAttributes[n] = s;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let e = 0, r = s.length; e < r; e++) {
            const r = s[e];
            t.addGroup(r.start, r.count, r.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
            const t = this.parameters;
            for (const r in t) void 0 !== t[r] && (e[r] = t[r]);
            return e;
          }
          e.data = {
            attributes: {}
          };
          const t = this.index;
          null !== t && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
          });
          const r = this.attributes;
          for (const t in r) {
            const n = r[t];
            e.data.attributes[t] = n.toJSON(e.data);
          }
          const n = {};
          let i = !1;
          for (const t in this.morphAttributes) {
            const r = this.morphAttributes[t],
              s = [];
            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];
              s.push(n.toJSON(e.data));
            }
            s.length > 0 && (n[t] = s, i = !0);
          }
          i && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const o = this.boundingSphere;
          return null !== o && (e.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
          }), e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const r = e.index;
          null !== r && this.setIndex(r.clone(t));
          const n = e.attributes;
          for (const e in n) {
            const r = n[e];
            this.setAttribute(e, r.clone(t));
          }
          const i = e.morphAttributes;
          for (const e in i) {
            const r = [],
              n = i[e];
            for (let e = 0, i = n.length; e < i; e++) r.push(n[e].clone(t));
            this.morphAttributes[e] = r;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const o = e.boundingBox;
          null !== o && (this.boundingBox = o.clone());
          const a = e.boundingSphere;
          return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const Wi = new Nn(),
        qi = new Un(),
        Xi = new kn(),
        Yi = new ln(),
        Ki = new ln(),
        Ji = new ln(),
        Zi = new ln(),
        $i = new ln(),
        es = new ln(),
        ts = new ln(),
        rs = new ln(),
        ns = new ln(),
        is = new kr(),
        ss = new kr(),
        os = new kr(),
        as = new ln(),
        ls = new ln();
      class cs extends ui {
        constructor(e = new Hi(), t = new Ei()) {
          super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const r = e[t[0]];
            if (void 0 !== r) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, t = r.length; e < t; e++) {
                const t = r[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
              }
            }
          }
        }
        raycast(e, t) {
          const r = this.geometry,
            n = this.material,
            i = this.matrixWorld;
          if (void 0 === n) return;
          if (null === r.boundingSphere && r.computeBoundingSphere(), Xi.copy(r.boundingSphere), Xi.applyMatrix4(i), !1 === e.ray.intersectsSphere(Xi)) return;
          if (Wi.copy(i).invert(), qi.copy(e.ray).applyMatrix4(Wi), null !== r.boundingBox && !1 === qi.intersectsBox(r.boundingBox)) return;
          let s;
          const o = r.index,
            a = r.attributes.position,
            l = r.morphAttributes.position,
            c = r.morphTargetsRelative,
            u = r.attributes.uv,
            h = r.attributes.uv2,
            p = r.groups,
            d = r.drawRange;
          if (null !== o) {
            if (Array.isArray(n)) for (let r = 0, i = p.length; r < i; r++) {
              const i = p[r],
                f = n[i.materialIndex];
              for (let r = Math.max(i.start, d.start), n = Math.min(o.count, Math.min(i.start + i.count, d.start + d.count)); r < n; r += 3) {
                const n = o.getX(r),
                  p = o.getX(r + 1),
                  d = o.getX(r + 2);
                s = us(this, f, e, qi, a, l, c, u, h, n, p, d), s && (s.faceIndex = Math.floor(r / 3), s.face.materialIndex = i.materialIndex, t.push(s));
              }
            } else for (let r = Math.max(0, d.start), i = Math.min(o.count, d.start + d.count); r < i; r += 3) {
              const i = o.getX(r),
                p = o.getX(r + 1),
                d = o.getX(r + 2);
              s = us(this, n, e, qi, a, l, c, u, h, i, p, d), s && (s.faceIndex = Math.floor(r / 3), t.push(s));
            }
          } else if (void 0 !== a) if (Array.isArray(n)) for (let r = 0, i = p.length; r < i; r++) {
            const i = p[r],
              o = n[i.materialIndex];
            for (let r = Math.max(i.start, d.start), n = Math.min(a.count, Math.min(i.start + i.count, d.start + d.count)); r < n; r += 3) s = us(this, o, e, qi, a, l, c, u, h, r, r + 1, r + 2), s && (s.faceIndex = Math.floor(r / 3), s.face.materialIndex = i.materialIndex, t.push(s));
          } else for (let r = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); r < i; r += 3) s = us(this, n, e, qi, a, l, c, u, h, r, r + 1, r + 2), s && (s.faceIndex = Math.floor(r / 3), t.push(s));
        }
      }
      function us(e, t, r, n, i, s, o, a, l, c, u, h) {
        Yi.fromBufferAttribute(i, c), Ki.fromBufferAttribute(i, u), Ji.fromBufferAttribute(i, h);
        const p = e.morphTargetInfluences;
        if (s && p) {
          ts.set(0, 0, 0), rs.set(0, 0, 0), ns.set(0, 0, 0);
          for (let e = 0, t = s.length; e < t; e++) {
            const t = p[e],
              r = s[e];
            0 !== t && (Zi.fromBufferAttribute(r, c), $i.fromBufferAttribute(r, u), es.fromBufferAttribute(r, h), o ? (ts.addScaledVector(Zi, t), rs.addScaledVector($i, t), ns.addScaledVector(es, t)) : (ts.addScaledVector(Zi.sub(Yi), t), rs.addScaledVector($i.sub(Ki), t), ns.addScaledVector(es.sub(Ji), t)));
          }
          Yi.add(ts), Ki.add(rs), Ji.add(ns);
        }
        e.isSkinnedMesh && (e.boneTransform(c, Yi), e.boneTransform(u, Ki), e.boneTransform(h, Ji));
        const d = function (e, t, r, n, i, s, o, a) {
          let l;
          if (l = t.side === m ? n.intersectTriangle(o, s, i, !0, a) : n.intersectTriangle(i, s, o, t.side !== _, a), null === l) return null;
          ls.copy(a), ls.applyMatrix4(e.matrixWorld);
          const c = r.ray.origin.distanceTo(ls);
          return c < r.near || c > r.far ? null : {
            distance: c,
            point: ls.clone(),
            object: e
          };
        }(e, t, r, n, Yi, Ki, Ji, as);
        if (d) {
          a && (is.fromBufferAttribute(a, c), ss.fromBufferAttribute(a, u), os.fromBufferAttribute(a, h), d.uv = yi.getUV(as, Yi, Ki, Ji, is, ss, os, new kr())), l && (is.fromBufferAttribute(l, c), ss.fromBufferAttribute(l, u), os.fromBufferAttribute(l, h), d.uv2 = yi.getUV(as, Yi, Ki, Ji, is, ss, os, new kr()));
          const e = {
            a: c,
            b: u,
            c: h,
            normal: new ln(),
            materialIndex: 0
          };
          yi.getNormal(Yi, Ki, Ji, e.normal), d.face = e;
        }
        return d;
      }
      class hs extends Hi {
        constructor(e = 1, t = 1, r = 1, n = 1, i = 1, s = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: s
          };
          const o = this;
          n = Math.floor(n), i = Math.floor(i), s = Math.floor(s);
          const a = [],
            l = [],
            c = [],
            u = [];
          let h = 0,
            p = 0;
          function d(e, t, r, n, i, s, d, f, m, _, g) {
            const v = s / m,
              A = d / _,
              b = s / 2,
              y = d / 2,
              x = f / 2,
              w = m + 1,
              E = _ + 1;
            let S = 0,
              C = 0;
            const M = new ln();
            for (let s = 0; s < E; s++) {
              const o = s * A - y;
              for (let a = 0; a < w; a++) {
                const h = a * v - b;
                M[e] = h * n, M[t] = o * i, M[r] = x, l.push(M.x, M.y, M.z), M[e] = 0, M[t] = 0, M[r] = f > 0 ? 1 : -1, c.push(M.x, M.y, M.z), u.push(a / m), u.push(1 - s / _), S += 1;
              }
            }
            for (let e = 0; e < _; e++) for (let t = 0; t < m; t++) {
              const r = h + t + w * e,
                n = h + t + w * (e + 1),
                i = h + (t + 1) + w * (e + 1),
                s = h + (t + 1) + w * e;
              a.push(r, n, s), a.push(n, i, s), C += 6;
            }
            o.addGroup(p, C, g), p += C, h += S;
          }
          d("z", "y", "x", -1, -1, r, t, e, s, i, 0), d("z", "y", "x", 1, -1, r, t, -e, s, i, 1), d("x", "z", "y", 1, 1, e, r, t, n, s, 2), d("x", "z", "y", 1, -1, e, r, -t, n, s, 3), d("x", "y", "z", 1, -1, e, t, r, n, i, 4), d("x", "y", "z", -1, -1, e, t, -r, n, i, 5), this.setIndex(a), this.setAttribute("position", new Oi(l, 3)), this.setAttribute("normal", new Oi(c, 3)), this.setAttribute("uv", new Oi(u, 2));
        }
        static fromJSON(e) {
          return new hs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function ps(e) {
        const t = {};
        for (const r in e) {
          t[r] = {};
          for (const n in e[r]) {
            const i = e[r][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[r][n] = i.clone() : Array.isArray(i) ? t[r][n] = i.slice() : t[r][n] = i;
          }
        }
        return t;
      }
      function ds(e) {
        const t = {};
        for (let r = 0; r < e.length; r++) {
          const n = ps(e[r]);
          for (const e in n) t[e] = n[e];
        }
        return t;
      }
      const fs = {
        clone: ps,
        merge: ds
      };
      class ms extends wi {
        constructor(e) {
          super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
          }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ps(e.uniforms), this.uniformsGroups = function (e) {
            const t = [];
            for (let r = 0; r < e.length; r++) t.push(e[r].clone());
            return t;
          }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion, t.uniforms = {};
          for (const r in this.uniforms) {
            const n = this.uniforms[r].value;
            n && n.isTexture ? t.uniforms[r] = {
              type: "t",
              value: n.toJSON(e).uuid
            } : n && n.isColor ? t.uniforms[r] = {
              type: "c",
              value: n.getHex()
            } : n && n.isVector2 ? t.uniforms[r] = {
              type: "v2",
              value: n.toArray()
            } : n && n.isVector3 ? t.uniforms[r] = {
              type: "v3",
              value: n.toArray()
            } : n && n.isVector4 ? t.uniforms[r] = {
              type: "v4",
              value: n.toArray()
            } : n && n.isMatrix3 ? t.uniforms[r] = {
              type: "m3",
              value: n.toArray()
            } : n && n.isMatrix4 ? t.uniforms[r] = {
              type: "m4",
              value: n.toArray()
            } : t.uniforms[r] = {
              value: n
            };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
          const r = {};
          for (const e in this.extensions) !0 === this.extensions[e] && (r[e] = !0);
          return Object.keys(r).length > 0 && (t.extensions = r), t;
        }
      }
      class _s extends ui {
        constructor() {
          super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Nn(), this.projectionMatrix = new Nn(), this.projectionMatrixInverse = new Nn();
        }
        copy(e, t) {
          return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class gs extends _s {
        constructor(e = 50, t = 1, r = .1, n = 2e3) {
          super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
          const t = .5 * this.getFilmHeight() / e;
          this.fov = 2 * Ar * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(.5 * vr * this.fov);
          return .5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
          return 2 * Ar * Math.atan(Math.tan(.5 * vr * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, r, n, i, s) {
          this.aspect = e / t, null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = s, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(.5 * vr * this.fov) / this.zoom,
            r = 2 * t,
            n = this.aspect * r,
            i = -.5 * n;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const e = s.fullWidth,
              o = s.fullHeight;
            i += s.offsetX * n / e, t -= s.offsetY * r / o, n *= s.width / e, r *= s.height / o;
          }
          const o = this.filmOffset;
          0 !== o && (i += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + n, t, t - r, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
      }
      const vs = 90;
      class As extends ui {
        constructor(e, t, r) {
          super(), this.type = "CubeCamera", this.renderTarget = r;
          const n = new gs(vs, 1, e, t);
          n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new ln(1, 0, 0)), this.add(n);
          const i = new gs(vs, 1, e, t);
          i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ln(-1, 0, 0)), this.add(i);
          const s = new gs(vs, 1, e, t);
          s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new ln(0, 1, 0)), this.add(s);
          const o = new gs(vs, 1, e, t);
          o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new ln(0, -1, 0)), this.add(o);
          const a = new gs(vs, 1, e, t);
          a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new ln(0, 0, 1)), this.add(a);
          const l = new gs(vs, 1, e, t);
          l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ln(0, 0, -1)), this.add(l);
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const r = this.renderTarget,
            [n, i, s, o, a, l] = this.children,
            c = e.getRenderTarget(),
            u = e.toneMapping,
            h = e.xr.enabled;
          e.toneMapping = K, e.xr.enabled = !1;
          const p = r.texture.generateMipmaps;
          r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, n), e.setRenderTarget(r, 1), e.render(t, i), e.setRenderTarget(r, 2), e.render(t, s), e.setRenderTarget(r, 3), e.render(t, o), e.setRenderTarget(r, 4), e.render(t, a), r.texture.generateMipmaps = p, e.setRenderTarget(r, 5), e.render(t, l), e.setRenderTarget(c), e.toneMapping = u, e.xr.enabled = h, r.texture.needsPMREMUpdate = !0;
        }
      }
      class bs extends Zr {
        constructor(e, t, r, n, i, s, o, a, l, c) {
          super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : ne, r, n, i, s, o, a, l, c), this.isCubeTexture = !0, this.flipY = !1;
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class ys extends en {
        constructor(e, t = {}) {
          super(e, e, t), this.isWebGLCubeRenderTarget = !0;
          const r = {
              width: e,
              height: e,
              depth: 1
            },
            n = [r, r, r, r, r, r];
          this.texture = new bs(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : _e;
        }
        fromEquirectangularTexture(e, t) {
          this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
          const r = {
              tEquirect: {
                value: null
              }
            },
            n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            s = new hs(5, 5, 5),
            o = new ms({
              name: "CubemapFromEquirect",
              uniforms: ps(r),
              vertexShader: n,
              fragmentShader: i,
              side: m,
              blending: g
            });
          o.uniforms.tEquirect.value = t;
          const a = new cs(s, o),
            l = t.minFilter;
          return t.minFilter === Ae && (t.minFilter = _e), new As(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t, r, n) {
          const i = e.getRenderTarget();
          for (let i = 0; i < 6; i++) e.setRenderTarget(this, i), e.clear(t, r, n);
          e.setRenderTarget(i);
        }
      }
      const xs = new ln(),
        ws = new ln(),
        Es = new Dr();
      class Ss {
        constructor(e = new ln(1, 0, 0), t = 0) {
          this.isPlane = !0, this.normal = e, this.constant = t;
        }
        set(e, t) {
          return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, r, n) {
          return this.normal.set(e, t, r), this.constant = n, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, r) {
          const n = xs.subVectors(r, t).cross(ws.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
        }
        intersectLine(e, t) {
          const r = e.delta(xs),
            n = this.normal.dot(r);
          if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const i = -(e.start.dot(this.normal) + this.constant) / n;
          return i < 0 || i > 1 ? null : t.copy(r).multiplyScalar(i).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            r = this.distanceToPoint(e.end);
          return t < 0 && r > 0 || r < 0 && t > 0;
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const r = t || Es.getNormalMatrix(e),
            n = this.coplanarPoint(xs).applyMatrix4(e),
            i = this.normal.applyMatrix3(r).normalize();
          return this.constant = -n.dot(i), this;
        }
        translate(e) {
          return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Cs = new kn(),
        Ms = new ln();
      class Ts {
        constructor(e = new Ss(), t = new Ss(), r = new Ss(), n = new Ss(), i = new Ss(), s = new Ss()) {
          this.planes = [e, t, r, n, i, s];
        }
        set(e, t, r, n, i, s) {
          const o = this.planes;
          return o[0].copy(e), o[1].copy(t), o[2].copy(r), o[3].copy(n), o[4].copy(i), o[5].copy(s), this;
        }
        copy(e) {
          const t = this.planes;
          for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            r = e.elements,
            n = r[0],
            i = r[1],
            s = r[2],
            o = r[3],
            a = r[4],
            l = r[5],
            c = r[6],
            u = r[7],
            h = r[8],
            p = r[9],
            d = r[10],
            f = r[11],
            m = r[12],
            _ = r[13],
            g = r[14],
            v = r[15];
          return t[0].setComponents(o - n, u - a, f - h, v - m).normalize(), t[1].setComponents(o + n, u + a, f + h, v + m).normalize(), t[2].setComponents(o + i, u + l, f + p, v + _).normalize(), t[3].setComponents(o - i, u - l, f - p, v - _).normalize(), t[4].setComponents(o - s, u - c, f - d, v - g).normalize(), t[5].setComponents(o + s, u + c, f + d, v + g).normalize(), this;
        }
        intersectsObject(e) {
          const t = e.geometry;
          return null === t.boundingSphere && t.computeBoundingSphere(), Cs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Cs);
        }
        intersectsSprite(e) {
          return Cs.center.set(0, 0, 0), Cs.radius = .7071067811865476, Cs.applyMatrix4(e.matrixWorld), this.intersectsSphere(Cs);
        }
        intersectsSphere(e) {
          const t = this.planes,
            r = e.center,
            n = -e.radius;
          for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(r) < n) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let r = 0; r < 6; r++) {
            const n = t[r];
            if (Ms.x = n.normal.x > 0 ? e.max.x : e.min.x, Ms.y = n.normal.y > 0 ? e.max.y : e.min.y, Ms.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Ms) < 0) return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Is() {
        let e = null,
          t = !1,
          r = null,
          n = null;
        function i(t, s) {
          r(t, s), n = e.requestAnimationFrame(i);
        }
        return {
          start: function () {
            !0 !== t && null !== r && (n = e.requestAnimationFrame(i), t = !0);
          },
          stop: function () {
            e.cancelAnimationFrame(n), t = !1;
          },
          setAnimationLoop: function (e) {
            r = e;
          },
          setContext: function (t) {
            e = t;
          }
        };
      }
      function ks(e, t) {
        const r = t.isWebGL2,
          n = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), n.get(e);
          },
          remove: function (t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            const r = n.get(t);
            r && (e.deleteBuffer(r.buffer), n.delete(t));
          },
          update: function (t, i) {
            if (t.isGLBufferAttribute) {
              const e = n.get(t);
              return void ((!e || e.version < t.version) && n.set(t, {
                buffer: t.buffer,
                type: t.type,
                bytesPerElement: t.elementSize,
                version: t.version
              }));
            }
            t.isInterleavedBufferAttribute && (t = t.data);
            const s = n.get(t);
            void 0 === s ? n.set(t, function (t, n) {
              const i = t.array,
                s = t.usage,
                o = e.createBuffer();
              let a;
              if (e.bindBuffer(n, o), e.bufferData(n, i, s), t.onUploadCallback(), i instanceof Float32Array) a = 5126;else if (i instanceof Uint16Array) {
                if (t.isFloat16BufferAttribute) {
                  if (!r) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                  a = 5131;
                } else a = 5123;
              } else if (i instanceof Int16Array) a = 5122;else if (i instanceof Uint32Array) a = 5125;else if (i instanceof Int32Array) a = 5124;else if (i instanceof Int8Array) a = 5120;else if (i instanceof Uint8Array) a = 5121;else {
                if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                a = 5121;
              }
              return {
                buffer: o,
                type: a,
                bytesPerElement: i.BYTES_PER_ELEMENT,
                version: t.version
              };
            }(t, i)) : s.version < t.version && (function (t, n, i) {
              const s = n.array,
                o = n.updateRange;
              e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, s) : (r ? e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1);
            }(s.buffer, t, i), s.version = t.version);
          }
        };
      }
      class Ds extends Hi {
        constructor(e = 1, t = 1, r = 1, n = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: n
          };
          const i = e / 2,
            s = t / 2,
            o = Math.floor(r),
            a = Math.floor(n),
            l = o + 1,
            c = a + 1,
            u = e / o,
            h = t / a,
            p = [],
            d = [],
            f = [],
            m = [];
          for (let e = 0; e < c; e++) {
            const t = e * h - s;
            for (let r = 0; r < l; r++) {
              const n = r * u - i;
              d.push(n, -t, 0), f.push(0, 0, 1), m.push(r / o), m.push(1 - e / a);
            }
          }
          for (let e = 0; e < a; e++) for (let t = 0; t < o; t++) {
            const r = t + l * e,
              n = t + l * (e + 1),
              i = t + 1 + l * (e + 1),
              s = t + 1 + l * e;
            p.push(r, n, s), p.push(n, i, s);
          }
          this.setIndex(p), this.setAttribute("position", new Oi(d, 3)), this.setAttribute("normal", new Oi(f, 3)), this.setAttribute("uv", new Oi(m, 2));
        }
        static fromJSON(e) {
          return new Ds(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const Ps = {
          alphamap_fragment: "#ifdef USE_ALPHAMAP\n\t#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\n\tdiffuseColor.a *= 1.0-texture2D( alphaMap, vUv ).g;\n\t#else\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\t#endif\n#endif",
          alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
          iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}",
          envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 transformDirection1( in vec3 dir, in mat4 matrix ) {\n\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\t}\n\tmat4 rotationMatrix(vec3 axis, float angle) {\n\t\taxis = normalize(axis);\n\t\tfloat s = sin(angle);\n\t\tfloat c = cos(angle);\n\t\tfloat oc = 1.0 - c;\n\t\treturn mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n\t\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n\t\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t\t\t\t0.0,                                0.0,                                0.0,                                1.0);\n\t}\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform float envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",
          envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tworldNormal = transformDirection1(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
          envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",
          lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
          lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\ndiffuseColor.a = min(max(diffuseColor.a, 0.), 1.);\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex: "#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
          transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#else\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
          uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nuniform bool flipX;\nuniform bool flipY;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;\n    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
        },
        Bs = {
          common: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            map: {
              value: null
            },
            uvTransform: {
              value: new Dr()
            },
            uv2Transform: {
              value: new Dr()
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            }
          },
          specularmap: {
            specularMap: {
              value: null
            }
          },
          envmap: {
            envMap: {
              value: null
            },
            envMapRotation: {
              value: 0
            },
            flipEnvMap: {
              value: -1
            },
            reflectivity: {
              value: 1
            },
            ior: {
              value: 1.5
            },
            refractionRatio: {
              value: .98
            }
          },
          aomap: {
            aoMap: {
              value: null
            },
            aoMapIntensity: {
              value: 1
            }
          },
          lightmap: {
            lightMap: {
              value: null
            },
            lightMapIntensity: {
              value: 1
            }
          },
          emissivemap: {
            emissiveMap: {
              value: null
            }
          },
          bumpmap: {
            bumpMap: {
              value: null
            },
            bumpScale: {
              value: 1
            }
          },
          normalmap: {
            normalMap: {
              value: null
            },
            normalScale: {
              value: new kr(1, 1)
            }
          },
          displacementmap: {
            displacementMap: {
              value: null
            },
            displacementScale: {
              value: 1
            },
            displacementBias: {
              value: 0
            }
          },
          roughnessmap: {
            roughnessMap: {
              value: null
            }
          },
          metalnessmap: {
            metalnessMap: {
              value: null
            }
          },
          gradientmap: {
            gradientMap: {
              value: null
            }
          },
          fog: {
            fogDensity: {
              value: 25e-5
            },
            fogNear: {
              value: 1
            },
            fogFar: {
              value: 2e3
            },
            fogColor: {
              value: new Wr(16777215)
            }
          },
          lights: {
            ambientLightColor: {
              value: []
            },
            lightProbe: {
              value: []
            },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {}
              }
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            directionalShadowMap: {
              value: []
            },
            directionalShadowMatrix: {
              value: []
            },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
              }
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            spotLightMap: {
              value: []
            },
            spotShadowMap: {
              value: []
            },
            spotLightMatrix: {
              value: []
            },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
              }
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
              }
            },
            pointShadowMap: {
              value: []
            },
            pointShadowMatrix: {
              value: []
            },
            hemisphereLights: {
              value: [],
              properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
              }
            },
            rectAreaLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                width: {},
                height: {}
              }
            },
            ltc_1: {
              value: null
            },
            ltc_2: {
              value: null
            }
          },
          points: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            size: {
              value: 1
            },
            scale: {
              value: 1
            },
            map: {
              value: null
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            },
            uvTransform: {
              value: new Dr()
            }
          },
          sprite: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            center: {
              value: new kr(.5, .5)
            },
            rotation: {
              value: 0
            },
            map: {
              value: null
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            },
            uvTransform: {
              value: new Dr()
            }
          }
        },
        Rs = {
          basic: {
            uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.fog]),
            vertexShader: Ps.meshbasic_vert,
            fragmentShader: Ps.meshbasic_frag
          },
          lambert: {
            uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, Bs.lights, {
              emissive: {
                value: new Wr(0)
              }
            }]),
            vertexShader: Ps.meshlambert_vert,
            fragmentShader: Ps.meshlambert_frag
          },
          phong: {
            uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, Bs.lights, {
              emissive: {
                value: new Wr(0)
              },
              specular: {
                value: new Wr(1118481)
              },
              shininess: {
                value: 30
              }
            }]),
            vertexShader: Ps.meshphong_vert,
            fragmentShader: Ps.meshphong_frag
          },
          standard: {
            uniforms: ds([Bs.common, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.roughnessmap, Bs.metalnessmap, Bs.fog, Bs.lights, {
              emissive: {
                value: new Wr(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }]),
            vertexShader: Ps.meshphysical_vert,
            fragmentShader: Ps.meshphysical_frag
          },
          toon: {
            uniforms: ds([Bs.common, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.gradientmap, Bs.fog, Bs.lights, {
              emissive: {
                value: new Wr(0)
              }
            }]),
            vertexShader: Ps.meshtoon_vert,
            fragmentShader: Ps.meshtoon_frag
          },
          matcap: {
            uniforms: ds([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, {
              matcap: {
                value: null
              }
            }]),
            vertexShader: Ps.meshmatcap_vert,
            fragmentShader: Ps.meshmatcap_frag
          },
          points: {
            uniforms: ds([Bs.points, Bs.fog]),
            vertexShader: Ps.points_vert,
            fragmentShader: Ps.points_frag
          },
          dashed: {
            uniforms: ds([Bs.common, Bs.fog, {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }]),
            vertexShader: Ps.linedashed_vert,
            fragmentShader: Ps.linedashed_frag
          },
          depth: {
            uniforms: ds([Bs.common, Bs.displacementmap]),
            vertexShader: Ps.depth_vert,
            fragmentShader: Ps.depth_frag
          },
          normal: {
            uniforms: ds([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, {
              opacity: {
                value: 1
              }
            }]),
            vertexShader: Ps.meshnormal_vert,
            fragmentShader: Ps.meshnormal_frag
          },
          sprite: {
            uniforms: ds([Bs.sprite, Bs.fog]),
            vertexShader: Ps.sprite_vert,
            fragmentShader: Ps.sprite_frag
          },
          background: {
            uniforms: {
              uvTransform: {
                value: new Dr()
              },
              t2D: {
                value: null
              },
              flipX: {
                value: !1
              },
              flipY: {
                value: !1
              }
            },
            vertexShader: Ps.background_vert,
            fragmentShader: Ps.background_frag
          },
          cube: {
            uniforms: ds([Bs.envmap, {
              opacity: {
                value: 1
              }
            }]),
            vertexShader: Ps.cube_vert,
            fragmentShader: Ps.cube_frag
          },
          equirect: {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: Ps.equirect_vert,
            fragmentShader: Ps.equirect_frag
          },
          distanceRGBA: {
            uniforms: ds([Bs.common, Bs.displacementmap, {
              referencePosition: {
                value: new ln()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }]),
            vertexShader: Ps.distanceRGBA_vert,
            fragmentShader: Ps.distanceRGBA_frag
          },
          shadow: {
            uniforms: ds([Bs.lights, Bs.fog, {
              color: {
                value: new Wr(0)
              },
              opacity: {
                value: 1
              }
            }]),
            vertexShader: Ps.shadow_vert,
            fragmentShader: Ps.shadow_frag
          }
        };
      function Ls(e, t, r, n, i, s) {
        const o = new Wr(0);
        let a,
          l,
          c = !0 === i ? 0 : 1,
          u = null,
          h = 0,
          p = null;
        function d(e, t) {
          r.buffers.color.setClear(e.r, e.g, e.b, t, s);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (e, t = 1) {
            o.set(e), c = t, d(o, c);
          },
          getClearAlpha: function () {
            return c;
          },
          setClearAlpha: function (e) {
            c = e, d(o, c);
          },
          getPlaneMesh: function () {
            return a;
          },
          getBoxMesh: function () {
            return l;
          },
          getBoxMesh2: function () {
            return void 0 === l && (l = new cs(new hs(1, 1, 1), new ms({
              name: "BackgroundCubeMaterial",
              uniforms: ps(Rs.cube.uniforms),
              vertexShader: Rs.cube.vertexShader,
              fragmentShader: Rs.cube.fragmentShader,
              side: m,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, r) {
              this.matrixWorld.copyPosition(r.matrixWorld);
            }, Object.defineProperty(l.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              }
            }), n.update(l)), l;
          },
          render: function (r, i) {
            let s = !1,
              _ = !0 === i.isScene ? i.background : null;
            _ && _.isTexture && (_ = t.get(_));
            const g = e.xr,
              v = g.getSession && g.getSession();
            v && "additive" === v.environmentBlendMode && (_ = null), null === _ ? d(o, c) : _ && _.isColor && (d(_, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), _ && (_.isCubeTexture || _.mapping === ae) ? (void 0 === l && (l = new cs(new hs(1, 1, 1), new ms({
              name: "BackgroundCubeMaterial",
              uniforms: ps(Rs.cube.uniforms),
              vertexShader: Rs.cube.vertexShader,
              fragmentShader: Rs.cube.fragmentShader,
              side: m,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, r) {
              this.matrixWorld.copyPosition(r.matrixWorld);
            }, Object.defineProperty(l.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              }
            }), n.update(l)), l.material.uniforms.envMap.value = _, l.material.uniforms.envMapRotation.value = _.rotation || 0, l.material.uniforms.flipEnvMap.value = _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1, u === _ && h === _.version && p === e.toneMapping || (l.material.needsUpdate = !0, u = _, h = _.version, p = e.toneMapping), l.layers.enableAll(), r.unshift(l, l.geometry, l.material, 0, 0, null)) : _ && _.isTexture && (void 0 === a && (a = new cs(new Ds(2, 2), new ms({
              name: "BackgroundMaterial",
              uniforms: ps(Rs.background.uniforms),
              vertexShader: Rs.background.vertexShader,
              fragmentShader: Rs.background.fragmentShader,
              side: f,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              }
            }), n.update(a)), a.material.uniforms.t2D.value = _, a.material.uniforms.flipX.value = _.userData.flipX || !1, a.material.uniforms.flipY.value = _.userData.flipY || !1, !0 === _.matrixAutoUpdate && _.updateMatrix(), a.material.uniforms.uvTransform.value.copy(_.matrix), u === _ && h === _.version && p === e.toneMapping || (a.material.needsUpdate = !0, u = _, h = _.version, p = e.toneMapping), a.layers.enableAll(), r.unshift(a, a.geometry, a.material, 0, 0, null));
          }
        };
      }
      function Os(e, t, r, n) {
        const i = e.getParameter(34921),
          s = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
          o = n.isWebGL2 || null !== s,
          a = {},
          l = d(null);
        let c = l,
          u = !1;
        function h(t) {
          return n.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
        }
        function p(t) {
          return n.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t);
        }
        function d(e) {
          const t = [],
            r = [],
            n = [];
          for (let e = 0; e < i; e++) t[e] = 0, r[e] = 0, n[e] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: r,
            attributeDivisors: n,
            object: e,
            attributes: {},
            index: null
          };
        }
        function f() {
          const e = c.newAttributes;
          for (let t = 0, r = e.length; t < r; t++) e[t] = 0;
        }
        function m(e) {
          _(e, 0);
        }
        function _(r, i) {
          const s = c.newAttributes,
            o = c.enabledAttributes,
            a = c.attributeDivisors;
          s[r] = 1, 0 === o[r] && (e.enableVertexAttribArray(r), o[r] = 1), a[r] !== i && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, i), a[r] = i);
        }
        function g() {
          const t = c.newAttributes,
            r = c.enabledAttributes;
          for (let n = 0, i = r.length; n < i; n++) r[n] !== t[n] && (e.disableVertexAttribArray(n), r[n] = 0);
        }
        function v(t, r, i, s, o, a) {
          !0 !== n.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, r, i, s, o, a) : e.vertexAttribIPointer(t, r, i, o, a);
        }
        function A() {
          b(), u = !0, c !== l && (c = l, h(c.object));
        }
        function b() {
          l.geometry = null, l.program = null, l.wireframe = !1;
        }
        return {
          setup: function (i, l, p, A, b) {
            let y = !1;
            if (o) {
              const t = function (t, r, i) {
                const o = !0 === i.wireframe;
                let l = a[t.id];
                void 0 === l && (l = {}, a[t.id] = l);
                let c = l[r.id];
                void 0 === c && (c = {}, l[r.id] = c);
                let u = c[o];
                return void 0 === u && (u = d(n.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[o] = u), u;
              }(A, p, l);
              c !== t && (c = t, h(c.object)), y = function (e, t, r, n) {
                const i = c.attributes,
                  s = t.attributes;
                let o = 0;
                const a = r.getAttributes();
                for (const t in a) if (a[t].location >= 0) {
                  const r = i[t];
                  let n = s[t];
                  if (void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor)), void 0 === r) return !0;
                  if (r.attribute !== n) return !0;
                  if (n && r.data !== n.data) return !0;
                  o++;
                }
                return c.attributesNum !== o || c.index !== n;
              }(i, A, p, b), y && function (e, t, r, n) {
                const i = {},
                  s = t.attributes;
                let o = 0;
                const a = r.getAttributes();
                for (const t in a) if (a[t].location >= 0) {
                  let r = s[t];
                  void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor));
                  const n = {};
                  n.attribute = r, r && r.data && (n.data = r.data), i[t] = n, o++;
                }
                c.attributes = i, c.attributesNum = o, c.index = n;
              }(i, A, p, b);
            } else {
              const e = !0 === l.wireframe;
              c.geometry === A.id && c.program === p.id && c.wireframe === e || (c.geometry = A.id, c.program = p.id, c.wireframe = e, y = !0);
            }
            null !== b && r.update(b, 34963), (y || u) && (u = !1, function (i, s, o, a) {
              if (!1 === n.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
              f();
              const l = a.attributes,
                c = o.getAttributes(),
                u = s.defaultAttributeValues;
              for (const t in c) {
                const n = c[t];
                if (n.location >= 0) {
                  let s = l[t];
                  if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (s = i.instanceColor)), void 0 !== s) {
                    const t = s.normalized,
                      o = s.itemSize,
                      l = r.get(s);
                    if (void 0 === l) continue;
                    const c = l.buffer,
                      u = l.type,
                      h = l.bytesPerElement;
                    if (s.isInterleavedBufferAttribute) {
                      const r = s.data,
                        l = r.stride,
                        p = s.offset;
                      if (r.isInstancedInterleavedBuffer) {
                        for (let e = 0; e < n.locationSize; e++) _(n.location + e, r.meshPerAttribute);
                        !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = r.meshPerAttribute * r.count);
                      } else for (let e = 0; e < n.locationSize; e++) m(n.location + e);
                      e.bindBuffer(34962, c);
                      for (let e = 0; e < n.locationSize; e++) v(n.location + e, o / n.locationSize, u, t, l * h, (p + o / n.locationSize * e) * h);
                    } else {
                      if (s.isInstancedBufferAttribute) {
                        for (let e = 0; e < n.locationSize; e++) _(n.location + e, s.meshPerAttribute);
                        !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count);
                      } else for (let e = 0; e < n.locationSize; e++) m(n.location + e);
                      e.bindBuffer(34962, c);
                      for (let e = 0; e < n.locationSize; e++) v(n.location + e, o / n.locationSize, u, t, o * h, o / n.locationSize * e * h);
                    }
                  } else if (void 0 !== u) {
                    const r = u[t];
                    if (void 0 !== r) switch (r.length) {
                      case 2:
                        e.vertexAttrib2fv(n.location, r);
                        break;
                      case 3:
                        e.vertexAttrib3fv(n.location, r);
                        break;
                      case 4:
                        e.vertexAttrib4fv(n.location, r);
                        break;
                      default:
                        e.vertexAttrib1fv(n.location, r);
                    }
                  }
                }
              }
              g();
            }(i, l, p, A), null !== b && e.bindBuffer(34963, r.get(b).buffer));
          },
          reset: A,
          resetDefaultState: b,
          dispose: function () {
            A();
            for (const e in a) {
              const t = a[e];
              for (const e in t) {
                const r = t[e];
                for (const e in r) p(r[e].object), delete r[e];
                delete t[e];
              }
              delete a[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 === a[e.id]) return;
            const t = a[e.id];
            for (const e in t) {
              const r = t[e];
              for (const e in r) p(r[e].object), delete r[e];
              delete t[e];
            }
            delete a[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in a) {
              const r = a[t];
              if (void 0 === r[e.id]) continue;
              const n = r[e.id];
              for (const e in n) p(n[e].object), delete n[e];
              delete r[e.id];
            }
          },
          initAttributes: f,
          enableAttribute: m,
          disableUnusedAttributes: g
        };
      }
      function Fs(e, t, r, n) {
        const i = n.isWebGL2;
        let s;
        this.setMode = function (e) {
          s = e;
        }, this.render = function (t, n) {
          e.drawArrays(s, t, n), r.update(n, s, 1);
        }, this.renderInstances = function (n, o, a) {
          if (0 === a) return;
          let l, c;
          if (i) l = e, c = "drawArraysInstanced";else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          l[c](s, n, o, a), r.update(o, s, a);
        };
      }
      function Us(e, t, r) {
        let n;
        function i(t) {
          if ("highp" === t) {
            if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            t = "mediump";
          }
          return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
        }
        const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
        let o = void 0 !== r.precision ? r.precision : "highp";
        const a = i(o);
        a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
        const l = s || t.has("WEBGL_draw_buffers"),
          c = !0 === r.logarithmicDepthBuffer,
          u = e.getParameter(34930),
          h = e.getParameter(35660),
          p = e.getParameter(3379),
          d = e.getParameter(34076),
          f = e.getParameter(34921),
          m = e.getParameter(36347),
          _ = e.getParameter(36348),
          g = e.getParameter(36349),
          v = h > 0,
          A = s || t.has("OES_texture_float");
        return {
          isWebGL2: s,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== n) return n;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
              const r = t.get("EXT_texture_filter_anisotropic");
              n = e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else n = 0;
            return n;
          },
          getMaxPrecision: i,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: p,
          maxCubemapSize: d,
          maxAttributes: f,
          maxVertexUniforms: m,
          maxVaryings: _,
          maxFragmentUniforms: g,
          vertexTextures: v,
          floatFragmentTextures: A,
          floatVertexTextures: v && A,
          maxSamples: s ? e.getParameter(36183) : 0
        };
      }
      function Ns(e) {
        const t = this;
        let r = null,
          n = 0,
          i = !1,
          s = !1;
        const o = new Ss(),
          a = new Dr(),
          l = {
            value: null,
            needsUpdate: !1
          };
        function c() {
          l.value !== r && (l.value = r, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
        }
        function u(e, r, n, i) {
          const s = null !== e ? e.length : 0;
          let c = null;
          if (0 !== s) {
            if (c = l.value, !0 !== i || null === c) {
              const t = n + 4 * s,
                i = r.matrixWorldInverse;
              a.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t));
              for (let t = 0, r = n; t !== s; ++t, r += 4) o.copy(e[t]).applyMatrix4(i, a), o.normal.toArray(c, r), c[r + 3] = o.constant;
            }
            l.value = c, l.needsUpdate = !0;
          }
          return t.numPlanes = s, t.numIntersection = 0, c;
        }
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) {
          const o = 0 !== e.length || t || 0 !== n || i;
          return i = t, r = u(e, s, 0), n = e.length, o;
        }, this.beginShadows = function () {
          s = !0, u(null);
        }, this.endShadows = function () {
          s = !1, c();
        }, this.setState = function (t, o, a) {
          const h = t.clippingPlanes,
            p = t.clipIntersection,
            d = t.clipShadows,
            f = e.get(t);
          if (!i || null === h || 0 === h.length || s && !d) s ? u(null) : c();else {
            const e = s ? 0 : n,
              t = 4 * e;
            let i = f.clippingState || null;
            l.value = i, i = u(h, o, t, a);
            for (let e = 0; e !== t; ++e) i[e] = r[e];
            f.clippingState = i, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += e;
          }
        };
      }
      function js(e) {
        let t = new WeakMap();
        function r(e, t) {
          return t === se ? e.mapping = ne : t === oe && (e.mapping = ie), e;
        }
        function n(e) {
          const r = e.target;
          r.removeEventListener("dispose", n);
          const i = t.get(r);
          void 0 !== i && (t.delete(r), i.dispose());
        }
        return {
          get: function (i) {
            if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
              const s = i.mapping;
              if (s === se || s === oe) {
                if (t.has(i)) {
                  const e = t.get(i).texture;
                  return e.rotation = i.rotation, r(e, i.mapping);
                }
                {
                  const s = i.image;
                  if (s && s.height > 0) {
                    const o = new ys(s.height / 2);
                    return o.fromEquirectangularTexture(e, i), o.texture.rotation = i.rotation, t.set(i, o), i.addEventListener("dispose", n), r(o.texture, i.mapping);
                  }
                  return null;
                }
              }
            }
            return i;
          },
          dispose: function () {
            t = new WeakMap();
          }
        };
      }
      Rs.physical = {
        uniforms: ds([Rs.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new kr(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          iridescence: {
            value: 0
          },
          iridescenceMap: {
            value: null
          },
          iridescenceIOR: {
            value: 1.3
          },
          iridescenceThicknessMinimum: {
            value: 100
          },
          iridescenceThicknessMaximum: {
            value: 400
          },
          iridescenceThicknessMap: {
            value: null
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Wr(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenRoughness: {
            value: 1
          },
          sheenRoughnessMap: {
            value: null
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new kr()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Wr(0)
          },
          specularIntensity: {
            value: 1
          },
          specularIntensityMap: {
            value: null
          },
          specularColor: {
            value: new Wr(1, 1, 1)
          },
          specularColorMap: {
            value: null
          }
        }]),
        vertexShader: Ps.meshphysical_vert,
        fragmentShader: Ps.meshphysical_frag
      };
      class zs extends _s {
        constructor(e = -1, t = 1, r = 1, n = -1, i = .1, s = 2e3) {
          super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = n, this.near = i, this.far = s, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, r, n, i, s) {
          null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = s, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            r = (this.right + this.left) / 2,
            n = (this.top + this.bottom) / 2;
          let i = r - e,
            s = r + e,
            o = n + t,
            a = n - t;
          if (null !== this.view && this.view.enabled) {
            const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
              t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            i += e * this.view.offsetX, s = i + e * this.view.width, o -= t * this.view.offsetY, a = o - t * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t;
        }
      }
      const Gs = [.125, .215, .35, .446, .526, .582],
        Vs = new zs(),
        Qs = new Wr();
      let Hs = null;
      const Ws = (1 + Math.sqrt(5)) / 2,
        qs = 1 / Ws,
        Xs = [new ln(1, 1, 1), new ln(-1, 1, 1), new ln(1, 1, -1), new ln(-1, 1, -1), new ln(0, Ws, qs), new ln(0, Ws, -qs), new ln(qs, 0, Ws), new ln(-qs, 0, Ws), new ln(Ws, qs, 0), new ln(-Ws, qs, 0)];
      class Ys {
        constructor(e) {
          this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, r = .1, n = 100) {
          Hs = this._renderer.getRenderTarget(), this._setSize(256);
          const i = this._allocateTargets();
          return i.depthBuffer = !0, this._sceneToCubeUV(e, r, n, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i;
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial && (this._cubemapMaterial = $s(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial && (this._equirectMaterial = Zs(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Hs), e.scissorTest = !1, Js(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === ne || e.mapping === ie ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Hs = this._renderer.getRenderTarget();
          const r = t || this._allocateTargets();
          return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            r = {
              magFilter: _e,
              minFilter: _e,
              generateMipmaps: !1,
              type: Te,
              format: Re,
              encoding: kt,
              depthBuffer: !1
            },
            n = Ks(e, t, r);
          if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Ks(e, t, r);
            const {
              _lodMax: n
            } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas
            } = function (e) {
              const t = [],
                r = [],
                n = [];
              let i = e;
              const s = e - 4 + 1 + Gs.length;
              for (let o = 0; o < s; o++) {
                const s = Math.pow(2, i);
                r.push(s);
                let a = 1 / s;
                o > e - 4 ? a = Gs[o - e + 4 - 1] : 0 === o && (a = 0), n.push(a);
                const l = 1 / (s - 2),
                  c = -l,
                  u = 1 + l,
                  h = [c, c, u, c, u, u, c, c, u, u, c, u],
                  p = 6,
                  d = 6,
                  f = 3,
                  m = 2,
                  _ = 1,
                  g = new Float32Array(f * d * p),
                  v = new Float32Array(m * d * p),
                  A = new Float32Array(_ * d * p);
                for (let e = 0; e < p; e++) {
                  const t = e % 3 * 2 / 3 - 1,
                    r = e > 2 ? 0 : -1,
                    n = [t, r, 0, t + 2 / 3, r, 0, t + 2 / 3, r + 1, 0, t, r, 0, t + 2 / 3, r + 1, 0, t, r + 1, 0];
                  g.set(n, f * d * e), v.set(h, m * d * e);
                  const i = [e, e, e, e, e, e];
                  A.set(i, _ * d * e);
                }
                const b = new Hi();
                b.setAttribute("position", new Mi(g, f)), b.setAttribute("uv", new Mi(v, m)), b.setAttribute("faceIndex", new Mi(A, _)), t.push(b), i > 4 && i--;
              }
              return {
                lodPlanes: t,
                sizeLods: r,
                sigmas: n
              };
            }(n)), this._blurMaterial = function (e, t, r) {
              const n = new Float32Array(20),
                i = new ln(0, 1, 0);
              return new ms({
                name: "SphericalGaussianBlur",
                defines: {
                  n: 20,
                  CUBEUV_TEXEL_WIDTH: 1 / t,
                  CUBEUV_TEXEL_HEIGHT: 1 / r,
                  CUBEUV_MAX_MIP: `${e}.0`
                },
                uniforms: {
                  envMap: {
                    value: null
                  },
                  samples: {
                    value: 1
                  },
                  weights: {
                    value: n
                  },
                  latitudinal: {
                    value: !1
                  },
                  dTheta: {
                    value: 0
                  },
                  mipInt: {
                    value: 0
                  },
                  poleAxis: {
                    value: i
                  }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: g,
                depthTest: !1,
                depthWrite: !1
              });
            }(n, e, t);
          }
          return n;
        }
        _compileMaterial(e) {
          const t = new cs(this._lodPlanes[0], e);
          this._renderer.compile(t, Vs);
        }
        _sceneToCubeUV(e, t, r, n) {
          const i = new gs(90, 1, t, r),
            s = [1, -1, 1, 1, 1, 1],
            o = [1, 1, 1, -1, -1, -1],
            a = this._renderer,
            l = a.autoClear,
            c = a.toneMapping;
          a.getClearColor(Qs), a.toneMapping = K, a.autoClear = !1;
          const u = new Ei({
              name: "PMREM.Background",
              side: m,
              depthWrite: !1,
              depthTest: !1
            }),
            h = new cs(new hs(), u);
          let p = !1;
          const d = e.background;
          d ? d.isColor && (u.color.copy(d), e.background = null, p = !0) : (u.color.copy(Qs), p = !0);
          for (let t = 0; t < 6; t++) {
            const r = t % 3;
            0 === r ? (i.up.set(0, s[t], 0), i.lookAt(o[t], 0, 0)) : 1 === r ? (i.up.set(0, 0, s[t]), i.lookAt(0, o[t], 0)) : (i.up.set(0, s[t], 0), i.lookAt(0, 0, o[t]));
            const l = this._cubeSize;
            Js(n, r * l, t > 2 ? l : 0, l, l), a.setRenderTarget(n), p && a.render(h, i), a.render(e, i);
          }
          h.geometry.dispose(), h.material.dispose(), a.toneMapping = c, a.autoClear = l, e.background = d;
        }
        _textureToCubeUV(e, t) {
          const r = this._renderer,
            n = e.mapping === ne || e.mapping === ie;
          n ? (null === this._cubemapMaterial && (this._cubemapMaterial = $s()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Zs());
          const i = n ? this._cubemapMaterial : this._equirectMaterial,
            s = new cs(this._lodPlanes[0], i);
          i.uniforms.envMap.value = e;
          const o = this._cubeSize;
          Js(t, 0, 0, 3 * o, 2 * o), r.setRenderTarget(t), r.render(s, Vs);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            r = t.autoClear;
          t.autoClear = !1;
          for (let t = 1; t < this._lodPlanes.length; t++) {
            const r = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
              n = Xs[(t - 1) % Xs.length];
            this._blur(e, t - 1, t, r, n);
          }
          t.autoClear = r;
        }
        _blur(e, t, r, n, i) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, r, n, "latitudinal", i), this._halfBlur(s, e, r, r, n, "longitudinal", i);
        }
        _halfBlur(e, t, r, n, i, s, o) {
          const a = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
          const c = new cs(this._lodPlanes[n], l),
            u = l.uniforms,
            h = this._sizeLods[r] - 1,
            p = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
            d = i / p,
            f = isFinite(i) ? 1 + Math.floor(3 * d) : 20;
          f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
          const m = [];
          let _ = 0;
          for (let e = 0; e < 20; ++e) {
            const t = e / d,
              r = Math.exp(-t * t / 2);
            m.push(r), 0 === e ? _ += r : e < f && (_ += 2 * r);
          }
          for (let e = 0; e < m.length; e++) m[e] = m[e] / _;
          u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o);
          const {
            _lodMax: g
          } = this;
          u.dTheta.value = p, u.mipInt.value = g - r;
          const v = this._sizeLods[n];
          Js(t, 3 * v * (n > g - 4 ? n - g + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), a.setRenderTarget(t), a.render(c, Vs);
        }
      }
      function Ks(e, t, r) {
        const n = new en(e, t, r);
        return n.texture.mapping = ae, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
      }
      function Js(e, t, r, n, i) {
        e.viewport.set(t, r, n, i), e.scissor.set(t, r, n, i);
      }
      function Zs() {
        return new ms({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: g,
          depthTest: !1,
          depthWrite: !1
        });
      }
      function $s() {
        return new ms({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: g,
          depthTest: !1,
          depthWrite: !1
        });
      }
      function eo(e) {
        let t = new WeakMap(),
          r = null;
        function n(e) {
          const r = e.target;
          r.removeEventListener("dispose", n);
          const i = t.get(r);
          void 0 !== i && (t.delete(r), i.dispose());
        }
        return {
          get: function (i) {
            if (i && i.isTexture) {
              const s = i.mapping,
                o = s === se || s === oe,
                a = s === ne || s === ie;
              if (o || a) {
                if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                  i.needsPMREMUpdate = !1;
                  let n = t.get(i);
                  return null === r && (r = new Ys(e)), n = o ? r.fromEquirectangular(i, n) : r.fromCubemap(i, n), t.set(i, n), n.texture;
                }
                if (t.has(i)) return t.get(i).texture;
                {
                  const s = i.image;
                  if (o && s && s.height > 0 || a && s && function (e) {
                    let t = 0;
                    for (let r = 0; r < 6; r++) void 0 !== e[r] && t++;
                    return 6 === t;
                  }(s)) {
                    null === r && (r = new Ys(e));
                    const s = o ? r.fromEquirectangular(i) : r.fromCubemap(i);
                    return t.set(i, s), i.addEventListener("dispose", n), s.texture;
                  }
                  return null;
                }
              }
            }
            return i;
          },
          dispose: function () {
            t = new WeakMap(), null !== r && (r.dispose(), r = null);
          }
        };
      }
      function to(e) {
        const t = {};
        function r(r) {
          if (void 0 !== t[r]) return t[r];
          let n;
          switch (r) {
            case "WEBGL_depth_texture":
              n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n = e.getExtension(r);
          }
          return t[r] = n, n;
        }
        return {
          has: function (e) {
            return null !== r(e);
          },
          init: function (e) {
            e.isWebGL2 ? r("EXT_color_buffer_float") : (r("WEBGL_depth_texture"), r("OES_texture_float"), r("OES_texture_half_float"), r("OES_texture_half_float_linear"), r("OES_standard_derivatives"), r("OES_element_index_uint"), r("OES_vertex_array_object"), r("ANGLE_instanced_arrays")), r("OES_texture_float_linear"), r("EXT_color_buffer_half_float"), r("WEBGL_multisampled_render_to_texture");
          },
          get: function (e) {
            const t = r(e);
            return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t;
          }
        };
      }
      function ro(e, t, r, n) {
        const i = {},
          s = new WeakMap();
        function o(e) {
          const a = e.target;
          null !== a.index && t.remove(a.index);
          for (const e in a.attributes) t.remove(a.attributes[e]);
          a.removeEventListener("dispose", o), delete i[a.id];
          const l = s.get(a);
          l && (t.remove(l), s.delete(a)), n.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, r.memory.geometries--;
        }
        function a(e) {
          const r = [],
            n = e.index,
            i = e.attributes.position;
          let o = 0;
          if (null !== n) {
            const e = n.array;
            o = n.version;
            for (let t = 0, n = e.length; t < n; t += 3) {
              const n = e[t + 0],
                i = e[t + 1],
                s = e[t + 2];
              r.push(n, i, i, s, s, n);
            }
          } else {
            const e = i.array;
            o = i.version;
            for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
              const e = t + 0,
                n = t + 1,
                i = t + 2;
              r.push(e, n, n, i, i, e);
            }
          }
          const a = new (Pr(r) ? Ri : Pi)(r, 1);
          a.version = o;
          const l = s.get(e);
          l && t.remove(l), s.set(e, a);
        }
        return {
          get: function (e, t) {
            return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, r.memory.geometries++), t;
          },
          update: function (e) {
            const r = e.attributes;
            for (const e in r) t.update(r[e], 34962);
            const n = e.morphAttributes;
            for (const e in n) {
              const r = n[e];
              for (let e = 0, n = r.length; e < n; e++) t.update(r[e], 34962);
            }
          },
          getWireframeAttribute: function (e) {
            const t = s.get(e);
            if (t) {
              const r = e.index;
              null !== r && t.version < r.version && a(e);
            } else a(e);
            return s.get(e);
          }
        };
      }
      function no(e, t, r, n) {
        const i = n.isWebGL2;
        let s, o, a;
        this.setMode = function (e) {
          s = e;
        }, this.setIndex = function (e) {
          o = e.type, a = e.bytesPerElement;
        }, this.render = function (t, n) {
          e.drawElements(s, n, o, t * a), r.update(n, s, 1);
        }, this.renderInstances = function (n, l, c) {
          if (0 === c) return;
          let u, h;
          if (i) u = e, h = "drawElementsInstanced";else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          u[h](s, l, o, n * a, c), r.update(l, s, c);
        };
      }
      function io(e) {
        const t = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        return {
          memory: {
            geometries: 0,
            textures: 0
          },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
          },
          update: function (e, r, n) {
            switch (t.calls++, r) {
              case 4:
                t.triangles += n * (e / 3);
                break;
              case 1:
                t.lines += n * (e / 2);
                break;
              case 3:
                t.lines += n * (e - 1);
                break;
              case 2:
                t.lines += n * e;
                break;
              case 0:
                t.points += n * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", r);
            }
          }
        };
      }
      function so(e, t) {
        return e[0] - t[0];
      }
      function oo(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function ao(e, t, r) {
        const n = {},
          i = new Float32Array(8),
          s = new WeakMap(),
          o = new $r(),
          a = [];
        for (let e = 0; e < 8; e++) a[e] = [e, 0];
        return {
          update: function (l, c, u, h) {
            const p = l.morphTargetInfluences;
            if (!0 === t.isWebGL2) {
              const n = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                i = void 0 !== n ? n.length : 0;
              let a = s.get(c);
              if (void 0 === a || a.count !== i) {
                void 0 !== a && a.texture.dispose();
                const e = void 0 !== c.morphAttributes.position,
                  r = void 0 !== c.morphAttributes.normal,
                  n = void 0 !== c.morphAttributes.color,
                  l = c.morphAttributes.position || [],
                  u = c.morphAttributes.normal || [],
                  h = c.morphAttributes.color || [];
                let p = 0;
                !0 === e && (p = 1), !0 === r && (p = 2), !0 === n && (p = 3);
                let d = c.attributes.position.count * p,
                  f = 1;
                d > t.maxTextureSize && (f = Math.ceil(d / t.maxTextureSize), d = t.maxTextureSize);
                const m = new Float32Array(d * f * 4 * i),
                  _ = new tn(m, d, f, i);
                _.type = Me, _.needsUpdate = !0;
                const g = 4 * p;
                for (let t = 0; t < i; t++) {
                  const i = l[t],
                    s = u[t],
                    a = h[t],
                    c = d * f * 4 * t;
                  for (let t = 0; t < i.count; t++) {
                    const l = t * g;
                    !0 === e && (o.fromBufferAttribute(i, t), m[c + l + 0] = o.x, m[c + l + 1] = o.y, m[c + l + 2] = o.z, m[c + l + 3] = 0), !0 === r && (o.fromBufferAttribute(s, t), m[c + l + 4] = o.x, m[c + l + 5] = o.y, m[c + l + 6] = o.z, m[c + l + 7] = 0), !0 === n && (o.fromBufferAttribute(a, t), m[c + l + 8] = o.x, m[c + l + 9] = o.y, m[c + l + 10] = o.z, m[c + l + 11] = 4 === a.itemSize ? o.w : 1);
                  }
                }
                a = {
                  count: i,
                  texture: _,
                  size: new kr(d, f)
                }, s.set(c, a), c.addEventListener("dispose", function e() {
                  _.dispose(), s.delete(c), c.removeEventListener("dispose", e);
                });
              }
              let l = 0;
              for (let e = 0; e < p.length; e++) l += p[e];
              const u = c.morphTargetsRelative ? 1 : 1 - l;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", p), h.getUniforms().setValue(e, "morphTargetsTexture", a.texture, r), h.getUniforms().setValue(e, "morphTargetsTextureSize", a.size);
            } else {
              const t = void 0 === p ? 0 : p.length;
              let r = n[c.id];
              if (void 0 === r || r.length !== t) {
                r = [];
                for (let e = 0; e < t; e++) r[e] = [e, 0];
                n[c.id] = r;
              }
              for (let e = 0; e < t; e++) {
                const t = r[e];
                t[0] = e, t[1] = p[e];
              }
              r.sort(oo);
              for (let e = 0; e < 8; e++) e < t && r[e][1] ? (a[e][0] = r[e][0], a[e][1] = r[e][1]) : (a[e][0] = Number.MAX_SAFE_INTEGER, a[e][1] = 0);
              a.sort(so);
              const s = c.morphAttributes.position,
                o = c.morphAttributes.normal;
              let l = 0;
              for (let e = 0; e < 8; e++) {
                const t = a[e],
                  r = t[0],
                  n = t[1];
                r !== Number.MAX_SAFE_INTEGER && n ? (s && c.getAttribute("morphTarget" + e) !== s[r] && c.setAttribute("morphTarget" + e, s[r]), o && c.getAttribute("morphNormal" + e) !== o[r] && c.setAttribute("morphNormal" + e, o[r]), i[e] = n, l += n) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), o && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), i[e] = 0);
              }
              const u = c.morphTargetsRelative ? 1 : 1 - l;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", i);
            }
          }
        };
      }
      function lo(e, t, r, n) {
        let i = new WeakMap();
        function s(e) {
          const t = e.target;
          t.removeEventListener("dispose", s), r.remove(t.instanceMatrix), null !== t.instanceColor && r.remove(t.instanceColor);
        }
        return {
          update: function (e) {
            const o = n.render.frame,
              a = e.geometry,
              l = t.get(e, a);
            return i.get(l) !== o && (t.update(l), i.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), r.update(e.instanceMatrix, 34962), null !== e.instanceColor && r.update(e.instanceColor, 34962)), l;
          },
          dispose: function () {
            i = new WeakMap();
          }
        };
      }
      const co = new Zr(),
        uo = new tn(),
        ho = new nn(),
        po = new bs(),
        fo = [],
        mo = [],
        _o = new Float32Array(16),
        go = new Float32Array(9),
        vo = new Float32Array(4);
      function Ao(e, t, r) {
        const n = e[0];
        if (n <= 0 || n > 0) return e;
        const i = t * r;
        let s = fo[i];
        if (void 0 === s && (s = new Float32Array(i), fo[i] = s), 0 !== t) {
          n.toArray(s, 0);
          for (let n = 1, i = 0; n !== t; ++n) i += r, e[n].toArray(s, i);
        }
        return s;
      }
      function bo(e, t) {
        if (e.length !== t.length) return !1;
        for (let r = 0, n = e.length; r < n; r++) if (e[r] !== t[r]) return !1;
        return !0;
      }
      function yo(e, t) {
        for (let r = 0, n = t.length; r < n; r++) e[r] = t[r];
      }
      function xo(e, t) {
        let r = mo[t];
        void 0 === r && (r = new Int32Array(t), mo[t] = r);
        for (let n = 0; n !== t; ++n) r[n] = e.allocateTextureUnit();
        return r;
      }
      function wo(e, t) {
        const r = this.cache;
        r[0] !== t && (e.uniform1f(this.addr, t), r[0] = t);
      }
      function Eo(e, t) {
        const r = this.cache;
        if (void 0 !== t.x) r[0] === t.x && r[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), r[0] = t.x, r[1] = t.y);else {
          if (bo(r, t)) return;
          e.uniform2fv(this.addr, t), yo(r, t);
        }
      }
      function So(e, t) {
        const r = this.cache;
        if (void 0 !== t.x) r[0] === t.x && r[1] === t.y && r[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), r[0] = t.x, r[1] = t.y, r[2] = t.z);else if (void 0 !== t.r) r[0] === t.r && r[1] === t.g && r[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), r[0] = t.r, r[1] = t.g, r[2] = t.b);else {
          if (bo(r, t)) return;
          e.uniform3fv(this.addr, t), yo(r, t);
        }
      }
      function Co(e, t) {
        const r = this.cache;
        if (void 0 !== t.x) r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = t.w);else {
          if (bo(r, t)) return;
          e.uniform4fv(this.addr, t), yo(r, t);
        }
      }
      function Mo(e, t) {
        const r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (bo(r, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), yo(r, t);
        } else {
          if (bo(r, n)) return;
          vo.set(n), e.uniformMatrix2fv(this.addr, !1, vo), yo(r, n);
        }
      }
      function To(e, t) {
        const r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (bo(r, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), yo(r, t);
        } else {
          if (bo(r, n)) return;
          go.set(n), e.uniformMatrix3fv(this.addr, !1, go), yo(r, n);
        }
      }
      function Io(e, t) {
        const r = this.cache,
          n = t.elements;
        if (void 0 === n) {
          if (bo(r, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), yo(r, t);
        } else {
          if (bo(r, n)) return;
          _o.set(n), e.uniformMatrix4fv(this.addr, !1, _o), yo(r, n);
        }
      }
      function ko(e, t) {
        const r = this.cache;
        r[0] !== t && (e.uniform1i(this.addr, t), r[0] = t);
      }
      function Do(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform2iv(this.addr, t), yo(r, t));
      }
      function Po(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform3iv(this.addr, t), yo(r, t));
      }
      function Bo(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform4iv(this.addr, t), yo(r, t));
      }
      function Ro(e, t) {
        const r = this.cache;
        r[0] !== t && (e.uniform1ui(this.addr, t), r[0] = t);
      }
      function Lo(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform2uiv(this.addr, t), yo(r, t));
      }
      function Oo(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform3uiv(this.addr, t), yo(r, t));
      }
      function Fo(e, t) {
        const r = this.cache;
        bo(r, t) || (e.uniform4uiv(this.addr, t), yo(r, t));
      }
      function Uo(e, t, r) {
        const n = this.cache,
          i = r.allocateTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTexture2D(t || co, i);
      }
      function No(e, t, r) {
        const n = this.cache,
          i = r.allocateTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTexture3D(t || ho, i);
      }
      function jo(e, t, r) {
        const n = this.cache,
          i = r.allocateTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTextureCube(t || po, i);
      }
      function zo(e, t, r) {
        const n = this.cache,
          i = r.allocateTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTexture2DArray(t || uo, i);
      }
      function Go(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function Vo(e, t) {
        const r = Ao(t, this.size, 2);
        e.uniform2fv(this.addr, r);
      }
      function Qo(e, t) {
        const r = Ao(t, this.size, 3);
        e.uniform3fv(this.addr, r);
      }
      function Ho(e, t) {
        const r = Ao(t, this.size, 4);
        e.uniform4fv(this.addr, r);
      }
      function Wo(e, t) {
        const r = Ao(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, r);
      }
      function qo(e, t) {
        const r = Ao(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, r);
      }
      function Xo(e, t) {
        const r = Ao(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, r);
      }
      function Yo(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function Ko(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function Jo(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function Zo(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function $o(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function ea(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function ta(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function ra(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function na(e, t, r) {
        const n = t.length,
          i = xo(r, n);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== n; ++e) r.setTexture2D(t[e] || co, i[e]);
      }
      function ia(e, t, r) {
        const n = t.length,
          i = xo(r, n);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== n; ++e) r.setTexture3D(t[e] || ho, i[e]);
      }
      function sa(e, t, r) {
        const n = t.length,
          i = xo(r, n);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== n; ++e) r.setTextureCube(t[e] || po, i[e]);
      }
      function oa(e, t, r) {
        const n = t.length,
          i = xo(r, n);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== n; ++e) r.setTexture2DArray(t[e] || uo, i[e]);
      }
      class aa {
        constructor(e, t, r) {
          this.id = e, this.addr = r, this.cache = [], this.setValue = function (e) {
            switch (e) {
              case 5126:
                return wo;
              case 35664:
                return Eo;
              case 35665:
                return So;
              case 35666:
                return Co;
              case 35674:
                return Mo;
              case 35675:
                return To;
              case 35676:
                return Io;
              case 5124:
              case 35670:
                return ko;
              case 35667:
              case 35671:
                return Do;
              case 35668:
              case 35672:
                return Po;
              case 35669:
              case 35673:
                return Bo;
              case 5125:
                return Ro;
              case 36294:
                return Lo;
              case 36295:
                return Oo;
              case 36296:
                return Fo;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Uo;
              case 35679:
              case 36299:
              case 36307:
                return No;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return jo;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return zo;
            }
          }(t.type);
        }
      }
      class la {
        constructor(e, t, r) {
          this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = function (e) {
            switch (e) {
              case 5126:
                return Go;
              case 35664:
                return Vo;
              case 35665:
                return Qo;
              case 35666:
                return Ho;
              case 35674:
                return Wo;
              case 35675:
                return qo;
              case 35676:
                return Xo;
              case 5124:
              case 35670:
                return Yo;
              case 35667:
              case 35671:
                return Ko;
              case 35668:
              case 35672:
                return Jo;
              case 35669:
              case 35673:
                return Zo;
              case 5125:
                return $o;
              case 36294:
                return ea;
              case 36295:
                return ta;
              case 36296:
                return ra;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return na;
              case 35679:
              case 36299:
              case 36307:
                return ia;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return sa;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return oa;
            }
          }(t.type);
        }
      }
      class ca {
        constructor(e) {
          this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, r) {
          const n = this.seq;
          for (let i = 0, s = n.length; i !== s; ++i) {
            const s = n[i];
            s.setValue(e, t[s.id], r);
          }
        }
      }
      const ua = /(\w+)(\])?(\[|\.)?/g;
      function ha(e, t) {
        e.seq.push(t), e.map[t.id] = t;
      }
      function pa(e, t, r) {
        const n = e.name,
          i = n.length;
        for (ua.lastIndex = 0;;) {
          const s = ua.exec(n),
            o = ua.lastIndex;
          let a = s[1];
          const l = "]" === s[2],
            c = s[3];
          if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === i) {
            ha(r, void 0 === c ? new aa(a, e, t) : new la(a, e, t));
            break;
          }
          {
            let e = r.map[a];
            void 0 === e && (e = new ca(a), ha(r, e)), r = e;
          }
        }
      }
      class da {
        constructor(e, t) {
          this.seq = [], this.map = {};
          const r = e.getProgramParameter(t, 35718);
          for (let n = 0; n < r; ++n) {
            const r = e.getActiveUniform(t, n);
            pa(r, e.getUniformLocation(t, r.name), this);
          }
        }
        setValue(e, t, r, n) {
          const i = this.map[t];
          void 0 !== i && i.setValue(e, r, n);
        }
        setOptional(e, t, r) {
          const n = t[r];
          void 0 !== n && this.setValue(e, r, n);
        }
        static upload(e, t, r, n) {
          for (let i = 0, s = t.length; i !== s; ++i) {
            const s = t[i],
              o = r[s.id];
            !1 !== o.needsUpdate && s.setValue(e, o.value, n);
          }
        }
        static seqWithValue(e, t) {
          const r = [];
          for (let n = 0, i = e.length; n !== i; ++n) {
            const i = e[n];
            i.id in t && r.push(i);
          }
          return r;
        }
      }
      function fa(e, t, r) {
        const n = e.createShader(t);
        return e.shaderSource(n, r), e.compileShader(n), n;
      }
      let ma = 0;
      function _a(e) {
        switch (e) {
          case kt:
            return ["Linear", "( value )"];
          case Dt:
            return ["sRGB", "( value )"];
          case Bt:
            return ["RGBM", "( value, 16.0 )"];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"];
        }
      }
      function ga(e, t, r) {
        const n = e.getShaderParameter(t, 35713),
          i = e.getShaderInfoLog(t).trim();
        if (n && "" === i) return "";
        const s = /ERROR: 0:(\d+)/.exec(i);
        if (s) {
          const n = parseInt(s[1]);
          return r.toUpperCase() + "\n\n" + i + "\n\n" + function (e, t) {
            const r = e.split("\n"),
              n = [],
              i = Math.max(t - 6, 0),
              s = Math.min(t + 6, r.length);
            for (let e = i; e < s; e++) {
              const i = e + 1;
              n.push(`${i === t ? ">" : " "} ${i}: ${r[e]}`);
            }
            return n.join("\n");
          }(e.getShaderSource(t), n);
        }
        return i;
      }
      function va(e, t) {
        const r = _a(t);
        return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }";
      }
      function Aa(e, t) {
        const r = _a(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }";
      }
      function ba(e, t) {
        let r;
        switch (t) {
          case J:
            r = "Linear";
            break;
          case Z:
            r = "Reinhard";
            break;
          case $:
            r = "OptimizedCineon";
            break;
          case ee:
            r = "ACESFilmic";
            break;
          case te:
            r = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), r = "Linear";
        }
        return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }";
      }
      function ya(e) {
        return "" !== e;
      }
      function xa(e, t) {
        const r = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, r).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function wa(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      const Ea = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Sa(e) {
        return e.replace(Ea, Ca);
      }
      function Ca(e, t) {
        const r = Ps[t];
        if (void 0 === r) throw new Error("Can not resolve #include <" + t + ">");
        return Sa(r);
      }
      const Ma = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Ta(e) {
        return e.replace(Ma, Ia);
      }
      function Ia(e, t, r, n) {
        let i = "";
        for (let e = parseInt(t); e < parseInt(r); e++) i += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        return i;
      }
      function ka(e) {
        let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t;
      }
      function Da(e, t, r, n) {
        const i = e.getContext(),
          s = r.defines;
        let o = r.vertexShader,
          a = r.fragmentShader;
        const l = function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === p ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === d && (t = "SHADOWMAP_TYPE_VSM"), t;
          }(r),
          c = function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap) switch (e.envMapMode) {
              case ne:
              case ie:
                t = "ENVMAP_TYPE_CUBE";
                break;
              case ae:
                t = "ENVMAP_TYPE_CUBE_UV";
            }
            return t;
          }(r),
          u = function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            return e.envMap && e.envMapMode === ie && (t = "ENVMAP_MODE_REFRACTION"), t;
          }(r),
          f = function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap) switch (e.combine) {
              case q:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case X:
                t = "ENVMAP_BLENDING_MIX";
                break;
              case Y:
                t = "ENVMAP_BLENDING_ADD";
            }
            return t;
          }(r),
          m = function (e) {
            const t = e.envMapCubeUVHeight;
            if (null === t) return null;
            const r = Math.log2(t) - 2,
              n = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, r), 112)),
              texelHeight: n,
              maxMip: r
            };
          }(r),
          _ = r.isWebGL2 ? "" : function (e) {
            return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ya).join("\n");
          }(r),
          g = function (e) {
            const t = [];
            for (const r in e) {
              const n = e[r];
              !1 !== n && t.push("#define " + r + " " + n);
            }
            return t.join("\n");
          }(s),
          v = i.createProgram();
        let A,
          b,
          y = r.glslVersion ? "#version " + r.glslVersion + "\n" : "";
        r.isRawShaderMaterial ? (A = [g].filter(ya).join("\n"), A.length > 0 && (A += "\n"), b = [_, g].filter(ya).join("\n"), b.length > 0 && (b += "\n")) : (A = [ka(r), "#define SHADER_NAME " + r.shaderName, g, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + u : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.morphColors && r.isWebGL2 ? "#define USE_MORPHCOLORS" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + r.morphTextureStride : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_COUNT " + r.morphTargetsCount : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ya).join("\n"), b = [_, ka(r), "#define SHADER_NAME " + r.shaderName, g, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + c : "", r.envMap ? "#define " + u : "", r.envMap ? "#define " + f : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoat ? "#define USE_CLEARCOAT" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.iridescence ? "#define USE_IRIDESCENCE" : "", r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.alphaTest ? "#define USE_ALPHATEST" : "", r.sheen ? "#define USE_SHEEN" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", r.toneMapping !== K ? "#define TONE_MAPPING" : "", r.toneMapping !== K ? Ps.tonemapping_pars_fragment : "", r.toneMapping !== K ? ba("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.opaque ? "#define OPAQUE" : "", Ps.encodings_pars_fragment, Aa("linearToOutputTexel", r.outputEncoding), r.transmissionSamplerMapEncoding ? va("transmissionSamplerMapTexelToLinear", r.transmissionSamplerMapEncoding) : "", r.useDepthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(ya).join("\n")), o = Sa(o), o = xa(o, r), o = wa(o, r), a = Sa(a), a = xa(a, r), a = wa(a, r), o = Ta(o), a = Ta(a), r.isWebGL2 && !0 !== r.isRawShaderMaterial && (y = "#version 300 es\n", A = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A, b = ["#define varying in", r.glslVersion === dr ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", r.glslVersion === dr ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
        const x = y + b + a,
          w = fa(i, 35633, y + A + o),
          E = fa(i, 35632, x);
        if (i.attachShader(v, w), i.attachShader(v, E), void 0 !== r.index0AttributeName ? i.bindAttribLocation(v, 0, r.index0AttributeName) : !0 === r.morphTargets && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v), e.debug.checkShaderErrors) {
          const e = i.getProgramInfoLog(v).trim(),
            t = i.getShaderInfoLog(w).trim(),
            r = i.getShaderInfoLog(E).trim();
          let n = !0,
            s = !0;
          if (!1 === i.getProgramParameter(v, 35714)) {
            n = !1;
            const t = ga(i, w, "vertex"),
              r = ga(i, E, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + r);
          } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== r || (s = !1);
          s && (this.diagnostics = {
            runnable: n,
            programLog: e,
            vertexShader: {
              log: t,
              prefix: A
            },
            fragmentShader: {
              log: r,
              prefix: b
            }
          });
        }
        let S, C;
        return i.deleteShader(w), i.deleteShader(E), this.getUniforms = function () {
          return void 0 === S && (S = new da(i, v)), S;
        }, this.getAttributes = function () {
          return void 0 === C && (C = function (e, t) {
            const r = {},
              n = e.getProgramParameter(t, 35721);
            for (let i = 0; i < n; i++) {
              const n = e.getActiveAttrib(t, i),
                s = n.name;
              let o = 1;
              35674 === n.type && (o = 2), 35675 === n.type && (o = 3), 35676 === n.type && (o = 4), r[s] = {
                type: n.type,
                location: e.getAttribLocation(t, s),
                locationSize: o
              };
            }
            return r;
          }(i, v)), C;
        }, this.destroy = function () {
          n.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0;
        }, this.name = r.shaderName, this.id = ma++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = w, this.fragmentShader = E, this;
      }
      let Pa = 0;
      class Ba {
        constructor() {
          this.shaderCache = new Map(), this.materialCache = new Map();
        }
        update(e) {
          const t = e.vertexShader,
            r = e.fragmentShader,
            n = this._getShaderStage(t),
            i = this._getShaderStage(r),
            s = this._getShaderCacheForMaterial(e);
          return !1 === s.has(n) && (s.add(n), n.usedTimes++), !1 === s.has(i) && (s.add(i), i.usedTimes++), this;
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let r = t.get(e);
          return void 0 === r && (r = new Set(), t.set(e, r)), r;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let r = t.get(e);
          return void 0 === r && (r = new Ra(e), t.set(e, r)), r;
        }
      }
      class Ra {
        constructor(e) {
          this.id = Pa++, this.code = e, this.usedTimes = 0;
        }
      }
      function La(e, t, r, n, i, s, o) {
        const a = new Kn(),
          l = new Ba(),
          c = [],
          u = i.isWebGL2,
          h = i.logarithmicDepthBuffer,
          p = i.vertexTextures;
        let d = i.precision;
        const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        return {
          getParameters: function (s, a, c, g, A) {
            const b = g.fog,
              y = A.geometry,
              x = s.isMeshStandardMaterial ? g.environment : null,
              w = (s.isMeshStandardMaterial ? r : t).get(s.envMap || x),
              E = w && w.mapping === ae ? w.image.height : null,
              S = f[s.type];
            null !== s.precision && (d = i.getMaxPrecision(s.precision), d !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", d, "instead."));
            const C = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
              M = void 0 !== C ? C.length : 0;
            let T,
              I,
              k,
              D,
              P = 0;
            if (void 0 !== y.morphAttributes.position && (P = 1), void 0 !== y.morphAttributes.normal && (P = 2), void 0 !== y.morphAttributes.color && (P = 3), S) {
              const e = Rs[S];
              T = e.vertexShader, I = e.fragmentShader;
            } else T = s.vertexShader, I = s.fragmentShader, l.update(s), k = l.getVertexShaderID(s), D = l.getFragmentShaderID(s);
            const B = e.getRenderTarget(),
              R = e.userData && e.userData.transmissionRenderTarget,
              L = s.alphaTest > 0,
              O = s.clearcoat > 0,
              F = s.iridescence > 0;
            return {
              isWebGL2: u,
              shaderID: S,
              shaderName: s.type,
              vertexShader: T,
              fragmentShader: I,
              defines: s.defines,
              customVertexShaderID: k,
              customFragmentShaderID: D,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: d,
              instancing: !0 === A.isInstancedMesh,
              instancingColor: !0 === A.isInstancedMesh && null !== A.instanceColor,
              supportsVertexTextures: p,
              outputEncoding: null === B ? e.outputEncoding : !0 === B.isXRRenderTarget || B.texture.encoding !== Dt ? B.texture.encoding : kt,
              map: !!s.map,
              matcap: !!s.matcap,
              envMap: !!w,
              envMapMode: w && w.mapping,
              envMapCubeUVHeight: E,
              lightMap: !!s.lightMap,
              aoMap: !!s.aoMap,
              emissiveMap: !!s.emissiveMap,
              bumpMap: !!s.bumpMap,
              normalMap: !!s.normalMap,
              objectSpaceNormalMap: s.normalMapType === Ft,
              tangentSpaceNormalMap: s.normalMapType === Ot,
              decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === Dt,
              clearcoat: O,
              clearcoatMap: O && !!s.clearcoatMap,
              clearcoatRoughnessMap: O && !!s.clearcoatRoughnessMap,
              clearcoatNormalMap: O && !!s.clearcoatNormalMap,
              iridescence: F,
              iridescenceMap: F && !!s.iridescenceMap,
              iridescenceThicknessMap: F && !!s.iridescenceThicknessMap,
              displacementMap: !!s.displacementMap,
              roughnessMap: !!s.roughnessMap,
              metalnessMap: !!s.metalnessMap,
              specularMap: !!s.specularMap,
              specularIntensityMap: !!s.specularIntensityMap,
              specularColorMap: !!s.specularColorMap,
              opaque: !1 === s.transparent && s.blending === v && !(s.transmission > 0),
              alphaMap: !!s.alphaMap,
              alphaTest: L,
              gradientMap: !!s.gradientMap,
              sheen: s.sheen > 0,
              sheenColorMap: !!s.sheenColorMap,
              sheenRoughnessMap: !!s.sheenRoughnessMap,
              transmission: s.transmission > 0,
              transmissionMap: !!s.transmissionMap,
              transmissionSamplerMapEncoding: R ? R.texture.encoding : kt,
              thicknessMap: !!s.thicknessMap,
              combine: s.combine,
              vertexTangents: !!s.normalMap && !!y.attributes.tangent,
              vertexColors: s.vertexColors,
              vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
              vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
              uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
              fog: !!b,
              useFog: !0 === s.fog,
              fogExp2: b && b.isFogExp2,
              flatShading: !!s.flatShading,
              sizeAttenuation: s.sizeAttenuation,
              logarithmicDepthBuffer: h,
              skinning: !0 === A.isSkinnedMesh,
              morphTargets: void 0 !== y.morphAttributes.position,
              morphNormals: void 0 !== y.morphAttributes.normal,
              morphColors: void 0 !== y.morphAttributes.color,
              morphTargetsCount: M,
              morphTextureStride: P,
              numDirLights: a.directional.length,
              numPointLights: a.point.length,
              numSpotLights: a.spot.length,
              numSpotLightMaps: a.spotLightMap.length,
              numRectAreaLights: a.rectArea.length,
              numHemiLights: a.hemi.length,
              numDirLightShadows: a.directionalShadowMap.length,
              numPointLightShadows: a.pointShadowMap.length,
              numSpotLightShadows: a.spotShadowMap.length,
              numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: s.toneMapped ? e.toneMapping : K,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: s.side === _,
              flipSided: s.side === m,
              useDepthPacking: !!s.depthPacking,
              depthPacking: s.depthPacking || 0,
              index0AttributeName: s.index0AttributeName,
              extensionDerivatives: s.extensions && s.extensions.derivatives,
              extensionFragDepth: s.extensions && s.extensions.fragDepth,
              extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
              extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
              customProgramCacheKey: s.customProgramCacheKey()
            };
          },
          getProgramCacheKey: function (t) {
            const r = [];
            if (t.shaderID ? r.push(t.shaderID) : (r.push(t.customVertexShaderID), r.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) r.push(e), r.push(t.defines[e]);
            return !1 === t.isRawShaderMaterial && (function (e, t) {
              e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking);
            }(r, t), function (e, t) {
              a.disableAll(), t.isWebGL2 && a.enable(0), t.supportsVertexTextures && a.enable(1), t.instancing && a.enable(2), t.instancingColor && a.enable(3), t.map && a.enable(4), t.matcap && a.enable(5), t.envMap && a.enable(6), t.lightMap && a.enable(7), t.aoMap && a.enable(8), t.emissiveMap && a.enable(9), t.bumpMap && a.enable(10), t.normalMap && a.enable(11), t.objectSpaceNormalMap && a.enable(12), t.tangentSpaceNormalMap && a.enable(13), t.clearcoat && a.enable(14), t.clearcoatMap && a.enable(15), t.clearcoatRoughnessMap && a.enable(16), t.clearcoatNormalMap && a.enable(17), t.iridescence && a.enable(18), t.iridescenceMap && a.enable(19), t.iridescenceThicknessMap && a.enable(20), t.displacementMap && a.enable(21), t.specularMap && a.enable(22), t.roughnessMap && a.enable(23), t.metalnessMap && a.enable(24), t.gradientMap && a.enable(25), t.alphaMap && a.enable(26), t.alphaTest && a.enable(27), t.vertexColors && a.enable(28), t.vertexAlphas && a.enable(29), t.vertexUvs && a.enable(30), t.vertexTangents && a.enable(31), t.uvsVertexOnly && a.enable(32), e.push(a.mask), a.disableAll(), t.fog && a.enable(0), t.useFog && a.enable(1), t.flatShading && a.enable(2), t.logarithmicDepthBuffer && a.enable(3), t.skinning && a.enable(4), t.morphTargets && a.enable(5), t.morphNormals && a.enable(6), t.morphColors && a.enable(7), t.premultipliedAlpha && a.enable(8), t.shadowMapEnabled && a.enable(9), t.physicallyCorrectLights && a.enable(10), t.doubleSided && a.enable(11), t.flipSided && a.enable(12), t.useDepthPacking && a.enable(13), t.dithering && a.enable(14), t.specularIntensityMap && a.enable(15), t.specularColorMap && a.enable(16), t.transmission && a.enable(17), t.transmissionMap && a.enable(18), t.thicknessMap && a.enable(19), t.sheen && a.enable(20), t.sheenColorMap && a.enable(21), t.sheenRoughnessMap && a.enable(22), t.decodeVideoTexture && a.enable(23), t.opaque && a.enable(24), e.push(a.mask);
            }(r, t), r.push(e.outputEncoding)), r.push(t.customProgramCacheKey), r.join();
          },
          getUniforms: function (e) {
            const t = f[e.type];
            let r;
            if (t) {
              const e = Rs[t];
              r = fs.clone(e.uniforms);
            } else r = e.uniforms;
            return r;
          },
          acquireProgram: function (t, r) {
            let n;
            for (let e = 0, t = c.length; e < t; e++) {
              const t = c[e];
              if (t.cacheKey === r) {
                n = t, ++n.usedTimes;
                break;
              }
            }
            return void 0 === n && (n = new Da(e, r, t, s), c.push(n)), n;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              const t = c.indexOf(e);
              c[t] = c[c.length - 1], c.pop(), e.destroy();
            }
          },
          releaseShaderCache: function (e) {
            l.remove(e);
          },
          programs: c,
          dispose: function () {
            l.dispose();
          }
        };
      }
      function Oa() {
        let e = new WeakMap();
        return {
          get: function (t) {
            let r = e.get(t);
            return void 0 === r && (r = {}, e.set(t, r)), r;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, r, n) {
            e.get(t)[r] = n;
          },
          dispose: function () {
            e = new WeakMap();
          }
        };
      }
      function Fa(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
      }
      function Ua(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
      }
      function Na() {
        const e = [];
        let t = 0;
        const r = [],
          n = [],
          i = [];
        function s(r, n, i, s, o, a) {
          let l = e[t];
          return void 0 === l ? (l = {
            id: r.id,
            object: r,
            geometry: n,
            material: i,
            groupOrder: s,
            renderOrder: r.renderOrder,
            z: o,
            group: a
          }, e[t] = l) : (l.id = r.id, l.object = r, l.geometry = n, l.material = i, l.groupOrder = s, l.renderOrder = r.renderOrder, l.z = o, l.group = a), t++, l;
        }
        return {
          opaque: r,
          transmissive: n,
          transparent: i,
          init: function () {
            t = 0, r.length = 0, n.length = 0, i.length = 0;
          },
          push: function (e, t, o, a, l, c) {
            const u = s(e, t, o, a, l, c);
            o.transmission > 0 ? n.push(u) : !0 === o.transparent ? i.push(u) : r.push(u);
          },
          unshift: function (e, t, o, a, l, c) {
            const u = s(e, t, o, a, l, c);
            o.transmission > 0 ? n.unshift(u) : !0 === o.transparent ? i.unshift(u) : r.unshift(u);
          },
          finish: function () {
            for (let r = t, n = e.length; r < n; r++) {
              const t = e[r];
              if (null === t.id) break;
              t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null;
            }
          },
          sort: function (e, t) {
            r.length > 1 && r.sort(e || Fa), n.length > 1 && n.sort(t || Ua), i.length > 1 && i.sort(t || Ua);
          }
        };
      }
      function ja() {
        let e = new WeakMap();
        return {
          get: function (t, r) {
            const n = e.get(t);
            let i;
            return void 0 === n ? (i = new Na(), e.set(t, [i])) : r >= n.length ? (i = new Na(), n.push(i)) : i = n[r], i;
          },
          dispose: function () {
            e = new WeakMap();
          }
        };
      }
      function za() {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let r;
            switch (t.type) {
              case "DirectionalLight":
                r = {
                  direction: new ln(),
                  color: new Wr()
                };
                break;
              case "SpotLight":
                r = {
                  position: new ln(),
                  direction: new ln(),
                  color: new Wr(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                r = {
                  position: new ln(),
                  color: new Wr(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                r = {
                  direction: new ln(),
                  skyColor: new Wr(),
                  groundColor: new Wr()
                };
                break;
              case "RectAreaLight":
                r = {
                  color: new Wr(),
                  position: new ln(),
                  halfWidth: new ln(),
                  halfHeight: new ln()
                };
            }
            return e[t.id] = r, r;
          }
        };
      }
      let Ga = 0;
      function Va(e, t) {
        return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0);
      }
      function Qa(e, t) {
        const r = new za(),
          n = function () {
            const e = {};
            return {
              get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let r;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    r = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new kr()
                    };
                    break;
                  case "PointLight":
                    r = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new kr(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3
                    };
                }
                return e[t.id] = r, r;
              }
            };
          }(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0
          };
        for (let e = 0; e < 9; e++) i.probe.push(new ln());
        const s = new ln(),
          o = new Nn(),
          a = new Nn();
        return {
          setup: function (s, o) {
            let a = 0,
              l = 0,
              c = 0;
            for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
            let u = 0,
              h = 0,
              p = 0,
              d = 0,
              f = 0,
              m = 0,
              _ = 0,
              g = 0,
              v = 0,
              A = 0;
            s.sort(Va);
            const b = !0 !== o ? Math.PI : 1;
            for (let e = 0, t = s.length; e < t; e++) {
              const t = s[e],
                o = t.color,
                y = t.intensity,
                x = t.distance,
                w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
              if (t.isAmbientLight) a += o.r * y * b, l += o.g * y * b, c += o.b * y * b;else if (t.isLightProbe) for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(t.sh.coefficients[e], y);else if (t.isDirectionalLight) {
                const e = r.get(t);
                if (e.color.copy(t.color).multiplyScalar(t.intensity * b), t.castShadow) {
                  const e = t.shadow,
                    r = n.get(t);
                  r.shadowBias = e.bias, r.shadowNormalBias = e.normalBias, r.shadowRadius = e.radius, r.shadowMapSize = e.mapSize, i.directionalShadow[u] = r, i.directionalShadowMap[u] = w, i.directionalShadowMatrix[u] = t.shadow.matrix, m++;
                }
                i.directional[u] = e, u++;
              } else if (t.isSpotLight) {
                const e = r.get(t);
                e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(o).multiplyScalar(y * b), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, i.spot[p] = e;
                const s = t.shadow;
                if (t.map && (i.spotLightMap[v] = t.map, v++, s.updateMatrices(t), t.castShadow && A++), i.spotLightMatrix[p] = s.matrix, t.castShadow) {
                  const e = n.get(t);
                  e.shadowBias = s.bias, e.shadowNormalBias = s.normalBias, e.shadowRadius = s.radius, e.shadowMapSize = s.mapSize, i.spotShadow[p] = e, i.spotShadowMap[p] = w, g++;
                }
                p++;
              } else if (t.isRectAreaLight) {
                const e = r.get(t);
                e.color.copy(o).multiplyScalar(y), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[d] = e, d++;
              } else if (t.isPointLight) {
                const e = r.get(t);
                if (e.color.copy(t.color).multiplyScalar(t.intensity * b), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                  const e = t.shadow,
                    r = n.get(t);
                  r.shadowBias = e.bias, r.shadowNormalBias = e.normalBias, r.shadowRadius = e.radius, r.shadowMapSize = e.mapSize, r.shadowCameraNear = e.camera.near, r.shadowCameraFar = e.camera.far, i.pointShadow[h] = r, i.pointShadowMap[h] = w, i.pointShadowMatrix[h] = t.shadow.matrix, _++;
                }
                i.point[h] = e, h++;
              } else if (t.isHemisphereLight) {
                const e = r.get(t);
                e.skyColor.copy(t.color).multiplyScalar(y * b), e.groundColor.copy(t.groundColor).multiplyScalar(y * b), i.hemi[f] = e, f++;
              }
            }
            d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Bs.LTC_FLOAT_1, i.rectAreaLTC2 = Bs.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Bs.LTC_HALF_1, i.rectAreaLTC2 = Bs.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = a, i.ambient[1] = l, i.ambient[2] = c;
            const y = i.hash;
            y.directionalLength === u && y.pointLength === h && y.spotLength === p && y.rectAreaLength === d && y.hemiLength === f && y.numDirectionalShadows === m && y.numPointShadows === _ && y.numSpotShadows === g && y.numSpotMaps === v || (i.directional.length = u, i.spot.length = p, i.rectArea.length = d, i.point.length = h, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = _, i.pointShadowMap.length = _, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = _, i.spotLightMatrix.length = g + v - A, i.spotLightMap.length = v, i.numSpotLightShadowsWithMaps = A, y.directionalLength = u, y.pointLength = h, y.spotLength = p, y.rectAreaLength = d, y.hemiLength = f, y.numDirectionalShadows = m, y.numPointShadows = _, y.numSpotShadows = g, y.numSpotMaps = v, i.version = Ga++);
          },
          setupView: function (e, t) {
            let r = 0,
              n = 0,
              l = 0,
              c = 0,
              u = 0;
            const h = t.matrixWorldInverse;
            for (let t = 0, p = e.length; t < p; t++) {
              const p = e[t];
              if (p.isDirectionalLight) {
                const e = i.directional[r];
                e.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), r++;
              } else if (p.isSpotLight) {
                const e = i.spot[l];
                e.position.setFromMatrixPosition(p.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), l++;
              } else if (p.isRectAreaLight) {
                const e = i.rectArea[c];
                e.position.setFromMatrixPosition(p.matrixWorld), e.position.applyMatrix4(h), a.identity(), o.copy(p.matrixWorld), o.premultiply(h), a.extractRotation(o), e.halfWidth.set(.5 * p.width, 0, 0), e.halfHeight.set(0, .5 * p.height, 0), e.halfWidth.applyMatrix4(a), e.halfHeight.applyMatrix4(a), c++;
              } else if (p.isPointLight) {
                const e = i.point[n];
                e.position.setFromMatrixPosition(p.matrixWorld), e.position.applyMatrix4(h), n++;
              } else if (p.isHemisphereLight) {
                const e = i.hemi[u];
                e.direction.setFromMatrixPosition(p.matrixWorld), e.direction.transformDirection(h), u++;
              }
            }
          },
          state: i
        };
      }
      function Ha(e, t) {
        const r = new Qa(e, t),
          n = [],
          i = [];
        return {
          init: function () {
            n.length = 0, i.length = 0;
          },
          state: {
            lightsArray: n,
            shadowsArray: i,
            lights: r
          },
          setupLights: function (e) {
            r.setup(n, e);
          },
          setupLightsView: function (e) {
            r.setupView(n, e);
          },
          pushLight: function (e) {
            n.push(e);
          },
          pushShadow: function (e) {
            i.push(e);
          }
        };
      }
      function Wa(e, t) {
        let r = new WeakMap();
        return {
          get: function (n, i = 0) {
            const s = r.get(n);
            let o;
            return void 0 === s ? (o = new Ha(e, t), r.set(n, [o])) : i >= s.length ? (o = new Ha(e, t), s.push(o)) : o = s[i], o;
          },
          dispose: function () {
            r = new WeakMap();
          }
        };
      }
      class qa extends wi {
        constructor(e) {
          super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Rt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
      }
      class Xa extends wi {
        constructor(e) {
          super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new ln(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
      }
      function Ya(e, t, r) {
        let n = new Ts();
        const i = new kr(),
          s = new kr(),
          o = new $r(),
          a = new qa({
            depthPacking: Lt
          }),
          l = new Xa(),
          c = {},
          u = r.maxTextureSize,
          p = {
            0: m,
            1: f,
            2: _
          },
          v = new ms({
            defines: {
              VSM_SAMPLES: 8
            },
            uniforms: {
              shadow_pass: {
                value: null
              },
              resolution: {
                value: new kr()
              },
              radius: {
                value: 4
              }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
          }),
          A = v.clone();
        A.defines.HORIZONTAL_PASS = 1;
        const b = new Hi();
        b.setAttribute("position", new Mi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const y = new cs(b, v),
          x = this;
        function w(r, n) {
          const s = t.update(y);
          v.defines.VSM_SAMPLES !== r.blurSamples && (v.defines.VSM_SAMPLES = r.blurSamples, A.defines.VSM_SAMPLES = r.blurSamples, v.needsUpdate = !0, A.needsUpdate = !0), null === r.mapPass && (r.mapPass = new en(i.x, i.y)), v.uniforms.shadow_pass.value = r.map.texture, v.uniforms.resolution.value = r.mapSize, v.uniforms.radius.value = r.radius, e.setRenderTarget(r.mapPass), e.clear(), e.renderBufferDirect(n, null, s, v, y, null), A.uniforms.shadow_pass.value = r.mapPass.texture, A.uniforms.resolution.value = r.mapSize, A.uniforms.radius.value = r.radius, e.setRenderTarget(r.map), e.clear(), e.renderBufferDirect(n, null, s, A, y, null);
        }
        function E(t, r, n, i, s, o) {
          let u = null;
          const h = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
          if (u = void 0 !== h ? h : !0 === n.isPointLight ? l : a, e.localClippingEnabled && !0 === r.clipShadows && Array.isArray(r.clippingPlanes) && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) {
            const e = u.uuid,
              t = r.uuid;
            let n = c[e];
            void 0 === n && (n = {}, c[e] = n);
            let i = n[t];
            void 0 === i && (i = u.clone(), n[t] = i), u = i;
          }
          return u.visible = r.visible, u.wireframe = r.wireframe, u.side = o === d ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : p[r.side], u.alphaMap = r.alphaMap, u.alphaTest = r.alphaTest, u.clipShadows = r.clipShadows, u.clippingPlanes = r.clippingPlanes, u.clipIntersection = r.clipIntersection, u.displacementMap = r.displacementMap, u.displacementScale = r.displacementScale, u.displacementBias = r.displacementBias, u.wireframeLinewidth = r.wireframeLinewidth, u.linewidth = r.linewidth, !0 === n.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(n.matrixWorld), u.nearDistance = i, u.farDistance = s), u;
        }
        function S(r, i, s, o, a) {
          if (!1 === r.visible) return;
          if (r.layers.test(i.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && a === d) && (!r.frustumCulled || n.intersectsObject(r))) {
            r.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, r.matrixWorld);
            const n = t.update(r),
              i = r.material;
            if (Array.isArray(i)) {
              const t = n.groups;
              for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l],
                  u = i[c.materialIndex];
                if (u && u.visible) {
                  const t = E(r, u, o, s.near, s.far, a);
                  e.renderBufferDirect(s, null, n, t, r, c);
                }
              }
            } else if (i.visible) {
              const t = E(r, i, o, s.near, s.far, a);
              e.renderBufferDirect(s, null, n, t, r, null);
            }
          }
          const l = r.children;
          for (let e = 0, t = l.length; e < t; e++) S(l[e], i, s, o, a);
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = h, this.render = function (t, r, a) {
          if (!1 === x.enabled) return;
          if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
          if (0 === t.length) return;
          const l = e.getRenderTarget(),
            c = e.getActiveCubeFace(),
            h = e.getActiveMipmapLevel(),
            p = e.state;
          p.setBlending(g), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
          for (let l = 0, c = t.length; l < c; l++) {
            const c = t[l],
              h = c.shadow;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
              continue;
            }
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            i.copy(h.mapSize);
            const f = h.getFrameExtents();
            if (i.multiply(f), s.copy(h.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / f.x), i.x = s.x * f.x, h.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / f.y), i.y = s.y * f.y, h.mapSize.y = s.y)), null === h.map) {
              const e = this.type !== d ? {
                minFilter: he,
                magFilter: he
              } : {};
              h.map = new en(i.x, i.y, e), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(h.map), e.clear();
            const m = h.getViewportCount();
            for (let e = 0; e < m; e++) {
              const t = h.getViewport(e);
              o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), p.viewport(o), h.updateMatrices(c, e), n = h.getFrustum(), S(r, a, h.camera, c, this.type);
            }
            !0 !== h.isPointLightShadow && this.type === d && w(h, a), h.needsUpdate = !1;
          }
          x.needsUpdate = !1, e.setRenderTarget(l, c, h);
        };
      }
      function Ka(e, t, r) {
        const n = r.isWebGL2,
          i = new function () {
            let t = !1;
            const r = new $r();
            let n = null;
            const i = new $r(0, 0, 0, 0);
            return {
              setMask: function (r) {
                n === r || t || (e.colorMask(r, r, r, r), n = r);
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, n, s, o, a) {
                !0 === a && (t *= o, n *= o, s *= o), r.set(t, n, s, o), !1 === i.equals(r) && (e.clearColor(t, n, s, o), i.copy(r));
              },
              reset: function () {
                t = !1, n = null, i.set(-1, 0, 0, 0);
              }
            };
          }(),
          s = new function () {
            let t = !1,
              r = null,
              n = null,
              i = null;
            return {
              setTest: function (e) {
                e ? ye(2929) : xe(2929);
              },
              setMask: function (n) {
                r === n || t || (e.depthMask(n), r = n);
              },
              setFunc: function (t) {
                if (n !== t) {
                  if (t) switch (t) {
                    case N:
                      e.depthFunc(512);
                      break;
                    case j:
                      e.depthFunc(519);
                      break;
                    case z:
                      e.depthFunc(513);
                      break;
                    case G:
                      e.depthFunc(515);
                      break;
                    case V:
                      e.depthFunc(514);
                      break;
                    case Q:
                      e.depthFunc(518);
                      break;
                    case H:
                      e.depthFunc(516);
                      break;
                    case W:
                      e.depthFunc(517);
                      break;
                    default:
                      e.depthFunc(515);
                  } else e.depthFunc(515);
                  n = t;
                }
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                i !== t && (e.clearDepth(t), i = t);
              },
              reset: function () {
                t = !1, r = null, n = null, i = null;
              }
            };
          }(),
          c = new function () {
            let t = !1,
              r = null,
              n = null,
              i = null,
              s = null,
              o = null,
              a = null,
              l = null,
              c = null;
            return {
              setTest: function (e) {
                t || (e ? ye(2960) : xe(2960));
              },
              setMask: function (n) {
                r === n || t || (e.stencilMask(n), r = n);
              },
              setFunc: function (t, r, o) {
                n === t && i === r && s === o || (e.stencilFunc(t, r, o), n = t, i = r, s = o);
              },
              setOp: function (t, r, n) {
                o === t && a === r && l === n || (e.stencilOp(t, r, n), o = t, a = r, l = n);
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                c !== t && (e.clearStencil(t), c = t);
              },
              reset: function () {
                t = !1, r = null, n = null, i = null, s = null, o = null, a = null, l = null, c = null;
              }
            };
          }(),
          u = new WeakMap(),
          h = new WeakMap();
        let p = {},
          d = {},
          f = new WeakMap(),
          q = [],
          X = null,
          Y = !1,
          K = null,
          J = null,
          Z = null,
          $ = null,
          ee = null,
          te = null,
          re = null,
          ne = !1,
          ie = null,
          se = null,
          oe = null,
          ae = null,
          le = null;
        const ce = e.getParameter(35661);
        let ue = !1,
          he = 0;
        const pe = e.getParameter(7938);
        -1 !== pe.indexOf("WebGL") ? (he = parseFloat(/^WebGL (\d)/.exec(pe)[1]), ue = he >= 1) : -1 !== pe.indexOf("OpenGL ES") && (he = parseFloat(/^OpenGL ES (\d)/.exec(pe)[1]), ue = he >= 2);
        let de = null,
          fe = {};
        const me = e.getParameter(3088),
          _e = e.getParameter(2978),
          ge = new $r().fromArray(me),
          ve = new $r().fromArray(_e);
        function Ae(t, r, n) {
          const i = new Uint8Array(4),
            s = e.createTexture();
          e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
          for (let t = 0; t < n; t++) e.texImage2D(r + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
          return s;
        }
        const be = {};
        function ye(t) {
          !0 !== p[t] && (e.enable(t), p[t] = !0);
        }
        function xe(t) {
          !1 !== p[t] && (e.disable(t), p[t] = !1);
        }
        be[3553] = Ae(3553, 3553, 1), be[34067] = Ae(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), c.setClear(0), ye(2929), s.setFunc(G), Ce(!1), Me(a), ye(2884), Se(g);
        const we = {
          [w]: 32774,
          [E]: 32778,
          [S]: 32779
        };
        if (n) we[C] = 32775, we[M] = 32776;else {
          const e = t.get("EXT_blend_minmax");
          null !== e && (we[C] = e.MIN_EXT, we[M] = e.MAX_EXT);
        }
        const Ee = {
          [T]: 0,
          [I]: 1,
          [k]: 768,
          [P]: 770,
          [U]: 776,
          [O]: 774,
          [R]: 772,
          [D]: 769,
          [B]: 771,
          [F]: 775,
          [L]: 773
        };
        function Se(t, r, n, i, s, o, a, l) {
          if (t !== g) {
            if (!1 === Y && (ye(3042), Y = !0), t === x) s = s || r, o = o || n, a = a || i, r === J && s === ee || (e.blendEquationSeparate(we[r], we[s]), J = r, ee = s), n === Z && i === $ && o === te && a === re || (e.blendFuncSeparate(Ee[n], Ee[i], Ee[o], Ee[a]), Z = n, $ = i, te = o, re = a), K = t, ne = null;else if (t !== K || l !== ne) {
              if (J === w && ee === w || (e.blendEquation(32774), J = w, ee = w), l) switch (t) {
                case v:
                  e.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case A:
                  e.blendFunc(1, 1);
                  break;
                case b:
                  e.blendFuncSeparate(0, 769, 0, 1);
                  break;
                case y:
                  e.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              } else switch (t) {
                case v:
                  e.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case A:
                  e.blendFunc(770, 1);
                  break;
                case b:
                  e.blendFuncSeparate(0, 769, 0, 1);
                  break;
                case y:
                  e.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
              Z = null, $ = null, te = null, re = null, K = t, ne = l;
            }
          } else !0 === Y && (xe(3042), Y = !1);
        }
        function Ce(t) {
          ie !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ie = t);
        }
        function Me(t) {
          t !== o ? (ye(2884), t !== se && (t === a ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : xe(2884), se = t;
        }
        function Te(t, r, n) {
          t ? (ye(32823), ae === r && le === n || (e.polygonOffset(r, n), ae = r, le = n)) : xe(32823);
        }
        function Ie(t) {
          void 0 === t && (t = 33984 + ce - 1), de !== t && (e.activeTexture(t), de = t);
        }
        return {
          buffers: {
            color: i,
            depth: s,
            stencil: c
          },
          enable: ye,
          disable: xe,
          bindFramebuffer: function (t, r) {
            return d[t] !== r && (e.bindFramebuffer(t, r), d[t] = r, n && (36009 === t && (d[36160] = r), 36160 === t && (d[36009] = r)), !0);
          },
          drawBuffers: function (n, i) {
            let s = q,
              o = !1;
            if (n) {
              if (s = f.get(i), void 0 === s && (s = [], f.set(i, s)), n.isWebGLMultipleRenderTargets) {
                const e = n.texture;
                if (s.length !== e.length || 36064 !== s[0]) {
                  for (let t = 0, r = e.length; t < r; t++) s[t] = 36064 + t;
                  s.length = e.length, o = !0;
                }
              } else 36064 !== s[0] && (s[0] = 36064, o = !0);
            } else 1029 !== s[0] && (s[0] = 1029, o = !0);
            o && (r.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
          },
          useProgram: function (t) {
            return X !== t && (e.useProgram(t), X = t, !0);
          },
          setBlending: Se,
          setMaterial: function (e, t) {
            e.side === _ ? xe(2884) : ye(2884);
            let r = e.side === m;
            t && (r = !r), Ce(r), e.blending === v && !1 === e.transparent ? Se(g) : Se(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), i.setMask(e.colorWrite);
            const n = e.stencilWrite;
            c.setTest(n), n && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Te(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ye(32926) : xe(32926);
          },
          setFlipSided: Ce,
          setCullFace: Me,
          setLineWidth: function (t) {
            t !== oe && (ue && e.lineWidth(t), oe = t);
          },
          setPolygonOffset: Te,
          setScissorTest: function (e) {
            e ? ye(3089) : xe(3089);
          },
          activeTexture: Ie,
          bindTexture: function (t, r) {
            null === de && Ie();
            let n = fe[de];
            void 0 === n && (n = {
              type: void 0,
              texture: void 0
            }, fe[de] = n), n.type === t && n.texture === r || (e.bindTexture(t, r || be[t]), n.type = t, n.texture = r);
          },
          unbindTexture: function () {
            const t = fe[de];
            void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0);
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          updateUBOMapping: function (t, r) {
            let n = h.get(r);
            void 0 === n && (n = new WeakMap(), h.set(r, n));
            let i = n.get(t);
            void 0 === i && (i = e.getUniformBlockIndex(r, t.name), n.set(t, i));
          },
          uniformBlockBinding: function (t, r) {
            const n = h.get(r).get(t);
            u.get(t) !== n && (e.uniformBlockBinding(r, n, t.__bindingPointIndex), u.set(t, n));
          },
          texStorage2D: function () {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage3D: function () {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage2D: function () {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage3D: function () {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (t) {
            !1 === ge.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ge.copy(t));
          },
          viewport: function (t) {
            !1 === ve.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ve.copy(t));
          },
          reset: function () {
            e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === n && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), p = {}, de = null, fe = {}, d = {}, f = new WeakMap(), q = [], X = null, Y = !1, K = null, J = null, Z = null, $ = null, ee = null, te = null, re = null, ne = !1, ie = null, se = null, oe = null, ae = null, le = null, ge.set(0, 0, e.canvas.width, e.canvas.height), ve.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), s.reset(), c.reset();
          }
        };
      }
      function Ja(e, t, r, n, i, s, o) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          u = i.maxTextureSize,
          h = i.maxSamples,
          p = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
          d = /OculusBrowser/g.test(navigator.userAgent),
          f = new WeakMap();
        let m;
        const _ = new WeakMap();
        let g = !1;
        try {
          g = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (e) {}
        function v(e, t) {
          return g ? new OffscreenCanvas(e, t) : Lr("canvas");
        }
        function A(e, t, r, n) {
          let i = 1;
          if ((e.width > n || e.height > n) && (i = n / Math.max(e.width, e.height)), i < 1 || !0 === t) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
              const n = t ? Cr : Math.floor,
                s = n(i * e.width),
                o = n(i * e.height);
              void 0 === m && (m = v(s, o));
              const a = r ? v(s, o) : m;
              return a.width = s, a.height = o, a.getContext("2d").drawImage(e, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + o + ")."), a;
            }
            return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e;
          }
          return e;
        }
        function b(e) {
          return Er(e.width) && Er(e.height);
        }
        function y(e, t) {
          return e.generateMipmaps && t && e.minFilter !== he && e.minFilter !== _e;
        }
        function x(t) {
          e.generateMipmap(t);
        }
        function w(r, n, i, s, o = !1) {
          if (!1 === a) return n;
          if (null !== r) {
            if (void 0 !== e[r]) return e[r];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + r + "'");
          }
          let l = n;
          return 6403 === n && (5126 === i && (l = 33326), 5131 === i && (l = 33325), 5121 === i && (l = 33321)), 33319 === n && (5126 === i && (l = 33328), 5131 === i && (l = 33327), 5121 === i && (l = 33323)), 6408 === n && (5126 === i && (l = 34836), 5131 === i && (l = 34842), 5121 === i && (l = s === Dt && !1 === o ? 35907 : 32856), 32819 === i && (l = 32854), 32820 === i && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"), l;
        }
        function E(e, t, r) {
          return !0 === y(e, r) || e.isFramebufferTexture && e.minFilter !== he && e.minFilter !== _e ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1;
        }
        function S(e) {
          return e === he || e === pe || e === fe ? 9728 : 9729;
        }
        function C(e) {
          const t = e.target;
          t.removeEventListener("dispose", C), function (e) {
            const t = n.get(e);
            if (void 0 === t.__webglInit) return;
            const r = e.source,
              i = _.get(r);
            if (i) {
              const n = i[t.__cacheKey];
              n.usedTimes--, 0 === n.usedTimes && T(e), 0 === Object.keys(i).length && _.delete(r);
            }
            n.remove(e);
          }(t), t.isVideoTexture && f.delete(t);
        }
        function M(t) {
          const r = t.target;
          r.removeEventListener("dispose", M), function (t) {
            const r = t.texture,
              i = n.get(t),
              s = n.get(r);
            if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), o.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) e.deleteFramebuffer(i.__webglFramebuffer[t]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]);else {
              if (e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer) for (let t = 0; t < i.__webglColorRenderbuffer.length; t++) i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
              i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
            }
            if (t.isWebGLMultipleRenderTargets) for (let t = 0, i = r.length; t < i; t++) {
              const i = n.get(r[t]);
              i.__webglTexture && (e.deleteTexture(i.__webglTexture), o.memory.textures--), n.remove(r[t]);
            }
            n.remove(r), n.remove(t);
          }(r);
        }
        function T(t) {
          const r = n.get(t);
          e.deleteTexture(r.__webglTexture);
          const i = t.source;
          delete _.get(i)[r.__cacheKey], o.memory.textures--;
        }
        let I = 0;
        function k(e, t) {
          const i = n.get(e);
          if (e.isVideoTexture && function (e) {
            const t = o.render.frame;
            f.get(e) !== t && (f.set(e, t), e.update());
          }(e), !1 === e.isRenderTargetTexture && e.version > 0 && i.__version !== e.version) {
            const r = e.image;
            if (null === r) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else {
              if (!1 !== r.complete) return void L(i, e, t);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          r.activeTexture(33984 + t), r.bindTexture(3553, i.__webglTexture);
        }
        const D = {
            [le]: 10497,
            [ce]: 33071,
            [ue]: 33648
          },
          P = {
            [he]: 9728,
            [pe]: 9984,
            [fe]: 9986,
            [_e]: 9729,
            [ge]: 9985,
            [Ae]: 9987
          };
        function B(r, s, o) {
          if (o ? (e.texParameteri(r, 10242, D[s.wrapS]), e.texParameteri(r, 10243, D[s.wrapT]), 32879 !== r && 35866 !== r || e.texParameteri(r, 32882, D[s.wrapR]), e.texParameteri(r, 10240, P[s.magFilter]), e.texParameteri(r, 10241, P[s.minFilter])) : (e.texParameteri(r, 10242, 33071), e.texParameteri(r, 10243, 33071), 32879 !== r && 35866 !== r || e.texParameteri(r, 32882, 33071), s.wrapS === ce && s.wrapT === ce || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(r, 10240, S(s.magFilter)), e.texParameteri(r, 10241, S(s.minFilter)), s.minFilter !== he && s.minFilter !== _e && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
            const o = t.get("EXT_texture_filter_anisotropic");
            if (s.type === Me && !1 === t.has("OES_texture_float_linear")) return;
            if (!1 === a && s.type === Te && !1 === t.has("OES_texture_half_float_linear")) return;
            (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (e.texParameterf(r, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy);
          }
        }
        function R(t, r) {
          let n = !1;
          void 0 === t.__webglInit && (t.__webglInit = !0, r.addEventListener("dispose", C));
          const i = r.source;
          let s = _.get(i);
          void 0 === s && (s = {}, _.set(i, s));
          const a = function (e) {
            const t = [];
            return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join();
          }(r);
          if (a !== t.__cacheKey) {
            void 0 === s[a] && (s[a] = {
              texture: e.createTexture(),
              usedTimes: 0
            }, o.memory.textures++, n = !0), s[a].usedTimes++;
            const i = s[t.__cacheKey];
            void 0 !== i && (s[t.__cacheKey].usedTimes--, 0 === i.usedTimes && T(r)), t.__cacheKey = a, t.__webglTexture = s[a].texture;
          }
          return n;
        }
        function L(t, n, i) {
          let o = 3553;
          n.isDataArrayTexture && (o = 35866), n.isData3DTexture && (o = 32879);
          const l = R(t, n),
            c = n.source;
          if (r.activeTexture(33984 + i), r.bindTexture(o, t.__webglTexture), c.version !== c.__currentVersion || !0 === l) {
            e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), e.pixelStorei(37443, 0);
            const t = function (e) {
              return !a && (e.wrapS !== ce || e.wrapT !== ce || e.minFilter !== he && e.minFilter !== _e);
            }(n) && !1 === b(n.image);
            let i = A(n.image, t, !1, u);
            i = z(n, i);
            const h = b(i) || a,
              p = s.convert(n.format, n.encoding);
            let d,
              f = s.convert(n.type),
              m = w(n.internalFormat, p, f, n.encoding, n.isVideoTexture);
            B(o, n, h);
            const _ = n.mipmaps,
              g = a && !0 !== n.isVideoTexture,
              v = void 0 === c.__currentVersion || !0 === l,
              S = E(n, i, h);
            if (n.isDepthTexture) m = 6402, a ? m = n.type === Me ? 36012 : n.type === Ce ? 33190 : n.type === De ? 35056 : 33189 : n.type === Me && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === Fe && 6402 === m && n.type !== Ee && n.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = Ce, f = s.convert(n.type)), n.format === Ue && 6402 === m && (m = 34041, n.type !== De && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = De, f = s.convert(n.type))), v && (g ? r.texStorage2D(3553, 1, m, i.width, i.height) : r.texImage2D(3553, 0, m, i.width, i.height, 0, p, f, null));else if (n.isDataTexture) {
              if (_.length > 0 && h) {
                g && v && r.texStorage2D(3553, S, m, _[0].width, _[0].height);
                for (let e = 0, t = _.length; e < t; e++) d = _[e], g ? r.texSubImage2D(3553, e, 0, 0, d.width, d.height, p, f, d.data) : r.texImage2D(3553, e, m, d.width, d.height, 0, p, f, d.data);
                n.generateMipmaps = !1;
              } else g ? (v && r.texStorage2D(3553, S, m, i.width, i.height), r.texSubImage2D(3553, 0, 0, 0, i.width, i.height, p, f, i.data)) : r.texImage2D(3553, 0, m, i.width, i.height, 0, p, f, i.data);
            } else if (n.isCompressedTexture) {
              g && v && r.texStorage2D(3553, S, m, _[0].width, _[0].height);
              for (let e = 0, t = _.length; e < t; e++) d = _[e], n.format !== Re ? null !== p ? g ? r.compressedTexSubImage2D(3553, e, 0, 0, d.width, d.height, p, d.data) : r.compressedTexImage2D(3553, e, m, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g ? r.texSubImage2D(3553, e, 0, 0, d.width, d.height, p, f, d.data) : r.texImage2D(3553, e, m, d.width, d.height, 0, p, f, d.data);
            } else if (n.isDataArrayTexture) g ? (v && r.texStorage3D(35866, S, m, i.width, i.height, i.depth), r.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, p, f, i.data)) : r.texImage3D(35866, 0, m, i.width, i.height, i.depth, 0, p, f, i.data);else if (n.isData3DTexture) g ? (v && r.texStorage3D(32879, S, m, i.width, i.height, i.depth), r.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, p, f, i.data)) : r.texImage3D(32879, 0, m, i.width, i.height, i.depth, 0, p, f, i.data);else if (n.isFramebufferTexture) {
              if (v) if (g) r.texStorage2D(3553, S, m, i.width, i.height);else {
                let e = i.width,
                  t = i.height;
                for (let n = 0; n < S; n++) r.texImage2D(3553, n, m, e, t, 0, p, f, null), e >>= 1, t >>= 1;
              }
            } else if (_.length > 0 && h) {
              g && v && r.texStorage2D(3553, S, m, _[0].width, _[0].height);
              for (let e = 0, t = _.length; e < t; e++) d = _[e], g ? r.texSubImage2D(3553, e, 0, 0, p, f, d) : r.texImage2D(3553, e, m, p, f, d);
              n.generateMipmaps = !1;
            } else g ? (v && r.texStorage2D(3553, S, m, i.width, i.height), r.texSubImage2D(3553, 0, 0, 0, p, f, i)) : r.texImage2D(3553, 0, m, p, f, i);
            y(n, h) && x(o), c.__currentVersion = c.version, n.onUpdate && n.onUpdate(n);
          }
          t.__version = n.version;
        }
        function O(t, i, o, a, l) {
          const c = s.convert(o.format, o.encoding),
            u = s.convert(o.type),
            h = w(o.internalFormat, c, u, o.encoding);
          n.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? r.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, c, u, null) : r.texImage2D(l, 0, h, i.width, i.height, 0, c, u, null)), r.bindFramebuffer(36160, t), j(i) ? p.framebufferTexture2DMultisampleEXT(36160, a, l, n.get(o).__webglTexture, 0, N(i)) : e.framebufferTexture2D(36160, a, l, n.get(o).__webglTexture, 0), r.bindFramebuffer(36160, null);
        }
        function F(t, r, n) {
          if (e.bindRenderbuffer(36161, t), r.depthBuffer && !r.stencilBuffer) {
            let i = 33189;
            if (n || j(r)) {
              const t = r.depthTexture;
              t && t.isDepthTexture && (t.type === Me ? i = 36012 : t.type === Ce && (i = 33190));
              const n = N(r);
              j(r) ? p.renderbufferStorageMultisampleEXT(36161, n, i, r.width, r.height) : e.renderbufferStorageMultisample(36161, n, i, r.width, r.height);
            } else e.renderbufferStorage(36161, i, r.width, r.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (r.depthBuffer && r.stencilBuffer) {
            const i = N(r);
            n && !1 === j(r) ? e.renderbufferStorageMultisample(36161, i, 35056, r.width, r.height) : j(r) ? p.renderbufferStorageMultisampleEXT(36161, i, 35056, r.width, r.height) : e.renderbufferStorage(36161, 34041, r.width, r.height), e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            const t = !0 === r.isWebGLMultipleRenderTargets ? r.texture : [r.texture];
            for (let i = 0; i < t.length; i++) {
              const o = t[i],
                a = s.convert(o.format, o.encoding),
                l = s.convert(o.type),
                c = w(o.internalFormat, a, l, o.encoding),
                u = N(r);
              n && !1 === j(r) ? e.renderbufferStorageMultisample(36161, u, c, r.width, r.height) : j(r) ? p.renderbufferStorageMultisampleEXT(36161, u, c, r.width, r.height) : e.renderbufferStorage(36161, c, r.width, r.height);
            }
          }
          e.bindRenderbuffer(36161, null);
        }
        function U(t) {
          const i = n.get(t),
            s = !0 === t.isWebGLCubeRenderTarget;
          if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
            if (s) throw new Error("target.depthTexture not supported in Cube render targets");
            !function (t, i) {
              if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
              if (r.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), k(i.depthTexture, 0);
              const s = n.get(i.depthTexture).__webglTexture,
                o = N(i);
              if (i.depthTexture.format === Fe) j(i) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);else {
                if (i.depthTexture.format !== Ue) throw new Error("Unknown depthTexture format");
                j(i) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
              }
            }(i.__webglFramebuffer, t);
          } else if (s) {
            i.__webglDepthbuffer = [];
            for (let n = 0; n < 6; n++) r.bindFramebuffer(36160, i.__webglFramebuffer[n]), i.__webglDepthbuffer[n] = e.createRenderbuffer(), F(i.__webglDepthbuffer[n], t, !1);
          } else r.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), F(i.__webglDepthbuffer, t, !1);
          r.bindFramebuffer(36160, null);
        }
        function N(e) {
          return Math.min(h, e.samples);
        }
        function j(e) {
          const r = n.get(e);
          return a && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== r.__useRenderToTexture;
        }
        function z(e, r) {
          const n = e.encoding,
            i = e.format,
            s = e.type;
          return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === fr || n !== kt && (n === Dt ? !1 === a ? !0 === t.has("EXT_sRGB") && i === Re ? (e.format = fr, e.minFilter = _e, e.generateMipmaps = !1) : r = Xr.sRGBToLinear(r) : i === Re && s === ye || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : n === RGBM16Encoding || console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)), r;
        }
        this.allocateTextureUnit = function () {
          const e = I;
          return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), I += 1, e;
        }, this.resetTextureUnits = function () {
          I = 0;
        }, this.setTexture2D = k, this.setTexture2DArray = function (e, t) {
          const i = n.get(e);
          e.version > 0 && i.__version !== e.version ? L(i, e, t) : (r.activeTexture(33984 + t), r.bindTexture(35866, i.__webglTexture));
        }, this.setTexture3D = function (e, t) {
          const i = n.get(e);
          e.version > 0 && i.__version !== e.version ? L(i, e, t) : (r.activeTexture(33984 + t), r.bindTexture(32879, i.__webglTexture));
        }, this.setTextureCube = function (t, i) {
          const o = n.get(t);
          t.version > 0 && o.__version !== t.version ? function (t, n, i) {
            if (6 !== n.image.length) return;
            const o = R(t, n),
              l = n.source;
            if (r.activeTexture(33984 + i), r.bindTexture(34067, t.__webglTexture), l.version !== l.__currentVersion || !0 === o) {
              e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), e.pixelStorei(37443, 0);
              const t = n.isCompressedTexture || n.image[0].isCompressedTexture,
                i = n.image[0] && n.image[0].isDataTexture,
                u = [];
              for (let e = 0; e < 6; e++) u[e] = t || i ? i ? n.image[e].image : n.image[e] : A(n.image[e], !1, !0, c), u[e] = z(n, u[e]);
              const h = u[0],
                p = b(h) || a,
                d = s.convert(n.format, n.encoding),
                f = s.convert(n.type),
                m = w(n.internalFormat, d, f, n.encoding),
                _ = a && !0 !== n.isVideoTexture,
                g = void 0 === l.__currentVersion || !0 === o;
              let v,
                S = E(n, h, p);
              if (B(34067, n, p), t) {
                _ && g && r.texStorage2D(34067, S, m, h.width, h.height);
                for (let e = 0; e < 6; e++) {
                  v = u[e].mipmaps;
                  for (let t = 0; t < v.length; t++) {
                    const i = v[t];
                    n.format !== Re ? null !== d ? _ ? r.compressedTexSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, i.data) : r.compressedTexImage2D(34069 + e, t, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _ ? r.texSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, f, i.data) : r.texImage2D(34069 + e, t, m, i.width, i.height, 0, d, f, i.data);
                  }
                }
              } else {
                v = n.mipmaps, _ && g && (v.length > 0 && S++, r.texStorage2D(34067, S, m, u[0].width, u[0].height));
                for (let e = 0; e < 6; e++) if (i) {
                  _ ? r.texSubImage2D(34069 + e, 0, 0, 0, u[e].width, u[e].height, d, f, u[e].data) : r.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, d, f, u[e].data);
                  for (let t = 0; t < v.length; t++) {
                    const n = v[t].image[e].image;
                    _ ? r.texSubImage2D(34069 + e, t + 1, 0, 0, n.width, n.height, d, f, n.data) : r.texImage2D(34069 + e, t + 1, m, n.width, n.height, 0, d, f, n.data);
                  }
                } else {
                  _ ? r.texSubImage2D(34069 + e, 0, 0, 0, d, f, u[e]) : r.texImage2D(34069 + e, 0, m, d, f, u[e]);
                  for (let t = 0; t < v.length; t++) {
                    const n = v[t];
                    _ ? r.texSubImage2D(34069 + e, t + 1, 0, 0, d, f, n.image[e]) : r.texImage2D(34069 + e, t + 1, m, d, f, n.image[e]);
                  }
                }
              }
              y(n, p) && x(34067), l.__currentVersion = l.version, n.onUpdate && n.onUpdate(n);
            }
            t.__version = n.version;
          }(o, t, i) : (r.activeTexture(33984 + i), r.bindTexture(34067, o.__webglTexture));
        }, this.rebindTextures = function (e, t, r) {
          const i = n.get(e);
          void 0 !== t && O(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== r && U(e);
        }, this.setupRenderTarget = function (t) {
          const l = t.texture,
            c = n.get(t),
            u = n.get(l);
          t.addEventListener("dispose", M), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, o.memory.textures++);
          const h = !0 === t.isWebGLCubeRenderTarget,
            p = !0 === t.isWebGLMultipleRenderTargets,
            d = b(t) || a;
          if (h) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer();
          } else {
            if (c.__webglFramebuffer = e.createFramebuffer(), p) if (i.drawBuffers) {
              const r = t.texture;
              for (let t = 0, i = r.length; t < i; t++) {
                const i = n.get(r[t]);
                void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), o.memory.textures++);
              }
            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && t.samples > 0 && !1 === j(t)) {
              const n = p ? l : [l];
              c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = [], r.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);
              for (let r = 0; r < n.length; r++) {
                const i = n[r];
                c.__webglColorRenderbuffer[r] = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[r]);
                const o = s.convert(i.format, i.encoding),
                  a = s.convert(i.type),
                  l = w(i.internalFormat, o, a, i.encoding),
                  u = N(t);
                e.renderbufferStorageMultisample(36161, u, l, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + r, 36161, c.__webglColorRenderbuffer[r]);
              }
              e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), F(c.__webglDepthRenderbuffer, t, !0)), r.bindFramebuffer(36160, null);
            }
          }
          if (h) {
            r.bindTexture(34067, u.__webglTexture), B(34067, l, d);
            for (let e = 0; e < 6; e++) O(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            y(l, d) && x(34067), r.unbindTexture();
          } else if (p) {
            const e = t.texture;
            for (let i = 0, s = e.length; i < s; i++) {
              const s = e[i],
                o = n.get(s);
              r.bindTexture(3553, o.__webglTexture), B(3553, s, d), O(c.__webglFramebuffer, t, s, 36064 + i, 3553), y(s, d) && x(3553);
            }
            r.unbindTexture();
          } else {
            let e = 3553;
            (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (a ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), r.bindTexture(e, u.__webglTexture), B(e, l, d), O(c.__webglFramebuffer, t, l, 36064, e), y(l, d) && x(e), r.unbindTexture();
          }
          t.depthBuffer && U(t);
        }, this.updateRenderTargetMipmap = function (e) {
          const t = b(e) || a,
            i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
            s = e.isWebGLCubeRenderTarget ? 34067 : 3553;
          for (let e = 0, o = i.length; e < o; e++) {
            const o = i[e],
              a = n.get(o),
              l = a.__webglTexture;
            a.__version !== o.version && (r.bindTexture(s, l), B(s, o, t), r.unbindTexture(), a.__version = o.version), y(o, t) && (r.bindTexture(s, l), x(s), r.unbindTexture());
          }
        }, this.updateMultisampleRenderTarget = function (t) {
          if (a && t.samples > 0 && !1 === j(t)) {
            const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
              s = t.width,
              o = t.height;
            let a = 16384;
            const l = [],
              c = t.stencilBuffer ? 33306 : 36096,
              u = n.get(t),
              h = !0 === t.isWebGLMultipleRenderTargets;
            if (h) for (let t = 0; t < i.length; t++) r.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, null), r.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
            r.bindFramebuffer(36008, u.__webglMultisampledFramebuffer), r.bindFramebuffer(36009, u.__webglFramebuffer);
            for (let r = 0; r < i.length; r++) {
              l.push(36064 + r), t.depthBuffer && l.push(c);
              const p = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
              if (!1 === p && (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024)), h && e.framebufferRenderbuffer(36008, 36064, 36161, u.__webglColorRenderbuffer[r]), !0 === p && (e.invalidateFramebuffer(36008, [c]), e.invalidateFramebuffer(36009, [c])), h) {
                const t = n.get(i[r]).__webglTexture;
                e.framebufferTexture2D(36009, 36064, 3553, t, 0);
              }
              e.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728), d && e.invalidateFramebuffer(36008, l);
            }
            if (r.bindFramebuffer(36008, null), r.bindFramebuffer(36009, null), h) for (let t = 0; t < i.length; t++) {
              r.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, u.__webglColorRenderbuffer[t]);
              const s = n.get(i[t]).__webglTexture;
              r.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0);
            }
            r.bindFramebuffer(36009, u.__webglMultisampledFramebuffer);
          }
        }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = O, this.useMultisampledRTT = j;
      }
      function Za(e, t, r) {
        const n = r.isWebGL2;
        return {
          convert: function (r, i = null) {
            let s;
            if (r === ye) return 5121;
            if (r === Ie) return 32819;
            if (r === ke) return 32820;
            if (r === xe) return 5120;
            if (r === we) return 5122;
            if (r === Ee) return 5123;
            if (r === Se) return 5124;
            if (r === Ce) return 5125;
            if (r === Me) return 5126;
            if (r === Te) return n ? 5131 : (s = t.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
            if (r === Pe) return 6406;
            if (r === Re) return 6408;
            if (r === Le) return 6409;
            if (r === Oe) return 6410;
            if (r === Fe) return 6402;
            if (r === Ue) return 34041;
            if (r === Ne) return 6403;
            if (r === Be) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
            if (r === fr) return s = t.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
            if (r === je) return 36244;
            if (r === ze) return 33319;
            if (r === Ge) return 33320;
            if (r === Ve) return 36249;
            if (r === Qe || r === He || r === We || r === qe) if (i === Dt) {
              if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
              if (r === Qe) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (r === He) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (r === We) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (r === qe) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (s = t.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
              if (r === Qe) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === He) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === We) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === qe) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if (r === Xe || r === Ye || r === Ke || r === Je) {
              if (s = t.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
              if (r === Xe) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === Ye) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === Ke) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === Je) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (r === Ze) return s = t.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
            if (r === $e || r === et) {
              if (s = t.get("WEBGL_compressed_texture_etc"), null === s) return null;
              if (r === $e) return i === Dt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
              if (r === et) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (r === tt || r === rt || r === nt || r === it || r === st || r === ot || r === at || r === lt || r === ct || r === ut || r === ht || r === pt || r === dt || r === ft) {
              if (s = t.get("WEBGL_compressed_texture_astc"), null === s) return null;
              if (r === tt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (r === rt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (r === nt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (r === it) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (r === st) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (r === ot) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (r === at) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (r === lt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (r === ct) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (r === ut) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (r === ht) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (r === pt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (r === dt) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (r === ft) return i === Dt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (r === mt) {
              if (s = t.get("EXT_texture_compression_bptc"), null === s) return null;
              if (r === mt) return i === Dt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            return r === De ? n ? 34042 : (s = t.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[r] ? e[r] : null;
          }
        };
      }
      class $a extends gs {
        constructor(e = []) {
          super(), this.isArrayCamera = !0, this.cameras = e;
        }
      }
      class el extends ui {
        constructor() {
          super(), this.isGroup = !0, this.type = "Group";
        }
      }
      const tl = {
        type: "move"
      };
      class rl {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return null === this._hand && (this._hand = new el(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
          }), this._hand;
        }
        getTargetRaySpace() {
          return null === this._targetRay && (this._targetRay = new el(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ln(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ln()), this._targetRay;
        }
        getGripSpace() {
          return null === this._grip && (this._grip = new el(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ln(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ln()), this._grip;
        }
        dispatchEvent(e) {
          return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this;
        }
        disconnect(e) {
          return this.dispatchEvent({
            type: "disconnected",
            data: e
          }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
        }
        update(e, t, r) {
          let n = null,
            i = null,
            s = null;
          const o = this._targetRay,
            a = this._grip,
            l = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (l && e.hand) {
              s = !0;
              for (const n of e.hand.values()) {
                const e = t.getJointPose(n, r);
                if (void 0 === l.joints[n.jointName]) {
                  const e = new el();
                  e.matrixAutoUpdate = !1, e.visible = !1, l.joints[n.jointName] = e, l.add(e);
                }
                const i = l.joints[n.jointName];
                null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e;
              }
              const n = l.joints["index-finger-tip"],
                i = l.joints["thumb-tip"],
                o = n.position.distanceTo(i.position),
                a = .02,
                c = .005;
              l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this
              })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                type: "pinchstart",
                handedness: e.handedness,
                target: this
              }));
            } else null !== a && e.gripSpace && (i = t.getPose(e.gripSpace, r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));
            null !== o && (n = t.getPose(e.targetRaySpace, r), null === n && null !== i && (n = i), null !== n && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), n.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = !1, n.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(tl)));
          }
          return null !== o && (o.visible = null !== n), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== s), this;
        }
      }
      class nl extends Zr {
        constructor(e, t, r, n, i, s, o, a, l, c) {
          if ((c = void 0 !== c ? c : Fe) !== Fe && c !== Ue) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          void 0 === r && c === Fe && (r = Ce), void 0 === r && c === Ue && (r = De), super(null, n, i, s, o, a, c, r, l), this.isDepthTexture = !0, this.image = {
            width: e,
            height: t
          }, this.magFilter = void 0 !== o ? o : he, this.minFilter = void 0 !== a ? a : he, this.flipY = !1, this.generateMipmaps = !1;
        }
      }
      class il extends mr {
        constructor(e, t) {
          super();
          const r = this;
          let n = null,
            i = 1,
            s = null,
            o = "local-floor",
            a = null,
            l = null,
            c = null,
            u = null,
            h = null,
            p = null;
          const d = t.getContextAttributes();
          let f = null,
            m = null;
          const _ = [],
            g = [],
            v = new gs();
          v.layers.enable(1), v.viewport = new $r();
          const A = new gs();
          A.layers.enable(2), A.viewport = new $r();
          const b = [v, A],
            y = new $a();
          y.layers.enable(1), y.layers.enable(2);
          let x = null,
            w = null;
          function E(e) {
            const t = g.indexOf(e.inputSource);
            if (-1 === t) return;
            const r = _[t];
            void 0 !== r && r.dispatchEvent({
              type: e.type,
              data: e.inputSource
            });
          }
          function S() {
            n.removeEventListener("select", E), n.removeEventListener("selectstart", E), n.removeEventListener("selectend", E), n.removeEventListener("squeeze", E), n.removeEventListener("squeezestart", E), n.removeEventListener("squeezeend", E), n.removeEventListener("end", S), n.removeEventListener("inputsourceschange", C);
            for (let e = 0; e < _.length; e++) {
              const t = g[e];
              null !== t && (g[e] = null, _[e].disconnect(t));
            }
            x = null, w = null, e.setRenderTarget(f), h = null, u = null, c = null, n = null, m = null, D.stop(), r.isPresenting = !1, r.dispatchEvent({
              type: "sessionend"
            });
          }
          function C(e) {
            for (let t = 0; t < e.removed.length; t++) {
              const r = e.removed[t],
                n = g.indexOf(r);
              n >= 0 && (g[n] = null, _[n].dispatchEvent({
                type: "disconnected",
                data: r
              }));
            }
            for (let t = 0; t < e.added.length; t++) {
              const r = e.added[t];
              let n = g.indexOf(r);
              if (-1 === n) {
                for (let e = 0; e < _.length; e++) {
                  if (e >= g.length) {
                    g.push(r), n = e;
                    break;
                  }
                  if (null === g[e]) {
                    g[e] = r, n = e;
                    break;
                  }
                }
                if (-1 === n) break;
              }
              const i = _[n];
              i && i.dispatchEvent({
                type: "connected",
                data: r
              });
            }
          }
          this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
            let t = _[e];
            return void 0 === t && (t = new rl(), _[e] = t), t.getTargetRaySpace();
          }, this.getControllerGrip = function (e) {
            let t = _[e];
            return void 0 === t && (t = new rl(), _[e] = t), t.getGripSpace();
          }, this.getHand = function (e) {
            let t = _[e];
            return void 0 === t && (t = new rl(), _[e] = t), t.getHandSpace();
          }, this.setFramebufferScaleFactor = function (e) {
            i = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function (e) {
            o = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function () {
            return a || s;
          }, this.setReferenceSpace = function (e) {
            a = e;
          }, this.getBaseLayer = function () {
            return null !== u ? u : h;
          }, this.getBinding = function () {
            return c;
          }, this.getFrame = function () {
            return p;
          }, this.getSession = function () {
            return n;
          }, this.setSession = async function (l) {
            if (n = l, null !== n) {
              if (f = e.getRenderTarget(), n.addEventListener("select", E), n.addEventListener("selectstart", E), n.addEventListener("selectend", E), n.addEventListener("squeeze", E), n.addEventListener("squeezestart", E), n.addEventListener("squeezeend", E), n.addEventListener("end", S), n.addEventListener("inputsourceschange", C), !0 !== d.xrCompatible && (await t.makeXRCompatible()), void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2) {
                const r = {
                  antialias: void 0 !== n.renderState.layers || d.antialias,
                  alpha: d.alpha,
                  depth: d.depth,
                  stencil: d.stencil,
                  framebufferScaleFactor: i
                };
                h = new XRWebGLLayer(n, t, r), n.updateRenderState({
                  baseLayer: h
                }), m = new en(h.framebufferWidth, h.framebufferHeight, {
                  format: Re,
                  type: ye,
                  encoding: e.outputEncoding,
                  stencilBuffer: d.stencil
                });
              } else {
                let r = null,
                  s = null,
                  o = null;
                d.depth && (o = d.stencil ? 35056 : 33190, r = d.stencil ? Ue : Fe, s = d.stencil ? De : Ce);
                const a = {
                  colorFormat: 32856,
                  depthFormat: o,
                  scaleFactor: i
                };
                c = new XRWebGLBinding(n, t), u = c.createProjectionLayer(a), n.updateRenderState({
                  layers: [u]
                }), m = new en(u.textureWidth, u.textureHeight, {
                  format: Re,
                  type: ye,
                  depthTexture: new nl(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, r),
                  stencilBuffer: d.stencil,
                  encoding: e.outputEncoding,
                  samples: d.antialias ? 4 : 0
                }), e.properties.get(m).__ignoreDepthValues = u.ignoreDepthValues;
              }
              m.isXRRenderTarget = !0, this.setFoveation(1), a = null, s = await n.requestReferenceSpace(o), D.setContext(n), D.start(), r.isPresenting = !0, r.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          const M = new ln(),
            T = new ln();
          function I(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert();
          }
          this.updateCamera = function (e) {
            if (null === n) return;
            y.near = A.near = v.near = e.near, y.far = A.far = v.far = e.far, x === y.near && w === y.far || (n.updateRenderState({
              depthNear: y.near,
              depthFar: y.far
            }), x = y.near, w = y.far);
            const t = e.parent,
              r = y.cameras;
            I(y, t);
            for (let e = 0; e < r.length; e++) I(r[e], t);
            y.matrixWorld.decompose(y.position, y.quaternion, y.scale), e.matrix.copy(y.matrix), e.matrix.decompose(e.position, e.quaternion, e.scale);
            const i = e.children;
            for (let e = 0, t = i.length; e < t; e++) i[e].updateMatrixWorld(!0);
            2 === r.length ? function (e, t, r) {
              M.setFromMatrixPosition(t.matrixWorld), T.setFromMatrixPosition(r.matrixWorld);
              const n = M.distanceTo(T),
                i = t.projectionMatrix.elements,
                s = r.projectionMatrix.elements,
                o = i[14] / (i[10] - 1),
                a = i[14] / (i[10] + 1),
                l = (i[9] + 1) / i[5],
                c = (i[9] - 1) / i[5],
                u = (i[8] - 1) / i[0],
                h = (s[8] + 1) / s[0],
                p = o * u,
                d = o * h,
                f = n / (-u + h),
                m = f * -u;
              t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
              const _ = o + f,
                g = a + f,
                v = p - m,
                A = d + (n - m),
                b = l * a / g * _,
                y = c * a / g * _;
              e.projectionMatrix.makePerspective(v, A, b, y, _, g);
            }(y, v, A) : y.projectionMatrix.copy(v.projectionMatrix);
          }, this.getCamera = function () {
            return y;
          }, this.getFoveation = function () {
            return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0;
          }, this.setFoveation = function (e) {
            null !== u && (u.fixedFoveation = e), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e);
          };
          let k = null;
          this.onPreAnimationFrameCallback = null;
          const D = new Is();
          D.setAnimationLoop(function (t, n) {
            if (r.onPreAnimationFrameCallback && r.onPreAnimationFrameCallback(t, n), l = n.getViewerPose(a || s), p = n, null !== l) {
              const t = l.views;
              null !== h && (e.setRenderTargetFramebuffer(m, h.framebuffer), e.setRenderTarget(m));
              let r = !1;
              t.length !== y.cameras.length && (y.cameras.length = 0, r = !0);
              for (let n = 0; n < t.length; n++) {
                const i = t[n];
                let s = null;
                if (null !== h) s = h.getViewport(i);else {
                  const t = c.getViewSubImage(u, i);
                  s = t.viewport, 0 === n && (e.setRenderTargetTextures(m, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(m));
                }
                let o = b[n];
                void 0 === o && (o = new gs(), o.layers.enable(n), o.viewport = new $r(), b[n] = o), o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === n && y.matrix.copy(o.matrix), !0 === r && y.cameras.push(o);
              }
            }
            for (let e = 0; e < _.length; e++) {
              const t = g[e],
                r = _[e];
              null !== t && void 0 !== r && r.update(t, n, a || s);
            }
            k && k(t, n), p = null;
          }), this.setAnimationLoop = function (e) {
            k = e;
          }, this.dispose = function () {};
        }
      }
      function sl(e, t) {
        function r(r, n) {
          r.opacity.value = n.opacity, n.color && r.diffuse.value.copy(n.color), n.emissive && r.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (r.map.value = n.map), n.alphaMap && (r.alphaMap.value = n.alphaMap), n.bumpMap && (r.bumpMap.value = n.bumpMap, r.bumpScale.value = n.bumpScale, n.side === m && (r.bumpScale.value *= -1)), n.displacementMap && (r.displacementMap.value = n.displacementMap, r.displacementScale.value = n.displacementScale, r.displacementBias.value = n.displacementBias), n.emissiveMap && (r.emissiveMap.value = n.emissiveMap), n.normalMap && (r.normalMap.value = n.normalMap, r.normalScale.value.copy(n.normalScale), n.side === m && r.normalScale.value.negate()), n.specularMap && (r.specularMap.value = n.specularMap), n.alphaTest > 0 && (r.alphaTest.value = n.alphaTest);
          const i = t.get(n).envMap;
          if (i) {
            r.envMap.value = i;
            const e = t.get(n).environment || i;
            r.envMapRotation.value = e ? e.rotation : 0, r.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, r.reflectivity.value = n.reflectivity, r.ior.value = n.ior, r.refractionRatio.value = n.refractionRatio;
          }
          if (n.lightMap) {
            r.lightMap.value = n.lightMap;
            const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
            r.lightMapIntensity.value = n.lightMapIntensity * t;
          }
          let s, o;
          n.aoMap && (r.aoMap.value = n.aoMap, r.aoMapIntensity.value = n.aoMapIntensity), n.map ? s = n.map : n.specularMap ? s = n.specularMap : n.displacementMap ? s = n.displacementMap : n.normalMap ? s = n.normalMap : n.bumpMap ? s = n.bumpMap : n.roughnessMap ? s = n.roughnessMap : n.metalnessMap ? s = n.metalnessMap : n.alphaMap ? s = n.alphaMap : n.emissiveMap ? s = n.emissiveMap : n.clearcoatMap ? s = n.clearcoatMap : n.clearcoatNormalMap ? s = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? s = n.clearcoatRoughnessMap : n.iridescenceMap ? s = n.iridescenceMap : n.iridescenceThicknessMap ? s = n.iridescenceThicknessMap : n.specularIntensityMap ? s = n.specularIntensityMap : n.specularColorMap ? s = n.specularColorMap : n.transmissionMap ? s = n.transmissionMap : n.thicknessMap ? s = n.thicknessMap : n.sheenColorMap ? s = n.sheenColorMap : n.sheenRoughnessMap && (s = n.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), r.uvTransform.value.copy(s.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), r.uv2Transform.value.copy(o.matrix));
        }
        return {
          refreshFogUniforms: function (e, t) {
            e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density);
          },
          refreshMaterialUniforms: function (e, n, i, s, o) {
            n.isMeshBasicMaterial || n.isMeshLambertMaterial ? r(e, n) : n.isMeshToonMaterial ? (r(e, n), function (e, t) {
              t.gradientMap && (e.gradientMap.value = t.gradientMap);
            }(e, n)) : n.isMeshPhongMaterial ? (r(e, n), function (e, t) {
              e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4);
            }(e, n)) : n.isMeshStandardMaterial ? (r(e, n), function (e, r) {
              e.roughness.value = r.roughness, e.metalness.value = r.metalness, r.roughnessMap && (e.roughnessMap.value = r.roughnessMap), r.metalnessMap && (e.metalnessMap.value = r.metalnessMap), t.get(r).envMap && (e.envMapIntensity.value = r.envMapIntensity);
            }(e, n), n.isMeshPhysicalMaterial && function (e, t, r) {
              e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === m && e.clearcoatNormalScale.value.negate())), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap)), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap);
            }(e, n, o)) : n.isMeshMatcapMaterial ? (r(e, n), function (e, t) {
              t.matcap && (e.matcap.value = t.matcap);
            }(e, n)) : n.isMeshDepthMaterial ? r(e, n) : n.isMeshDistanceMaterial ? (r(e, n), function (e, t) {
              e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance;
            }(e, n)) : n.isMeshNormalMaterial ? r(e, n) : n.isLineBasicMaterial ? (function (e, t) {
              e.diffuse.value.copy(t.color), e.opacity.value = t.opacity;
            }(e, n), n.isLineDashedMaterial && function (e, t) {
              e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale;
            }(e, n)) : n.isPointsMaterial ? function (e, t, r, n) {
              let i;
              e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * r, e.scale.value = .5 * n, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? i = t.map : t.alphaMap && (i = t.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix));
            }(e, n, i, s) : n.isSpriteMaterial ? function (e, t) {
              let r;
              e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? r = t.map : t.alphaMap && (r = t.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix));
            }(e, n) : n.isShadowMaterial ? (e.color.value.copy(n.color), e.opacity.value = n.opacity) : n.isShaderMaterial && (void 0 !== n.transmission && (e.transmission && (e.transmission.value = n.transmission), e.transmissionSamplerMap && o && (e.transmissionSamplerMap.value = o ? o.texture : null), e.transmissionSamplerSize && o && e.transmissionSamplerSize.value.set(o.width, o.height)), n.uniformsNeedUpdate = !1);
          }
        };
      }
      function ol(e, t, r, n) {
        let i = {},
          s = {},
          o = [];
        const a = r.isWebGL2 ? e.getParameter(35375) : 0;
        function l(e, t, r) {
          const n = e.value;
          if (void 0 === r[t]) return r[t] = "number" == typeof n ? n : n.clone(), !0;
          if ("number" == typeof n) {
            if (r[t] !== n) return r[t] = n, !0;
          } else {
            const e = r[t];
            if (!1 === e.equals(n)) return e.copy(n), !0;
          }
          return !1;
        }
        function c(e) {
          const t = e.value,
            r = {
              boundary: 0,
              storage: 0
            };
          return "number" == typeof t ? (r.boundary = 4, r.storage = 4) : t.isVector2 ? (r.boundary = 8, r.storage = 8) : t.isVector3 || t.isColor ? (r.boundary = 16, r.storage = 12) : t.isVector4 ? (r.boundary = 16, r.storage = 16) : t.isMatrix3 ? (r.boundary = 48, r.storage = 48) : t.isMatrix4 ? (r.boundary = 64, r.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), r;
        }
        function u(t) {
          const r = t.target;
          r.removeEventListener("dispose", u);
          const n = o.indexOf(r.__bindingPointIndex);
          o.splice(n, 1), e.deleteBuffer(i[r.id]), delete i[r.id], delete s[r.id];
        }
        return {
          bind: function (e, t) {
            const r = t.program;
            n.uniformBlockBinding(e, r);
          },
          update: function (r, h) {
            let p = i[r.id];
            void 0 === p && (function (e) {
              const t = e.uniforms;
              let r = 0;
              let n = 0;
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e],
                  s = c(i);
                if (i.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), i.__offset = r, e > 0) {
                  n = r % 16;
                  const e = 16 - n;
                  0 !== n && e - s.boundary < 0 && (r += 16 - n, i.__offset = r);
                }
                r += s.storage;
              }
              n = r % 16, n > 0 && (r += 16 - n), e.__size = r, e.__cache = {};
            }(r), p = function (t) {
              const r = function () {
                for (let e = 0; e < a; e++) if (-1 === o.indexOf(e)) return o.push(e), e;
                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
              }();
              t.__bindingPointIndex = r;
              const n = e.createBuffer(),
                i = t.__size,
                s = t.usage;
              return e.bindBuffer(35345, n), e.bufferData(35345, i, s), e.bindBuffer(35345, null), e.bindBufferBase(35345, r, n), n;
            }(r), i[r.id] = p, r.addEventListener("dispose", u));
            const d = h.program;
            n.updateUBOMapping(r, d);
            const f = t.render.frame;
            s[r.id] !== f && (function (t) {
              const r = i[t.id],
                n = t.uniforms,
                s = t.__cache;
              e.bindBuffer(35345, r);
              for (let t = 0, r = n.length; t < r; t++) {
                const r = n[t];
                if (!0 === l(r, t, s)) {
                  const t = r.value,
                    n = r.__offset;
                  "number" == typeof t ? (r.__data[0] = t, e.bufferSubData(35345, n, r.__data)) : (r.value.isMatrix3 ? (r.__data[0] = r.value.elements[0], r.__data[1] = r.value.elements[1], r.__data[2] = r.value.elements[2], r.__data[3] = r.value.elements[0], r.__data[4] = r.value.elements[3], r.__data[5] = r.value.elements[4], r.__data[6] = r.value.elements[5], r.__data[7] = r.value.elements[0], r.__data[8] = r.value.elements[6], r.__data[9] = r.value.elements[7], r.__data[10] = r.value.elements[8], r.__data[11] = r.value.elements[0]) : t.toArray(r.__data), e.bufferSubData(35345, n, r.__data));
                }
              }
              e.bindBuffer(35345, null);
            }(r), s[r.id] = f);
          },
          dispose: function () {
            for (const t in i) e.deleteBuffer(i[t]);
            o = [], i = {}, s = {};
          }
        };
      }
      function al(e = {}) {
        this.isWebGLRenderer = !0;
        const t = void 0 !== e.canvas ? e.canvas : function () {
            const e = Lr("canvas");
            return e.style.display = "block", e;
          }(),
          r = void 0 !== e.context ? e.context : null,
          i = void 0 === e.depth || e.depth,
          s = void 0 === e.stencil || e.stencil,
          o = void 0 !== e.antialias && e.antialias,
          a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          c = void 0 !== e.powerPreference ? e.powerPreference : "default",
          u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
        let h;
        h = null !== r ? r.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
        let p = null,
          d = null;
        const g = [],
          v = [];
        this.domElement = t, this.debug = {
          checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = kt, this.physicallyCorrectLights = !1, this.toneMapping = K, this.toneMappingExposure = 1, this.userData = {}, Object.defineProperties(this, {
          gammaFactor: {
            get: function () {
              return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
            },
            set: function () {
              console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            }
          }
        });
        const A = this;
        let b = !1,
          y = 0,
          x = 0,
          w = null,
          E = -1,
          S = null;
        const C = new $r(),
          M = new $r();
        let T = null,
          I = t.width,
          k = t.height,
          D = 1,
          P = null,
          B = null;
        const R = new $r(0, 0, I, k),
          L = new $r(0, 0, I, k);
        let O = !1;
        const F = new Ts();
        let U = !1,
          N = !1,
          j = null;
        const z = new Nn(),
          G = new kr(),
          V = new ln(),
          Q = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
          };
        function H() {
          return null === w ? D : 1;
        }
        let W,
          q,
          X,
          Y,
          J,
          Z,
          $,
          ee,
          te,
          re,
          ne,
          ie,
          se,
          oe,
          ae,
          le,
          ce,
          ue,
          he,
          pe,
          de,
          fe,
          me,
          _e,
          ge = r;
        function ve(e, r) {
          for (let n = 0; n < e.length; n++) {
            const i = e[n],
              s = t.getContext(i, r);
            if (null !== s) return s;
          }
          return null;
        }
        try {
          const e = {
            alpha: !0,
            depth: i,
            stencil: s,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: u
          };
          if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${n}`), t.addEventListener("webglcontextlost", we, !1), t.addEventListener("webglcontextrestored", Ee, !1), t.addEventListener("webglcontextcreationerror", Se, !1), null === ge) {
            const t = ["webgl2", "webgl", "experimental-webgl"];
            if (!0 === A.isWebGL1Renderer && t.shift(), ge = ve(t, e), null === ge) throw ve(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
          void 0 === ge.getShaderPrecisionFormat && (ge.getShaderPrecisionFormat = function () {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1
            };
          });
        } catch (e) {
          throw console.error("THREE.WebGLRenderer: " + e.message), e;
        }
        function be() {
          W = new to(ge), q = new Us(ge, W, e), W.init(q), fe = new Za(ge, W, q), X = new Ka(ge, W, q), Y = new io(), J = new Oa(), Z = new Ja(ge, W, X, J, q, fe, Y), $ = new js(A), ee = new eo(A), te = new ks(ge, q), me = new Os(ge, W, te, q), re = new ro(ge, te, Y, me), ne = new lo(ge, re, te, Y), he = new ao(ge, q, Z), le = new Ns(J), ie = new La(A, $, ee, W, q, me, le), se = new sl(A, J), oe = new ja(), ae = new Wa(W, q), ue = new Ls(A, $, X, ne, h, a), ce = new Ya(A, ne, q), _e = new ol(ge, Y, q, X), pe = new Fs(ge, W, Y, q), de = new no(ge, W, Y, q), Y.programs = ie.programs, A.capabilities = q, A.extensions = W, A.properties = J, A.renderLists = oe, A.shadowMap = ce, A.state = X, A.info = Y, A.background = ue, A.cubeuvmaps = ee;
        }
        be();
        const xe = new il(A, ge);
        function we(e) {
          e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0;
        }
        function Ee() {
          console.log("THREE.WebGLRenderer: Context Restored."), b = !1;
          const e = Y.autoReset,
            t = ce.enabled,
            r = ce.autoUpdate,
            n = ce.needsUpdate,
            i = ce.type;
          be(), Y.autoReset = e, ce.enabled = t, ce.autoUpdate = r, ce.needsUpdate = n, ce.type = i;
        }
        function Se(e) {
          console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage);
        }
        function Ce(e) {
          const t = e.target;
          t.removeEventListener("dispose", Ce), function (e) {
            (function (e) {
              const t = J.get(e).programs;
              void 0 !== t && (t.forEach(function (e) {
                ie.releaseProgram(e);
              }), e.isShaderMaterial && ie.releaseShaderCache(e));
            })(e), J.remove(e);
          }(t);
        }
        this.xr = xe, this.getContext = function () {
          return ge;
        }, this.getContextAttributes = function () {
          return ge.getContextAttributes();
        }, this.forceContextLoss = function () {
          const e = W.get("WEBGL_lose_context");
          e && e.loseContext();
        }, this.forceContextRestore = function () {
          const e = W.get("WEBGL_lose_context");
          e && e.restoreContext();
        }, this.getPixelRatio = function () {
          return D;
        }, this.setPixelRatio = function (e) {
          void 0 !== e && (D = e, this.setSize(I, k, !1));
        }, this.getSize = function (e) {
          return e.set(I, k);
        }, this.setSize = function (e, r, n) {
          xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = e, k = r, t.width = Math.floor(e * D), t.height = Math.floor(r * D), !1 !== n && (t.style.width = e + "px", t.style.height = r + "px"), this.setViewport(0, 0, e, r));
        }, this.getDrawingBufferSize = function (e) {
          return e.set(I * D, k * D).floor();
        }, this.setDrawingBufferSize = function (e, r, n) {
          I = e, k = r, D = n, t.width = Math.floor(e * n), t.height = Math.floor(r * n), this.setViewport(0, 0, e, r);
        }, this.getCurrentViewport = function (e) {
          return e.copy(C);
        }, this.getViewport = function (e) {
          return e.copy(R);
        }, this.setViewport = function (e, t, r, n) {
          e.isVector4 ? R.set(e.x, e.y, e.z, e.w) : R.set(e, t, r, n), X.viewport(C.copy(R).multiplyScalar(D).floor());
        }, this.getScissor = function (e) {
          return e.copy(L);
        }, this.setScissor = function (e, t, r, n) {
          e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, r, n), X.scissor(M.copy(L).multiplyScalar(D).floor());
        }, this.getScissorTest = function () {
          return O;
        }, this.setScissorTest = function (e) {
          X.setScissorTest(O = e);
        }, this.setOpaqueSort = function (e) {
          P = e;
        }, this.setTransparentSort = function (e) {
          B = e;
        }, this.getClearColor = function (e) {
          return e.copy(ue.getClearColor());
        }, this.setClearColor = function () {
          ue.setClearColor.apply(ue, arguments);
        }, this.getClearAlpha = function () {
          return ue.getClearAlpha();
        }, this.setClearAlpha = function () {
          ue.setClearAlpha.apply(ue, arguments);
        }, this.clear = function (e = !0, t = !0, r = !0) {
          let n = 0;
          e && (n |= 16384), t && (n |= 256), r && (n |= 1024), ge.clear(n);
        }, this.clearColor = function () {
          this.clear(!0, !1, !1);
        }, this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }, this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }, this.dispose = function () {
          t.removeEventListener("webglcontextlost", we, !1), t.removeEventListener("webglcontextrestored", Ee, !1), t.removeEventListener("webglcontextcreationerror", Se, !1), oe.dispose(), ae.dispose(), J.dispose(), $.dispose(), ee.dispose(), ne.dispose(), me.dispose(), _e.dispose(), ie.dispose(), xe.dispose(), xe.removeEventListener("sessionstart", ke), xe.removeEventListener("sessionend", De), j && (j.dispose(), j = null), Pe.stop();
        }, this.renderBufferDirect = function (e, t, r, n, i, s) {
          null === t && (t = Q);
          const o = i.isMesh && i.matrixWorld.determinant() < 0,
            a = function (e, t, r, n, i) {
              !0 !== t.isScene && (t = Q), Z.resetTextureUnits();
              const s = t.fog,
                o = n.isMeshStandardMaterial ? t.environment : null,
                a = null === w ? A.outputEncoding : !0 === w.isXRRenderTarget || w.texture.encoding && w.texture.encoding !== Dt ? w.texture.encoding : kt,
                l = (n.isMeshStandardMaterial ? ee : $).get(n.envMap || o),
                c = !0 === n.vertexColors && !!r.attributes.color && 4 === r.attributes.color.itemSize,
                u = !!n.normalMap && !!r.attributes.tangent,
                h = !!r.morphAttributes.position,
                p = !!r.morphAttributes.normal,
                f = !!r.morphAttributes.color,
                m = n.toneMapped ? A.toneMapping : K,
                _ = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color,
                g = void 0 !== _ ? _.length : 0,
                v = J.get(n),
                b = d.state.lights;
              if (!0 === U && (!0 === N || e !== S)) {
                const t = e === S && n.id === E;
                le.setState(n, e, t);
              }
              let y = !1;
              n.version === v.__version ? v.needsLights && v.lightsStateVersion !== b.state.version || v.outputEncoding !== a || i.isInstancedMesh && !1 === v.instancing ? y = !0 : i.isInstancedMesh || !0 !== v.instancing ? i.isSkinnedMesh && !1 === v.skinning ? y = !0 : i.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== l || !0 === n.fog && v.fog !== s ? y = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === le.numPlanes && v.numIntersection === le.numIntersection ? (v.vertexAlphas !== c || v.vertexTangents !== u || v.morphTargets !== h || v.morphNormals !== p || v.morphColors !== f || v.toneMapping !== m || !0 === q.isWebGL2 && v.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, v.__version = n.version);
              let x = v.currentProgram;
              !0 === y && (x = Ue(n, t, i));
              let C = !1,
                M = !1,
                T = !1;
              const I = x.getUniforms(),
                P = v.uniforms;
              if (X.useProgram(x.program) && (C = !0, M = !0, T = !0), n.id !== E && (E = n.id, M = !0), C || S !== e) {
                if (I.setValue(ge, "projectionMatrix", e.projectionMatrix), q.logarithmicDepthBuffer && I.setValue(ge, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), S !== e && (S = e, M = !0, T = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                  const t = I.map.cameraPosition;
                  void 0 !== t && t.setValue(ge, V.setFromMatrixPosition(e.matrixWorld));
                }
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && I.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && I.setValue(ge, "viewMatrix", e.matrixWorldInverse);
              }
              if (i.isSkinnedMesh) {
                I.setOptional(ge, i, "bindMatrix"), I.setOptional(ge, i, "bindMatrixInverse");
                const e = i.skeleton;
                e && (q.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), I.setValue(ge, "boneTexture", e.boneTexture, Z), I.setValue(ge, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
              }
              const B = r.morphAttributes;
              var R, L;
              (void 0 !== B.position || void 0 !== B.normal || void 0 !== B.color && !0 === q.isWebGL2) && he.update(i, r, n, x), (M || v.receiveShadow !== i.receiveShadow) && (v.receiveShadow = i.receiveShadow, I.setValue(ge, "receiveShadow", i.receiveShadow)), n.isMeshGouraudMaterial && null !== n.envMap && (P.envMap.value = l, P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), M && (I.setValue(ge, "toneMappingExposure", A.toneMappingExposure), v.needsLights && (L = T, (R = P).ambientLightColor.needsUpdate = L, R.lightProbe.needsUpdate = L, R.directionalLights.needsUpdate = L, R.directionalLightShadows.needsUpdate = L, R.pointLights.needsUpdate = L, R.pointLightShadows.needsUpdate = L, R.spotLights.needsUpdate = L, R.spotLightShadows.needsUpdate = L, R.rectAreaLights.needsUpdate = L, R.hemisphereLights.needsUpdate = L), s && !0 === n.fog && se.refreshFogUniforms(P, s), se.refreshMaterialUniforms(P, n, D, k, A.userData.transmissionRenderTarget || j), da.upload(ge, v.uniformsList, P, Z)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (da.upload(ge, v.uniformsList, P, Z), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && I.setValue(ge, "center", i.center), I.setValue(ge, "modelViewMatrix", i.modelViewMatrix), I.setValue(ge, "normalMatrix", i.normalMatrix), I.setValue(ge, "modelMatrix", i.matrixWorld);
              const O = n.extraUniformsToUpload;
              if (O && Object.entries(O).forEach(([e, t]) => I.setValue(ge, e, t.value, Z)), n.isShaderMaterial || n.isRawShaderMaterial) {
                const e = n.uniformsGroups;
                for (let t = 0, r = e.length; t < r; t++) if (q.isWebGL2) {
                  const r = e[t];
                  _e.update(r, x), _e.bind(r, x);
                } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
              }
              return x;
            }(e, t, r, n, i);
          X.setMaterial(n, o);
          let l = r.index;
          const c = r.attributes.position;
          if (null === l) {
            if (void 0 === c || 0 === c.count) return;
          } else if (0 === l.count) return;
          let u,
            h = 1;
          !0 === n.wireframe && (l = re.getWireframeAttribute(r), h = 2), me.setup(i, n, a, r, l);
          let p = pe;
          null !== l && (u = te.get(l), p = de, p.setIndex(u));
          const f = null !== l ? l.count : c.count,
            m = r.drawRange.start * h,
            _ = r.drawRange.count * h,
            g = null !== s ? s.start * h : 0,
            v = null !== s ? s.count * h : 1 / 0,
            b = Math.max(m, g),
            y = Math.min(f, m + _, g + v) - 1,
            x = Math.max(0, y - b + 1);
          if (0 !== x) {
            if (i.isMesh) !0 === n.wireframe ? (X.setLineWidth(n.wireframeLinewidth * H()), p.setMode(1)) : p.setMode(4);else if (i.isLine) {
              let e = n.linewidth;
              void 0 === e && (e = 1), X.setLineWidth(e * H()), i.isLineSegments ? p.setMode(1) : i.isLineLoop ? p.setMode(2) : p.setMode(3);
            } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
            if (i.isInstancedMesh) p.renderInstances(b, x, i.count);else if (r.isInstancedBufferGeometry) {
              const e = Math.min(r.instanceCount, r._maxInstanceCount);
              p.renderInstances(b, x, e);
            } else p.render(b, x);
          }
        }, this.compile = function (e, t) {
          function r(e, t, r) {
            !0 === e.transparent && e.side === _ ? (e.side = m, e.needsUpdate = !0, Ue(e, t, r), e.side = f, e.needsUpdate = !0, Ue(e, t, r), e.side = _) : Ue(e, t, r);
          }
          d = ae.get(e), d.init(), v.push(d), e.traverseVisible(function (e) {
            e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e));
          }), d.setupLights(A.physicallyCorrectLights), e.traverse(function (t) {
            const n = t.material;
            if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++) r(n[i], e, t);else r(n, e, t);
          }), v.pop(), d = null;
        };
        let Ie = null;
        function ke() {
          Pe.stop();
        }
        function De() {
          Pe.start();
        }
        const Pe = new Is();
        function Be(e, t, r, n) {
          if (!1 === e.visible) return;
          if (e.layers.test(t.layers)) if (e.isGroup) r = e.renderOrder;else if (e.isLOD) !0 === e.autoUpdate && e.update(t);else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);else if (e.isSprite) {
            if (!e.frustumCulled || F.intersectsSprite(e)) {
              n && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
              const t = ne.update(e),
                i = e.material;
              i.visible && p.push(e, t, i, r, V.z, null);
            }
          } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Y.render.frame && (e.skeleton.update(), e.skeleton.frame = Y.render.frame), !e.frustumCulled || F.intersectsObject(e))) {
            n && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
            const t = ne.update(e),
              i = e.material;
            if (Array.isArray(i)) {
              const n = t.groups;
              for (let s = 0, o = n.length; s < o; s++) {
                const o = n[s],
                  a = i[o.materialIndex];
                a && a.visible && p.push(e, t, a, r, V.z, o);
              }
            } else i.visible && p.push(e, t, i, r, V.z, null);
          }
          const i = e.children;
          for (let e = 0, s = i.length; e < s; e++) Be(i[e], t, r, n);
        }
        function Le(e, t, r, n) {
          const i = e.opaque,
            s = e.transmissive,
            a = e.transparent;
          if (d.setupLightsView(r), void 0 === A.userData.transmissionRender && !1 !== A.userData.renderTransmissionPass && s.length > 0 && function (e, t, r) {
            console.error("three.js internal render transmission pass should not be called");
            const n = q.isWebGL2;
            null === j && (j = new en(1, 1, {
              generateMipmaps: !0,
              type: W.has("EXT_color_buffer_half_float") ? Te : ye,
              minFilter: Ae,
              samples: n && !0 === o ? 4 : 0
            })), A.getDrawingBufferSize(G), n ? j.setSize(G.x, G.y) : j.setSize(Cr(G.x), Cr(G.y));
            const i = A.getRenderTarget();
            A.setRenderTarget(j), A.clear();
            const s = A.toneMapping;
            A.toneMapping = K, Oe(e, t, r), A.toneMapping = s, Z.updateMultisampleRenderTarget(j), Z.updateRenderTargetMipmap(j), A.setRenderTarget(i);
          }([...i, ...a], t, r), n && X.viewport(C.copy(n)), !1 !== A.userData.opaqueRender && i.length > 0 && Oe(i, t, r), !1 !== A.userData.transparentRender && a.length > 0 && Oe(a, t, r), !1 !== A.userData.transmissionRender && s.length > 0) {
            j || (j = new en(1, 1));
            const e = A.userData.transmissionRenderTarget.texture,
              n = q.isWebGL2,
              i = e.generateMipmaps,
              o = e.minFilter;
            n && A.userData.blurTransmissionTarget && (e.generateMipmaps = !0, e.minFilter = Ae, e.needsUpdate = !0, Z.updateRenderTargetMipmap(A.userData.transmissionRenderTarget)), Oe(s, t, r), n && A.userData.blurTransmissionTarget && (e.generateMipmaps = i, e.minFilter = o, e.needsUpdate = !0, Z.updateRenderTargetMipmap(A.userData.transmissionRenderTarget));
          }
          X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1);
        }
        function Oe(e, t, r) {
          const n = {
            ...A.userData
          };
          A.userData.opaqueRender = void 0, A.userData.transparentRender = void 0, A.userData.transmissionRender = void 0, A.userData.backgroundRender = void 0;
          const i = !0 === t.isScene ? t.overrideMaterial : null;
          for (let n = 0, s = e.length; n < s; n++) {
            const s = e[n],
              o = s.object,
              a = s.geometry,
              l = null === i ? s.material : i,
              c = s.group;
            o.layers.test(r.layers) && Fe(o, t, r, a, l, c);
          }
          Object.assign(A.userData, n);
        }
        function Fe(e, t, r, n, i, s) {
          e.onBeforeRender(A, t, r, n, i, s), e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(A, t, r, n, e, s), !0 === i.transparent && i.side === _ ? (i.side = m, i.needsUpdate = !0, A.renderBufferDirect(r, t, n, i, e, s), i.side = f, i.needsUpdate = !0, A.renderBufferDirect(r, t, n, i, e, s), i.side = _) : A.renderBufferDirect(r, t, n, i, e, s), e.onAfterRender(A, t, r, n, i, s), i.onAfterRender(A, t, r, n, e, s);
        }
        function Ue(e, t, r) {
          !0 !== t.isScene && (t = Q);
          const n = J.get(e),
            i = d.state.lights,
            s = d.state.shadowsArray,
            o = i.state.version,
            a = ie.getParameters(e, i.state, s, t, r),
            l = ie.getProgramCacheKey(a);
          let c = n.programs;
          n.environment = e.isMeshStandardMaterial ? t.environment : null, n.fog = t.fog, n.envMap = (e.isMeshStandardMaterial ? ee : $).get(e.envMap || n.environment), void 0 === c && (e.addEventListener("dispose", Ce), c = new Map(), n.programs = c);
          let u = c.get(l);
          if (void 0 !== u) {
            if (n.currentProgram === u && n.lightsStateVersion === o) return Ne(e, a), u;
          } else a.uniforms = ie.getUniforms(e), e.onBuild(r, a, A), e.onBeforeCompile(a, A), u = ie.acquireProgram(a, l), c.set(l, u), n.uniforms = a.uniforms;
          const h = n.uniforms;
          (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = le.uniform), Ne(e, a), n.needsLights = function (e) {
            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights;
          }(e), n.lightsStateVersion = o, n.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotLightMatrix.value = i.state.spotLightMatrix, h.spotLightMap.value = i.state.spotLightMap, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
          const p = u.getUniforms(),
            f = da.seqWithValue(p.seq, h);
          return n.currentProgram = u, n.uniformsList = f, u;
        }
        function Ne(e, t) {
          const r = J.get(e);
          r.outputEncoding = t.outputEncoding, r.instancing = t.instancing, r.skinning = t.skinning, r.morphTargets = t.morphTargets, r.morphNormals = t.morphNormals, r.morphColors = t.morphColors, r.morphTargetsCount = t.morphTargetsCount, r.numClippingPlanes = t.numClippingPlanes, r.numIntersection = t.numClipIntersection, r.vertexAlphas = t.vertexAlphas, r.vertexTangents = t.vertexTangents, r.toneMapping = t.toneMapping;
        }
        Pe.setAnimationLoop(function (e) {
          Ie && Ie(e);
        }), "undefined" != typeof self && Pe.setContext(self), this.setAnimationLoop = function (e) {
          Ie = e, xe.setAnimationLoop(e), null === e ? Pe.stop() : Pe.start();
        }, xe.addEventListener("sessionstart", ke), xe.addEventListener("sessionend", De), this.render = function (e, t) {
          if (void 0 === t || !0 === t.isCamera) {
            if (!0 !== b) {
              if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t), t = xe.getCamera()), !0 === e.isScene && e.onBeforeRender(A, e, t, w), d = ae.get(e, v.length), d.init(), v.push(d), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), F.setFromProjectionMatrix(z), N = this.localClippingEnabled, U = le.init(this.clippingPlanes, N, t), p = oe.get(e, g.length), p.init(), g.push(p), Be(e, t, 0, A.sortObjects), p.finish(), !0 === A.sortObjects && p.sort(P, B), A.userData.shadowMapRender) {
                !0 === U && le.beginShadows();
                const r = d.state.shadowsArray;
                r.length > 0 && ce.render(r, e, t), !0 === U && le.endShadows();
              }
              if (!0 === this.info.autoReset && this.info.reset(), !1 !== A.userData.backgroundRender && ue.render(p, e), !1 !== A.userData.sceneRender) if (d.setupLights(A.physicallyCorrectLights), t.isArrayCamera) {
                const r = t.cameras;
                for (let t = 0, n = r.length; t < n; t++) {
                  const n = r[t];
                  Le(p, e, n, n.viewport);
                }
              } else Le(p, e, t);
              null !== w && (Z.updateMultisampleRenderTarget(w), Z.updateRenderTargetMipmap(w)), !0 === e.isScene && e.onAfterRender(A, e, t), me.resetDefaultState(), E = -1, S = null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null;
            }
          } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        }, this.getActiveCubeFace = function () {
          return y;
        }, this.getActiveMipmapLevel = function () {
          return x;
        }, this.getRenderTarget = function () {
          return w;
        }, this.setRenderTargetTextures = function (e, t, r) {
          J.get(e.texture).__webglTexture = t, J.get(e.depthTexture).__webglTexture = r;
          const n = J.get(e);
          n.__hasExternalTextures = !0, n.__hasExternalTextures && (n.__autoAllocateDepthBuffer = void 0 === r, n.__autoAllocateDepthBuffer || !0 === W.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n.__useRenderToTexture = !1));
        }, this.setRenderTargetFramebuffer = function (e, t) {
          const r = J.get(e);
          r.__webglFramebuffer = t, r.__useDefaultFramebuffer = void 0 === t;
        }, this.setRenderTarget = function (e, t = 0, r = 0) {
          w = e, y = t, x = r;
          let n = !0;
          if (e) {
            const t = J.get(e);
            void 0 !== t.__useDefaultFramebuffer ? (X.bindFramebuffer(36160, null), n = !1) : void 0 === t.__webglFramebuffer ? Z.setupRenderTarget(e) : t.__hasExternalTextures && Z.rebindTextures(e, J.get(e.texture).__webglTexture, J.get(e.depthTexture).__webglTexture);
          }
          let i = null,
            s = !1,
            o = !1;
          if (e) {
            const r = e.texture;
            (r.isData3DTexture || r.isDataArrayTexture) && (o = !0);
            const n = J.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget ? (i = n[t], s = !0) : i = q.isWebGL2 && e.samples > 0 && !1 === Z.useMultisampledRTT(e) ? J.get(e).__webglMultisampledFramebuffer : n, C.copy(e.viewport), M.copy(e.scissor), T = e.scissorTest;
          } else C.copy(R).multiplyScalar(D).floor(), M.copy(L).multiplyScalar(D).floor(), T = O;
          if (X.bindFramebuffer(36160, i) && q.drawBuffers && n && X.drawBuffers(e, i), X.viewport(C), X.scissor(M), X.setScissorTest(T), s) {
            const n = J.get(e.texture);
            ge.framebufferTexture2D(36160, 36064, 34069 + t, n.__webglTexture, r);
          } else if (o) {
            const n = J.get(e.texture),
              i = t || 0;
            ge.framebufferTextureLayer(36160, 36064, n.__webglTexture, r || 0, i);
          }
          E = -1;
        }, this.readRenderTargetPixels = function (e, t, r, n, i, s, o) {
          if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let a = J.get(e).__webglFramebuffer;
          if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
            X.bindFramebuffer(36160, a);
            try {
              const o = e.texture,
                a = o.format,
                l = o.type;
              if (a !== Re && fe.convert(a) !== ge.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              const c = l === Te && (W.has("EXT_color_buffer_half_float") || q.isWebGL2 && W.has("EXT_color_buffer_float"));
              if (!(l === ye || fe.convert(l) === ge.getParameter(35738) || l === Me && (q.isWebGL2 || W.has("OES_texture_float") || W.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              t >= 0 && t <= e.width - n && r >= 0 && r <= e.height - i && ge.readPixels(t, r, n, i, fe.convert(a), fe.convert(l), s);
            } finally {
              const e = null !== w ? J.get(w).__webglFramebuffer : null;
              X.bindFramebuffer(36160, e);
            }
          }
        }, this.copyFramebufferToTexture = function (e, t, r = 0) {
          const n = Math.pow(2, -r),
            i = Math.floor(t.image.width * n),
            s = Math.floor(t.image.height * n);
          Z.setTexture2D(t, 0), ge.copyTexSubImage2D(3553, r, 0, 0, e.x, e.y, i, s), X.unbindTexture();
        }, this.copyTextureToTexture = function (e, t, r, n = 0) {
          const i = t.image.width,
            s = t.image.height,
            o = fe.convert(r.format),
            a = fe.convert(r.type);
          Z.setTexture2D(r, 0), ge.pixelStorei(37440, r.flipY), ge.pixelStorei(37441, r.premultiplyAlpha), ge.pixelStorei(3317, r.unpackAlignment), t.isDataTexture ? ge.texSubImage2D(3553, n, e.x, e.y, i, s, o, a, t.image.data) : t.isCompressedTexture ? ge.compressedTexSubImage2D(3553, n, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ge.texSubImage2D(3553, n, e.x, e.y, o, a, t.image), 0 === n && r.generateMipmaps && ge.generateMipmap(3553), X.unbindTexture();
        }, this.copyTextureToTexture3D = function (e, t, r, n, i = 0) {
          if (A.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          const s = e.max.x - e.min.x + 1,
            o = e.max.y - e.min.y + 1,
            a = e.max.z - e.min.z + 1,
            l = fe.convert(n.format),
            c = fe.convert(n.type);
          let u;
          if (n.isData3DTexture) Z.setTexture3D(n, 0), u = 32879;else {
            if (!n.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            Z.setTexture2DArray(n, 0), u = 35866;
          }
          ge.pixelStorei(37440, n.flipY), ge.pixelStorei(37441, n.premultiplyAlpha), ge.pixelStorei(3317, n.unpackAlignment);
          const h = ge.getParameter(3314),
            p = ge.getParameter(32878),
            d = ge.getParameter(3316),
            f = ge.getParameter(3315),
            m = ge.getParameter(32877),
            _ = r.isCompressedTexture ? r.mipmaps[0] : r.image;
          ge.pixelStorei(3314, _.width), ge.pixelStorei(32878, _.height), ge.pixelStorei(3316, e.min.x), ge.pixelStorei(3315, e.min.y), ge.pixelStorei(32877, e.min.z), r.isDataTexture || r.isData3DTexture ? ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, _.data) : r.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ge.compressedTexSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, _.data)) : ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, _), ge.pixelStorei(3314, h), ge.pixelStorei(32878, p), ge.pixelStorei(3316, d), ge.pixelStorei(3315, f), ge.pixelStorei(32877, m), 0 === i && n.generateMipmaps && ge.generateMipmap(u), X.unbindTexture();
        }, this.initTexture = function (e) {
          e.isCubeTexture ? Z.setTextureCube(e, 0) : e.isData3DTexture ? Z.setTexture3D(e, 0) : e.isDataArrayTexture ? Z.setTexture2DArray(e, 0) : Z.setTexture2D(e, 0), X.unbindTexture();
        }, this.resetState = function () {
          y = 0, x = 0, w = null, X.reset(), me.reset();
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
      class ll extends al {}
      ll.prototype.isWebGL1Renderer = !0;
      class cl {
        constructor(e, t = 25e-5) {
          this.isFogExp2 = !0, this.name = "", this.color = new Wr(e), this.density = t;
        }
        clone() {
          return new cl(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      }
      class ul {
        constructor(e, t = 1, r = 1e3) {
          this.isFog = !0, this.name = "", this.color = new Wr(e), this.near = t, this.far = r;
        }
        clone() {
          return new ul(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      }
      class hl extends ui {
        constructor() {
          super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(e, t) {
          return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
        }
        get autoUpdate() {
          return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
        }
        set autoUpdate(e) {
          console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
        }
      }
      class pl {
        constructor(e, t) {
          this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = nr, this.updateRange = {
            offset: 0,
            count: -1
          }, this.version = 0, this.uuid = br();
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        copy(e) {
          return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, r) {
          e *= this.stride, r *= t.stride;
          for (let n = 0, i = this.stride; n < i; n++) this.array[e + n] = t.array[r + n];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = br()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            r = new this.constructor(t, this.stride);
          return r.setUsage(this.usage), r;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        toJSON(e) {
          return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = br()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const dl = new ln();
      class fl {
        constructor(e, t, r, n = !1) {
          this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = !0 === n;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, r = this.data.count; t < r; t++) dl.fromBufferAttribute(this, t), dl.applyMatrix4(e), this.setXYZ(t, dl.x, dl.y, dl.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, r = this.count; t < r; t++) dl.fromBufferAttribute(this, t), dl.applyNormalMatrix(e), this.setXYZ(t, dl.x, dl.y, dl.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, r = this.count; t < r; t++) dl.fromBufferAttribute(this, t), dl.transformDirection(e), this.setXYZ(t, dl.x, dl.y, dl.z);
          return this;
        }
        setX(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
          return this.normalized && (t = Tr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Mr(t, this.array)), t;
        }
        setXY(e, t, r) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
        }
        setXYZ(e, t, r, n) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array), n = Tr(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this;
        }
        setXYZW(e, t, r, n, i) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = Tr(t, this.array), r = Tr(r, this.array), n = Tr(n, this.array), i = Tr(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this.data.array[e + 3] = i, this;
        }
        clone(e) {
          if (void 0 === e) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const r = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[r + t]);
            }
            return new Mi(new this.array.constructor(e), this.itemSize, this.normalized);
          }
          return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new fl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
          if (void 0 === e) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const r = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[r + t]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: e,
              normalized: this.normalized
            };
          }
          return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      class ml extends wi {
        constructor(e) {
          super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Wr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      let _l;
      const gl = new ln(),
        vl = new ln(),
        Al = new ln(),
        bl = new kr(),
        yl = new kr(),
        xl = new Nn(),
        wl = new ln(),
        El = new ln(),
        Sl = new ln(),
        Cl = new kr(),
        Ml = new kr(),
        Tl = new kr();
      class Il extends ui {
        constructor(e) {
          if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === _l) {
            _l = new Hi();
            const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
              t = new pl(e, 5);
            _l.setIndex([0, 1, 2, 0, 2, 3]), _l.setAttribute("position", new fl(t, 3, 0, !1)), _l.setAttribute("uv", new fl(t, 2, 3, !1));
          }
          this.geometry = _l, this.material = void 0 !== e ? e : new ml(), this.center = new kr(.5, .5);
        }
        raycast(e, t) {
          null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), vl.setFromMatrixScale(this.matrixWorld), xl.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Al.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && vl.multiplyScalar(-Al.z);
          const r = this.material.rotation;
          let n, i;
          0 !== r && (i = Math.cos(r), n = Math.sin(r));
          const s = this.center;
          kl(wl.set(-.5, -.5, 0), Al, s, vl, n, i), kl(El.set(.5, -.5, 0), Al, s, vl, n, i), kl(Sl.set(.5, .5, 0), Al, s, vl, n, i), Cl.set(0, 0), Ml.set(1, 0), Tl.set(1, 1);
          let o = e.ray.intersectTriangle(wl, El, Sl, !1, gl);
          if (null === o && (kl(El.set(-.5, .5, 0), Al, s, vl, n, i), Ml.set(0, 1), o = e.ray.intersectTriangle(wl, Sl, El, !1, gl), null === o)) return;
          const a = e.ray.origin.distanceTo(gl);
          a < e.near || a > e.far || t.push({
            distance: a,
            point: gl.clone(),
            uv: yi.getUV(gl, wl, El, Sl, Cl, Ml, Tl, new kr()),
            face: null,
            object: this
          });
        }
        copy(e, t) {
          return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this;
        }
      }
      function kl(e, t, r, n, i, s) {
        bl.subVectors(e, r).addScalar(.5).multiply(n), void 0 !== i ? (yl.x = s * bl.x - i * bl.y, yl.y = i * bl.x + s * bl.y) : yl.copy(bl), e.copy(t), e.x += yl.x, e.y += yl.y, e.applyMatrix4(xl);
      }
      const Dl = new ln(),
        Pl = new ln();
      class Bl extends ui {
        constructor() {
          super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
              enumerable: !0,
              value: []
            },
            isLOD: {
              value: !0
            }
          }), this.autoUpdate = !0;
        }
        copy(e) {
          super.copy(e, !1);
          const t = e.levels;
          for (let e = 0, r = t.length; e < r; e++) {
            const r = t[e];
            this.addLevel(r.object.clone(), r.distance);
          }
          return this.autoUpdate = e.autoUpdate, this;
        }
        addLevel(e, t = 0) {
          t = Math.abs(t);
          const r = this.levels;
          let n;
          for (n = 0; n < r.length && !(t < r[n].distance); n++);
          return r.splice(n, 0, {
            distance: t,
            object: e
          }), this.add(e), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(e) {
          const t = this.levels;
          if (t.length > 0) {
            let r, n;
            for (r = 1, n = t.length; r < n && !(e < t[r].distance); r++);
            return t[r - 1].object;
          }
          return null;
        }
        raycast(e, t) {
          if (this.levels.length > 0) {
            Dl.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Dl);
            this.getObjectForDistance(r).raycast(e, t);
          }
        }
        update(e) {
          const t = this.levels;
          if (t.length > 1) {
            Dl.setFromMatrixPosition(e.matrixWorld), Pl.setFromMatrixPosition(this.matrixWorld);
            const r = Dl.distanceTo(Pl) / e.zoom;
            let n, i;
            for (t[0].object.visible = !0, n = 1, i = t.length; n < i && r >= t[n].distance; n++) t[n - 1].object.visible = !1, t[n].object.visible = !0;
            for (this._currentLevel = n - 1; n < i; n++) t[n].object.visible = !1;
          }
        }
        toJSON(e) {
          const t = super.toJSON(e);
          !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
          const r = this.levels;
          for (let e = 0, n = r.length; e < n; e++) {
            const n = r[e];
            t.object.levels.push({
              object: n.object.uuid,
              distance: n.distance
            });
          }
          return t;
        }
      }
      const Rl = new ln(),
        Ll = new $r(),
        Ol = new $r(),
        Fl = new ln(),
        Ul = new Nn();
      class Nl extends cs {
        constructor(e, t) {
          super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Nn(), this.bindMatrixInverse = new Nn();
        }
        copy(e, t) {
          return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
        }
        bind(e, t) {
          this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new $r(),
            t = this.geometry.attributes.skinWeight;
          for (let r = 0, n = t.count; r < n; r++) {
            e.fromBufferAttribute(t, r);
            const n = 1 / e.manhattanLength();
            n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        boneTransform(e, t) {
          const r = this.skeleton,
            n = this.geometry;
          Ll.fromBufferAttribute(n.attributes.skinIndex, e), Ol.fromBufferAttribute(n.attributes.skinWeight, e), Rl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
          for (let e = 0; e < 4; e++) {
            const n = Ol.getComponent(e);
            if (0 !== n) {
              const i = Ll.getComponent(e);
              Ul.multiplyMatrices(r.bones[i].matrixWorld, r.boneInverses[i]), t.addScaledVector(Fl.copy(Rl).applyMatrix4(Ul), n);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class jl extends ui {
        constructor() {
          super(), this.isBone = !0, this.type = "Bone";
        }
      }
      class zl extends Zr {
        constructor(e = null, t = 1, r = 1, n, i, s, o, a, l = he, c = he, u, h) {
          super(null, s, o, a, l, c, n, i, u, h), this.isDataTexture = !0, this.image = {
            data: e,
            width: t,
            height: r
          }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
      }
      const Gl = new Nn(),
        Vl = new Nn();
      class Ql {
        constructor(e = [], t = []) {
          this.uuid = br(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Nn());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new Nn();
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            r = this.boneMatrices,
            n = this.boneTexture;
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n] ? e[n].matrixWorld : Vl;
            Gl.multiplyMatrices(i, t[n]), Gl.toArray(r, 16 * n);
          }
          null !== n && (n.needsUpdate = !0);
        }
        clone() {
          return new Ql(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(4 * this.bones.length);
          e = Sr(e), e = Math.max(e, 4);
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const r = new zl(t, e, e, Re, Me);
          return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this;
        }
        getBoneByName(e) {
          for (let t = 0, r = this.bones.length; t < r; t++) {
            const r = this.bones[t];
            if (r.name === e) return r;
          }
        }
        dispose() {
          null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let r = 0, n = e.bones.length; r < n; r++) {
            const n = e.bones[r];
            let i = t[n];
            void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", n), i = new jl()), this.bones.push(i), this.boneInverses.push(new Nn().fromArray(e.boneInverses[r]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          e.uuid = this.uuid;
          const t = this.bones,
            r = this.boneInverses;
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.bones.push(i.uuid);
            const s = r[n];
            e.boneInverses.push(s.toArray());
          }
          return e;
        }
      }
      class Hl extends Mi {
        constructor(e, t, r, n = 1) {
          super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
        }
      }
      const Wl = new Nn(),
        ql = new Nn(),
        Xl = [],
        Yl = new cs();
      class Kl extends cs {
        constructor(e, t, r) {
          super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Hl(new Float32Array(16 * r), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1;
        }
        copy(e, t) {
          return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, 3 * e);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        }
        raycast(e, t) {
          const r = this.matrixWorld,
            n = this.count;
          if (Yl.geometry = this.geometry, Yl.material = this.material, void 0 !== Yl.material) for (let i = 0; i < n; i++) {
            this.getMatrixAt(i, Wl), ql.multiplyMatrices(r, Wl), Yl.matrixWorld = ql, Yl.raycast(e, Xl);
            for (let e = 0, r = Xl.length; e < r; e++) {
              const r = Xl[e];
              r.instanceId = i, r.object = this, t.push(r);
            }
            Xl.length = 0;
          }
        }
        setColorAt(e, t) {
          null === this.instanceColor && (this.instanceColor = new Hl(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class Jl extends wi {
        constructor(e) {
          super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Wr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
      }
      const Zl = new ln(),
        $l = new ln(),
        ec = new Nn(),
        tc = new Un(),
        rc = new kn();
      class nc extends ui {
        constructor(e = new Hi(), t = new Jl()) {
          super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              r = [0];
            for (let e = 1, n = t.count; e < n; e++) Zl.fromBufferAttribute(t, e - 1), $l.fromBufferAttribute(t, e), r[e] = r[e - 1], r[e] += Zl.distanceTo($l);
            e.setAttribute("lineDistance", new Oi(r, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e, t) {
          const r = this.geometry,
            n = this.matrixWorld,
            i = e.params.Line.threshold,
            s = r.drawRange;
          if (null === r.boundingSphere && r.computeBoundingSphere(), rc.copy(r.boundingSphere), rc.applyMatrix4(n), rc.radius += i, !1 === e.ray.intersectsSphere(rc)) return;
          ec.copy(n).invert(), tc.copy(e.ray).applyMatrix4(ec);
          const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = new ln(),
            c = new ln(),
            u = new ln(),
            h = new ln(),
            p = this.isLineSegments ? 2 : 1,
            d = r.index,
            f = r.attributes.position;
          if (null !== d) for (let r = Math.max(0, s.start), n = Math.min(d.count, s.start + s.count) - 1; r < n; r += p) {
            const n = d.getX(r),
              i = d.getX(r + 1);
            if (l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, i), tc.distanceSqToSegment(l, c, h, u) > a) continue;
            h.applyMatrix4(this.matrixWorld);
            const s = e.ray.origin.distanceTo(h);
            s < e.near || s > e.far || t.push({
              distance: s,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              object: this
            });
          } else for (let r = Math.max(0, s.start), n = Math.min(f.count, s.start + s.count) - 1; r < n; r += p) {
            if (l.fromBufferAttribute(f, r), c.fromBufferAttribute(f, r + 1), tc.distanceSqToSegment(l, c, h, u) > a) continue;
            h.applyMatrix4(this.matrixWorld);
            const n = e.ray.origin.distanceTo(h);
            n < e.near || n > e.far || t.push({
              distance: n,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const r = e[t[0]];
            if (void 0 !== r) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, t = r.length; e < t; e++) {
                const t = r[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
              }
            }
          }
        }
      }
      const ic = new ln(),
        sc = new ln();
      class oc extends nc {
        constructor(e, t) {
          super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              r = [];
            for (let e = 0, n = t.count; e < n; e += 2) ic.fromBufferAttribute(t, e), sc.fromBufferAttribute(t, e + 1), r[e] = 0 === e ? 0 : r[e - 1], r[e + 1] = r[e] + ic.distanceTo(sc);
            e.setAttribute("lineDistance", new Oi(r, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class ac extends nc {
        constructor(e, t) {
          super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
        }
      }
      class lc extends wi {
        constructor(e) {
          super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Wr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      const cc = new Nn(),
        uc = new Un(),
        hc = new kn(),
        pc = new ln();
      class dc extends ui {
        constructor(e = new Hi(), t = new lc()) {
          super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
          const r = this.geometry,
            n = this.matrixWorld,
            i = e.params.Points.threshold,
            s = r.drawRange;
          if (null === r.boundingSphere && r.computeBoundingSphere(), hc.copy(r.boundingSphere), hc.applyMatrix4(n), hc.radius += i, !1 === e.ray.intersectsSphere(hc)) return;
          cc.copy(n).invert(), uc.copy(e.ray).applyMatrix4(cc);
          const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = r.index,
            c = r.attributes.position;
          if (null !== l) for (let r = Math.max(0, s.start), i = Math.min(l.count, s.start + s.count); r < i; r++) {
            const i = l.getX(r);
            pc.fromBufferAttribute(c, i), fc(pc, i, a, n, e, t, this);
          } else for (let r = Math.max(0, s.start), i = Math.min(c.count, s.start + s.count); r < i; r++) pc.fromBufferAttribute(c, r), fc(pc, r, a, n, e, t, this);
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const r = e[t[0]];
            if (void 0 !== r) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, t = r.length; e < t; e++) {
                const t = r[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
              }
            }
          }
        }
      }
      function fc(e, t, r, n, i, s, o) {
        const a = uc.distanceSqToPoint(e);
        if (a < r) {
          const r = new ln();
          uc.closestPointToPoint(e, r), r.applyMatrix4(n);
          const l = i.ray.origin.distanceTo(r);
          if (l < i.near || l > i.far) return;
          s.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: r,
            index: t,
            face: null,
            object: o
          });
        }
      }
      class mc extends Zr {
        constructor(e, t, r, n, i, s, o, a, l) {
          super(e, t, r, n, i, s, o, a, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : _e, this.magFilter = void 0 !== i ? i : _e, this.generateMipmaps = !1;
          const c = this;
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
            c.needsUpdate = !0, e.requestVideoFrameCallback(t);
          });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        }
      }
      class _c extends Zr {
        constructor(e, t, r) {
          super({
            width: e,
            height: t
          }), this.isFramebufferTexture = !0, this.format = r, this.magFilter = he, this.minFilter = he, this.generateMipmaps = !1, this.needsUpdate = !0;
        }
      }
      class gc extends Zr {
        constructor(e, t, r, n, i, s, o, a, l, c, u, h) {
          super(null, s, o, a, l, c, n, i, u, h), this.isCompressedTexture = !0, this.image = {
            width: t,
            height: r
          }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
        }
      }
      class vc extends Zr {
        constructor(e, t, r, n, i, s, o, a, l) {
          super(e, t, r, n, i, s, o, a, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
        }
      }
      class Ac {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200;
        }
        getPoint() {
          return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        }
        getPointAt(e, t) {
          const r = this.getUtoTmapping(e);
          return this.getPoint(r, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let r,
            n = this.getPoint(0),
            i = 0;
          t.push(0);
          for (let s = 1; s <= e; s++) r = this.getPoint(s / e), i += r.distanceTo(n), t.push(i), n = r;
          return this.cacheArcLengths = t, t;
        }
        updateArcLengths() {
          this.needsUpdate = !0, this.getLengths();
        }
        getUtoTmapping(e, t) {
          const r = this.getLengths();
          let n = 0;
          const i = r.length;
          let s;
          s = t || e * r[i - 1];
          let o,
            a = 0,
            l = i - 1;
          for (; a <= l;) if (n = Math.floor(a + (l - a) / 2), o = r[n] - s, o < 0) a = n + 1;else {
            if (!(o > 0)) {
              l = n;
              break;
            }
            l = n - 1;
          }
          if (n = l, r[n] === s) return n / (i - 1);
          const c = r[n];
          return (n + (s - c) / (r[n + 1] - c)) / (i - 1);
        }
        getTangent(e, t) {
          const r = 1e-4;
          let n = e - r,
            i = e + r;
          n < 0 && (n = 0), i > 1 && (i = 1);
          const s = this.getPoint(n),
            o = this.getPoint(i),
            a = t || (s.isVector2 ? new kr() : new ln());
          return a.copy(o).sub(s).normalize(), a;
        }
        getTangentAt(e, t) {
          const r = this.getUtoTmapping(e);
          return this.getTangent(r, t);
        }
        computeFrenetFrames(e, t) {
          const r = new ln(),
            n = [],
            i = [],
            s = [],
            o = new ln(),
            a = new Nn();
          for (let t = 0; t <= e; t++) {
            const r = t / e;
            n[t] = this.getTangentAt(r, new ln());
          }
          i[0] = new ln(), s[0] = new ln();
          let l = Number.MAX_VALUE;
          const c = Math.abs(n[0].x),
            u = Math.abs(n[0].y),
            h = Math.abs(n[0].z);
          c <= l && (l = c, r.set(1, 0, 0)), u <= l && (l = u, r.set(0, 1, 0)), h <= l && r.set(0, 0, 1), o.crossVectors(n[0], r).normalize(), i[0].crossVectors(n[0], o), s[0].crossVectors(n[0], i[0]);
          for (let t = 1; t <= e; t++) {
            if (i[t] = i[t - 1].clone(), s[t] = s[t - 1].clone(), o.crossVectors(n[t - 1], n[t]), o.length() > Number.EPSILON) {
              o.normalize();
              const e = Math.acos(yr(n[t - 1].dot(n[t]), -1, 1));
              i[t].applyMatrix4(a.makeRotationAxis(o, e));
            }
            s[t].crossVectors(n[t], i[t]);
          }
          if (!0 === t) {
            let t = Math.acos(yr(i[0].dot(i[e]), -1, 1));
            t /= e, n[0].dot(o.crossVectors(i[0], i[e])) > 0 && (t = -t);
            for (let r = 1; r <= e; r++) i[r].applyMatrix4(a.makeRotationAxis(n[r], t * r)), s[r].crossVectors(n[r], i[r]);
          }
          return {
            tangents: n,
            normals: i,
            binormals: s
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
        }
        fromJSON(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
      }
      class bc extends Ac {
        constructor(e = 0, t = 0, r = 1, n = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) {
          super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a;
        }
        getPoint(e, t) {
          const r = t || new kr(),
            n = 2 * Math.PI;
          let i = this.aEndAngle - this.aStartAngle;
          const s = Math.abs(i) < Number.EPSILON;
          for (; i < 0;) i += n;
          for (; i > n;) i -= n;
          i < Number.EPSILON && (i = s ? 0 : n), !0 !== this.aClockwise || s || (i === n ? i = -n : i -= n);
          const o = this.aStartAngle + e * i;
          let a = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            const e = Math.cos(this.aRotation),
              t = Math.sin(this.aRotation),
              r = a - this.aX,
              n = l - this.aY;
            a = r * e - n * t + this.aX, l = r * t + n * e + this.aY;
          }
          return r.set(a, l);
        }
        copy(e) {
          return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
      }
      class yc extends bc {
        constructor(e, t, r, n, i, s) {
          super(e, t, r, r, n, i, s), this.isArcCurve = !0, this.type = "ArcCurve";
        }
      }
      function xc() {
        let e = 0,
          t = 0,
          r = 0,
          n = 0;
        function i(i, s, o, a) {
          e = i, t = o, r = -3 * i + 3 * s - 2 * o - a, n = 2 * i - 2 * s + o + a;
        }
        return {
          initCatmullRom: function (e, t, r, n, s) {
            i(t, r, s * (r - e), s * (n - t));
          },
          initNonuniformCatmullRom: function (e, t, r, n, s, o, a) {
            let l = (t - e) / s - (r - e) / (s + o) + (r - t) / o,
              c = (r - t) / o - (n - t) / (o + a) + (n - r) / a;
            l *= o, c *= o, i(t, r, l, c);
          },
          calc: function (i) {
            const s = i * i;
            return e + t * i + r * s + n * (s * i);
          }
        };
      }
      const wc = new ln(),
        Ec = new xc(),
        Sc = new xc(),
        Cc = new xc();
      class Mc extends Ac {
        constructor(e = [], t = !1, r = "centripetal", n = .5) {
          super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
        }
        getPoint(e, t = new ln()) {
          const r = t,
            n = this.points,
            i = n.length,
            s = (i - (this.closed ? 0 : 1)) * e;
          let o,
            a,
            l = Math.floor(s),
            c = s - l;
          this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = n[(l - 1) % i] : (wc.subVectors(n[0], n[1]).add(n[0]), o = wc);
          const u = n[l % i],
            h = n[(l + 1) % i];
          if (this.closed || l + 2 < i ? a = n[(l + 2) % i] : (wc.subVectors(n[i - 1], n[i - 2]).add(n[i - 1]), a = wc), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const e = "chordal" === this.curveType ? .5 : .25;
            let t = Math.pow(o.distanceToSquared(u), e),
              r = Math.pow(u.distanceToSquared(h), e),
              n = Math.pow(h.distanceToSquared(a), e);
            r < 1e-4 && (r = 1), t < 1e-4 && (t = r), n < 1e-4 && (n = r), Ec.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, t, r, n), Sc.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, t, r, n), Cc.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, t, r, n);
          } else "catmullrom" === this.curveType && (Ec.initCatmullRom(o.x, u.x, h.x, a.x, this.tension), Sc.initCatmullRom(o.y, u.y, h.y, a.y, this.tension), Cc.initCatmullRom(o.z, u.z, h.z, a.z, this.tension));
          return r.set(Ec.calc(c), Sc.calc(c), Cc.calc(c)), r;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, r = e.points.length; t < r; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, r = this.points.length; t < r; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
          }
          return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, r = e.points.length; t < r; t++) {
            const r = e.points[t];
            this.points.push(new ln().fromArray(r));
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
      }
      function Tc(e, t, r, n, i) {
        const s = .5 * (n - t),
          o = .5 * (i - r),
          a = e * e;
        return (2 * r - 2 * n + s + o) * (e * a) + (-3 * r + 3 * n - 2 * s - o) * a + s * e + r;
      }
      function Ic(e, t, r, n) {
        return function (e, t) {
          const r = 1 - e;
          return r * r * t;
        }(e, t) + function (e, t) {
          return 2 * (1 - e) * e * t;
        }(e, r) + function (e, t) {
          return e * e * t;
        }(e, n);
      }
      function kc(e, t, r, n, i) {
        return function (e, t) {
          const r = 1 - e;
          return r * r * r * t;
        }(e, t) + function (e, t) {
          const r = 1 - e;
          return 3 * r * r * e * t;
        }(e, r) + function (e, t) {
          return 3 * (1 - e) * e * e * t;
        }(e, n) + function (e, t) {
          return e * e * e * t;
        }(e, i);
      }
      class Dc extends Ac {
        constructor(e = new kr(), t = new kr(), r = new kr(), n = new kr()) {
          super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
        }
        getPoint(e, t = new kr()) {
          const r = t,
            n = this.v0,
            i = this.v1,
            s = this.v2,
            o = this.v3;
          return r.set(kc(e, n.x, i.x, s.x, o.x), kc(e, n.y, i.y, s.y, o.y)), r;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class Pc extends Ac {
        constructor(e = new ln(), t = new ln(), r = new ln(), n = new ln()) {
          super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
        }
        getPoint(e, t = new ln()) {
          const r = t,
            n = this.v0,
            i = this.v1,
            s = this.v2,
            o = this.v3;
          return r.set(kc(e, n.x, i.x, s.x, o.x), kc(e, n.y, i.y, s.y, o.y), kc(e, n.z, i.z, s.z, o.z)), r;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class Bc extends Ac {
        constructor(e = new kr(), t = new kr()) {
          super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new kr()) {
          const r = t;
          return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const r = t || new kr();
          return r.copy(this.v2).sub(this.v1).normalize(), r;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class Rc extends Ac {
        constructor(e = new ln(), t = new ln()) {
          super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new ln()) {
          const r = t;
          return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class Lc extends Ac {
        constructor(e = new kr(), t = new kr(), r = new kr()) {
          super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
        }
        getPoint(e, t = new kr()) {
          const r = t,
            n = this.v0,
            i = this.v1,
            s = this.v2;
          return r.set(Ic(e, n.x, i.x, s.x), Ic(e, n.y, i.y, s.y)), r;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class Oc extends Ac {
        constructor(e = new ln(), t = new ln(), r = new ln()) {
          super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
        }
        getPoint(e, t = new ln()) {
          const r = t,
            n = this.v0,
            i = this.v1,
            s = this.v2;
          return r.set(Ic(e, n.x, i.x, s.x), Ic(e, n.y, i.y, s.y), Ic(e, n.z, i.z, s.z)), r;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class Fc extends Ac {
        constructor(e = []) {
          super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
        }
        getPoint(e, t = new kr()) {
          const r = t,
            n = this.points,
            i = (n.length - 1) * e,
            s = Math.floor(i),
            o = i - s,
            a = n[0 === s ? s : s - 1],
            l = n[s],
            c = n[s > n.length - 2 ? n.length - 1 : s + 1],
            u = n[s > n.length - 3 ? n.length - 1 : s + 2];
          return r.set(Tc(o, a.x, l.x, c.x, u.x), Tc(o, a.y, l.y, c.y, u.y)), r;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, r = e.points.length; t < r; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, r = this.points.length; t < r; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, r = e.points.length; t < r; t++) {
            const r = e.points[t];
            this.points.push(new kr().fromArray(r));
          }
          return this;
        }
      }
      var Uc = Object.freeze({
        __proto__: null,
        ArcCurve: yc,
        CatmullRomCurve3: Mc,
        CubicBezierCurve: Dc,
        CubicBezierCurve3: Pc,
        EllipseCurve: bc,
        LineCurve: Bc,
        LineCurve3: Rc,
        QuadraticBezierCurve: Lc,
        QuadraticBezierCurve3: Oc,
        SplineCurve: Fc
      });
      class Nc extends Ac {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new Bc(t, e));
        }
        getPoint(e, t) {
          const r = e * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length;) {
            if (n[i] >= r) {
              const e = n[i] - r,
                s = this.curves[i],
                o = s.getLength(),
                a = 0 === o ? 0 : 1 - e / o;
              return s.getPointAt(a, t);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let r = 0, n = this.curves.length; r < n; r++) t += this.curves[r].getLength(), e.push(t);
          return this.cacheLengths = e, e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let r;
          for (let n = 0, i = this.curves; n < i.length; n++) {
            const s = i[n],
              o = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e,
              a = s.getPoints(o);
            for (let e = 0; e < a.length; e++) {
              const n = a[e];
              r && r.equals(n) || (t.push(n), r = n);
            }
          }
          return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
        }
        copy(e) {
          super.copy(e), this.curves = [];
          for (let t = 0, r = e.curves.length; t < r; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone());
          }
          return this.autoClose = e.autoClose, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.autoClose = this.autoClose, e.curves = [];
          for (let t = 0, r = this.curves.length; t < r; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
          for (let t = 0, r = e.curves.length; t < r; t++) {
            const r = e.curves[t];
            this.curves.push(new Uc[r.type]().fromJSON(r));
          }
          return this;
        }
      }
      class jc extends Nc {
        constructor(e) {
          super(), this.type = "Path", this.currentPoint = new kr(), e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const r = new Bc(this.currentPoint.clone(), new kr(e, t));
          return this.curves.push(r), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, r, n) {
          const i = new Lc(this.currentPoint.clone(), new kr(e, t), new kr(r, n));
          return this.curves.push(i), this.currentPoint.set(r, n), this;
        }
        bezierCurveTo(e, t, r, n, i, s) {
          const o = new Dc(this.currentPoint.clone(), new kr(e, t), new kr(r, n), new kr(i, s));
          return this.curves.push(o), this.currentPoint.set(i, s), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            r = new Fc(t);
          return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
        }
        arc(e, t, r, n, i, s) {
          const o = this.currentPoint.x,
            a = this.currentPoint.y;
          return this.absarc(e + o, t + a, r, n, i, s), this;
        }
        absarc(e, t, r, n, i, s) {
          return this.absellipse(e, t, r, r, n, i, s), this;
        }
        ellipse(e, t, r, n, i, s, o, a) {
          const l = this.currentPoint.x,
            c = this.currentPoint.y;
          return this.absellipse(e + l, t + c, r, n, i, s, o, a), this;
        }
        absellipse(e, t, r, n, i, s, o, a) {
          const l = new bc(e, t, r, n, i, s, o, a);
          if (this.curves.length > 0) {
            const e = l.getPoint(0);
            e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
          }
          this.curves.push(l);
          const c = l.getPoint(1);
          return this.currentPoint.copy(c), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.currentPoint = this.currentPoint.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
        }
      }
      class zc extends Hi {
        constructor(e = [new kr(0, -.5), new kr(.5, 0), new kr(0, .5)], t = 12, r = 0, n = 2 * Math.PI) {
          super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: n
          }, t = Math.floor(t), n = yr(n, 0, 2 * Math.PI);
          const i = [],
            s = [],
            o = [],
            a = [],
            l = [],
            c = 1 / t,
            u = new ln(),
            h = new kr(),
            p = new ln(),
            d = new ln(),
            f = new ln();
          let m = 0,
            _ = 0;
          for (let t = 0; t <= e.length - 1; t++) switch (t) {
            case 0:
              m = e[t + 1].x - e[t].x, _ = e[t + 1].y - e[t].y, p.x = 1 * _, p.y = -m, p.z = 0 * _, f.copy(p), p.normalize(), a.push(p.x, p.y, p.z);
              break;
            case e.length - 1:
              a.push(f.x, f.y, f.z);
              break;
            default:
              m = e[t + 1].x - e[t].x, _ = e[t + 1].y - e[t].y, p.x = 1 * _, p.y = -m, p.z = 0 * _, d.copy(p), p.x += f.x, p.y += f.y, p.z += f.z, p.normalize(), a.push(p.x, p.y, p.z), f.copy(d);
          }
          for (let i = 0; i <= t; i++) {
            const p = r + i * c * n,
              d = Math.sin(p),
              f = Math.cos(p);
            for (let r = 0; r <= e.length - 1; r++) {
              u.x = e[r].x * d, u.y = e[r].y, u.z = e[r].x * f, s.push(u.x, u.y, u.z), h.x = i / t, h.y = r / (e.length - 1), o.push(h.x, h.y);
              const n = a[3 * r + 0] * d,
                c = a[3 * r + 1],
                p = a[3 * r + 0] * f;
              l.push(n, c, p);
            }
          }
          for (let r = 0; r < t; r++) for (let t = 0; t < e.length - 1; t++) {
            const n = t + r * e.length,
              s = n,
              o = n + e.length,
              a = n + e.length + 1,
              l = n + 1;
            i.push(s, o, l), i.push(a, l, o);
          }
          this.setIndex(i), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("uv", new Oi(o, 2)), this.setAttribute("normal", new Oi(l, 3));
        }
        static fromJSON(e) {
          return new zc(e.points, e.segments, e.phiStart, e.phiLength);
        }
      }
      class Gc extends zc {
        constructor(e = 1, t = 1, r = 4, n = 8) {
          const i = new jc();
          i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(r), n), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            height: t,
            capSegments: r,
            radialSegments: n
          };
        }
        static fromJSON(e) {
          return new Gc(e.radius, e.length, e.capSegments, e.radialSegments);
        }
      }
      class Vc extends Hi {
        constructor(e = 1, t = 8, r = 0, n = 2 * Math.PI) {
          super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: n
          }, t = Math.max(3, t);
          const i = [],
            s = [],
            o = [],
            a = [],
            l = new ln(),
            c = new kr();
          s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
          for (let i = 0, u = 3; i <= t; i++, u += 3) {
            const h = r + i / t * n;
            l.x = e * Math.cos(h), l.y = e * Math.sin(h), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[u] / e + 1) / 2, c.y = (s[u + 1] / e + 1) / 2, a.push(c.x, c.y);
          }
          for (let e = 1; e <= t; e++) i.push(e, e + 1, 0);
          this.setIndex(i), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("normal", new Oi(o, 3)), this.setAttribute("uv", new Oi(a, 2));
        }
        static fromJSON(e) {
          return new Vc(e.radius, e.segments, e.thetaStart, e.thetaLength);
        }
      }
      class Qc extends Hi {
        constructor(e = 1, t = 1, r = 1, n = 8, i = 1, s = !1, o = 0, a = 2 * Math.PI) {
          super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
          };
          const l = this;
          n = Math.floor(n), i = Math.floor(i);
          const c = [],
            u = [],
            h = [],
            p = [];
          let d = 0;
          const f = [],
            m = r / 2;
          let _ = 0;
          function g(r) {
            const i = d,
              s = new kr(),
              f = new ln();
            let g = 0;
            const v = !0 === r ? e : t,
              A = !0 === r ? 1 : -1;
            for (let e = 1; e <= n; e++) u.push(0, m * A, 0), h.push(0, A, 0), p.push(.5, .5), d++;
            const b = d;
            for (let e = 0; e <= n; e++) {
              const t = e / n * a + o,
                r = Math.cos(t),
                i = Math.sin(t);
              f.x = v * i, f.y = m * A, f.z = v * r, u.push(f.x, f.y, f.z), h.push(0, A, 0), s.x = .5 * r + .5, s.y = .5 * i * A + .5, p.push(s.x, s.y), d++;
            }
            for (let e = 0; e < n; e++) {
              const t = i + e,
                n = b + e;
              !0 === r ? c.push(n, n + 1, t) : c.push(n + 1, n, t), g += 3;
            }
            l.addGroup(_, g, !0 === r ? 1 : 2), _ += g;
          }
          !function () {
            const s = new ln(),
              g = new ln();
            let v = 0;
            const A = (t - e) / r;
            for (let l = 0; l <= i; l++) {
              const c = [],
                _ = l / i,
                v = _ * (t - e) + e;
              for (let e = 0; e <= n; e++) {
                const t = e / n,
                  i = t * a + o,
                  l = Math.sin(i),
                  f = Math.cos(i);
                g.x = v * l, g.y = -_ * r + m, g.z = v * f, u.push(g.x, g.y, g.z), s.set(l, A, f).normalize(), h.push(s.x, s.y, s.z), p.push(t, 1 - _), c.push(d++);
              }
              f.push(c);
            }
            for (let e = 0; e < n; e++) for (let t = 0; t < i; t++) {
              const r = f[t][e],
                n = f[t + 1][e],
                i = f[t + 1][e + 1],
                s = f[t][e + 1];
              c.push(r, n, s), c.push(n, i, s), v += 6;
            }
            l.addGroup(_, v, 0), _ += v;
          }(), !1 === s && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(c), this.setAttribute("position", new Oi(u, 3)), this.setAttribute("normal", new Oi(h, 3)), this.setAttribute("uv", new Oi(p, 2));
        }
        static fromJSON(e) {
          return new Qc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
        }
      }
      class Hc extends Qc {
        constructor(e = 1, t = 1, r = 8, n = 1, i = !1, s = 0, o = 2 * Math.PI) {
          super(0, e, t, r, n, i, s, o), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: i,
            thetaStart: s,
            thetaLength: o
          };
        }
        static fromJSON(e) {
          return new Hc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
        }
      }
      class Wc extends Hi {
        constructor(e = [], t = [], r = 1, n = 0) {
          super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: n
          };
          const i = [],
            s = [];
          function o(e, t, r, n) {
            const i = n + 1,
              s = [];
            for (let n = 0; n <= i; n++) {
              s[n] = [];
              const o = e.clone().lerp(r, n / i),
                a = t.clone().lerp(r, n / i),
                l = i - n;
              for (let e = 0; e <= l; e++) s[n][e] = 0 === e && n === i ? o : o.clone().lerp(a, e / l);
            }
            for (let e = 0; e < i; e++) for (let t = 0; t < 2 * (i - e) - 1; t++) {
              const r = Math.floor(t / 2);
              t % 2 == 0 ? (a(s[e][r + 1]), a(s[e + 1][r]), a(s[e][r])) : (a(s[e][r + 1]), a(s[e + 1][r + 1]), a(s[e + 1][r]));
            }
          }
          function a(e) {
            i.push(e.x, e.y, e.z);
          }
          function l(t, r) {
            const n = 3 * t;
            r.x = e[n + 0], r.y = e[n + 1], r.z = e[n + 2];
          }
          function c(e, t, r, n) {
            n < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === r.x && 0 === r.z && (s[t] = n / 2 / Math.PI + .5);
          }
          function u(e) {
            return Math.atan2(e.z, -e.x);
          }
          !function (e) {
            const r = new ln(),
              n = new ln(),
              i = new ln();
            for (let s = 0; s < t.length; s += 3) l(t[s + 0], r), l(t[s + 1], n), l(t[s + 2], i), o(r, n, i, e);
          }(n), function (e) {
            const t = new ln();
            for (let r = 0; r < i.length; r += 3) t.x = i[r + 0], t.y = i[r + 1], t.z = i[r + 2], t.normalize().multiplyScalar(e), i[r + 0] = t.x, i[r + 1] = t.y, i[r + 2] = t.z;
          }(r), function () {
            const e = new ln();
            for (let r = 0; r < i.length; r += 3) {
              e.x = i[r + 0], e.y = i[r + 1], e.z = i[r + 2];
              const n = u(e) / 2 / Math.PI + .5,
                o = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
              s.push(n, 1 - o);
            }
            var t;
            (function () {
              const e = new ln(),
                t = new ln(),
                r = new ln(),
                n = new ln(),
                o = new kr(),
                a = new kr(),
                l = new kr();
              for (let h = 0, p = 0; h < i.length; h += 9, p += 6) {
                e.set(i[h + 0], i[h + 1], i[h + 2]), t.set(i[h + 3], i[h + 4], i[h + 5]), r.set(i[h + 6], i[h + 7], i[h + 8]), o.set(s[p + 0], s[p + 1]), a.set(s[p + 2], s[p + 3]), l.set(s[p + 4], s[p + 5]), n.copy(e).add(t).add(r).divideScalar(3);
                const d = u(n);
                c(o, p + 0, e, d), c(a, p + 2, t, d), c(l, p + 4, r, d);
              }
            })(), function () {
              for (let e = 0; e < s.length; e += 6) {
                const t = s[e + 0],
                  r = s[e + 2],
                  n = s[e + 4],
                  i = Math.max(t, r, n),
                  o = Math.min(t, r, n);
                i > .9 && o < .1 && (t < .2 && (s[e + 0] += 1), r < .2 && (s[e + 2] += 1), n < .2 && (s[e + 4] += 1));
              }
            }();
          }(), this.setAttribute("position", new Oi(i, 3)), this.setAttribute("normal", new Oi(i.slice(), 3)), this.setAttribute("uv", new Oi(s, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(e) {
          return new Wc(e.vertices, e.indices, e.radius, e.details);
        }
      }
      class qc extends Wc {
        constructor(e = 1, t = 0) {
          const r = (1 + Math.sqrt(5)) / 2,
            n = 1 / r;
          super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, 0, -r, 0, -n, r, 0, -n, -r, 0, n, r, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
          };
        }
        static fromJSON(e) {
          return new qc(e.radius, e.detail);
        }
      }
      const Xc = new ln(),
        Yc = new ln(),
        Kc = new ln(),
        Jc = new yi();
      class Zc extends Hi {
        constructor(e = null, t = 1) {
          if (super(), this.type = "EdgesGeometry", this.parameters = {
            geometry: e,
            thresholdAngle: t
          }, null !== e) {
            const r = 4,
              n = Math.pow(10, r),
              i = Math.cos(vr * t),
              s = e.getIndex(),
              o = e.getAttribute("position"),
              a = s ? s.count : o.count,
              l = [0, 0, 0],
              c = ["a", "b", "c"],
              u = new Array(3),
              h = {},
              p = [];
            for (let e = 0; e < a; e += 3) {
              s ? (l[0] = s.getX(e), l[1] = s.getX(e + 1), l[2] = s.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
              const {
                a: t,
                b: r,
                c: a
              } = Jc;
              if (t.fromBufferAttribute(o, l[0]), r.fromBufferAttribute(o, l[1]), a.fromBufferAttribute(o, l[2]), Jc.getNormal(Kc), u[0] = `${Math.round(t.x * n)},${Math.round(t.y * n)},${Math.round(t.z * n)}`, u[1] = `${Math.round(r.x * n)},${Math.round(r.y * n)},${Math.round(r.z * n)}`, u[2] = `${Math.round(a.x * n)},${Math.round(a.y * n)},${Math.round(a.z * n)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0]) for (let e = 0; e < 3; e++) {
                const t = (e + 1) % 3,
                  r = u[e],
                  n = u[t],
                  s = Jc[c[e]],
                  o = Jc[c[t]],
                  a = `${r}_${n}`,
                  d = `${n}_${r}`;
                d in h && h[d] ? (Kc.dot(h[d].normal) <= i && (p.push(s.x, s.y, s.z), p.push(o.x, o.y, o.z)), h[d] = null) : a in h || (h[a] = {
                  index0: l[e],
                  index1: l[t],
                  normal: Kc.clone()
                });
              }
            }
            for (const e in h) if (h[e]) {
              const {
                index0: t,
                index1: r
              } = h[e];
              Xc.fromBufferAttribute(o, t), Yc.fromBufferAttribute(o, r), p.push(Xc.x, Xc.y, Xc.z), p.push(Yc.x, Yc.y, Yc.z);
            }
            this.setAttribute("position", new Oi(p, 3));
          }
        }
      }
      class $c extends jc {
        constructor(e) {
          super(e), this.uuid = br(), this.type = "Shape", this.holes = [];
        }
        getPointsHoles(e) {
          const t = [];
          for (let r = 0, n = this.holes.length; r < n; r++) t[r] = this.holes[r].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
          };
        }
        copy(e) {
          super.copy(e), this.holes = [];
          for (let t = 0, r = e.holes.length; t < r; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.uuid = this.uuid, e.holes = [];
          for (let t = 0, r = this.holes.length; t < r; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
          for (let t = 0, r = e.holes.length; t < r; t++) {
            const r = e.holes[t];
            this.holes.push(new jc().fromJSON(r));
          }
          return this;
        }
      }
      function eu(e, t, r, n, i) {
        let s, o;
        if (i === function (e, t, r, n) {
          let i = 0;
          for (let s = t, o = r - n; s < r; s += n) i += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s;
          return i;
        }(e, t, r, n) > 0) for (s = t; s < r; s += n) o = yu(s, e[s], e[s + 1], o);else for (s = r - n; s >= t; s -= n) o = yu(s, e[s], e[s + 1], o);
        return o && mu(o, o.next) && (xu(o), o = o.next), o;
      }
      function tu(e, t) {
        if (!e) return e;
        t || (t = e);
        let r,
          n = e;
        do {
          if (r = !1, n.steiner || !mu(n, n.next) && 0 !== fu(n.prev, n, n.next)) n = n.next;else {
            if (xu(n), n = t = n.prev, n === n.next) break;
            r = !0;
          }
        } while (r || n !== t);
        return t;
      }
      function ru(e, t, r, n, i, s, o) {
        if (!e) return;
        !o && s && function (e, t, r, n) {
          let i = e;
          do {
            null === i.z && (i.z = uu(i.x, i.y, t, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
          } while (i !== e);
          i.prevZ.nextZ = null, i.prevZ = null, function (e) {
            let t,
              r,
              n,
              i,
              s,
              o,
              a,
              l,
              c = 1;
            do {
              for (r = e, e = null, s = null, o = 0; r;) {
                for (o++, n = r, a = 0, t = 0; t < c && (a++, n = n.nextZ, n); t++);
                for (l = c; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, a--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;
                r = n;
              }
              s.nextZ = null, c *= 2;
            } while (o > 1);
          }(i);
        }(e, n, i, s);
        let a,
          l,
          c = e;
        for (; e.prev !== e.next;) if (a = e.prev, l = e.next, s ? iu(e, n, i, s) : nu(e)) t.push(a.i / r), t.push(e.i / r), t.push(l.i / r), xu(e), e = l.next, c = l.next;else if ((e = l) === c) {
          o ? 1 === o ? ru(e = su(tu(e), t, r), t, r, n, i, s, 2) : 2 === o && ou(e, t, r, n, i, s) : ru(tu(e), t, r, n, i, s, 1);
          break;
        }
      }
      function nu(e) {
        const t = e.prev,
          r = e,
          n = e.next;
        if (fu(t, r, n) >= 0) return !1;
        let i = e.next.next;
        for (; i !== e.prev;) {
          if (pu(t.x, t.y, r.x, r.y, n.x, n.y, i.x, i.y) && fu(i.prev, i, i.next) >= 0) return !1;
          i = i.next;
        }
        return !0;
      }
      function iu(e, t, r, n) {
        const i = e.prev,
          s = e,
          o = e.next;
        if (fu(i, s, o) >= 0) return !1;
        const a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
          l = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
          c = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
          u = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
          h = uu(a, l, t, r, n),
          p = uu(c, u, t, r, n);
        let d = e.prevZ,
          f = e.nextZ;
        for (; d && d.z >= h && f && f.z <= p;) {
          if (d !== e.prev && d !== e.next && pu(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && fu(d.prev, d, d.next) >= 0) return !1;
          if (d = d.prevZ, f !== e.prev && f !== e.next && pu(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && fu(f.prev, f, f.next) >= 0) return !1;
          f = f.nextZ;
        }
        for (; d && d.z >= h;) {
          if (d !== e.prev && d !== e.next && pu(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && fu(d.prev, d, d.next) >= 0) return !1;
          d = d.prevZ;
        }
        for (; f && f.z <= p;) {
          if (f !== e.prev && f !== e.next && pu(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && fu(f.prev, f, f.next) >= 0) return !1;
          f = f.nextZ;
        }
        return !0;
      }
      function su(e, t, r) {
        let n = e;
        do {
          const i = n.prev,
            s = n.next.next;
          !mu(i, s) && _u(i, n, n.next, s) && Au(i, s) && Au(s, i) && (t.push(i.i / r), t.push(n.i / r), t.push(s.i / r), xu(n), xu(n.next), n = e = s), n = n.next;
        } while (n !== e);
        return tu(n);
      }
      function ou(e, t, r, n, i, s) {
        let o = e;
        do {
          let e = o.next.next;
          for (; e !== o.prev;) {
            if (o.i !== e.i && du(o, e)) {
              let a = bu(o, e);
              return o = tu(o, o.next), a = tu(a, a.next), ru(o, t, r, n, i, s), void ru(a, t, r, n, i, s);
            }
            e = e.next;
          }
          o = o.next;
        } while (o !== e);
      }
      function au(e, t) {
        return e.x - t.x;
      }
      function lu(e, t) {
        if (t = function (e, t) {
          let r = t;
          const n = e.x,
            i = e.y;
          let s,
            o = -1 / 0;
          do {
            if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
              const e = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
              if (e <= n && e > o) {
                if (o = e, e === n) {
                  if (i === r.y) return r;
                  if (i === r.next.y) return r.next;
                }
                s = r.x < r.next.x ? r : r.next;
              }
            }
            r = r.next;
          } while (r !== t);
          if (!s) return null;
          if (n === o) return s;
          const a = s,
            l = s.x,
            c = s.y;
          let u,
            h = 1 / 0;
          r = s;
          do {
            n >= r.x && r.x >= l && n !== r.x && pu(i < c ? n : o, i, l, c, i < c ? o : n, i, r.x, r.y) && (u = Math.abs(i - r.y) / (n - r.x), Au(r, e) && (u < h || u === h && (r.x > s.x || r.x === s.x && cu(s, r))) && (s = r, h = u)), r = r.next;
          } while (r !== a);
          return s;
        }(e, t), t) {
          const r = bu(t, e);
          tu(t, t.next), tu(r, r.next);
        }
      }
      function cu(e, t) {
        return fu(e.prev, e, t.prev) < 0 && fu(t.next, e, e.next) < 0;
      }
      function uu(e, t, r, n, i) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
      }
      function hu(e) {
        let t = e,
          r = e;
        do {
          (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next;
        } while (t !== e);
        return r;
      }
      function pu(e, t, r, n, i, s, o, a) {
        return (i - o) * (t - a) - (e - o) * (s - a) >= 0 && (e - o) * (n - a) - (r - o) * (t - a) >= 0 && (r - o) * (s - a) - (i - o) * (n - a) >= 0;
      }
      function du(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) {
          let r = e;
          do {
            if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && _u(r, r.next, e, t)) return !0;
            r = r.next;
          } while (r !== e);
          return !1;
        }(e, t) && (Au(e, t) && Au(t, e) && function (e, t) {
          let r = e,
            n = !1;
          const i = (e.x + t.x) / 2,
            s = (e.y + t.y) / 2;
          do {
            r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
          } while (r !== e);
          return n;
        }(e, t) && (fu(e.prev, e, t.prev) || fu(e, t.prev, t)) || mu(e, t) && fu(e.prev, e, e.next) > 0 && fu(t.prev, t, t.next) > 0);
      }
      function fu(e, t, r) {
        return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);
      }
      function mu(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function _u(e, t, r, n) {
        const i = vu(fu(e, t, r)),
          s = vu(fu(e, t, n)),
          o = vu(fu(r, n, e)),
          a = vu(fu(r, n, t));
        return i !== s && o !== a || !(0 !== i || !gu(e, r, t)) || !(0 !== s || !gu(e, n, t)) || !(0 !== o || !gu(r, e, n)) || !(0 !== a || !gu(r, t, n));
      }
      function gu(e, t, r) {
        return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y);
      }
      function vu(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function Au(e, t) {
        return fu(e.prev, e, e.next) < 0 ? fu(e, t, e.next) >= 0 && fu(e, e.prev, t) >= 0 : fu(e, t, e.prev) < 0 || fu(e, e.next, t) < 0;
      }
      function bu(e, t) {
        const r = new wu(e.i, e.x, e.y),
          n = new wu(t.i, t.x, t.y),
          i = e.next,
          s = t.prev;
        return e.next = t, t.prev = e, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
      }
      function yu(e, t, r, n) {
        const i = new wu(e, t, r);
        return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
      }
      function xu(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function wu(e, t, r) {
        this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      class Eu {
        static area(e) {
          const t = e.length;
          let r = 0;
          for (let n = t - 1, i = 0; i < t; n = i++) r += e[n].x * e[i].y - e[i].x * e[n].y;
          return .5 * r;
        }
        static isClockWise(e) {
          return Eu.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const r = [],
            n = [],
            i = [];
          Su(e), Cu(r, e);
          let s = e.length;
          t.forEach(Su);
          for (let e = 0; e < t.length; e++) n.push(s), s += t[e].length, Cu(r, t[e]);
          const o = function (e, t, r = 2) {
            const n = t && t.length,
              i = n ? t[0] * r : e.length;
            let s = eu(e, 0, i, r, !0);
            const o = [];
            if (!s || s.next === s.prev) return o;
            let a, l, c, u, h, p, d;
            if (n && (s = function (e, t, r, n) {
              const i = [];
              let s, o, a, l, c;
              for (s = 0, o = t.length; s < o; s++) a = t[s] * n, l = s < o - 1 ? t[s + 1] * n : e.length, c = eu(e, a, l, n, !1), c === c.next && (c.steiner = !0), i.push(hu(c));
              for (i.sort(au), s = 0; s < i.length; s++) lu(i[s], r), r = tu(r, r.next);
              return r;
            }(e, t, s, r)), e.length > 80 * r) {
              a = c = e[0], l = u = e[1];
              for (let t = r; t < i; t += r) h = e[t], p = e[t + 1], h < a && (a = h), p < l && (l = p), h > c && (c = h), p > u && (u = p);
              d = Math.max(c - a, u - l), d = 0 !== d ? 1 / d : 0;
            }
            return ru(s, o, r, a, l, d), o;
          }(r, n);
          for (let e = 0; e < o.length; e += 3) i.push(o.slice(e, e + 3));
          return i;
        }
      }
      function Su(e) {
        const t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function Cu(e, t) {
        for (let r = 0; r < t.length; r++) e.push(t[r].x), e.push(t[r].y);
      }
      class Mu extends Hi {
        constructor(e = new $c([new kr(.5, .5), new kr(-.5, .5), new kr(-.5, -.5), new kr(.5, -.5)]), t = {}) {
          super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
          }, e = Array.isArray(e) ? e : [e];
          const r = this,
            n = [],
            i = [];
          for (let t = 0, r = e.length; t < r; t++) s(e[t]);
          function s(e) {
            const s = [],
              o = void 0 !== t.curveSegments ? t.curveSegments : 12,
              a = void 0 !== t.steps ? t.steps : 1,
              l = void 0 !== t.depth ? t.depth : 1;
            let c = void 0 === t.bevelEnabled || t.bevelEnabled,
              u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
              h = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
              p = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
              d = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
            const f = t.extrudePath,
              m = void 0 !== t.UVGenerator ? t.UVGenerator : Tu;
            let _,
              g,
              v,
              A,
              b,
              y = !1;
            f && (_ = f.getSpacedPoints(a), y = !0, c = !1, g = f.computeFrenetFrames(a, !1), v = new ln(), A = new ln(), b = new ln()), c || (d = 0, u = 0, h = 0, p = 0);
            const x = e.extractPoints(o);
            let w = x.shape;
            const E = x.holes;
            if (!Eu.isClockWise(w)) {
              w = w.reverse();
              for (let e = 0, t = E.length; e < t; e++) {
                const t = E[e];
                Eu.isClockWise(t) && (E[e] = t.reverse());
              }
            }
            const S = Eu.triangulateShape(w, E),
              C = w;
            for (let e = 0, t = E.length; e < t; e++) {
              const t = E[e];
              w = w.concat(t);
            }
            function M(e, t, r) {
              return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(r).add(e);
            }
            const T = w.length,
              I = S.length;
            function k(e, t, r) {
              let n, i, s;
              const o = e.x - t.x,
                a = e.y - t.y,
                l = r.x - e.x,
                c = r.y - e.y,
                u = o * o + a * a,
                h = o * c - a * l;
              if (Math.abs(h) > Number.EPSILON) {
                const h = Math.sqrt(u),
                  p = Math.sqrt(l * l + c * c),
                  d = t.x - a / h,
                  f = t.y + o / h,
                  m = ((r.x - c / p - d) * c - (r.y + l / p - f) * l) / (o * c - a * l);
                n = d + o * m - e.x, i = f + a * m - e.y;
                const _ = n * n + i * i;
                if (_ <= 2) return new kr(n, i);
                s = Math.sqrt(_ / 2);
              } else {
                let e = !1;
                o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(c) && (e = !0), e ? (n = -a, i = o, s = Math.sqrt(u)) : (n = o, i = a, s = Math.sqrt(u / 2));
              }
              return new kr(n / s, i / s);
            }
            const D = [];
            for (let e = 0, t = C.length, r = t - 1, n = e + 1; e < t; e++, r++, n++) r === t && (r = 0), n === t && (n = 0), D[e] = k(C[e], C[r], C[n]);
            const P = [];
            let B,
              R = D.concat();
            for (let e = 0, t = E.length; e < t; e++) {
              const t = E[e];
              B = [];
              for (let e = 0, r = t.length, n = r - 1, i = e + 1; e < r; e++, n++, i++) n === r && (n = 0), i === r && (i = 0), B[e] = k(t[e], t[n], t[i]);
              P.push(B), R = R.concat(B);
            }
            for (let e = 0; e < d; e++) {
              const t = e / d,
                r = u * Math.cos(t * Math.PI / 2),
                n = h * Math.sin(t * Math.PI / 2) + p;
              for (let e = 0, t = C.length; e < t; e++) {
                const t = M(C[e], D[e], n);
                F(t.x, t.y, -r);
              }
              for (let e = 0, t = E.length; e < t; e++) {
                const t = E[e];
                B = P[e];
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = M(t[e], B[e], n);
                  F(i.x, i.y, -r);
                }
              }
            }
            const L = h + p;
            for (let e = 0; e < T; e++) {
              const t = c ? M(w[e], R[e], L) : w[e];
              y ? (A.copy(g.normals[0]).multiplyScalar(t.x), v.copy(g.binormals[0]).multiplyScalar(t.y), b.copy(_[0]).add(A).add(v), F(b.x, b.y, b.z)) : F(t.x, t.y, 0);
            }
            for (let e = 1; e <= a; e++) for (let t = 0; t < T; t++) {
              const r = c ? M(w[t], R[t], L) : w[t];
              y ? (A.copy(g.normals[e]).multiplyScalar(r.x), v.copy(g.binormals[e]).multiplyScalar(r.y), b.copy(_[e]).add(A).add(v), F(b.x, b.y, b.z)) : F(r.x, r.y, l / a * e);
            }
            for (let e = d - 1; e >= 0; e--) {
              const t = e / d,
                r = u * Math.cos(t * Math.PI / 2),
                n = h * Math.sin(t * Math.PI / 2) + p;
              for (let e = 0, t = C.length; e < t; e++) {
                const t = M(C[e], D[e], n);
                F(t.x, t.y, l + r);
              }
              for (let e = 0, t = E.length; e < t; e++) {
                const t = E[e];
                B = P[e];
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = M(t[e], B[e], n);
                  y ? F(i.x, i.y + _[a - 1].y, _[a - 1].x + r) : F(i.x, i.y, l + r);
                }
              }
            }
            function O(e, t) {
              let r = e.length;
              for (; --r >= 0;) {
                const n = r;
                let i = r - 1;
                i < 0 && (i = e.length - 1);
                for (let e = 0, r = a + 2 * d; e < r; e++) {
                  const r = T * e,
                    s = T * (e + 1);
                  N(t + n + r, t + i + r, t + i + s, t + n + s);
                }
              }
            }
            function F(e, t, r) {
              s.push(e), s.push(t), s.push(r);
            }
            function U(e, t, i) {
              j(e), j(t), j(i);
              const s = n.length / 3,
                o = m.generateTopUV(r, n, s - 3, s - 2, s - 1);
              z(o[0]), z(o[1]), z(o[2]);
            }
            function N(e, t, i, s) {
              j(e), j(t), j(s), j(t), j(i), j(s);
              const o = n.length / 3,
                a = m.generateSideWallUV(r, n, o - 6, o - 3, o - 2, o - 1);
              z(a[0]), z(a[1]), z(a[3]), z(a[1]), z(a[2]), z(a[3]);
            }
            function j(e) {
              n.push(s[3 * e + 0]), n.push(s[3 * e + 1]), n.push(s[3 * e + 2]);
            }
            function z(e) {
              i.push(e.x), i.push(e.y);
            }
            !function () {
              const e = n.length / 3;
              if (c) {
                let e = 0,
                  t = T * e;
                for (let e = 0; e < I; e++) {
                  const r = S[e];
                  U(r[2] + t, r[1] + t, r[0] + t);
                }
                e = a + 2 * d, t = T * e;
                for (let e = 0; e < I; e++) {
                  const r = S[e];
                  U(r[0] + t, r[1] + t, r[2] + t);
                }
              } else {
                for (let e = 0; e < I; e++) {
                  const t = S[e];
                  U(t[2], t[1], t[0]);
                }
                for (let e = 0; e < I; e++) {
                  const t = S[e];
                  U(t[0] + T * a, t[1] + T * a, t[2] + T * a);
                }
              }
              r.addGroup(e, n.length / 3 - e, 0);
            }(), function () {
              const e = n.length / 3;
              let t = 0;
              O(C, t), t += C.length;
              for (let e = 0, r = E.length; e < r; e++) {
                const r = E[e];
                O(r, t), t += r.length;
              }
              r.addGroup(e, n.length / 3 - e, 1);
            }();
          }
          this.setAttribute("position", new Oi(n, 3)), this.setAttribute("uv", new Oi(i, 2)), this.computeVertexNormals();
        }
        toJSON() {
          const e = super.toJSON();
          return function (e, t, r) {
            if (r.shapes = [], Array.isArray(e)) for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              r.shapes.push(n.uuid);
            } else r.shapes.push(e.uuid);
            return r.options = Object.assign({}, t), void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()), r;
          }(this.parameters.shapes, this.parameters.options, e);
        }
        static fromJSON(e, t) {
          const r = [];
          for (let n = 0, i = e.shapes.length; n < i; n++) {
            const i = t[e.shapes[n]];
            r.push(i);
          }
          const n = e.options.extrudePath;
          return void 0 !== n && (e.options.extrudePath = new Uc[n.type]().fromJSON(n)), new Mu(r, e.options);
        }
      }
      const Tu = {
        generateTopUV: function (e, t, r, n, i) {
          const s = t[3 * r],
            o = t[3 * r + 1],
            a = t[3 * n],
            l = t[3 * n + 1],
            c = t[3 * i],
            u = t[3 * i + 1];
          return [new kr(s, o), new kr(a, l), new kr(c, u)];
        },
        generateSideWallUV: function (e, t, r, n, i, s) {
          const o = t[3 * r],
            a = t[3 * r + 1],
            l = t[3 * r + 2],
            c = t[3 * n],
            u = t[3 * n + 1],
            h = t[3 * n + 2],
            p = t[3 * i],
            d = t[3 * i + 1],
            f = t[3 * i + 2],
            m = t[3 * s],
            _ = t[3 * s + 1],
            g = t[3 * s + 2];
          return Math.abs(a - u) < Math.abs(o - c) ? [new kr(o, 1 - l), new kr(c, 1 - h), new kr(p, 1 - f), new kr(m, 1 - g)] : [new kr(a, 1 - l), new kr(u, 1 - h), new kr(d, 1 - f), new kr(_, 1 - g)];
        }
      };
      class Iu extends Wc {
        constructor(e = 1, t = 0) {
          const r = (1 + Math.sqrt(5)) / 2;
          super([-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
          };
        }
        static fromJSON(e) {
          return new Iu(e.radius, e.detail);
        }
      }
      class ku extends Wc {
        constructor(e = 1, t = 0) {
          super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
          };
        }
        static fromJSON(e) {
          return new ku(e.radius, e.detail);
        }
      }
      class Du extends Hi {
        constructor(e = .5, t = 1, r = 8, n = 1, i = 0, s = 2 * Math.PI) {
          super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: n,
            thetaStart: i,
            thetaLength: s
          }, r = Math.max(3, r);
          const o = [],
            a = [],
            l = [],
            c = [];
          let u = e;
          const h = (t - e) / (n = Math.max(1, n)),
            p = new ln(),
            d = new kr();
          for (let e = 0; e <= n; e++) {
            for (let e = 0; e <= r; e++) {
              const n = i + e / r * s;
              p.x = u * Math.cos(n), p.y = u * Math.sin(n), a.push(p.x, p.y, p.z), l.push(0, 0, 1), d.x = (p.x / t + 1) / 2, d.y = (p.y / t + 1) / 2, c.push(d.x, d.y);
            }
            u += h;
          }
          for (let e = 0; e < n; e++) {
            const t = e * (r + 1);
            for (let e = 0; e < r; e++) {
              const n = e + t,
                i = n,
                s = n + r + 1,
                a = n + r + 2,
                l = n + 1;
              o.push(i, s, l), o.push(s, a, l);
            }
          }
          this.setIndex(o), this.setAttribute("position", new Oi(a, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2));
        }
        static fromJSON(e) {
          return new Du(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
        }
      }
      class Pu extends Hi {
        constructor(e = new $c([new kr(0, .5), new kr(-.5, -.5), new kr(.5, -.5)]), t = 12) {
          super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
          };
          const r = [],
            n = [],
            i = [],
            s = [];
          let o = 0,
            a = 0;
          if (!1 === Array.isArray(e)) l(e);else for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(o, a, t), o += a, a = 0;
          function l(e) {
            const o = n.length / 3,
              l = e.extractPoints(t);
            let c = l.shape;
            const u = l.holes;
            !1 === Eu.isClockWise(c) && (c = c.reverse());
            for (let e = 0, t = u.length; e < t; e++) {
              const t = u[e];
              !0 === Eu.isClockWise(t) && (u[e] = t.reverse());
            }
            const h = Eu.triangulateShape(c, u);
            for (let e = 0, t = u.length; e < t; e++) {
              const t = u[e];
              c = c.concat(t);
            }
            for (let e = 0, t = c.length; e < t; e++) {
              const t = c[e];
              n.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y);
            }
            for (let e = 0, t = h.length; e < t; e++) {
              const t = h[e],
                n = t[0] + o,
                i = t[1] + o,
                s = t[2] + o;
              r.push(n, i, s), a += 3;
            }
          }
          this.setIndex(r), this.setAttribute("position", new Oi(n, 3)), this.setAttribute("normal", new Oi(i, 3)), this.setAttribute("uv", new Oi(s, 2));
        }
        toJSON() {
          const e = super.toJSON();
          return function (e, t) {
            if (t.shapes = [], Array.isArray(e)) for (let r = 0, n = e.length; r < n; r++) {
              const n = e[r];
              t.shapes.push(n.uuid);
            } else t.shapes.push(e.uuid);
            return t;
          }(this.parameters.shapes, e);
        }
        static fromJSON(e, t) {
          const r = [];
          for (let n = 0, i = e.shapes.length; n < i; n++) {
            const i = t[e.shapes[n]];
            r.push(i);
          }
          return new Pu(r, e.curveSegments);
        }
      }
      class Bu extends Hi {
        constructor(e = 1, t = 32, r = 16, n = 0, i = 2 * Math.PI, s = 0, o = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: s,
            thetaLength: o
          }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
          const a = Math.min(s + o, Math.PI);
          let l = 0;
          const c = [],
            u = new ln(),
            h = new ln(),
            p = [],
            d = [],
            f = [],
            m = [];
          for (let p = 0; p <= r; p++) {
            const _ = [],
              g = p / r;
            let v = 0;
            0 == p && 0 == s ? v = .5 / t : p == r && a == Math.PI && (v = -.5 / t);
            for (let r = 0; r <= t; r++) {
              const a = r / t;
              u.x = -e * Math.cos(n + a * i) * Math.sin(s + g * o), u.y = e * Math.cos(s + g * o), u.z = e * Math.sin(n + a * i) * Math.sin(s + g * o), d.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(a + v, 1 - g), _.push(l++);
            }
            c.push(_);
          }
          for (let e = 0; e < r; e++) for (let n = 0; n < t; n++) {
            const t = c[e][n + 1],
              i = c[e][n],
              o = c[e + 1][n],
              l = c[e + 1][n + 1];
            (0 !== e || s > 0) && p.push(t, i, l), (e !== r - 1 || a < Math.PI) && p.push(i, o, l);
          }
          this.setIndex(p), this.setAttribute("position", new Oi(d, 3)), this.setAttribute("normal", new Oi(f, 3)), this.setAttribute("uv", new Oi(m, 2));
        }
        static fromJSON(e) {
          return new Bu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
        }
      }
      class Ru extends Wc {
        constructor(e = 1, t = 0) {
          super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
          };
        }
        static fromJSON(e) {
          return new Ru(e.radius, e.detail);
        }
      }
      class Lu extends Hi {
        constructor(e = 1, t = .4, r = 8, n = 6, i = 2 * Math.PI) {
          super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: n,
            arc: i
          }, r = Math.floor(r), n = Math.floor(n);
          const s = [],
            o = [],
            a = [],
            l = [],
            c = new ln(),
            u = new ln(),
            h = new ln();
          for (let s = 0; s <= r; s++) for (let p = 0; p <= n; p++) {
            const d = p / n * i,
              f = s / r * Math.PI * 2;
            u.x = (e + t * Math.cos(f)) * Math.cos(d), u.y = (e + t * Math.cos(f)) * Math.sin(d), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(d), c.y = e * Math.sin(d), h.subVectors(u, c).normalize(), a.push(h.x, h.y, h.z), l.push(p / n), l.push(s / r);
          }
          for (let e = 1; e <= r; e++) for (let t = 1; t <= n; t++) {
            const r = (n + 1) * e + t - 1,
              i = (n + 1) * (e - 1) + t - 1,
              o = (n + 1) * (e - 1) + t,
              a = (n + 1) * e + t;
            s.push(r, i, a), s.push(i, o, a);
          }
          this.setIndex(s), this.setAttribute("position", new Oi(o, 3)), this.setAttribute("normal", new Oi(a, 3)), this.setAttribute("uv", new Oi(l, 2));
        }
        static fromJSON(e) {
          return new Lu(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
        }
      }
      class Ou extends Hi {
        constructor(e = 1, t = .4, r = 64, n = 8, i = 2, s = 3) {
          super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: i,
            q: s
          }, r = Math.floor(r), n = Math.floor(n);
          const o = [],
            a = [],
            l = [],
            c = [],
            u = new ln(),
            h = new ln(),
            p = new ln(),
            d = new ln(),
            f = new ln(),
            m = new ln(),
            _ = new ln();
          for (let o = 0; o <= r; ++o) {
            const v = o / r * i * Math.PI * 2;
            g(v, i, s, e, p), g(v + .01, i, s, e, d), m.subVectors(d, p), _.addVectors(d, p), f.crossVectors(m, _), _.crossVectors(f, m), f.normalize(), _.normalize();
            for (let e = 0; e <= n; ++e) {
              const i = e / n * Math.PI * 2,
                s = -t * Math.cos(i),
                d = t * Math.sin(i);
              u.x = p.x + (s * _.x + d * f.x), u.y = p.y + (s * _.y + d * f.y), u.z = p.z + (s * _.z + d * f.z), a.push(u.x, u.y, u.z), h.subVectors(u, p).normalize(), l.push(h.x, h.y, h.z), c.push(o / r), c.push(e / n);
            }
          }
          for (let e = 1; e <= r; e++) for (let t = 1; t <= n; t++) {
            const r = (n + 1) * (e - 1) + (t - 1),
              i = (n + 1) * e + (t - 1),
              s = (n + 1) * e + t,
              a = (n + 1) * (e - 1) + t;
            o.push(r, i, a), o.push(i, s, a);
          }
          function g(e, t, r, n, i) {
            const s = Math.cos(e),
              o = Math.sin(e),
              a = r / t * e,
              l = Math.cos(a);
            i.x = n * (2 + l) * .5 * s, i.y = n * (2 + l) * o * .5, i.z = n * Math.sin(a) * .5;
          }
          this.setIndex(o), this.setAttribute("position", new Oi(a, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2));
        }
        static fromJSON(e) {
          return new Ou(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
        }
      }
      class Fu extends Hi {
        constructor(e = new Oc(new ln(-1, -1, 0), new ln(-1, 1, 0), new ln(1, 1, 0)), t = 64, r = 1, n = 8, i = !1) {
          super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: n,
            closed: i
          };
          const s = e.computeFrenetFrames(t, i);
          this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
          const o = new ln(),
            a = new ln(),
            l = new kr();
          let c = new ln();
          const u = [],
            h = [],
            p = [],
            d = [];
          function f(i) {
            c = e.getPointAt(i / t, c);
            const l = s.normals[i],
              p = s.binormals[i];
            for (let e = 0; e <= n; e++) {
              const t = e / n * Math.PI * 2,
                i = Math.sin(t),
                s = -Math.cos(t);
              a.x = s * l.x + i * p.x, a.y = s * l.y + i * p.y, a.z = s * l.z + i * p.z, a.normalize(), h.push(a.x, a.y, a.z), o.x = c.x + r * a.x, o.y = c.y + r * a.y, o.z = c.z + r * a.z, u.push(o.x, o.y, o.z);
            }
          }
          !function () {
            for (let e = 0; e < t; e++) f(e);
            f(!1 === i ? t : 0), function () {
              for (let e = 0; e <= t; e++) for (let r = 0; r <= n; r++) l.x = e / t, l.y = r / n, p.push(l.x, l.y);
            }(), function () {
              for (let e = 1; e <= t; e++) for (let t = 1; t <= n; t++) {
                const r = (n + 1) * (e - 1) + (t - 1),
                  i = (n + 1) * e + (t - 1),
                  s = (n + 1) * e + t,
                  o = (n + 1) * (e - 1) + t;
                d.push(r, i, o), d.push(i, s, o);
              }
            }();
          }(), this.setIndex(d), this.setAttribute("position", new Oi(u, 3)), this.setAttribute("normal", new Oi(h, 3)), this.setAttribute("uv", new Oi(p, 2));
        }
        toJSON() {
          const e = super.toJSON();
          return e.path = this.parameters.path.toJSON(), e;
        }
        static fromJSON(e) {
          return new Fu(new Uc[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
        }
      }
      class Uu extends Hi {
        constructor(e = null) {
          if (super(), this.type = "WireframeGeometry", this.parameters = {
            geometry: e
          }, null !== e) {
            const t = [],
              r = new Set(),
              n = new ln(),
              i = new ln();
            if (null !== e.index) {
              const s = e.attributes.position,
                o = e.index;
              let a = e.groups;
              0 === a.length && (a = [{
                start: 0,
                count: o.count,
                materialIndex: 0
              }]);
              for (let e = 0, l = a.length; e < l; ++e) {
                const l = a[e],
                  c = l.start;
                for (let e = c, a = c + l.count; e < a; e += 3) for (let a = 0; a < 3; a++) {
                  const l = o.getX(e + a),
                    c = o.getX(e + (a + 1) % 3);
                  n.fromBufferAttribute(s, l), i.fromBufferAttribute(s, c), !0 === Nu(n, i, r) && (t.push(n.x, n.y, n.z), t.push(i.x, i.y, i.z));
                }
              }
            } else {
              const s = e.attributes.position;
              for (let e = 0, o = s.count / 3; e < o; e++) for (let o = 0; o < 3; o++) {
                const a = 3 * e + o,
                  l = 3 * e + (o + 1) % 3;
                n.fromBufferAttribute(s, a), i.fromBufferAttribute(s, l), !0 === Nu(n, i, r) && (t.push(n.x, n.y, n.z), t.push(i.x, i.y, i.z));
              }
            }
            this.setAttribute("position", new Oi(t, 3));
          }
        }
      }
      function Nu(e, t, r) {
        const n = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
          i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
        return !0 !== r.has(n) && !0 !== r.has(i) && (r.add(n), r.add(i), !0);
      }
      var ju = Object.freeze({
        __proto__: null,
        BoxGeometry: hs,
        CapsuleGeometry: Gc,
        CircleGeometry: Vc,
        ConeGeometry: Hc,
        CylinderGeometry: Qc,
        DodecahedronGeometry: qc,
        EdgesGeometry: Zc,
        ExtrudeGeometry: Mu,
        IcosahedronGeometry: Iu,
        LatheGeometry: zc,
        OctahedronGeometry: ku,
        PlaneGeometry: Ds,
        PolyhedronGeometry: Wc,
        RingGeometry: Du,
        ShapeGeometry: Pu,
        SphereGeometry: Bu,
        TetrahedronGeometry: Ru,
        TorusGeometry: Lu,
        TorusKnotGeometry: Ou,
        TubeGeometry: Fu,
        WireframeGeometry: Uu
      });
      class zu extends wi {
        constructor(e) {
          super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Wr(0), this.transparent = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
        }
      }
      class Gu extends ms {
        constructor(e) {
          super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
        }
      }
      class Vu extends wi {
        constructor(e) {
          super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
          }, this.type = "MeshStandardMaterial", this.color = new Wr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: ""
          }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class Qu extends Vu {
        constructor(e) {
          super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new kr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function () {
              return yr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function (e) {
              this.ior = (1 + .4 * e) / (1 - .4 * e);
            }
          }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Wr(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Wr(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Wr(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
      }
      class Hu extends wi {
        constructor(e) {
          super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Wr(16777215), this.specular = new Wr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class Wu extends wi {
        constructor(e) {
          super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
          }, this.type = "MeshToonMaterial", this.color = new Wr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      class qu extends wi {
        constructor(e) {
          super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
        }
      }
      class Xu extends wi {
        constructor(e) {
          super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Wr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class Yu extends wi {
        constructor(e) {
          super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
          }, this.type = "MeshMatcapMaterial", this.color = new Wr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            MATCAP: ""
          }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class Ku extends Jl {
        constructor(e) {
          super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
        }
      }
      function Ju(e, t, r) {
        return $u(e) ? new e.constructor(e.subarray(t, void 0 !== r ? r : e.length)) : e.slice(t, r);
      }
      function Zu(e, t, r) {
        return !e || !r && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e);
      }
      function $u(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function eh(e) {
        const t = e.length,
          r = new Array(t);
        for (let e = 0; e !== t; ++e) r[e] = e;
        return r.sort(function (t, r) {
          return e[t] - e[r];
        }), r;
      }
      function th(e, t, r) {
        const n = e.length,
          i = new e.constructor(n);
        for (let s = 0, o = 0; o !== n; ++s) {
          const n = r[s] * t;
          for (let r = 0; r !== t; ++r) i[o++] = e[n + r];
        }
        return i;
      }
      function rh(e, t, r, n) {
        let i = 1,
          s = e[0];
        for (; void 0 !== s && void 0 === s[n];) s = e[i++];
        if (void 0 === s) return;
        let o = s[n];
        if (void 0 !== o) if (Array.isArray(o)) do {
          o = s[n], void 0 !== o && (t.push(s.time), r.push.apply(r, o)), s = e[i++];
        } while (void 0 !== s);else if (void 0 !== o.toArray) do {
          o = s[n], void 0 !== o && (t.push(s.time), o.toArray(r, r.length)), s = e[i++];
        } while (void 0 !== s);else do {
          o = s[n], void 0 !== o && (t.push(s.time), r.push(o)), s = e[i++];
        } while (void 0 !== s);
      }
      var nh = Object.freeze({
        __proto__: null,
        arraySlice: Ju,
        convertArray: Zu,
        isTypedArray: $u,
        getKeyframeOrder: eh,
        sortedArray: th,
        flattenJSON: rh,
        subclip: function (e, t, r, n, i = 30) {
          const s = e.clone();
          s.name = t;
          const o = [];
          for (let e = 0; e < s.tracks.length; ++e) {
            const t = s.tracks[e],
              a = t.getValueSize(),
              l = [],
              c = [];
            for (let e = 0; e < t.times.length; ++e) {
              const s = t.times[e] * i;
              if (!(s < r || s >= n)) {
                l.push(t.times[e]);
                for (let r = 0; r < a; ++r) c.push(t.values[e * a + r]);
              }
            }
            0 !== l.length && (t.times = Zu(l, t.times.constructor), t.values = Zu(c, t.values.constructor), o.push(t));
          }
          s.tracks = o;
          let a = 1 / 0;
          for (let e = 0; e < s.tracks.length; ++e) a > s.tracks[e].times[0] && (a = s.tracks[e].times[0]);
          for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * a);
          return s.resetDuration(), s;
        },
        makeClipAdditive: function (e, t = 0, r = e, n = 30) {
          n <= 0 && (n = 30);
          const i = r.tracks.length,
            s = t / n;
          for (let t = 0; t < i; ++t) {
            const n = r.tracks[t],
              i = n.ValueTypeName;
            if ("bool" === i || "string" === i) continue;
            const o = e.tracks.find(function (e) {
              return e.name === n.name && e.ValueTypeName === i;
            });
            if (void 0 === o) continue;
            let a = 0;
            const l = n.getValueSize();
            n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
            let c = 0;
            const u = o.getValueSize();
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
            const h = n.times.length - 1;
            let p;
            if (s <= n.times[0]) {
              const e = a,
                t = l - a;
              p = Ju(n.values, e, t);
            } else if (s >= n.times[h]) {
              const e = h * l + a,
                t = e + l - a;
              p = Ju(n.values, e, t);
            } else {
              const e = n.createInterpolant(),
                t = a,
                r = l - a;
              e.evaluate(s), p = Ju(e.resultBuffer, t, r);
            }
            "quaternion" === i && new an().fromArray(p).normalize().conjugate().toArray(p);
            const d = o.times.length;
            for (let e = 0; e < d; ++e) {
              const t = e * u + c;
              if ("quaternion" === i) an.multiplyQuaternionsFlat(o.values, t, p, 0, o.values, t);else {
                const e = u - 2 * c;
                for (let r = 0; r < e; ++r) o.values[t + r] -= p[r];
              }
            }
          }
          return e.blendMode = Ct, e;
        }
      });
      class ih {
        constructor(e, t, r, n) {
          this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let r = this._cachedIndex,
            n = t[r],
            i = t[r - 1];
          e: {
            t: {
              let s;
              r: {
                n: if (!(e < n)) {
                  for (let s = r + 2;;) {
                    if (void 0 === n) {
                      if (e < i) break n;
                      return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
                    }
                    if (r === s) break;
                    if (i = n, n = t[++r], e < n) break t;
                  }
                  s = t.length;
                  break r;
                }
                if (e >= i) break e;
                {
                  const o = t[1];
                  e < o && (r = 2, i = o);
                  for (let s = r - 2;;) {
                    if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (r === s) break;
                    if (n = i, i = t[--r - 1], e >= i) break t;
                  }
                  s = r, r = 0;
                }
              }
              for (; r < s;) {
                const n = r + s >>> 1;
                e < t[n] ? s = n : r = n + 1;
              }
              if (n = t[r], i = t[r - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (void 0 === n) return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
            }
            this._cachedIndex = r, this.intervalChanged_(r, i, n);
          }
          return this.interpolate_(r, i, e, n);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            r = this.sampleValues,
            n = this.valueSize,
            i = e * n;
          for (let e = 0; e !== n; ++e) t[e] = r[i + e];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class sh extends ih {
        constructor(e, t, r, n) {
          super(e, t, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: xt,
            endingEnd: xt
          };
        }
        intervalChanged_(e, t, r) {
          const n = this.parameterPositions;
          let i = e - 2,
            s = e + 1,
            o = n[i],
            a = n[s];
          if (void 0 === o) switch (this.getSettings_().endingStart) {
            case wt:
              i = e, o = 2 * t - r;
              break;
            case Et:
              i = n.length - 2, o = t + n[i] - n[i + 1];
              break;
            default:
              i = e, o = r;
          }
          if (void 0 === a) switch (this.getSettings_().endingEnd) {
            case wt:
              s = e, a = 2 * r - t;
              break;
            case Et:
              s = 1, a = r + n[1] - n[0];
              break;
            default:
              s = e - 1, a = t;
          }
          const l = .5 * (r - t),
            c = this.valueSize;
          this._weightPrev = l / (t - o), this._weightNext = l / (a - r), this._offsetPrev = i * c, this._offsetNext = s * c;
        }
        interpolate_(e, t, r, n) {
          const i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = e * o,
            l = a - o,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            p = this._weightNext,
            d = (r - t) / (n - t),
            f = d * d,
            m = f * d,
            _ = -h * m + 2 * h * f - h * d,
            g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * d + 1,
            v = (-1 - p) * m + (1.5 + p) * f + .5 * d,
            A = p * m - p * f;
          for (let e = 0; e !== o; ++e) i[e] = _ * s[c + e] + g * s[l + e] + v * s[a + e] + A * s[u + e];
          return i;
        }
      }
      class oh extends ih {
        constructor(e, t, r, n) {
          super(e, t, r, n);
        }
        interpolate_(e, t, r, n) {
          const i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = e * o,
            l = a - o,
            c = (r - t) / (n - t),
            u = 1 - c;
          for (let e = 0; e !== o; ++e) i[e] = s[l + e] * u + s[a + e] * c;
          return i;
        }
      }
      class ah extends ih {
        constructor(e, t, r, n) {
          super(e, t, r, n);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class lh {
        constructor(e, t, r, n) {
          if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          this.name = e, this.times = Zu(t, this.TimeBufferType), this.values = Zu(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let r;
          if (t.toJSON !== this.toJSON) r = t.toJSON(e);else {
            r = {
              name: e.name,
              times: Zu(e.times, Array),
              values: Zu(e.values, Array)
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (r.interpolation = t);
          }
          return r.type = e.ValueTypeName, r;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new ah(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new oh(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new sh(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case At:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case bt:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case yt:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(t);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", t), this;
          }
          return this.createInterpolant = t, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return At;
            case this.InterpolantFactoryMethodLinear:
              return bt;
            case this.InterpolantFactoryMethodSmooth:
              return yt;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let r = 0, n = t.length; r !== n; ++r) t[r] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let r = 0, n = t.length; r !== n; ++r) t[r] *= e;
          }
          return this;
        }
        trim(e, t) {
          const r = this.times,
            n = r.length;
          let i = 0,
            s = n - 1;
          for (; i !== n && r[i] < e;) ++i;
          for (; -1 !== s && r[s] > t;) --s;
          if (++s, 0 !== i || s !== n) {
            i >= s && (s = Math.max(s, 1), i = s - 1);
            const e = this.getValueSize();
            this.times = Ju(r, i, s), this.values = Ju(this.values, i * e, s * e);
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
          const r = this.times,
            n = this.values,
            i = r.length;
          0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
          let s = null;
          for (let t = 0; t !== i; t++) {
            const n = r[t];
            if ("number" == typeof n && isNaN(n)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, n), e = !1;
              break;
            }
            if (null !== s && s > n) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, s), e = !1;
              break;
            }
            s = n;
          }
          if (void 0 !== n && $u(n)) for (let t = 0, r = n.length; t !== r; ++t) {
            const r = n[t];
            if (isNaN(r)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, r), e = !1;
              break;
            }
          }
          return e;
        }
        optimize() {
          const e = Ju(this.times),
            t = Ju(this.values),
            r = this.getValueSize(),
            n = this.getInterpolation() === yt,
            i = e.length - 1;
          let s = 1;
          for (let o = 1; o < i; ++o) {
            let i = !1;
            const a = e[o];
            if (a !== e[o + 1] && (1 !== o || a !== e[0])) if (n) i = !0;else {
              const e = o * r,
                n = e - r,
                s = e + r;
              for (let o = 0; o !== r; ++o) {
                const r = t[e + o];
                if (r !== t[n + o] || r !== t[s + o]) {
                  i = !0;
                  break;
                }
              }
            }
            if (i) {
              if (o !== s) {
                e[s] = e[o];
                const n = o * r,
                  i = s * r;
                for (let e = 0; e !== r; ++e) t[i + e] = t[n + e];
              }
              ++s;
            }
          }
          if (i > 0) {
            e[s] = e[i];
            for (let e = i * r, n = s * r, o = 0; o !== r; ++o) t[n + o] = t[e + o];
            ++s;
          }
          return s !== e.length ? (this.times = Ju(e, 0, s), this.values = Ju(t, 0, s * r)) : (this.times = e, this.values = t), this;
        }
        clone() {
          const e = Ju(this.times, 0),
            t = Ju(this.values, 0),
            r = new (0, this.constructor)(this.name, e, t);
          return r.createInterpolant = this.createInterpolant, r;
        }
      }
      lh.prototype.TimeBufferType = Float32Array, lh.prototype.ValueBufferType = Float32Array, lh.prototype.DefaultInterpolation = bt;
      class ch extends lh {}
      ch.prototype.ValueTypeName = "bool", ch.prototype.ValueBufferType = Array, ch.prototype.DefaultInterpolation = At, ch.prototype.InterpolantFactoryMethodLinear = void 0, ch.prototype.InterpolantFactoryMethodSmooth = void 0;
      class uh extends lh {}
      uh.prototype.ValueTypeName = "color";
      class hh extends lh {}
      hh.prototype.ValueTypeName = "number";
      class ph extends ih {
        constructor(e, t, r, n) {
          super(e, t, r, n);
        }
        interpolate_(e, t, r, n) {
          const i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = (r - t) / (n - t);
          let l = e * o;
          for (let e = l + o; l !== e; l += 4) an.slerpFlat(i, 0, s, l - o, s, l, a);
          return i;
        }
      }
      class dh extends lh {
        InterpolantFactoryMethodLinear(e) {
          return new ph(this.times, this.values, this.getValueSize(), e);
        }
      }
      dh.prototype.ValueTypeName = "quaternion", dh.prototype.DefaultInterpolation = bt, dh.prototype.InterpolantFactoryMethodSmooth = void 0;
      class fh extends lh {}
      fh.prototype.ValueTypeName = "string", fh.prototype.ValueBufferType = Array, fh.prototype.DefaultInterpolation = At, fh.prototype.InterpolantFactoryMethodLinear = void 0, fh.prototype.InterpolantFactoryMethodSmooth = void 0;
      class mh extends lh {}
      mh.prototype.ValueTypeName = "vector";
      class _h {
        constructor(e, t = -1, r, n = St) {
          this.name = e, this.tracks = r, this.duration = t, this.blendMode = n, this.uuid = br(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            r = e.tracks,
            n = 1 / (e.fps || 1);
          for (let e = 0, i = r.length; e !== i; ++e) t.push(gh(r[e]).scale(n));
          const i = new this(e.name, e.duration, t, e.blendMode);
          return i.uuid = e.uuid, i;
        }
        static toJSON(e) {
          const t = [],
            r = e.tracks,
            n = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode
            };
          for (let e = 0, n = r.length; e !== n; ++e) t.push(lh.toJSON(r[e]));
          return n;
        }
        static CreateFromMorphTargetSequence(e, t, r, n) {
          const i = t.length,
            s = [];
          for (let e = 0; e < i; e++) {
            let o = [],
              a = [];
            o.push((e + i - 1) % i, e, (e + 1) % i), a.push(0, 1, 0);
            const l = eh(o);
            o = th(o, 1, l), a = th(a, 1, l), n || 0 !== o[0] || (o.push(i), a.push(a[0])), s.push(new hh(".morphTargetInfluences[" + t[e].name + "]", o, a).scale(1 / r));
          }
          return new this(e, -1, s);
        }
        static findByName(e, t) {
          let r = e;
          if (!Array.isArray(e)) {
            const t = e;
            r = t.geometry && t.geometry.animations || t.animations;
          }
          for (let e = 0; e < r.length; e++) if (r[e].name === t) return r[e];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, r) {
          const n = {},
            i = /^([\w-]*?)([\d]+)$/;
          for (let t = 0, r = e.length; t < r; t++) {
            const r = e[t],
              s = r.name.match(i);
            if (s && s.length > 1) {
              const e = s[1];
              let t = n[e];
              t || (n[e] = t = []), t.push(r);
            }
          }
          const s = [];
          for (const e in n) s.push(this.CreateFromMorphTargetSequence(e, n[e], t, r));
          return s;
        }
        static parseAnimation(e, t) {
          if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const r = function (e, t, r, n, i) {
              if (0 !== r.length) {
                const s = [],
                  o = [];
                rh(r, s, o, n), 0 !== s.length && i.push(new e(t, s, o));
              }
            },
            n = [],
            i = e.name || "default",
            s = e.fps || 30,
            o = e.blendMode;
          let a = e.length || -1;
          const l = e.hierarchy || [];
          for (let e = 0; e < l.length; e++) {
            const i = l[e].keys;
            if (i && 0 !== i.length) if (i[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < i.length; t++) if (i[t].morphTargets) for (let r = 0; r < i[t].morphTargets.length; r++) e[i[t].morphTargets[r]] = -1;
              for (const r in e) {
                const e = [],
                  s = [];
                for (let n = 0; n !== i[t].morphTargets.length; ++n) {
                  const n = i[t];
                  e.push(n.time), s.push(n.morphTarget === r ? 1 : 0);
                }
                n.push(new hh(".morphTargetInfluence[" + r + "]", e, s));
              }
              a = e.length * s;
            } else {
              const s = ".bones[" + t[e].name + "]";
              r(mh, s + ".position", i, "pos", n), r(dh, s + ".quaternion", i, "rot", n), r(mh, s + ".scale", i, "scl", n);
            }
          }
          return 0 === n.length ? null : new this(i, a, n, o);
        }
        resetDuration() {
          let e = 0;
          for (let t = 0, r = this.tracks.length; t !== r; ++t) {
            const r = this.tracks[t];
            e = Math.max(e, r.times[r.times.length - 1]);
          }
          return this.duration = e, this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
          return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function gh(e) {
        if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t = function (e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return hh;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return mh;
            case "color":
              return uh;
            case "quaternion":
              return dh;
            case "bool":
            case "boolean":
              return ch;
            case "string":
              return fh;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        }(e.type);
        if (void 0 === e.times) {
          const t = [],
            r = [];
          rh(e.keys, t, r, "value"), e.times = t, e.values = r;
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
      }
      const vh = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e, t) {
          return !1 === this.enabled ? t ? Promise.resolve() : void 0 : t ? Promise.resolve(this.files[e]) : this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        }
      };
      class Ah {
        constructor(e, t, r) {
          const n = this;
          let i,
            s = !1,
            o = 0,
            a = 0;
          const l = [];
          this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function (e) {
            a++, !1 === s && void 0 !== n.onStart && n.onStart(e, o, a), s = !0;
          }, this.itemEnd = function (e) {
            o++, void 0 !== n.onProgress && n.onProgress(e, o, a), o === a && (s = !1, void 0 !== n.onLoad && n.onLoad());
          }, this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e);
          }, this.resolveURL = function (e) {
            return i ? i(e) : e;
          }, this.setURLModifier = function (e) {
            return i = e, this;
          }, this.addHandler = function (e, t) {
            return l.push(e, t), this;
          }, this.removeHandler = function (e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this;
          }, this.getHandler = function (e) {
            for (let t = 0, r = l.length; t < r; t += 2) {
              const r = l[t],
                n = l[t + 1];
              if (r.global && (r.lastIndex = 0), r.test(e)) return n;
            }
            return null;
          };
        }
      }
      const bh = new Ah();
      class yh {
        constructor(e) {
          this.manager = void 0 !== e ? e : bh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {}
        loadAsync(e, t) {
          const r = this;
          return new Promise(function (n, i) {
            r.load(e, n, t, i);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
          return this.withCredentials = e, this;
        }
        setPath(e) {
          return this.path = e, this;
        }
        setResourcePath(e) {
          return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
          return this.requestHeader = e, this;
        }
      }
      const xh = {};
      class wh extends Error {
        constructor(e, t) {
          super(e), this.response = t;
        }
      }
      class Eh extends yh {
        constructor(e) {
          super(e), this.responseType = "text";
        }
        load(e, t, r, n) {
          void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e), vh.get(e, this.responseType, this.mimeType).then(i => {
            if (void 0 !== i) return this.manager.itemStart(e), setTimeout(() => {
              t && t(i), this.manager.itemEnd(e);
            }, 0), i;
            if (void 0 !== xh[e]) return void xh[e].push({
              onLoad: t,
              onProgress: r,
              onError: n
            });
            xh[e] = [], xh[e].push({
              onLoad: t,
              onProgress: r,
              onError: n
            });
            const s = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
              }),
              o = this.mimeType,
              a = this.responseType;
            fetch(s).then(t => {
              if (200 === t.status || 0 === t.status) {
                if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                const r = xh[e],
                  n = t.body.getReader(),
                  i = t.headers.get("Content-Length"),
                  s = i ? parseInt(i) : 0,
                  o = 0 !== s;
                let a = 0;
                const l = new ReadableStream({
                  start(e) {
                    !function t() {
                      n.read().then(({
                        done: n,
                        value: i
                      }) => {
                        if (n) e.close();else {
                          a += i.byteLength;
                          const n = new ProgressEvent("progress", {
                            lengthComputable: o,
                            loaded: a,
                            total: s
                          });
                          for (let e = 0, t = r.length; e < t; e++) {
                            const t = r[e];
                            t.onProgress && t.onProgress(n);
                          }
                          e.enqueue(i), t();
                        }
                      });
                    }();
                  }
                });
                return new Response(l);
              }
              throw new wh(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t);
            }).then(e => {
              switch (a) {
                case "arraybuffer":
                  return e.arrayBuffer();
                case "blob":
                  return e.blob();
                case "document":
                  return e.text().then(e => new DOMParser().parseFromString(e, o));
                case "json":
                  return e.json();
                default:
                  if (void 0 === o) return e.text();
                  {
                    const t = /charset="?([^;"\s]*)"?/i.exec(o),
                      r = t && t[1] ? t[1].toLowerCase() : void 0,
                      n = new TextDecoder(r);
                    return e.arrayBuffer().then(e => n.decode(e));
                  }
              }
            }).then(t => {
              vh.add(e, t, this.responseType);
              const r = xh[e];
              delete xh[e];
              for (let e = 0, n = r.length; e < n; e++) {
                const n = r[e];
                n.onLoad && n.onLoad(t);
              }
            }).catch(t => {
              const r = xh[e];
              if (void 0 === r) throw this.manager.itemError(e), t;
              delete xh[e];
              for (let e = 0, n = r.length; e < n; e++) {
                const n = r[e];
                n.onError && n.onError(t);
              }
              this.manager.itemError(e);
            }).finally(() => {
              this.manager.itemEnd(e);
            }), this.manager.itemStart(e);
          });
        }
        setResponseType(e) {
          return this.responseType = e, this;
        }
        setMimeType(e) {
          return this.mimeType = e, this;
        }
      }
      class Sh extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = new Eh(this.manager);
          s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (r) {
            try {
              t(i.parse(JSON.parse(r)));
            } catch (t) {
              n ? n(t) : console.error(t), i.manager.itemError(e);
            }
          }, r, n);
        }
        parse(e) {
          const t = [];
          for (let r = 0; r < e.length; r++) {
            const n = _h.parse(e[r]);
            t.push(n);
          }
          return t;
        }
      }
      class Ch extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = [],
            o = new gc(),
            a = new Eh(this.manager);
          a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials);
          let l = 0;
          function c(c) {
            a.load(e[c], function (e) {
              const r = i.parse(e, !0);
              s[c] = {
                width: r.width,
                height: r.height,
                format: r.format,
                mipmaps: r.mipmaps
              }, l += 1, 6 === l && (1 === r.mipmapCount && (o.minFilter = _e), o.image = s, o.format = r.format, o.needsUpdate = !0, t && t(o));
            }, r, n);
          }
          if (Array.isArray(e)) for (let t = 0, r = e.length; t < r; ++t) c(t);else a.load(e, function (e) {
            const r = i.parse(e, !0);
            if (r.isCubemap) {
              const e = r.mipmaps.length / r.mipmapCount;
              for (let t = 0; t < e; t++) {
                s[t] = {
                  mipmaps: []
                };
                for (let e = 0; e < r.mipmapCount; e++) s[t].mipmaps.push(r.mipmaps[t * r.mipmapCount + e]), s[t].format = r.format, s[t].width = r.width, s[t].height = r.height;
              }
              o.image = s;
            } else o.image.width = r.width, o.image.height = r.height, o.mipmaps = r.mipmaps;
            1 === r.mipmapCount && (o.minFilter = _e), o.format = r.format, o.needsUpdate = !0, t && t(o);
          }, r, n);
          return o;
        }
      }
      class Mh extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
          const i = this,
            s = vh.get(e);
          if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () {
            t && t(s), i.manager.itemEnd(e);
          }, 0), s;
          const o = Lr("img");
          function a() {
            c(), vh.add(e, this), t && t(this), i.manager.itemEnd(e);
          }
          function l(t) {
            c(), n && n(t), i.manager.itemError(e), i.manager.itemEnd(e);
          }
          function c() {
            o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1);
          }
          return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o;
        }
      }
      class Th extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = new bs(),
            s = new Mh(this.manager);
          s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
          let o = 0;
          function a(r) {
            s.load(e[r], function (e) {
              i.images[r] = e, o++, 6 === o && (i.needsUpdate = !0, t && t(i));
            }, void 0, n);
          }
          for (let t = 0; t < e.length; ++t) a(t);
          return i;
        }
      }
      class Ih extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = new zl(),
            o = new Eh(this.manager);
          return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, function (e) {
            const r = i.parse(e);
            r && (void 0 !== r.image ? s.image = r.image : void 0 !== r.data && (s.image.width = r.width, s.image.height = r.height, s.image.data = r.data, s.image.complete = !0), s.wrapS = void 0 !== r.wrapS ? r.wrapS : ce, s.wrapT = void 0 !== r.wrapT ? r.wrapT : ce, s.magFilter = void 0 !== r.magFilter ? r.magFilter : _e, s.minFilter = void 0 !== r.minFilter ? r.minFilter : _e, s.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1, void 0 !== r.encoding && (s.encoding = r.encoding), void 0 !== r.flipY && (s.flipY = r.flipY), void 0 !== r.format && (s.format = r.format), void 0 !== r.type && (s.type = r.type), void 0 !== r.mipmaps && (s.mipmaps = r.mipmaps, s.minFilter = Ae), 1 === r.mipmapCount && (s.minFilter = _e), void 0 !== r.generateMipmaps && (s.generateMipmaps = r.generateMipmaps), s.needsUpdate = !0, t && t(s, r));
          }, r, n), s;
        }
      }
      class kh extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = new Zr(),
            s = new Mh(this.manager);
          return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (e) {
            i.image = e, i.needsUpdate = !0, void 0 !== t && t(i);
          }, r, n), i;
        }
      }
      class Dh extends ui {
        constructor(e, t = 1) {
          super(), this.isLight = !0, this.type = "Light", this.color = new Wr(e), this.intensity = t;
        }
        dispose() {}
        copy(e, t) {
          return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t;
        }
      }
      class Ph extends Dh {
        constructor(e, t, r) {
          super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.groundColor = new Wr(t);
        }
        copy(e, t) {
          return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
        }
      }
      const Bh = new Nn(),
        Rh = new ln(),
        Lh = new ln();
      class Oh {
        constructor(e) {
          this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new kr(512, 512), this.map = null, this.mapPass = null, this.matrix = new Nn(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ts(), this._frameExtents = new kr(1, 1), this._viewportCount = 1, this._viewports = [new $r(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            r = this.matrix;
          Rh.setFromMatrixPosition(e.matrixWorld), t.position.copy(Rh), Lh.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Lh), t.updateMatrixWorld(), Bh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Bh), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(t.projectionMatrix), r.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return this.camera = e.camera.clone(), this.bias = e.bias, this.normalBias = e.normalBias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
        }
      }
      class Fh extends Oh {
        constructor() {
          super(new gs(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
        }
        updateMatrices(e) {
          const t = this.camera,
            r = 2 * Ar * e.angle * this.focus,
            n = this.mapSize.width / this.mapSize.height,
            i = e.distance || t.far;
          r === t.fov && n === t.aspect && i === t.far || (t.fov = r, t.aspect = n, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), this.focus = e.focus, this;
        }
      }
      class Uh extends Dh {
        constructor(e, t, r = 0, n = Math.PI / 3, i = 0, s = 1) {
          super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.distance = r, this.angle = n, this.penumbra = i, this.decay = s, this.map = null, this.shadow = new Fh();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      const Nh = new Nn(),
        jh = new ln(),
        zh = new ln();
      class Gh extends Oh {
        constructor() {
          super(new gs(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new kr(4, 2), this._viewportCount = 6, this._viewports = [new $r(2, 1, 1, 1), new $r(0, 1, 1, 1), new $r(3, 1, 1, 1), new $r(1, 1, 1, 1), new $r(3, 0, 1, 1), new $r(1, 0, 1, 1)], this._cubeDirections = [new ln(1, 0, 0), new ln(-1, 0, 0), new ln(0, 0, 1), new ln(0, 0, -1), new ln(0, 1, 0), new ln(0, -1, 0)], this._cubeUps = [new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 0, 1), new ln(0, 0, -1)];
        }
        updateMatrices(e, t = 0) {
          const r = this.camera,
            n = this.matrix,
            i = e.distance || r.far;
          i !== r.far && (r.far = i, r.updateProjectionMatrix()), jh.setFromMatrixPosition(e.matrixWorld), r.position.copy(jh), zh.copy(r.position), zh.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(zh), r.updateMatrixWorld(), n.makeTranslation(-jh.x, -jh.y, -jh.z), Nh.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Nh);
        }
      }
      class Vh extends Dh {
        constructor(e, t, r = 0, n = 1) {
          super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = n, this.shadow = new Gh();
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
      }
      class Qh extends Oh {
        constructor() {
          super(new zs(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
        }
      }
      class Hh extends Dh {
        constructor(e, t) {
          super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.shadow = new Qh();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      class Wh extends Dh {
        constructor(e, t) {
          super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
        }
      }
      class qh extends Dh {
        constructor(e, t, r = 10, n = 10) {
          super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = n;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
          this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
          return super.copy(e), this.width = e.width, this.height = e.height, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.width = this.width, t.object.height = this.height, t;
        }
      }
      class Xh {
        constructor() {
          this.isSphericalHarmonics3 = !0, this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new ln());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const r = e.x,
            n = e.y,
            i = e.z,
            s = this.coefficients;
          return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * n), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * r), t.addScaledVector(s[4], r * n * 1.092548), t.addScaledVector(s[5], n * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], r * i * 1.092548), t.addScaledVector(s[8], .546274 * (r * r - n * n)), t;
        }
        getIrradianceAt(e, t) {
          const r = e.x,
            n = e.y,
            i = e.z,
            s = this.coefficients;
          return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * n), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * r), t.addScaledVector(s[4], .858086 * r * n), t.addScaledVector(s[5], .858086 * n * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * r * i), t.addScaledVector(s[8], .429043 * (r * r - n * n)), t;
        }
        add(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let r = 0; r < 9; r++) this.coefficients[r].addScaledVector(e.coefficients[r], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const r = this.coefficients;
          for (let n = 0; n < 9; n++) r[n].fromArray(e, t + 3 * n);
          return this;
        }
        toArray(e = [], t = 0) {
          const r = this.coefficients;
          for (let n = 0; n < 9; n++) r[n].toArray(e, t + 3 * n);
          return e;
        }
        static getBasisAt(e, t) {
          const r = e.x,
            n = e.y,
            i = e.z;
          t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * i, t[3] = .488603 * r, t[4] = 1.092548 * r * n, t[5] = 1.092548 * n * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * r * i, t[8] = .546274 * (r * r - n * n);
        }
      }
      class Yh extends Dh {
        constructor(e = new Xh(), t = 1) {
          super(void 0, t), this.isLightProbe = !0, this.sh = e;
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.sh = this.sh.toArray(), t;
        }
      }
      class Kh extends yh {
        constructor(e) {
          super(e), this.textures = {};
        }
        load(e, t, r, n) {
          const i = this,
            s = new Eh(i.manager);
          s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (r) {
            try {
              t(i.parse(JSON.parse(r)));
            } catch (t) {
              n ? n(t) : console.error(t), i.manager.itemError(e);
            }
          }, r, n);
        }
        parse(e) {
          const t = this.textures;
          function r(e) {
            return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e];
          }
          const n = Kh.createMaterialFromType(e.type);
          if (void 0 !== e.uuid && (n.uuid = e.uuid), void 0 !== e.name && (n.name = e.name), void 0 !== e.color && void 0 !== n.color && n.color.setHex(e.color), void 0 !== e.roughness && (n.roughness = e.roughness), void 0 !== e.metalness && (n.metalness = e.metalness), void 0 !== e.sheen && (n.sheen = e.sheen), void 0 !== e.sheenColor && (n.sheenColor = new Wr().setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (n.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== n.emissive && n.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== n.specular && n.specular.setHex(e.specular), void 0 !== e.specularIntensity && (n.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== n.specularColor && n.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (n.shininess = e.shininess), void 0 !== e.clearcoat && (n.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (n.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.iridescence && (n.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (n.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (n.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (n.transmission = e.transmission), void 0 !== e.thickness && (n.thickness = e.thickness), void 0 !== e.attenuationDistance && (n.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== n.attenuationColor && n.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (n.fog = e.fog), void 0 !== e.flatShading && (n.flatShading = e.flatShading), void 0 !== e.blending && (n.blending = e.blending), void 0 !== e.combine && (n.combine = e.combine), void 0 !== e.side && (n.side = e.side), void 0 !== e.shadowSide && (n.shadowSide = e.shadowSide), void 0 !== e.opacity && (n.opacity = e.opacity), void 0 !== e.transparent && (n.transparent = e.transparent), void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest), void 0 !== e.depthTest && (n.depthTest = e.depthTest), void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (n.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (n.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (n.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (n.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (n.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (n.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (n.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (n.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (n.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (n.rotation = e.rotation), 1 !== e.linewidth && (n.linewidth = e.linewidth), void 0 !== e.dashSize && (n.dashSize = e.dashSize), void 0 !== e.gapSize && (n.gapSize = e.gapSize), void 0 !== e.scale && (n.scale = e.scale), void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (n.dithering = e.dithering), void 0 !== e.alphaToCoverage && (n.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (n.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.toneMapped && (n.toneMapped = e.toneMapped), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (const t in e.uniforms) {
            const i = e.uniforms[t];
            switch (n.uniforms[t] = {}, i.type) {
              case "t":
                n.uniforms[t].value = r(i.value);
                break;
              case "c":
                n.uniforms[t].value = new Wr().setHex(i.value);
                break;
              case "v2":
                n.uniforms[t].value = new kr().fromArray(i.value);
                break;
              case "v3":
                n.uniforms[t].value = new ln().fromArray(i.value);
                break;
              case "v4":
                n.uniforms[t].value = new $r().fromArray(i.value);
                break;
              case "m3":
                n.uniforms[t].value = new Dr().fromArray(i.value);
                break;
              case "m4":
                n.uniforms[t].value = new Nn().fromArray(i.value);
                break;
              default:
                n.uniforms[t].value = i.value;
            }
          }
          if (void 0 !== e.defines && (n.defines = e.defines), void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (n.glslVersion = e.glslVersion), void 0 !== e.extensions) for (const t in e.extensions) n.extensions[t] = e.extensions[t];
          if (void 0 !== e.size && (n.size = e.size), void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (n.map = r(e.map)), void 0 !== e.matcap && (n.matcap = r(e.matcap)), void 0 !== e.alphaMap && (n.alphaMap = r(e.alphaMap)), void 0 !== e.bumpMap && (n.bumpMap = r(e.bumpMap)), void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale), void 0 !== e.normalMap && (n.normalMap = r(e.normalMap)), void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
            let t = e.normalScale;
            !1 === Array.isArray(t) && (t = [t, t]), n.normalScale = new kr().fromArray(t);
          }
          return void 0 !== e.displacementMap && (n.displacementMap = r(e.displacementMap)), void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (n.roughnessMap = r(e.roughnessMap)), void 0 !== e.metalnessMap && (n.metalnessMap = r(e.metalnessMap)), void 0 !== e.emissiveMap && (n.emissiveMap = r(e.emissiveMap)), void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (n.specularMap = r(e.specularMap)), void 0 !== e.specularIntensityMap && (n.specularIntensityMap = r(e.specularIntensityMap)), void 0 !== e.specularColorMap && (n.specularColorMap = r(e.specularColorMap)), void 0 !== e.envMap && (n.envMap = r(e.envMap)), void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (n.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (n.lightMap = r(e.lightMap)), void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (n.aoMap = r(e.aoMap)), void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (n.gradientMap = r(e.gradientMap)), void 0 !== e.clearcoatMap && (n.clearcoatMap = r(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (n.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (n.clearcoatNormalMap = r(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (n.clearcoatNormalScale = new kr().fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (n.iridescenceMap = r(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (n.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (n.transmissionMap = r(e.transmissionMap)), void 0 !== e.thicknessMap && (n.thicknessMap = r(e.thicknessMap)), void 0 !== e.sheenColorMap && (n.sheenColorMap = r(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (n.sheenRoughnessMap = r(e.sheenRoughnessMap)), n;
        }
        setTextures(e) {
          return this.textures = e, this;
        }
        static createMaterialFromType(e) {
          return new {
            ShadowMaterial: zu,
            SpriteMaterial: ml,
            RawShaderMaterial: Gu,
            ShaderMaterial: ms,
            PointsMaterial: lc,
            MeshPhysicalMaterial: Qu,
            MeshStandardMaterial: Vu,
            MeshPhongMaterial: Hu,
            MeshToonMaterial: Wu,
            MeshNormalMaterial: qu,
            MeshLambertMaterial: Xu,
            MeshDepthMaterial: qa,
            MeshDistanceMaterial: Xa,
            MeshBasicMaterial: Ei,
            MeshMatcapMaterial: Yu,
            LineDashedMaterial: Ku,
            LineBasicMaterial: Jl,
            Material: wi
          }[e]();
        }
      }
      class Jh {
        static decodeText(e) {
          if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
          let t = "";
          for (let r = 0, n = e.length; r < n; r++) t += String.fromCharCode(e[r]);
          try {
            return decodeURIComponent(escape(t));
          } catch (e) {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
      }
      class Zh extends Hi {
        constructor() {
          super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(e) {
          return super.copy(e), this.instanceCount = e.instanceCount, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
        }
      }
      class $h extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = new Eh(i.manager);
          s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (r) {
            try {
              t(i.parse(JSON.parse(r)));
            } catch (t) {
              n ? n(t) : console.error(t), i.manager.itemError(e);
            }
          }, r, n);
        }
        parse(e) {
          const t = {},
            r = {};
          function n(e, n) {
            if (void 0 !== t[n]) return t[n];
            const i = e.interleavedBuffers[n],
              s = function (e, t) {
                if (void 0 !== r[t]) return r[t];
                const n = e.arrayBuffers[t],
                  i = new Uint32Array(n).buffer;
                return r[t] = i, i;
              }(e, i.buffer),
              o = Rr(i.type, s),
              a = new pl(o, i.stride);
            return a.uuid = i.uuid, t[n] = a, a;
          }
          const i = e.isInstancedBufferGeometry ? new Zh() : new Hi(),
            s = e.data.index;
          if (void 0 !== s) {
            const e = Rr(s.type, s.array);
            i.setIndex(new Mi(e, 1));
          }
          const o = e.data.attributes;
          for (const t in o) {
            const r = o[t];
            let s;
            if (r.isInterleavedBufferAttribute) {
              const t = n(e.data, r.data);
              s = new fl(t, r.itemSize, r.offset, r.normalized);
            } else {
              const e = Rr(r.type, r.array);
              s = new (r.isInstancedBufferAttribute ? Hl : Mi)(e, r.itemSize, r.normalized);
            }
            void 0 !== r.name && (s.name = r.name), void 0 !== r.usage && s.setUsage(r.usage), void 0 !== r.updateRange && (s.updateRange.offset = r.updateRange.offset, s.updateRange.count = r.updateRange.count), i.setAttribute(t, s);
          }
          const a = e.data.morphAttributes;
          if (a) for (const t in a) {
            const r = a[t],
              s = [];
            for (let t = 0, i = r.length; t < i; t++) {
              const i = r[t];
              let o;
              if (i.isInterleavedBufferAttribute) {
                const t = n(e.data, i.data);
                o = new fl(t, i.itemSize, i.offset, i.normalized);
              } else {
                const e = Rr(i.type, i.array);
                o = new Mi(e, i.itemSize, i.normalized);
              }
              void 0 !== i.name && (o.name = i.name), s.push(o);
            }
            i.morphAttributes[t] = s;
          }
          e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
          const l = e.data.groups || e.data.drawcalls || e.data.offsets;
          if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) {
            const t = l[e];
            i.addGroup(t.start, t.count, t.materialIndex);
          }
          const c = e.data.boundingSphere;
          if (void 0 !== c) {
            const e = new ln();
            void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new kn(e, c.radius);
          }
          return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i;
        }
      }
      class ep extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = "" === this.path ? Jh.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || s;
          const o = new Eh(this.manager);
          o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (r) {
            let s = null;
            try {
              s = JSON.parse(r);
            } catch (t) {
              return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message);
            }
            const o = s.metadata;
            void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e);
          }, r, n);
        }
        async loadAsync(e, t) {
          const r = "" === this.path ? Jh.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || r;
          const n = new Eh(this.manager);
          n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials);
          const i = await n.loadAsync(e, t),
            s = JSON.parse(i),
            o = s.metadata;
          if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
          return await this.parseAsync(s);
        }
        parse(e, t) {
          const r = this.parseAnimations(e.animations),
            n = this.parseShapes(e.shapes),
            i = this.parseGeometries(e.geometries, n),
            s = this.parseImages(e.images, function () {
              void 0 !== t && t(l);
            }),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, i, a, o, r),
            c = this.parseSkeletons(e.skeletons, l);
          if (this.bindSkeletons(l, c), void 0 !== t) {
            let e = !1;
            for (const t in s) if (s[t].data instanceof HTMLImageElement) {
              e = !0;
              break;
            }
            !1 === e && t(l);
          }
          return l;
        }
        async parseAsync(e) {
          const t = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            n = this.parseGeometries(e.geometries, r),
            i = await this.parseImagesAsync(e.images),
            s = this.parseTextures(e.textures, i),
            o = this.parseMaterials(e.materials, s),
            a = this.parseObject(e.object, n, o, s, t),
            l = this.parseSkeletons(e.skeletons, a);
          return this.bindSkeletons(a, l), a;
        }
        parseShapes(e) {
          const t = {};
          if (void 0 !== e) for (let r = 0, n = e.length; r < n; r++) {
            const n = new $c().fromJSON(e[r]);
            t[n.uuid] = n;
          }
          return t;
        }
        parseSkeletons(e, t) {
          const r = {},
            n = {};
          if (t.traverse(function (e) {
            e.isBone && (n[e.uuid] = e);
          }), void 0 !== e) for (let t = 0, i = e.length; t < i; t++) {
            const i = new Ql().fromJSON(e[t], n);
            r[i.uuid] = i;
          }
          return r;
        }
        parseGeometries(e, t) {
          const r = {};
          if (void 0 !== e) {
            const n = new $h();
            for (let i = 0, s = e.length; i < s; i++) {
              let s;
              const o = e[i];
              switch (o.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  s = n.parse(o);
                  break;
                default:
                  o.type in ju ? s = ju[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`);
              }
              s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), r[o.uuid] = s;
            }
          }
          return r;
        }
        parseMaterials(e, t) {
          const r = {},
            n = {};
          if (void 0 !== e) {
            const i = new Kh();
            i.setTextures(t);
            for (let t = 0, s = e.length; t < s; t++) {
              const s = e[t];
              void 0 === r[s.uuid] && (r[s.uuid] = i.parse(s)), n[s.uuid] = r[s.uuid];
            }
          }
          return n;
        }
        parseAnimations(e) {
          const t = {};
          if (void 0 !== e) for (let r = 0; r < e.length; r++) {
            const n = e[r],
              i = _h.parse(n);
            t[i.uuid] = i;
          }
          return t;
        }
        parseImages(e, t) {
          const r = this,
            n = {};
          let i;
          function s(e) {
            if ("string" == typeof e) {
              const t = e;
              return function (e) {
                return r.manager.itemStart(e), i.load(e, function () {
                  r.manager.itemEnd(e);
                }, void 0, function () {
                  r.manager.itemError(e), r.manager.itemEnd(e);
                });
              }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : r.resourcePath + t);
            }
            return e.data ? {
              data: Rr(e.type, e.data),
              width: e.width,
              height: e.height,
              complete: !0
            } : null;
          }
          if (void 0 !== e && e.length > 0) {
            const r = new Ah(t);
            i = new Mh(r), i.setCrossOrigin(this.crossOrigin);
            for (let t = 0, r = e.length; t < r; t++) {
              const r = e[t],
                i = r.url;
              if (Array.isArray(i)) {
                const e = [];
                for (let t = 0, r = i.length; t < r; t++) {
                  const r = s(i[t]);
                  null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new zl(r.data, r.width, r.height)));
                }
                n[r.uuid] = new Yr(e);
              } else {
                const e = s(r.url);
                n[r.uuid] = new Yr(e);
              }
            }
          }
          return n;
        }
        async parseImagesAsync(e) {
          const t = this,
            r = {};
          let n;
          async function i(e) {
            if ("string" == typeof e) {
              const r = e,
                i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r) ? r : t.resourcePath + r;
              return await n.loadAsync(i);
            }
            return e.data ? {
              data: Rr(e.type, e.data),
              width: e.width,
              height: e.height,
              complete: !0
            } : null;
          }
          if (void 0 !== e && e.length > 0) {
            n = new Mh(this.manager), n.setCrossOrigin(this.crossOrigin);
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t],
                s = n.url;
              if (Array.isArray(s)) {
                const e = [];
                for (let t = 0, r = s.length; t < r; t++) {
                  const r = s[t],
                    n = await i(r);
                  null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new zl(n.data, n.width, n.height)));
                }
                r[n.uuid] = new Yr(e);
              } else {
                const e = await i(n.url);
                r[n.uuid] = new Yr(e);
              }
            }
          }
          return r;
        }
        parseTextures(e, t) {
          function r(e, t) {
            return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]);
          }
          const n = {};
          if (void 0 !== e) for (let i = 0, s = e.length; i < s; i++) {
            const s = e[i];
            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
            const o = t[s.image],
              a = o ? o.data : void 0;
            let l;
            Array.isArray(a) ? (l = new bs(), 6 === a.length && (l.needsUpdate = !0)) : (l = a && a.data ? new zl() : new Zr(), a && a.complete && (l.needsUpdate = !0)), l.source = o, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = r(s.mapping, tp)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = r(s.wrap[0], rp), l.wrapT = r(s.wrap[1], rp)), void 0 !== s.format && (l.format = s.format), void 0 !== s.type && (l.type = s.type), void 0 !== s.encoding && (l.encoding = s.encoding), void 0 !== s.minFilter && (l.minFilter = r(s.minFilter, np)), void 0 !== s.magFilter && (l.magFilter = r(s.magFilter, np)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (l.userData = s.userData), n[s.uuid] = l;
          }
          return n;
        }
        parseObject(e, t, r, n, i) {
          let s, o, a;
          function l(e) {
            return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e];
          }
          function c(e) {
            if (void 0 !== e) {
              if (Array.isArray(e)) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                  const i = e[n];
                  void 0 === r[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(r[i]);
                }
                return t;
              }
              return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined material", e), r[e];
            }
          }
          function u(e) {
            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), n[e];
          }
          switch (e.type) {
            case "Scene":
              s = new hl(), void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new Wr(e.background) : s.background = u(e.background)), void 0 !== e.environment && (s.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new ul(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new cl(e.fog.color, e.fog.density)));
              break;
            case "PerspectiveCamera":
              s = new gs(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view));
              break;
            case "OrthographicCamera":
              s = new zs(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view));
              break;
            case "AmbientLight":
              s = new Wh(e.color, e.intensity);
              break;
            case "DirectionalLight":
              s = new Hh(e.color, e.intensity);
              break;
            case "PointLight":
              s = new Vh(e.color, e.intensity, e.distance, e.decay);
              break;
            case "RectAreaLight":
              s = new qh(e.color, e.intensity, e.width, e.height);
              break;
            case "SpotLight":
              s = new Uh(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
              break;
            case "HemisphereLight":
              s = new Ph(e.color, e.groundColor, e.intensity);
              break;
            case "LightProbe":
              s = new Yh().fromJSON(e);
              break;
            case "SkinnedMesh":
              o = l(e.geometry), a = c(e.material), s = new Nl(o, a), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton);
              break;
            case "Mesh":
              o = l(e.geometry), a = c(e.material), s = new cs(o, a);
              break;
            case "InstancedMesh":
              o = l(e.geometry), a = c(e.material);
              const t = e.count,
                r = e.instanceMatrix,
                n = e.instanceColor;
              s = new Kl(o, a, t), s.instanceMatrix = new Hl(new Float32Array(r.array), 16), void 0 !== n && (s.instanceColor = new Hl(new Float32Array(n.array), n.itemSize));
              break;
            case "LOD":
              s = new Bl();
              break;
            case "Line":
              s = new nc(l(e.geometry), c(e.material));
              break;
            case "LineLoop":
              s = new ac(l(e.geometry), c(e.material));
              break;
            case "LineSegments":
              s = new oc(l(e.geometry), c(e.material));
              break;
            case "PointCloud":
            case "Points":
              s = new dc(l(e.geometry), c(e.material));
              break;
            case "Sprite":
              s = new Il(c(e.material));
              break;
            case "Group":
              s = new el();
              break;
            case "Bone":
              s = new jl();
              break;
            default:
              s = new ui();
          }
          if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) {
            const o = e.children;
            for (let e = 0; e < o.length; e++) s.add(this.parseObject(o[e], t, r, n, i));
          }
          if (void 0 !== e.animations) {
            const t = e.animations;
            for (let e = 0; e < t.length; e++) {
              const r = t[e];
              s.animations.push(i[r]);
            }
          }
          if ("LOD" === e.type) {
            void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
            const t = e.levels;
            for (let e = 0; e < t.length; e++) {
              const r = t[e],
                n = s.getObjectByProperty("uuid", r.object);
              void 0 !== n && s.addLevel(n, r.distance);
            }
          }
          return s;
        }
        bindSkeletons(e, t) {
          0 !== Object.keys(t).length && e.traverse(function (e) {
            if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
              const r = t[e.skeleton];
              void 0 === r ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(r, e.bindMatrix);
            }
          });
        }
      }
      const tp = {
          UVMapping: re,
          CubeReflectionMapping: ne,
          CubeRefractionMapping: ie,
          EquirectangularReflectionMapping: se,
          EquirectangularRefractionMapping: oe,
          CubeUVReflectionMapping: ae
        },
        rp = {
          RepeatWrapping: le,
          ClampToEdgeWrapping: ce,
          MirroredRepeatWrapping: ue
        },
        np = {
          NearestFilter: he,
          NearestMipmapNearestFilter: pe,
          NearestMipmapLinearFilter: fe,
          LinearFilter: _e,
          LinearMipmapNearestFilter: ge,
          LinearMipmapLinearFilter: Ae
        };
      class ip extends yh {
        constructor(e) {
          super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(e) {
          return this.options = e, this;
        }
        load(e, t, r, n) {
          void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
          const i = this,
            s = vh.get(e);
          if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () {
            t && t(s), i.manager.itemEnd(e);
          }, 0), s;
          const o = {};
          o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function (e) {
            return e.blob();
          }).then(function (e) {
            return createImageBitmap(e, Object.assign(i.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function (r) {
            vh.add(e, r), t && t(r), i.manager.itemEnd(e);
          }).catch(function (t) {
            n && n(t), i.manager.itemError(e), i.manager.itemEnd(e);
          }), i.manager.itemStart(e);
        }
      }
      let sp;
      const op = {
        getContext: function () {
          return void 0 === sp && (sp = new (window.AudioContext || window.webkitAudioContext)()), sp;
        },
        setContext: function (e) {
          sp = e;
        }
      };
      class ap extends yh {
        constructor(e) {
          super(e);
        }
        load(e, t, r, n) {
          const i = this,
            s = new Eh(this.manager);
          s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (r) {
            try {
              const e = r.slice(0);
              op.getContext().decodeAudioData(e, function (e) {
                t(e);
              });
            } catch (t) {
              n ? n(t) : console.error(t), i.manager.itemError(e);
            }
          }, r, n);
        }
      }
      class lp extends Yh {
        constructor(e, t, r = 1) {
          super(void 0, r), this.isHemisphereLightProbe = !0;
          const n = new Wr().set(e),
            i = new Wr().set(t),
            s = new ln(n.r, n.g, n.b),
            o = new ln(i.r, i.g, i.b),
            a = Math.sqrt(Math.PI),
            l = a * Math.sqrt(.75);
          this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l);
        }
      }
      class cp extends Yh {
        constructor(e, t = 1) {
          super(void 0, t), this.isAmbientLightProbe = !0;
          const r = new Wr().set(e);
          this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      const up = new Nn(),
        hp = new Nn(),
        pp = new Nn();
      class dp {
        constructor() {
          this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new gs(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new gs(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(e) {
          const t = this._cache;
          if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, pp.copy(e.projectionMatrix);
            const r = t.eyeSep / 2,
              n = r * t.near / t.focus,
              i = t.near * Math.tan(vr * t.fov * .5) / t.zoom;
            let s, o;
            hp.elements[12] = -r, up.elements[12] = r, s = -i * t.aspect + n, o = i * t.aspect + n, pp.elements[0] = 2 * t.near / (o - s), pp.elements[8] = (o + s) / (o - s), this.cameraL.projectionMatrix.copy(pp), s = -i * t.aspect - n, o = i * t.aspect - n, pp.elements[0] = 2 * t.near / (o - s), pp.elements[8] = (o + s) / (o - s), this.cameraR.projectionMatrix.copy(pp);
          }
          this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(hp), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(up);
        }
      }
      class fp {
        constructor(e = !0) {
          this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
        }
        start() {
          this.startTime = mp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        }
        stop() {
          this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = mp();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
          }
          return e;
        }
      }
      function mp() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const _p = new ln(),
        gp = new an(),
        vp = new ln(),
        Ap = new ln();
      class bp extends ui {
        constructor() {
          super(), this.type = "AudioListener", this.context = op.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new fp();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(e) {
          return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(e) {
          return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e);
          const t = this.context.listener,
            r = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_p, gp, vp), Ap.set(0, 0, -1).applyQuaternion(gp), t.positionX) {
            const e = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(_p.x, e), t.positionY.linearRampToValueAtTime(_p.y, e), t.positionZ.linearRampToValueAtTime(_p.z, e), t.forwardX.linearRampToValueAtTime(Ap.x, e), t.forwardY.linearRampToValueAtTime(Ap.y, e), t.forwardZ.linearRampToValueAtTime(Ap.z, e), t.upX.linearRampToValueAtTime(r.x, e), t.upY.linearRampToValueAtTime(r.y, e), t.upZ.linearRampToValueAtTime(r.z, e);
          } else t.setPosition(_p.x, _p.y, _p.z), t.setOrientation(Ap.x, Ap.y, Ap.z, r.x, r.y, r.z);
        }
      }
      class yp extends ui {
        constructor(e) {
          super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
        }
        setMediaElementSource(e) {
          return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
        }
        setMediaStreamSource(e) {
          return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
        }
        setBuffer(e) {
          return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(e = 0) {
          if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this._connected = !0, this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this._connected = !1, this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
        }
        setDetune(e) {
          if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
        }
        setLoop(e) {
          if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(e) {
          return this.loopStart = e, this;
        }
        setLoopEnd(e) {
          return this.loopEnd = e, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
        }
      }
      const xp = new ln(),
        wp = new an(),
        Ep = new ln(),
        Sp = new ln();
      class Cp extends yp {
        constructor(e) {
          super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        disconnect() {
          super.disconnect(), this.panner.disconnect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(e) {
          return this.panner.refDistance = e, this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
          return this.panner.rolloffFactor = e, this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(e) {
          return this.panner.distanceModel = e, this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(e) {
          return this.panner.maxDistance = e, this;
        }
        setDirectionalCone(e, t, r) {
          return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
        }
        updateMatrixWorld(e) {
          if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
          this.matrixWorld.decompose(xp, wp, Ep), Sp.set(0, 0, 1).applyQuaternion(wp);
          const t = this.panner;
          if (t.positionX) {
            const e = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(xp.x, e), t.positionY.linearRampToValueAtTime(xp.y, e), t.positionZ.linearRampToValueAtTime(xp.z, e), t.orientationX.linearRampToValueAtTime(Sp.x, e), t.orientationY.linearRampToValueAtTime(Sp.y, e), t.orientationZ.linearRampToValueAtTime(Sp.z, e);
          } else t.setPosition(xp.x, xp.y, xp.z), t.setOrientation(Sp.x, Sp.y, Sp.z);
        }
      }
      class Mp {
        constructor(e, t = 2048) {
          this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let e = 0;
          const t = this.getFrequencyData();
          for (let r = 0; r < t.length; r++) e += t[r];
          return e / t.length;
        }
      }
      class Tp {
        constructor(e, t, r) {
          let n, i, s;
          switch (this.binding = e, this.valueSize = r, t) {
            case "quaternion":
              n = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * r), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              n = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * r);
              break;
            default:
              n = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * r);
          }
          this._mixBufferRegion = n, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e, t) {
          const r = this.buffer,
            n = this.valueSize,
            i = e * n + n;
          let s = this.cumulativeWeight;
          if (0 === s) {
            for (let e = 0; e !== n; ++e) r[i + e] = r[e];
            s = t;
          } else {
            s += t;
            const e = t / s;
            this._mixBufferRegion(r, i, 0, e, n);
          }
          this.cumulativeWeight = s;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            r = this.valueSize,
            n = r * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, r), this.cumulativeWeightAdditive += e;
        }
        apply(e) {
          const t = this.valueSize,
            r = this.buffer,
            n = e * t + t,
            i = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            o = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
            const e = t * this._origIndex;
            this._mixBufferRegion(r, n, e, 1 - i, t);
          }
          s > 0 && this._mixBufferRegionAdditive(r, n, this._addIndex * t, 1, t);
          for (let e = t, i = t + t; e !== i; ++e) if (r[e] !== r[e + t]) {
            o.setValue(r, n);
            break;
          }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            r = this.valueSize,
            n = r * this._origIndex;
          e.getValue(t, n);
          for (let e = r, i = n; e !== i; ++e) t[e] = t[n + e % r];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const e = 3 * this.valueSize;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let r = e; r < t; r++) this.buffer[r] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let r = 0; r < this.valueSize; r++) this.buffer[t + r] = this.buffer[e + r];
        }
        _select(e, t, r, n, i) {
          if (n >= .5) for (let n = 0; n !== i; ++n) e[t + n] = e[r + n];
        }
        _slerp(e, t, r, n) {
          an.slerpFlat(e, t, e, t, e, r, n);
        }
        _slerpAdditive(e, t, r, n, i) {
          const s = this._workIndex * i;
          an.multiplyQuaternionsFlat(e, s, e, t, e, r), an.slerpFlat(e, t, e, t, e, s, n);
        }
        _lerp(e, t, r, n, i) {
          const s = 1 - n;
          for (let o = 0; o !== i; ++o) {
            const i = t + o;
            e[i] = e[i] * s + e[r + o] * n;
          }
        }
        _lerpAdditive(e, t, r, n, i) {
          for (let s = 0; s !== i; ++s) {
            const i = t + s;
            e[i] = e[i] + e[r + s] * n;
          }
        }
      }
      const Ip = new RegExp("[\\[\\]\\.:\\/]", "g"),
        kp = "[^\\[\\]\\.:\\/]",
        Dp = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Pp = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", kp) + /(WCOD+)?/.source.replace("WCOD", Dp) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kp) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kp) + "$"),
        Bp = ["material", "materials", "bones", "map"];
      class Rp {
        constructor(e, t, r) {
          this.path = t, this.parsedPath = r || Rp.parseTrackName(t), this.node = Rp.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, r) {
          return e && e.isAnimationObjectGroup ? new Rp.Composite(e, t, r) : new Rp(e, t, r);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Ip, "");
        }
        static parseTrackName(e) {
          const t = Pp.exec(e);
          if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const r = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6]
            },
            n = r.nodeName && r.nodeName.lastIndexOf(".");
          if (void 0 !== n && -1 !== n) {
            const e = r.nodeName.substring(n + 1);
            -1 !== Bp.indexOf(e) && (r.nodeName = r.nodeName.substring(0, n), r.objectName = e);
          }
          if (null === r.propertyName || 0 === r.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          return r;
        }
        static findNode(e, t) {
          if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
          if (e.skeleton) {
            const r = e.skeleton.getBoneByName(t);
            if (void 0 !== r) return r;
          }
          if (e.children) {
            const r = function (e) {
                for (let n = 0; n < e.length; n++) {
                  const i = e[n];
                  if (i.name === t || i.uuid === t) return i;
                  const s = r(i.children);
                  if (s) return s;
                }
                return null;
              },
              n = r(e.children);
            if (n) return n;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const r = this.resolvedProperty;
          for (let n = 0, i = r.length; n !== i; ++n) e[t++] = r[n];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_array(e, t) {
          const r = this.resolvedProperty;
          for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const r = this.resolvedProperty;
          for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const r = this.resolvedProperty;
          for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            r = t.objectName,
            n = t.propertyName;
          let i = t.propertyIndex;
          if (e || (e = Rp.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          if (r) {
            let n = t.objectIndex;
            switch (r) {
              case "materials":
                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++) if (e[t].name === n) {
                  n = t;
                  break;
                }
                break;
              case "map":
                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                e = e.material.map;
                break;
              default:
                if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                e = e[r];
            }
            if (void 0 !== n) {
              if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
              e = e[n];
            }
          }
          const s = e[n];
          if (void 0 === s) {
            const r = t.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + r + "." + n + " but it wasn't found.", e);
          }
          let o = this.Versioning.None;
          this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
          let a = this.BindingType.Direct;
          if (void 0 !== i) {
            if ("morphTargetInfluences" === n) {
              if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]);
            }
            a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i;
          } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      Rp.Composite = class {
        constructor(e, t, r) {
          const n = r || Rp.parseTrackName(t);
          this._targetGroup = e, this._bindings = e.subscribe_(t, n);
        }
        getValue(e, t) {
          this.bind();
          const r = this._targetGroup.nCachedObjects_,
            n = this._bindings[r];
          void 0 !== n && n.getValue(e, t);
        }
        setValue(e, t) {
          const r = this._bindings;
          for (let n = this._targetGroup.nCachedObjects_, i = r.length; n !== i; ++n) r[n].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t) e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t) e[t].unbind();
        }
      }, Rp.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      }, Rp.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      }, Rp.prototype.GetterByBindingType = [Rp.prototype._getValue_direct, Rp.prototype._getValue_array, Rp.prototype._getValue_arrayElement, Rp.prototype._getValue_toArray], Rp.prototype.SetterByBindingTypeAndVersioning = [[Rp.prototype._setValue_direct, Rp.prototype._setValue_direct_setNeedsUpdate, Rp.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_array, Rp.prototype._setValue_array_setNeedsUpdate, Rp.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_arrayElement, Rp.prototype._setValue_arrayElement_setNeedsUpdate, Rp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_fromArray, Rp.prototype._setValue_fromArray_setNeedsUpdate, Rp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
      class Lp {
        constructor() {
          this.isAnimationObjectGroup = !0, this.uuid = br(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
          const e = {};
          this._indicesByUUID = e;
          for (let t = 0, r = arguments.length; t !== r; ++t) e[arguments[t].uuid] = t;
          this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
          const t = this;
          this.stats = {
            objects: {
              get total() {
                return t._objects.length;
              },
              get inUse() {
                return this.total - t.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return t._bindings.length;
            }
          };
        }
        add() {
          const e = this._objects,
            t = this._indicesByUUID,
            r = this._paths,
            n = this._parsedPaths,
            i = this._bindings,
            s = i.length;
          let o,
            a = e.length,
            l = this.nCachedObjects_;
          for (let c = 0, u = arguments.length; c !== u; ++c) {
            const u = arguments[c],
              h = u.uuid;
            let p = t[h];
            if (void 0 === p) {
              p = a++, t[h] = p, e.push(u);
              for (let e = 0, t = s; e !== t; ++e) i[e].push(new Rp(u, r[e], n[e]));
            } else if (p < l) {
              o = e[p];
              const a = --l,
                c = e[a];
              t[c.uuid] = p, e[p] = c, t[h] = a, e[a] = u;
              for (let e = 0, t = s; e !== t; ++e) {
                const t = i[e],
                  s = t[a];
                let o = t[p];
                t[p] = s, void 0 === o && (o = new Rp(u, r[e], n[e])), t[a] = o;
              }
            } else e[p] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
          this.nCachedObjects_ = l;
        }
        remove() {
          const e = this._objects,
            t = this._indicesByUUID,
            r = this._bindings,
            n = r.length;
          let i = this.nCachedObjects_;
          for (let s = 0, o = arguments.length; s !== o; ++s) {
            const o = arguments[s],
              a = o.uuid,
              l = t[a];
            if (void 0 !== l && l >= i) {
              const s = i++,
                c = e[s];
              t[c.uuid] = l, e[l] = c, t[a] = s, e[s] = o;
              for (let e = 0, t = n; e !== t; ++e) {
                const t = r[e],
                  n = t[s],
                  i = t[l];
                t[l] = n, t[s] = i;
              }
            }
          }
          this.nCachedObjects_ = i;
        }
        uncache() {
          const e = this._objects,
            t = this._indicesByUUID,
            r = this._bindings,
            n = r.length;
          let i = this.nCachedObjects_,
            s = e.length;
          for (let o = 0, a = arguments.length; o !== a; ++o) {
            const a = arguments[o].uuid,
              l = t[a];
            if (void 0 !== l) if (delete t[a], l < i) {
              const o = --i,
                a = e[o],
                c = --s,
                u = e[c];
              t[a.uuid] = l, e[l] = a, t[u.uuid] = o, e[o] = u, e.pop();
              for (let e = 0, t = n; e !== t; ++e) {
                const t = r[e],
                  n = t[o],
                  i = t[c];
                t[l] = n, t[o] = i, t.pop();
              }
            } else {
              const i = --s,
                o = e[i];
              i > 0 && (t[o.uuid] = l), e[l] = o, e.pop();
              for (let e = 0, t = n; e !== t; ++e) {
                const t = r[e];
                t[l] = t[i], t.pop();
              }
            }
          }
          this.nCachedObjects_ = i;
        }
        subscribe_(e, t) {
          const r = this._bindingsIndicesByPath;
          let n = r[e];
          const i = this._bindings;
          if (void 0 !== n) return i[n];
          const s = this._paths,
            o = this._parsedPaths,
            a = this._objects,
            l = a.length,
            c = this.nCachedObjects_,
            u = new Array(l);
          n = i.length, r[e] = n, s.push(e), o.push(t), i.push(u);
          for (let r = c, n = a.length; r !== n; ++r) {
            const n = a[r];
            u[r] = new Rp(n, e, t);
          }
          return u;
        }
        unsubscribe_(e) {
          const t = this._bindingsIndicesByPath,
            r = t[e];
          if (void 0 !== r) {
            const n = this._paths,
              i = this._parsedPaths,
              s = this._bindings,
              o = s.length - 1,
              a = s[o];
            t[e[o]] = r, s[r] = a, s.pop(), i[r] = i[o], i.pop(), n[r] = n[o], n.pop();
          }
        }
      }
      class Op {
        constructor(e, t, r = null, n = t.blendMode) {
          this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = n;
          const i = t.tracks,
            s = i.length,
            o = new Array(s),
            a = {
              endingStart: xt,
              endingEnd: xt
            };
          for (let e = 0; e !== s; ++e) {
            const t = i[e].createInterpolant(null);
            o[e] = t, t.settings = a;
          }
          this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = gt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return this._startTime = e, this;
        }
        setLoop(e, t) {
          return this.loop = e, this.repetitions = t, this;
        }
        setEffectiveWeight(e) {
          return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, r) {
          if (e.fadeOut(t), this.fadeIn(t), r) {
            const r = this._clip.duration,
              n = e._clip.duration,
              i = n / r,
              s = r / n;
            e.warp(1, i, t), this.warp(s, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, r) {
          return e.crossFadeFrom(this, t, r);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        setEffectiveTimeScale(e) {
          return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return this.timeScale = this._clip.duration / e, this.stopWarping();
        }
        syncWith(e) {
          return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, r) {
          const n = this._mixer,
            i = n.time,
            s = this.timeScale;
          let o = this._timeScaleInterpolant;
          null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
          const a = o.parameterPositions,
            l = o.sampleValues;
          return a[0] = i, a[1] = i + r, l[0] = e / s, l[1] = t / s, this;
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, r, n) {
          if (!this.enabled) return void this._updateWeight(e);
          const i = this._startTime;
          if (null !== i) {
            const n = (e - i) * r;
            n < 0 || 0 === r ? t = 0 : (this._startTime = null, t = r * n);
          }
          t *= this._updateTimeScale(e);
          const s = this._updateTime(t),
            o = this._updateWeight(e);
          if (o > 0) {
            const e = this._interpolants,
              t = this._propertyBindings;
            if (this.blendMode === Ct) for (let r = 0, n = e.length; r !== n; ++r) e[r].evaluate(s), t[r].accumulateAdditive(o);else for (let r = 0, i = e.length; r !== i; ++r) e[r].evaluate(s), t[r].accumulate(n, o);
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const r = this._weightInterpolant;
            if (null !== r) {
              const n = r.evaluate(e)[0];
              t *= n, e > r.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1));
            }
          }
          return this._effectiveWeight = t, t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const r = this._timeScaleInterpolant;
            null !== r && (t *= r.evaluate(e)[0], e > r.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t));
          }
          return this._effectiveTimeScale = t, t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            r = this.loop;
          let n = this.time + e,
            i = this._loopCount;
          const s = r === vt;
          if (0 === e) return -1 === i ? n : s && 1 == (1 & i) ? t - n : n;
          if (r === _t) {
            -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
              if (n >= t) n = t;else {
                if (!(n < 0)) {
                  this.time = n;
                  break e;
                }
                n = 0;
              }
              this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1
              });
            }
          } else {
            if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), n >= t || n < 0) {
              const r = Math.floor(n / t);
              n -= t * r, i += Math.abs(r);
              const o = this.repetitions - i;
              if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e > 0 ? 1 : -1
              });else {
                if (1 === o) {
                  const t = e < 0;
                  this._setEndings(t, !t, s);
                } else this._setEndings(!1, !1, s);
                this._loopCount = i, this.time = n, this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: r
                });
              }
            } else this.time = n;
            if (s && 1 == (1 & i)) return t - n;
          }
          return n;
        }
        _setEndings(e, t, r) {
          const n = this._interpolantSettings;
          r ? (n.endingStart = wt, n.endingEnd = wt) : (n.endingStart = e ? this.zeroSlopeAtStart ? wt : xt : Et, n.endingEnd = t ? this.zeroSlopeAtEnd ? wt : xt : Et);
        }
        _scheduleFading(e, t, r) {
          const n = this._mixer,
            i = n.time;
          let s = this._weightInterpolant;
          null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
          const o = s.parameterPositions,
            a = s.sampleValues;
          return o[0] = i, a[0] = t, o[1] = i + e, a[1] = r, this;
        }
      }
      const Fp = new Float32Array(1);
      class Up extends mr {
        constructor(e) {
          super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e, t) {
          const r = e._localRoot || this._root,
            n = e._clip.tracks,
            i = n.length,
            s = e._propertyBindings,
            o = e._interpolants,
            a = r.uuid,
            l = this._bindingsByRootAndName;
          let c = l[a];
          void 0 === c && (c = {}, l[a] = c);
          for (let e = 0; e !== i; ++e) {
            const i = n[e],
              l = i.name;
            let u = c[l];
            if (void 0 !== u) ++u.referenceCount, s[e] = u;else {
              if (u = s[e], void 0 !== u) {
                null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l));
                continue;
              }
              const n = t && t._propertyBindings[e].binding.parsedPath;
              u = new Tp(Rp.create(r, l, n), i.ValueTypeName, i.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, l), s[e] = u;
            }
            o[e].resultBuffer = u.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
              const t = (e._localRoot || this._root).uuid,
                r = e._clip.uuid,
                n = this._actionsByClip[r];
              this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, r, t);
            }
            const t = e._propertyBindings;
            for (let e = 0, r = t.length; e !== r; ++e) {
              const r = t[e];
              0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let e = 0, r = t.length; e !== r; ++e) {
              const r = t[e];
              0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return null !== t && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, r) {
          const n = this._actions,
            i = this._actionsByClip;
          let s = i[t];
          if (void 0 === s) s = {
            knownActions: [e],
            actionByRoot: {}
          }, e._byClipCacheIndex = 0, i[t] = s;else {
            const t = s.knownActions;
            e._byClipCacheIndex = t.length, t.push(e);
          }
          e._cacheIndex = n.length, n.push(e), s.actionByRoot[r] = e;
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            r = t[t.length - 1],
            n = e._cacheIndex;
          r._cacheIndex = n, t[n] = r, t.pop(), e._cacheIndex = null;
          const i = e._clip.uuid,
            s = this._actionsByClip,
            o = s[i],
            a = o.knownActions,
            l = a[a.length - 1],
            c = e._byClipCacheIndex;
          l._byClipCacheIndex = c, a[c] = l, a.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let e = 0, r = t.length; e !== r; ++e) {
            const r = t[e];
            0 == --r.referenceCount && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            r = e._cacheIndex,
            n = this._nActiveActions++,
            i = t[n];
          e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
        }
        _takeBackAction(e) {
          const t = this._actions,
            r = e._cacheIndex,
            n = --this._nActiveActions,
            i = t[n];
          e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
        }
        _addInactiveBinding(e, t, r) {
          const n = this._bindingsByRootAndName,
            i = this._bindings;
          let s = n[t];
          void 0 === s && (s = {}, n[t] = s), s[r] = e, e._cacheIndex = i.length, i.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            r = e.binding,
            n = r.rootNode.uuid,
            i = r.path,
            s = this._bindingsByRootAndName,
            o = s[n],
            a = t[t.length - 1],
            l = e._cacheIndex;
          a._cacheIndex = l, t[l] = a, t.pop(), delete o[i], 0 === Object.keys(o).length && delete s[n];
        }
        _lendBinding(e) {
          const t = this._bindings,
            r = e._cacheIndex,
            n = this._nActiveBindings++,
            i = t[n];
          e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            r = e._cacheIndex,
            n = --this._nActiveBindings,
            i = t[n];
          e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let r = e[t];
          return void 0 === r && (r = new oh(new Float32Array(2), new Float32Array(2), 1, Fp), r.__cacheIndex = t, e[t] = r), r;
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            r = e.__cacheIndex,
            n = --this._nActiveControlInterpolants,
            i = t[n];
          e.__cacheIndex = n, t[n] = e, i.__cacheIndex = r, t[r] = i;
        }
        clipAction(e, t, r) {
          const n = t || this._root,
            i = n.uuid;
          let s = "string" == typeof e ? _h.findByName(n, e) : e;
          const o = null !== s ? s.uuid : e,
            a = this._actionsByClip[o];
          let l = null;
          if (void 0 === r && (r = null !== s ? s.blendMode : St), void 0 !== a) {
            const e = a.actionByRoot[i];
            if (void 0 !== e && e.blendMode === r) return e;
            l = a.knownActions[0], null === s && (s = l._clip);
          }
          if (null === s) return null;
          const c = new Op(this, s, t, r);
          return this._bindAction(c, l), this._addInactiveAction(c, o, i), c;
        }
        existingAction(e, t) {
          const r = t || this._root,
            n = r.uuid,
            i = "string" == typeof e ? _h.findByName(r, e) : e,
            s = i ? i.uuid : e,
            o = this._actionsByClip[s];
          return void 0 !== o && o.actionByRoot[n] || null;
        }
        stopAllAction() {
          const e = this._actions;
          for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            r = this._nActiveActions,
            n = this.time += e,
            i = Math.sign(e),
            s = this._accuIndex ^= 1;
          for (let o = 0; o !== r; ++o) t[o]._update(n, e, i, s);
          const o = this._bindings,
            a = this._nActiveBindings;
          for (let e = 0; e !== a; ++e) o[e].apply(s);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            r = e.uuid,
            n = this._actionsByClip,
            i = n[r];
          if (void 0 !== i) {
            const e = i.knownActions;
            for (let r = 0, n = e.length; r !== n; ++r) {
              const n = e[r];
              this._deactivateAction(n);
              const i = n._cacheIndex,
                s = t[t.length - 1];
              n._cacheIndex = null, n._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(n);
            }
            delete n[r];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            r = this._actionsByClip;
          for (const e in r) {
            const n = r[e].actionByRoot[t];
            void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
          }
          const n = this._bindingsByRootAndName[t];
          if (void 0 !== n) for (const e in n) {
            const t = n[e];
            t.restoreOriginalState(), this._removeInactiveBinding(t);
          }
        }
        uncacheAction(e, t) {
          const r = this.existingAction(e, t);
          null !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
        }
      }
      class Np {
        constructor(e) {
          this.value = e;
        }
        clone() {
          return new Np(void 0 === this.value.clone ? this.value : this.value.clone());
        }
      }
      let jp = 0;
      class zp extends mr {
        constructor() {
          super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
            value: jp++
          }), this.name = "", this.usage = nr, this.uniforms = [];
        }
        add(e) {
          return this.uniforms.push(e), this;
        }
        remove(e) {
          const t = this.uniforms.indexOf(e);
          return -1 !== t && this.uniforms.splice(t, 1), this;
        }
        setName(e) {
          return this.name = e, this;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        dispose() {
          return this.dispatchEvent({
            type: "dispose"
          }), this;
        }
        copy(e) {
          this.name = e.name, this.usage = e.usage;
          const t = e.uniforms;
          this.uniforms.length = 0;
          for (let e = 0, r = t.length; e < r; e++) this.uniforms.push(t[e].clone());
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Gp extends pl {
        constructor(e, t, r = 1) {
          super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        clone(e) {
          const t = super.clone(e);
          return t.meshPerAttribute = this.meshPerAttribute, t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
        }
      }
      class Vp {
        constructor(e, t, r, n, i) {
          this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = n, this.count = i, this.version = 0;
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setBuffer(e) {
          return this.buffer = e, this;
        }
        setType(e, t) {
          return this.type = e, this.elementSize = t, this;
        }
        setItemSize(e) {
          return this.itemSize = e, this;
        }
        setCount(e) {
          return this.count = e, this;
        }
      }
      class Qp {
        constructor(e, t, r = 0, n = 1 / 0) {
          this.ray = new Un(e, t), this.near = r, this.far = n, this.camera = null, this.layers = new Kn(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
        }
        intersectObject(e, t = !0, r = []) {
          return Wp(e, this, r, t), r.sort(Hp), r;
        }
        intersectObjects(e, t = !0, r = []) {
          for (let n = 0, i = e.length; n < i; n++) Wp(e[n], this, r, t);
          return r.sort(Hp), r;
        }
      }
      function Hp(e, t) {
        return e.distance - t.distance;
      }
      function Wp(e, t, r, n) {
        if (e.layers.test(t.layers) && e.raycast(t, r), !0 === n) {
          const n = e.children;
          for (let e = 0, i = n.length; e < i; e++) Wp(n[e], t, r, !0);
        }
      }
      class qp {
        constructor(e = 1, t = 0, r = 0) {
          return this.radius = e, this.phi = t, this.theta = r, this;
        }
        set(e, t, r) {
          return this.radius = e, this.phi = t, this.theta = r, this;
        }
        copy(e) {
          return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
        }
        makeSafe() {
          const e = 1e-6;
          return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, r) {
          return this.radius = Math.sqrt(e * e + t * t + r * r), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(yr(t / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Xp {
        constructor(e = 1, t = 0, r = 0) {
          return this.radius = e, this.theta = t, this.y = r, this;
        }
        set(e, t, r) {
          return this.radius = e, this.theta = t, this.y = r, this;
        }
        copy(e) {
          return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, r) {
          return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Yp = new kr();
      class Kp {
        constructor(e = new kr(1 / 0, 1 / 0), t = new kr(-1 / 0, -1 / 0)) {
          this.isBox2 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const r = Yp.copy(t).multiplyScalar(.5);
          return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
          return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(e) {
          return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return Yp.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const Jp = new ln(),
        Zp = new ln();
      class $p {
        constructor(e = new ln(), t = new ln()) {
          this.start = e, this.end = t;
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return e.addVectors(this.start, this.end).multiplyScalar(.5);
        }
        delta(e) {
          return e.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
          Jp.subVectors(e, this.start), Zp.subVectors(this.end, this.start);
          const r = Zp.dot(Zp);
          let n = Zp.dot(Jp) / r;
          return t && (n = yr(n, 0, 1)), n;
        }
        closestPointToPoint(e, t, r) {
          const n = this.closestPointToPointParameter(e, t);
          return this.delta(r).multiplyScalar(n).add(this.start);
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ed = new ln();
      class td extends ui {
        constructor(e, t) {
          super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
          const r = new Hi(),
            n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let e = 0, t = 1, r = 32; e < r; e++, t++) {
            const i = e / r * Math.PI * 2,
              s = t / r * Math.PI * 2;
            n.push(Math.cos(i), Math.sin(i), 1, Math.cos(s), Math.sin(s), 1);
          }
          r.setAttribute("position", new Oi(n, 3));
          const i = new Jl({
            fog: !1,
            toneMapped: !1
          });
          this.cone = new oc(r, i), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
          this.cone.scale.set(t, t, e), ed.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(ed), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        }
      }
      const rd = new ln(),
        nd = new Nn(),
        id = new Nn();
      class sd extends oc {
        constructor(e) {
          const t = od(e),
            r = new Hi(),
            n = [],
            i = [],
            s = new Wr(0, 0, 1),
            o = new Wr(0, 1, 0);
          for (let e = 0; e < t.length; e++) {
            const r = t[e];
            r.parent && r.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b));
          }
          r.setAttribute("position", new Oi(n, 3)), r.setAttribute("color", new Oi(i, 3)), super(r, new Jl({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
          })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            r = this.geometry,
            n = r.getAttribute("position");
          id.copy(this.root.matrixWorld).invert();
          for (let e = 0, r = 0; e < t.length; e++) {
            const i = t[e];
            i.parent && i.parent.isBone && (nd.multiplyMatrices(id, i.matrixWorld), rd.setFromMatrixPosition(nd), n.setXYZ(r, rd.x, rd.y, rd.z), nd.multiplyMatrices(id, i.parent.matrixWorld), rd.setFromMatrixPosition(nd), n.setXYZ(r + 1, rd.x, rd.y, rd.z), r += 2);
          }
          r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
        }
      }
      function od(e) {
        const t = [];
        !0 === e.isBone && t.push(e);
        for (let r = 0; r < e.children.length; r++) t.push.apply(t, od(e.children[r]));
        return t;
      }
      class ad extends cs {
        constructor(e, t, r) {
          super(new Bu(t, 4, 2), new Ei({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
          })), this.light = e, this.light.updateMatrixWorld(), this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
        }
      }
      const ld = new ln(),
        cd = new Wr(),
        ud = new Wr();
      class hd extends ui {
        constructor(e, t, r) {
          super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
          const n = new ku(t);
          n.rotateY(.5 * Math.PI), this.material = new Ei({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
          }), void 0 === this.color && (this.material.vertexColors = !0);
          const i = n.getAttribute("position"),
            s = new Float32Array(3 * i.count);
          n.setAttribute("color", new Mi(s, 3)), this.add(new cs(n, this.material)), this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }
        update() {
          const e = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);else {
            const t = e.geometry.getAttribute("color");
            cd.copy(this.light.color), ud.copy(this.light.groundColor);
            for (let e = 0, r = t.count; e < r; e++) {
              const n = e < r / 2 ? cd : ud;
              t.setXYZ(e, n.r, n.g, n.b);
            }
            t.needsUpdate = !0;
          }
          e.lookAt(ld.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class pd extends oc {
        constructor(e = 10, t = 10, r = 4473924, n = 8947848) {
          r = new Wr(r), n = new Wr(n);
          const i = t / 2,
            s = e / t,
            o = e / 2,
            a = [],
            l = [];
          for (let e = 0, c = 0, u = -o; e <= t; e++, u += s) {
            a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
            const t = e === i ? r : n;
            t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3;
          }
          const c = new Hi();
          c.setAttribute("position", new Oi(a, 3)), c.setAttribute("color", new Oi(l, 3)), super(c, new Jl({
            vertexColors: !0,
            toneMapped: !1
          })), this.type = "GridHelper";
        }
      }
      class dd extends oc {
        constructor(e = 10, t = 16, r = 8, n = 64, i = 4473924, s = 8947848) {
          i = new Wr(i), s = new Wr(s);
          const o = [],
            a = [];
          if (t > 1) for (let r = 0; r < t; r++) {
            const n = r / t * (2 * Math.PI),
              l = Math.sin(n) * e,
              c = Math.cos(n) * e;
            o.push(0, 0, 0), o.push(l, 0, c);
            const u = 1 & r ? i : s;
            a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b);
          }
          for (let t = 0; t < r; t++) {
            const l = 1 & t ? i : s,
              c = e - e / r * t;
            for (let e = 0; e < n; e++) {
              let t = e / n * (2 * Math.PI),
                r = Math.sin(t) * c,
                i = Math.cos(t) * c;
              o.push(r, 0, i), a.push(l.r, l.g, l.b), t = (e + 1) / n * (2 * Math.PI), r = Math.sin(t) * c, i = Math.cos(t) * c, o.push(r, 0, i), a.push(l.r, l.g, l.b);
            }
          }
          const l = new Hi();
          l.setAttribute("position", new Oi(o, 3)), l.setAttribute("color", new Oi(a, 3)), super(l, new Jl({
            vertexColors: !0,
            toneMapped: !1
          })), this.type = "PolarGridHelper";
        }
      }
      const fd = new ln(),
        md = new ln(),
        _d = new ln();
      class gd extends ui {
        constructor(e, t, r) {
          super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, void 0 === t && (t = 1);
          let n = new Hi();
          n.setAttribute("position", new Oi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
          const i = new Jl({
            fog: !1,
            toneMapped: !1
          });
          this.lightPlane = new nc(n, i), this.add(this.lightPlane), n = new Hi(), n.setAttribute("position", new Oi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new nc(n, i), this.add(this.targetLine), this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
          fd.setFromMatrixPosition(this.light.matrixWorld), md.setFromMatrixPosition(this.light.target.matrixWorld), _d.subVectors(md, fd), this.lightPlane.lookAt(md), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(md), this.targetLine.scale.z = _d.length();
        }
      }
      const vd = new ln(),
        Ad = new _s();
      class bd extends oc {
        constructor(e) {
          const t = new Hi(),
            r = new Jl({
              color: 16777215,
              vertexColors: !0,
              toneMapped: !1
            }),
            n = [],
            i = [],
            s = {};
          function o(e, t) {
            a(e), a(t);
          }
          function a(e) {
            n.push(0, 0, 0), i.push(0, 0, 0), void 0 === s[e] && (s[e] = []), s[e].push(n.length / 3 - 1);
          }
          o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), t.setAttribute("position", new Oi(n, 3)), t.setAttribute("color", new Oi(i, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
          const l = new Wr(16755200),
            c = new Wr(16711680),
            u = new Wr(43775),
            h = new Wr(16777215),
            p = new Wr(3355443);
          this.setColors(l, c, u, h, p);
        }
        setColors(e, t, r, n, i) {
          const s = this.geometry.getAttribute("color");
          s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, r.r, r.g, r.b), s.setXYZ(33, r.r, r.g, r.b), s.setXYZ(34, r.r, r.g, r.b), s.setXYZ(35, r.r, r.g, r.b), s.setXYZ(36, r.r, r.g, r.b), s.setXYZ(37, r.r, r.g, r.b), s.setXYZ(38, n.r, n.g, n.b), s.setXYZ(39, n.r, n.g, n.b), s.setXYZ(40, i.r, i.g, i.b), s.setXYZ(41, i.r, i.g, i.b), s.setXYZ(42, i.r, i.g, i.b), s.setXYZ(43, i.r, i.g, i.b), s.setXYZ(44, i.r, i.g, i.b), s.setXYZ(45, i.r, i.g, i.b), s.setXYZ(46, i.r, i.g, i.b), s.setXYZ(47, i.r, i.g, i.b), s.setXYZ(48, i.r, i.g, i.b), s.setXYZ(49, i.r, i.g, i.b), s.needsUpdate = !0;
        }
        update() {
          const e = this.geometry,
            t = this.pointMap;
          Ad.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yd("c", t, e, Ad, 0, 0, -1), yd("t", t, e, Ad, 0, 0, 1), yd("n1", t, e, Ad, -1, -1, -1), yd("n2", t, e, Ad, 1, -1, -1), yd("n3", t, e, Ad, -1, 1, -1), yd("n4", t, e, Ad, 1, 1, -1), yd("f1", t, e, Ad, -1, -1, 1), yd("f2", t, e, Ad, 1, -1, 1), yd("f3", t, e, Ad, -1, 1, 1), yd("f4", t, e, Ad, 1, 1, 1), yd("u1", t, e, Ad, .7, 1.1, -1), yd("u2", t, e, Ad, -.7, 1.1, -1), yd("u3", t, e, Ad, 0, 2, -1), yd("cf1", t, e, Ad, -1, 0, 1), yd("cf2", t, e, Ad, 1, 0, 1), yd("cf3", t, e, Ad, 0, -1, 1), yd("cf4", t, e, Ad, 0, 1, 1), yd("cn1", t, e, Ad, -1, 0, -1), yd("cn2", t, e, Ad, 1, 0, -1), yd("cn3", t, e, Ad, 0, -1, -1), yd("cn4", t, e, Ad, 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function yd(e, t, r, n, i, s, o) {
        vd.set(i, s, o).unproject(n);
        const a = t[e];
        if (void 0 !== a) {
          const e = r.getAttribute("position");
          for (let t = 0, r = a.length; t < r; t++) e.setXYZ(a[t], vd.x, vd.y, vd.z);
        }
      }
      const xd = new hn();
      class wd extends oc {
        constructor(e, t = 16776960) {
          const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24),
            i = new Hi();
          i.setIndex(new Mi(r, 1)), i.setAttribute("position", new Mi(n, 3)), super(i, new Jl({
            color: t,
            toneMapped: !1
          })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
        }
        update(e) {
          if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && xd.setFromObject(this.object), xd.isEmpty()) return;
          const t = xd.min,
            r = xd.max,
            n = this.geometry.attributes.position,
            i = n.array;
          i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = t.x, i[4] = r.y, i[5] = r.z, i[6] = t.x, i[7] = t.y, i[8] = r.z, i[9] = r.x, i[10] = t.y, i[11] = r.z, i[12] = r.x, i[13] = r.y, i[14] = t.z, i[15] = t.x, i[16] = r.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = r.x, i[22] = t.y, i[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
        }
        setFromObject(e) {
          return this.object = e, this.update(), this;
        }
        copy(e, t) {
          return super.copy(e, t), this.object = e.object, this;
        }
      }
      class Ed extends oc {
        constructor(e, t = 16776960) {
          const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Hi();
          n.setIndex(new Mi(r, 1)), n.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(n, new Jl({
            color: t,
            toneMapped: !1
          })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e) {
          const t = this.box;
          t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e));
        }
      }
      class Sd extends nc {
        constructor(e, t = 1, r = 16776960) {
          const n = r,
            i = new Hi();
          i.setAttribute("position", new Oi([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere(), super(i, new Jl({
            color: n,
            toneMapped: !1
          })), this.type = "PlaneHelper", this.plane = e, this.size = t;
          const s = new Hi();
          s.setAttribute("position", new Oi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s.computeBoundingSphere(), this.add(new cs(s, new Ei({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
          })));
        }
        updateMatrixWorld(e) {
          this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
        }
      }
      const Cd = new ln();
      let Md, Td;
      class Id extends ui {
        constructor(e = new ln(0, 0, 1), t = new ln(0, 0, 0), r = 1, n = 16776960, i = .2 * r, s = .2 * i) {
          super(), this.type = "ArrowHelper", void 0 === Md && (Md = new Hi(), Md.setAttribute("position", new Oi([0, 0, 0, 0, 1, 0], 3)), Td = new Qc(0, .5, 1, 5, 1), Td.translate(0, -.5, 0)), this.position.copy(t), this.line = new nc(Md, new Jl({
            color: n,
            toneMapped: !1
          })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new cs(Td, new Ei({
            color: n,
            toneMapped: !1
          })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, i, s);
        }
        setDirection(e) {
          if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);else {
            Cd.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Cd, t);
          }
        }
        setLength(e, t = .2 * e, r = .2 * t) {
          this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
        }
        setColor(e) {
          this.line.material.color.set(e), this.cone.material.color.set(e);
        }
        copy(e) {
          return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
        }
      }
      class kd extends oc {
        constructor(e = 1) {
          const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            r = new Hi();
          r.setAttribute("position", new Oi(t, 3)), r.setAttribute("color", new Oi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(r, new Jl({
            vertexColors: !0,
            toneMapped: !1
          })), this.type = "AxesHelper";
        }
        setColors(e, t, r) {
          const n = new Wr(),
            i = this.geometry.attributes.color.array;
          return n.set(e), n.toArray(i, 0), n.toArray(i, 3), n.set(t), n.toArray(i, 6), n.toArray(i, 9), n.set(r), n.toArray(i, 12), n.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      class Dd {
        constructor() {
          this.type = "ShapePath", this.color = new Wr(), this.subPaths = [], this.currentPath = null;
        }
        moveTo(e, t) {
          return this.currentPath = new jc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
        }
        lineTo(e, t) {
          return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, r, n) {
          return this.currentPath.quadraticCurveTo(e, t, r, n), this;
        }
        bezierCurveTo(e, t, r, n, i, s) {
          return this.currentPath.bezierCurveTo(e, t, r, n, i, s), this;
        }
        splineThru(e) {
          return this.currentPath.splineThru(e), this;
        }
        toShapes(e, t) {
          function r(e) {
            const t = [];
            for (let r = 0, n = e.length; r < n; r++) {
              const n = e[r],
                i = new $c();
              i.curves = n.curves, t.push(i);
            }
            return t;
          }
          function n(e, t) {
            const r = t.length;
            let n = !1;
            for (let i = r - 1, s = 0; s < r; i = s++) {
              let r = t[i],
                o = t[s],
                a = o.x - r.x,
                l = o.y - r.y;
              if (Math.abs(l) > Number.EPSILON) {
                if (l < 0 && (r = t[s], a = -a, o = t[i], l = -l), e.y < r.y || e.y > o.y) continue;
                if (e.y === r.y) {
                  if (e.x === r.x) return !0;
                } else {
                  const t = l * (e.x - r.x) - a * (e.y - r.y);
                  if (0 === t) return !0;
                  if (t < 0) continue;
                  n = !n;
                }
              } else {
                if (e.y !== r.y) continue;
                if (o.x <= e.x && e.x <= r.x || r.x <= e.x && e.x <= o.x) return !0;
              }
            }
            return n;
          }
          const i = Eu.isClockWise,
            s = this.subPaths;
          if (0 === s.length) return [];
          if (!0 === t) return r(s);
          let o, a, l;
          const c = [];
          if (1 === s.length) return a = s[0], l = new $c(), l.curves = a.curves, c.push(l), c;
          let u = !i(s[0].getPoints());
          u = e ? !u : u;
          const h = [],
            p = [];
          let d,
            f,
            m = [],
            _ = 0;
          p[_] = void 0, m[_] = [];
          for (let t = 0, r = s.length; t < r; t++) a = s[t], d = a.getPoints(), o = i(d), o = e ? !o : o, o ? (!u && p[_] && _++, p[_] = {
            s: new $c(),
            p: d
          }, p[_].s.curves = a.curves, u && _++, m[_] = []) : m[_].push({
            h: a,
            p: d[0]
          });
          if (!p[0]) return r(s);
          if (p.length > 1) {
            let e = !1,
              t = 0;
            for (let e = 0, t = p.length; e < t; e++) h[e] = [];
            for (let r = 0, i = p.length; r < i; r++) {
              const i = m[r];
              for (let s = 0; s < i.length; s++) {
                const o = i[s];
                let a = !0;
                for (let i = 0; i < p.length; i++) n(o.p, p[i].p) && (r !== i && t++, a ? (a = !1, h[i].push(o)) : e = !0);
                a && h[r].push(o);
              }
            }
            t > 0 && !1 === e && (m = h);
          }
          for (let e = 0, t = p.length; e < t; e++) {
            l = p[e].s, c.push(l), f = m[e];
            for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h);
          }
          return c;
        }
      }
      const Pd = Bd();
      function Bd() {
        const e = new ArrayBuffer(4),
          t = new Float32Array(e),
          r = new Uint32Array(e),
          n = new Uint32Array(512),
          i = new Uint32Array(512);
        for (let e = 0; e < 256; ++e) {
          const t = e - 127;
          t < -27 ? (n[e] = 0, n[256 | e] = 32768, i[e] = 24, i[256 | e] = 24) : t < -14 ? (n[e] = 1024 >> -t - 14, n[256 | e] = 1024 >> -t - 14 | 32768, i[e] = -t - 1, i[256 | e] = -t - 1) : t <= 15 ? (n[e] = t + 15 << 10, n[256 | e] = t + 15 << 10 | 32768, i[e] = 13, i[256 | e] = 13) : t < 128 ? (n[e] = 31744, n[256 | e] = 64512, i[e] = 24, i[256 | e] = 24) : (n[e] = 31744, n[256 | e] = 64512, i[e] = 13, i[256 | e] = 13);
        }
        const s = new Uint32Array(2048),
          o = new Uint32Array(64),
          a = new Uint32Array(64);
        for (let e = 1; e < 1024; ++e) {
          let t = e << 13,
            r = 0;
          for (; 0 == (8388608 & t);) t <<= 1, r -= 8388608;
          t &= -8388609, r += 947912704, s[e] = t | r;
        }
        for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
        for (let e = 1; e < 31; ++e) o[e] = e << 23;
        o[31] = 1199570944, o[32] = 2147483648;
        for (let e = 33; e < 63; ++e) o[e] = 2147483648 + (e - 32 << 23);
        o[63] = 3347054592;
        for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);
        return {
          floatView: t,
          uint32View: r,
          baseTable: n,
          shiftTable: i,
          mantissaTable: s,
          exponentTable: o,
          offsetTable: a
        };
      }
      var Rd = Object.freeze({
        __proto__: null,
        toHalfFloat: function (e) {
          Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = yr(e, -65504, 65504), Pd.floatView[0] = e;
          const t = Pd.uint32View[0],
            r = t >> 23 & 511;
          return Pd.baseTable[r] + ((8388607 & t) >> Pd.shiftTable[r]);
        },
        fromHalfFloat: function (e) {
          const t = e >> 10;
          return Pd.uint32View[0] = Pd.mantissaTable[Pd.offsetTable[t] + (1023 & e)] + Pd.exponentTable[t], Pd.floatView[0];
        }
      });
      function Ld() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      class Od extends en {
        constructor(e, t, r) {
          console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, r), this.samples = 4;
        }
      }
      class Fd extends tn {
        constructor(e, t, r, n) {
          console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, r, n);
        }
      }
      class Ud extends nn {
        constructor(e, t, r, n) {
          console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, r, n);
        }
      }
      class Nd extends hs {
        constructor(e, t, r, n, i, s) {
          console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, r, n, i, s);
        }
      }
      class jd extends Gc {
        constructor(e, t, r, n) {
          console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, r, n);
        }
      }
      class zd extends Vc {
        constructor(e, t, r, n) {
          console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, r, n);
        }
      }
      class Gd extends Hc {
        constructor(e, t, r, n, i, s, o) {
          console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, r, n, i, s, o);
        }
      }
      class Vd extends Qc {
        constructor(e, t, r, n, i, s, o, a) {
          console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, r, n, i, s, o, a);
        }
      }
      class Qd extends qc {
        constructor(e, t) {
          console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t);
        }
      }
      class Hd extends Mu {
        constructor(e, t) {
          console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t);
        }
      }
      class Wd extends Iu {
        constructor(e, t) {
          console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t);
        }
      }
      class qd extends zc {
        constructor(e, t, r, n) {
          console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, r, n);
        }
      }
      class Xd extends ku {
        constructor(e, t) {
          console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t);
        }
      }
      class Yd extends Ds {
        constructor(e, t, r, n) {
          console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, r, n);
        }
      }
      class Kd extends Wc {
        constructor(e, t, r, n) {
          console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, r, n);
        }
      }
      class Jd extends Du {
        constructor(e, t, r, n, i, s) {
          console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, r, n, i, s);
        }
      }
      class Zd extends Pu {
        constructor(e, t) {
          console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t);
        }
      }
      class $d extends Bu {
        constructor(e, t, r, n, i, s, o) {
          console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, r, n, i, s, o);
        }
      }
      class ef extends Ru {
        constructor(e, t) {
          console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t);
        }
      }
      class tf extends Lu {
        constructor(e, t, r, n, i) {
          console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, r, n, i);
        }
      }
      class rf extends Ou {
        constructor(e, t, r, n, i, s) {
          console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, r, n, i, s);
        }
      }
      class nf extends Fu {
        constructor(e, t, r, n, i) {
          console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, r, n, i);
        }
      }
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: n
        }
      })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n);
    },
    553: function (e, t, r) {
      r.d(t, {
        _: function () {
          return s;
        }
      });
      var n = r(988);
      const i = new WeakMap();
      class s extends n.aNw {
        constructor(e) {
          super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
          }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
          };
        }
        setDecoderPath(e) {
          return this.decoderPath = e, this;
        }
        setDecoderConfig(e) {
          return this.decoderConfig = e, this;
        }
        setWorkerLimit(e) {
          return this.workerLimit = e, this;
        }
        load(e, t, r, i) {
          const s = new n.hH6(this.manager);
          s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, e => {
            this.decodeDracoFile(e, t).catch(i);
          }, r, i);
        }
        decodeDracoFile(e, t, r, n) {
          const i = {
            attributeIDs: r || this.defaultAttributeIDs,
            attributeTypes: n || this.defaultAttributeTypes,
            useUniqueIDs: !!r
          };
          return this.decodeGeometry(e, i).then(t);
        }
        decodeGeometry(e, t) {
          const r = JSON.stringify(t);
          if (i.has(e)) {
            const t = i.get(e);
            if (t.key === r) return t.promise;
            if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
          }
          let n;
          const s = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(s, o).then(r => (n = r, new Promise((r, i) => {
              n._callbacks[s] = {
                resolve: r,
                reject: i
              }, n.postMessage({
                type: "decode",
                id: s,
                taskConfig: t,
                buffer: e
              }, [e]);
            }))).then(e => this._createGeometry(e.geometry));
          return a.catch(() => !0).then(() => {
            n && s && this._releaseTask(n, s);
          }), i.set(e, {
            key: r,
            promise: a
          }), a;
        }
        _createGeometry(e) {
          const t = new n.u9r();
          e.index && t.setIndex(new n.TlE(e.index.array, 1));
          for (let r = 0; r < e.attributes.length; r++) {
            const i = e.attributes[r],
              s = i.name,
              o = i.array,
              a = i.itemSize;
            t.setAttribute(s, new n.TlE(o, a));
          }
          return t;
        }
        _loadLibrary(e, t) {
          const r = new n.hH6(this.manager);
          return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((t, n) => {
            r.load(e, t, void 0, n);
          });
        }
        preload() {
          return this._initDecoder(), this;
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending;
          const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
            t = [];
          return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(t => {
            const r = t[0];
            e || (this.decoderConfig.wasmBinary = t[1]);
            const n = o.toString(),
              i = ["/* draco decoder */", r, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
            this.workerSourceURL = URL.createObjectURL(new Blob([i]));
          }), this.decoderPending;
        }
        _getWorker(e, t) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const e = new Worker(this.workerSourceURL);
              e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                type: "init",
                decoderConfig: this.decoderConfig
              }), e.onmessage = function (t) {
                const r = t.data;
                switch (r.type) {
                  case "decode":
                    e._callbacks[r.id].resolve(r);
                    break;
                  case "error":
                    e._callbacks[r.id].reject(r);
                    break;
                  default:
                    console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
                }
              }, this.workerPool.push(e);
            } else this.workerPool.sort(function (e, t) {
              return e._taskLoad > t._taskLoad ? -1 : 1;
            });
            const r = this.workerPool[this.workerPool.length - 1];
            return r._taskCosts[e] = t, r._taskLoad += t, r;
          });
        }
        _releaseTask(e, t) {
          e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
        }
        debug() {
          console.log("Task load: ", this.workerPool.map(e => e._taskLoad));
        }
        dispose() {
          for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
          return this.workerPool.length = 0, this;
        }
      }
      function o() {
        let e, t;
        function r(e, t, r, n, i, s) {
          const o = s.num_components(),
            a = r.num_points() * o,
            l = a * i.BYTES_PER_ELEMENT,
            c = function (e, t) {
              switch (t) {
                case Float32Array:
                  return e.DT_FLOAT32;
                case Int8Array:
                  return e.DT_INT8;
                case Int16Array:
                  return e.DT_INT16;
                case Int32Array:
                  return e.DT_INT32;
                case Uint8Array:
                  return e.DT_UINT8;
                case Uint16Array:
                  return e.DT_UINT16;
                case Uint32Array:
                  return e.DT_UINT32;
              }
            }(e, i),
            u = e._malloc(l);
          t.GetAttributeDataArrayForAllPoints(r, s, c, l, u);
          const h = new i(e.HEAPF32.buffer, u, a).slice();
          return e._free(u), {
            name: n,
            array: h,
            itemSize: o
          };
        }
        onmessage = function (n) {
          const i = n.data;
          switch (i.type) {
            case "init":
              e = i.decoderConfig, t = new Promise(function (t) {
                e.onModuleLoaded = function (e) {
                  t({
                    draco: e
                  });
                }, DracoDecoderModule(e);
              });
              break;
            case "decode":
              const n = i.buffer,
                s = i.taskConfig;
              t.then(e => {
                const t = e.draco,
                  o = new t.Decoder(),
                  a = new t.DecoderBuffer();
                a.Init(new Int8Array(n), n.byteLength);
                try {
                  const e = function (e, t, n, i) {
                      const s = i.attributeIDs,
                        o = i.attributeTypes;
                      let a, l;
                      const c = t.GetEncodedGeometryType(n);
                      if (c === e.TRIANGULAR_MESH) a = new e.Mesh(), l = t.DecodeBufferToMesh(n, a);else {
                        if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                        a = new e.PointCloud(), l = t.DecodeBufferToPointCloud(n, a);
                      }
                      if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                      const u = {
                        index: null,
                        attributes: []
                      };
                      for (const n in s) {
                        const l = self[o[n]];
                        let c, h;
                        if (i.useUniqueIDs) h = s[n], c = t.GetAttributeByUniqueId(a, h);else {
                          if (h = t.GetAttributeId(a, e[s[n]]), -1 === h) continue;
                          c = t.GetAttribute(a, h);
                        }
                        u.attributes.push(r(e, t, a, n, l, c));
                      }
                      return c === e.TRIANGULAR_MESH && (u.index = function (e, t, r) {
                        const n = 3 * r.num_faces(),
                          i = 4 * n,
                          s = e._malloc(i);
                        t.GetTrianglesUInt32Array(r, i, s);
                        const o = new Uint32Array(e.HEAPF32.buffer, s, n).slice();
                        return e._free(s), {
                          array: o,
                          itemSize: 1
                        };
                      }(e, t, a)), e.destroy(a), u;
                    }(t, o, a, s),
                    n = e.attributes.map(e => e.array.buffer);
                  e.index && n.push(e.index.array.buffer), self.postMessage({
                    type: "decode",
                    id: i.id,
                    geometry: e
                  }, n);
                } catch (e) {
                  console.error(e), self.postMessage({
                    type: "error",
                    id: i.id,
                    error: e.message
                  });
                } finally {
                  t.destroy(a), t.destroy(o);
                }
              });
          }
        };
      }
    }
  },
  __webpackgi_module_cache__ = {};
function __webpackgi_require__(e) {
  var t = __webpackgi_module_cache__[e];
  if (void 0 !== t) return t.exports;
  var r = __webpackgi_module_cache__[e] = {
    id: e,
    exports: {}
  };
  return __webpackgi_modules__[e].call(r.exports, r, r.exports, __webpackgi_require__), r.exports;
}
__webpackgi_require__.n = function (e) {
  var t = e && e.__esModule ? function () {
    return e.default;
  } : function () {
    return e;
  };
  return __webpackgi_require__.d(t, {
    a: t
  }), t;
}, __webpackgi_require__.d = function (e, t) {
  for (var r in t) __webpackgi_require__.o(t, r) && !__webpackgi_require__.o(e, r) && Object.defineProperty(e, r, {
    enumerable: !0,
    get: t[r]
  });
}, __webpackgi_require__.o = function (e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}, __webpackgi_require__.r = function (e) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
    value: "Module"
  }), Object.defineProperty(e, "__esModule", {
    value: !0
  });
}, __webpackgi_require__.nc = void 0;
var __webpackgi_exports__ = {};
!function () {
  __webpackgi_require__.d(__webpackgi_exports__, {
    LY2: function () {
      return n.LY2;
    },
    HRj: function () {
      return rr;
    },
    li4: function () {
      return Py;
    },
    FO5: function () {
      return By;
    },
    Nlh: function () {
      return My;
    },
    QvI: function () {
      return ro;
    },
    JHp: function () {
      return Eo;
    },
    bGH: function () {
      return n.bGH;
    },
    NDo: function () {
      return n.NDo;
    },
    gSk: function () {
      return n.gSk;
    },
    WMw: function () {
      return n.WMw;
    },
    OTo: function () {
      return n.OTo;
    },
    Se2: function () {
      return n.Se2;
    },
    cum: function () {
      return n.cum;
    },
    Mig: function () {
      return n.Mig;
    },
    B$7: function () {
      return Ys;
    },
    i_9: function () {
      return n.i_9;
    },
    m7l: function () {
      return n.m7l;
    },
    sYA: function () {
      return n.sYA;
    },
    Xcj: function () {
      return n.Xcj;
    },
    mzJ: function () {
      return n.mzJ;
    },
    ZZA: function () {
      return n.ZZA;
    },
    $Ph: function () {
      return xu;
    },
    T__: function () {
      return n.T__;
    },
    HkE: function () {
      return n.HkE;
    },
    tGC: function () {
      return n.tGC;
    },
    g1S: function () {
      return eg;
    },
    I$C: function () {
      return tg;
    },
    QIH: function () {
      return Js;
    },
    _JE: function () {
      return vp;
    },
    ksm: function () {
      return to;
    },
    jl_: function () {
      return Ji;
    },
    b7R: function () {
      return ds;
    },
    BDV: function () {
      return Vi;
    },
    Ea_: function () {
      return ts;
    },
    qff: function () {
      return Ji;
    },
    tmC: function () {
      return qi;
    },
    BON: function () {
      return js;
    },
    P40: function () {
      return cs;
    },
    wLL: function () {
      return Rs;
    },
    iHO: function () {
      return ss;
    },
    BbS: function () {
      return n.BbS;
    },
    kqm: function () {
      return n.kqm;
    },
    Hmr: function () {
      return n.Hmr;
    },
    SJI: function () {
      return n.SJI;
    },
    mTL: function () {
      return n.mTL;
    },
    y8_: function () {
      return n.y8_;
    },
    _Li: function () {
      return n._Li;
    },
    g56: function () {
      return fu;
    },
    bj3: function () {
      return K;
    },
    z81: function () {
      return n.z81;
    },
    _MY: function () {
      return n._MY;
    },
    yEv: function () {
      return A_;
    },
    dFZ: function () {
      return bu;
    },
    N$j: function () {
      return n.N$j;
    },
    _YM: function () {
      return n._YM;
    },
    TUj: function () {
      return n.TUj;
    },
    ZzF: function () {
      return n.ZzF;
    },
    qzb: function () {
      return k;
    },
    GQ: function () {
      return n.GQ;
    },
    nvb: function () {
      return n.nvb;
    },
    DvJ: function () {
      return n.DvJ;
    },
    fQA: function () {
      return n.fQA;
    },
    cPz: function () {
      return za;
    },
    TlE: function () {
      return n.TlE;
    },
    u9r: function () {
      return n.u9r;
    },
    s4_: function () {
      return n.s4_;
    },
    T95: function () {
      return n.T95;
    },
    F5w: function () {
      return sS;
    },
    NlP: function () {
      return TM;
    },
    $8Z: function () {
      return nS;
    },
    YYN: function () {
      return vy;
    },
    CtF: function () {
      return n.CtF;
    },
    V1s: function () {
      return n.V1s;
    },
    jOv: function () {
      return _t;
    },
    Rki: function () {
      return n.Rki;
    },
    pzV: function () {
      return UT;
    },
    itZ: function () {
      return rh;
    },
    qKx: function () {
      return nh;
    },
    vlJ: function () {
      return Fy;
    },
    nPO: function () {
      return Ny;
    },
    zcQ: function () {
      return Ju;
    },
    GH1: function () {
      return $u;
    },
    ROQ: function () {
      return n.ROQ;
    },
    YN5: function () {
      return n.YN5;
    },
    BVQ: function () {
      return n.BVQ;
    },
    YT8: function () {
      return n.YT8;
    },
    _DE: function () {
      return zp;
    },
    YGz: function () {
      return n.YGz;
    },
    trn: function () {
      return n.trn;
    },
    zf8: function () {
      return n.zf8;
    },
    uWy: function () {
      return n.uWy;
    },
    wYQ: function () {
      return zu;
    },
    SUY: function () {
      return n.SUY;
    },
    Ilk: function () {
      return n.Ilk;
    },
    R2R: function () {
      return n.R2R;
    },
    epp: function () {
      return n.epp;
    },
    xmJ: function () {
      return bp;
    },
    GD$: function () {
      return Ki;
    },
    EB7: function () {
      return n.EB7;
    },
    DqL: function () {
      return n.DqL;
    },
    _3: function () {
      return n._3;
    },
    b_z: function () {
      return n.b_z;
    },
    OCn: function () {
      return Vy;
    },
    _am: function () {
      return n._am;
    },
    kB7: function () {
      return Ho;
    },
    fY$: function () {
      return n.fY$;
    },
    vxC: function () {
      return n.vxC;
    },
    BtG: function () {
      return n.BtG;
    },
    cBK: function () {
      return n.cBK;
    },
    g8_: function () {
      return n.g8_;
    },
    AXT: function () {
      return n.AXT;
    },
    yj7: function () {
      return n.yj7;
    },
    dYG: function () {
      return n.dYG;
    },
    tm_: function () {
      return n.tm_;
    },
    S2y: function () {
      return n.S2y;
    },
    B02: function () {
      return n.B02;
    },
    PeU: function () {
      return n.PeU;
    },
    Hyl: function () {
      return n.Hyl;
    },
    Wqd: function () {
      return n.Wqd;
    },
    Xaj: function () {
      return n.Xaj;
    },
    DUb: function () {
      return Fu;
    },
    dZ3: function () {
      return n.dZ3;
    },
    m_w: function () {
      return n.m_w;
    },
    fHI: function () {
      return n.fHI;
    },
    LBq: function () {
      return n.LBq;
    },
    dHf: function () {
      return Ey;
    },
    Qww: function () {
      return wn.Q;
    },
    CGV: function () {
      return Sy;
    },
    JUT: function () {
      return n.JUT;
    },
    p3g: function () {
      return n.p3g;
    },
    IEO: function () {
      return n.IEO;
    },
    CN8: function () {
      return n.CN8;
    },
    zob: function () {
      return n.zob;
    },
    yxD: function () {
      return n.yxD;
    },
    CUS: function () {
      return b_;
    },
    A5E: function () {
      return n.A5E;
    },
    zqG: function () {
      return Yc;
    },
    PfX: function () {
      return ys;
    },
    Q1o: function () {
      return ps;
    },
    jfJ: function () {
      return n.jfJ;
    },
    T_J: function () {
      return n.T_J;
    },
    tEQ: function () {
      return n.tEQ;
    },
    gb4: function () {
      return Gi;
    },
    qkB: function () {
      return n.qkB;
    },
    cvk: function () {
      return vh;
    },
    HWo: function () {
      return bh;
    },
    brP: function () {
      return n.brP;
    },
    $YQ: function () {
      return n.$YQ;
    },
    X8d: function () {
      return OM;
    },
    Zdt: function () {
      return UM;
    },
    yNB: function () {
      return Zo;
    },
    h7x: function () {
      return Gc;
    },
    Ox3: function () {
      return n.Ox3;
    },
    qtn: function () {
      return Ws;
    },
    cBI: function () {
      return n.cBI;
    },
    cU9: function () {
      return n.cU9;
    },
    DT1: function () {
      return n.DT1;
    },
    Kgo: function () {
      return n.Kgo;
    },
    ehD: function () {
      return n.ehD;
    },
    fhJ: function () {
      return xo;
    },
    y1s: function () {
      return wo;
    },
    fSK: function () {
      return n.fSK;
    },
    Vdb: function () {
      return n.Vdb;
    },
    l8J: function () {
      return n.l8J;
    },
    dj0: function () {
      return n.dj0;
    },
    QM0: function () {
      return n.QM0;
    },
    OIS: function () {
      return ym;
    },
    q8b: function () {
      return kc;
    },
    TOt: function () {
      return n.TOt;
    },
    xaN: function () {
      return d;
    },
    Ny0: function () {
      return n.Ny0;
    },
    NeD: function () {
      return PE;
    },
    Zof: function () {
      return xs;
    },
    eD: function () {
      return n.eD;
    },
    jwo: function () {
      return n.jwo;
    },
    dSO: function () {
      return n.dSO;
    },
    Bf4: function () {
      return n.Bf4;
    },
    USm: function () {
      return n.USm;
    },
    pBf: function () {
      return n.pBf;
    },
    $Vf: function () {
      return n.$Vf;
    },
    O7d: function () {
      return n.O7d;
    },
    ksq: function () {
      return qm;
    },
    gXf: function () {
      return au;
    },
    hH6: function () {
      return n.hH6;
    },
    kpi: function () {
      return Hp;
    },
    DwZ: function () {
      return QM;
    },
    kN3: function () {
      return HM;
    },
    e62: function () {
      return n.e62;
    },
    a$l: function () {
      return n.a$l;
    },
    OM3: function () {
      return n.OM3;
    },
    VzW: function () {
      return n.VzW;
    },
    ybr: function () {
      return n.ybr;
    },
    yo9: function () {
      return n.yo9;
    },
    $Bt: function () {
      return Oc;
    },
    Wzm: function () {
      return n.Wzm;
    },
    Wl3: function () {
      return n.Wl3;
    },
    iWj: function () {
      return n.iWj;
    },
    DNz: function () {
      return yo;
    },
    m1M: function () {
      return lo;
    },
    ylh: function () {
      return n.ylh;
    },
    v9Y: function () {
      return n.v9Y;
    },
    LSk: function () {
      return n.LSk;
    },
    LHE: function () {
      return Wc;
    },
    KE0: function () {
      return Vb;
    },
    KCF: function () {
      return Gb;
    },
    a4n: function () {
      return V_;
    },
    zIH: function () {
      return rn;
    },
    Hfk: function () {
      return gn;
    },
    png: function () {
      return mn;
    },
    tAj: function () {
      return _n;
    },
    Eb_: function () {
      return vn;
    },
    BT2: function () {
      return $m;
    },
    _8p: function () {
      return G_;
    },
    V5Z: function () {
      return wp;
    },
    s5b: function () {
      return Ep;
    },
    hkn: function () {
      return Vt;
    },
    GFY: function () {
      return io;
    },
    w$m: function () {
      return n.w$m;
    },
    ksN: function () {
      return n.ksN;
    },
    j4z: function () {
      return n.j4z;
    },
    OAl: function () {
      return n.OAl;
    },
    VLJ: function () {
      return n.VLJ;
    },
    C73: function () {
      return _u;
    },
    ZAu: function () {
      return n.ZAu;
    },
    ibP: function () {
      return es;
    },
    _fI: function () {
      return Ki;
    },
    hUN: function () {
      return fh;
    },
    cLu: function () {
      return n.cLu;
    },
    vmT: function () {
      return n.vmT;
    },
    Qpg: function () {
      return n.Qpg;
    },
    So8: function () {
      return n.So8;
    },
    eOv: function () {
      return PT;
    },
    Wjw: function () {
      return n.Wjw;
    },
    cJO: function () {
      return n.cJO;
    },
    QRU: function () {
      return n.QRU;
    },
    S3k: function () {
      return n.S3k;
    },
    PpQ: function () {
      return n.PpQ;
    },
    AHu: function () {
      return n.AHu;
    },
    q_9: function () {
      return ir;
    },
    ZRs: function () {
      return n.ZRs;
    },
    oqc: function () {
      return n.oqc;
    },
    T_x: function () {
      return Wi;
    },
    lb7: function () {
      return n.lb7;
    },
    L5s: function () {
      return n.L5s;
    },
    $TI: function () {
      return n.$TI;
    },
    SPe: function () {
      return n.SPe;
    },
    aVm: function () {
      return n.aVm;
    },
    j87: function () {
      return n.j87;
    },
    RNb: function () {
      return n.RNb;
    },
    Kz5: function () {
      return n.Kz5;
    },
    vpT: function () {
      return n.vpT;
    },
    kB5: function () {
      return n.kB5;
    },
    _C8: function () {
      return n._C8;
    },
    Syv: function () {
      return n.Syv;
    },
    NMF: function () {
      return n.NMF;
    },
    pIN: function () {
      return n.pIN;
    },
    eMJ: function () {
      return n.eMJ;
    },
    rN7: function () {
      return Gh;
    },
    iUp: function () {
      return Vh;
    },
    GFd: function () {
      return v_;
    },
    x5V: function () {
      return n.x5V;
    },
    tUh: function () {
      return n.tUh;
    },
    z8B: function () {
      return n.z8B;
    },
    vcl: function () {
      return Bp;
    },
    GZb: function () {
      return n.GZb;
    },
    p7y: function () {
      return n.p7y;
    },
    S9g: function () {
      return n.S9g;
    },
    Zr5: function () {
      return n.Zr5;
    },
    vCF: function () {
      return n.vCF;
    },
    yt0: function () {
      return n.yt0;
    },
    uXU: function () {
      return n.uXU;
    },
    _kC: function () {
      return n._kC;
    },
    lk7: function () {
      return n.lk7;
    },
    USc: function () {
      return BT;
    },
    x12: function () {
      return n.x12;
    },
    Zzh: function () {
      return n.Zzh;
    },
    nls: function () {
      return n.nls;
    },
    g_z: function () {
      return n.g_z;
    },
    U7: function () {
      return n.U7;
    },
    FT0: function () {
      return n.FT0;
    },
    blk: function () {
      return n.blk;
    },
    ejS: function () {
      return n.ejS;
    },
    rnI: function () {
      return n.rnI;
    },
    wem: function () {
      return n.wem;
    },
    lfu: function () {
      return n.lfu;
    },
    FDw: function () {
      return n.FDw;
    },
    lRj: function () {
      return n.lRj;
    },
    D1R: function () {
      return n.D1R;
    },
    qyh: function () {
      return n.qyh;
    },
    GUF: function () {
      return n.GUF;
    },
    EoG: function () {
      return n.EoG;
    },
    aNw: function () {
      return n.aNw;
    },
    Zp0: function () {
      return n.Zp0;
    },
    lLk: function () {
      return n.lLk;
    },
    jAl: function () {
      return n.jAl;
    },
    uEv: function () {
      return n.uEv;
    },
    YKA: function () {
      return n.YKA;
    },
    cRx: function () {
      return n.cRx;
    },
    Y8D: function () {
      return n.Y8D;
    },
    RsA: function () {
      return n.RsA;
    },
    Y0m: function () {
      return r_;
    },
    F5T: function () {
      return n.F5T;
    },
    EDU: function () {
      return qy;
    },
    z$Q: function () {
      return dE;
    },
    KA8: function () {
      return Ft;
    },
    XUj: function () {
      return fE;
    },
    Me$: function () {
      return mE;
    },
    u7G: function () {
      return n.u7G;
    },
    PEk: function () {
      return nr;
    },
    BG4: function () {
      return Wy;
    },
    M8C: function () {
      return n.M8C;
    },
    Vkp: function () {
      return n.Vkp;
    },
    yGw: function () {
      return n.yGw;
    },
    Sm8: function () {
      return n.Sm8;
    },
    Kj0: function () {
      return n.Kj0;
    },
    vBJ: function () {
      return n.vBJ;
    },
    QfV: function () {
      return Zt;
    },
    lRF: function () {
      return n.lRF;
    },
    Lun: function () {
      return n.Lun;
    },
    YBo: function () {
      return n.YBo;
    },
    kaV: function () {
      return n.kaV;
    },
    RSm: function () {
      return n.RSm;
    },
    xoR: function () {
      return n.xoR;
    },
    EJi: function () {
      return n.EJi;
    },
    Wid: function () {
      return n.Wid;
    },
    iuj: function () {
      return Kt;
    },
    IKL: function () {
      return n.IKL;
    },
    r_: function () {
      return n.r_;
    },
    OoA: function () {
      return n.OoA;
    },
    qhX: function () {
      return n.qhX;
    },
    qPT: function () {
      return So;
    },
    M5h: function () {
      return n.M5h;
    },
    Ns1: function () {
      return n.Ns1;
    },
    TyD: function () {
      return n.TyD;
    },
    vZf: function () {
      return n.vZf;
    },
    HTd: function () {
      return n.HTd;
    },
    aH4: function () {
      return n.aH4;
    },
    YLQ: function () {
      return n.YLQ;
    },
    BVF: function () {
      return n.BVF;
    },
    MyG: function () {
      return n.MyG;
    },
    jFi: function () {
      return n.jFi;
    },
    aCh: function () {
      return n.aCh;
    },
    uL9: function () {
      return n.uL9;
    },
    TNj: function () {
      return Du;
    },
    IFH: function () {
      return n.IFH;
    },
    bdR: function () {
      return n.bdR;
    },
    kM_: function () {
      return Wo;
    },
    M6v: function () {
      return n.M6v;
    },
    RvT: function () {
      return n.RvT;
    },
    dUE: function () {
      return n.dUE;
    },
    oe_: function () {
      return f_;
    },
    BuN: function () {
      return m_;
    },
    Tme: function () {
      return n.Tme;
    },
    N9P: function () {
      return ar;
    },
    Gql: function () {
      return n.Gql;
    },
    $XY: function () {
      return sn;
    },
    O9d: function () {
      return $o;
    },
    zEO: function () {
      return cr;
    },
    qfx: function () {
      return bE;
    },
    PA7: function () {
      return n.PA7;
    },
    REq: function () {
      return n.REq;
    },
    pQR: function () {
      return n.pQR;
    },
    ghN: function () {
      return n.ghN;
    },
    Hy8: function () {
      return n.Hy8;
    },
    Wpd: function () {
      return n.Wpd;
    },
    LgZ: function () {
      return n.LgZ;
    },
    iWC: function () {
      return n.iWC;
    },
    mqn: function () {
      return AI;
    },
    SKe: function () {
      return ft;
    },
    iKG: function () {
      return n.iKG;
    },
    _iA: function () {
      return n._iA;
    },
    ntZ: function () {
      return n.ntZ;
    },
    anP: function () {
      return n.anP;
    },
    X2e: function () {
      return ly;
    },
    FCo: function () {
      return wE;
    },
    y$t: function () {
      return n.y$t;
    },
    cPb: function () {
      return n.cPb;
    },
    lmx: function () {
      return Nc;
    },
    JOQ: function () {
      return n.JOQ;
    },
    BKK: function () {
      return n.BKK;
    },
    _12: function () {
      return n._12;
    },
    tJx: function () {
      return n.tJx;
    },
    cek: function () {
      return n.cek;
    },
    qD0: function () {
      return Xs;
    },
    xG9: function () {
      return n.xG9;
    },
    wI8: function () {
      return $M;
    },
    Sgv: function () {
      return eT;
    },
    woe: function () {
      return n.woe;
    },
    UY4: function () {
      return n.UY4;
    },
    aq0: function () {
      return n.aq0;
    },
    ujx: function () {
      return n.ujx;
    },
    Uol: function () {
      return n.Uol;
    },
    JiH: function () {
      return BE;
    },
    VYz: function () {
      return n.VYz;
    },
    _Pm: function () {
      return Jh;
    },
    EsW: function () {
      return To;
    },
    iUV: function () {
      return n.iUV;
    },
    tf: function () {
      return n.tf;
    },
    ZQ6: function () {
      return n.ZQ6;
    },
    mXe: function () {
      return n.mXe;
    },
    _fP: function () {
      return n._fP;
    },
    iLg: function () {
      return n.iLg;
    },
    zbs: function () {
      return n.zbs;
    },
    UZH: function () {
      return n.UZH;
    },
    mSO: function () {
      return n.mSO;
    },
    wk1: function () {
      return n.wk1;
    },
    E2K: function () {
      return n.E2K;
    },
    FUD: function () {
      return n.FUD;
    },
    pKu: function () {
      return n.pKu;
    },
    GG6: function () {
      return n.GG6;
    },
    Gih: function () {
      return n.Gih;
    },
    iiP: function () {
      return n.iiP;
    },
    SvJ: function () {
      return n.SvJ;
    },
    ptH: function () {
      return n.ptH;
    },
    jZA: function () {
      return n.jZA;
    },
    y2t: function () {
      return n.y2t;
    },
    gi4: function () {
      return n.gi4;
    },
    Djp: function () {
      return n.Djp;
    },
    BG$: function () {
      return n.BG$;
    },
    NYV: function () {
      return n.NYV;
    },
    xJs: function () {
      return n.xJs;
    },
    bsb: function () {
      return n.bsb;
    },
    ekQ: function () {
      return n.ekQ;
    },
    CaW: function () {
      return n.CaW;
    },
    eaV: function () {
      return n.eaV;
    },
    BFQ: function () {
      return n.BFQ;
    },
    v3W: function () {
      return n.v3W;
    },
    ILR: function () {
      return n.ILR;
    },
    UCm: function () {
      return n.UCm;
    },
    Inb: function () {
      return n.Inb;
    },
    U1$: function () {
      return R;
    },
    LgE: function () {
      return n.LgE;
    },
    fto: function () {
      return n.fto;
    },
    l0P: function () {
      return n.l0P;
    },
    vCx: function () {
      return n.vCx;
    },
    _AM: function () {
      return n._AM;
    },
    wuA: function () {
      return n.wuA;
    },
    av9: function () {
      return n.av9;
    },
    CtA: function () {
      return n.CtA;
    },
    BvQ: function () {
      return su;
    },
    FZJ: function () {
      return hh;
    },
    FIo: function () {
      return n.FIo;
    },
    zHn: function () {
      return n.zHn;
    },
    iMs: function () {
      return n.iMs;
    },
    T_f: function () {
      return n.T_f;
    },
    hEm: function () {
      return n.hEm;
    },
    D9w: function () {
      return n.D9w;
    },
    sHH: function () {
      return pu;
    },
    CdI: function () {
      return n.CdI;
    },
    rkc: function () {
      return FT;
    },
    rpg: function () {
      return n.rpg;
    },
    ce8: function () {
      return n.ce8;
    },
    rOj: function () {
      return n.rOj;
    },
    P6m: function () {
      return Zm;
    },
    JA6: function () {
      return Jm;
    },
    V4E: function () {
      return n.V4E;
    },
    o8S: function () {
      return n.o8S;
    },
    flB: function () {
      return vt;
    },
    DUH: function () {
      return wy;
    },
    KI_: function () {
      return n.KI_;
    },
    iLN: function () {
      return Qo;
    },
    jsw: function () {
      return wh;
    },
    srG: function () {
      return CE;
    },
    i6Z: function () {
      return No;
    },
    vfv: function () {
      return t_;
    },
    xsS: function () {
      return n.xsS;
    },
    or: function () {
      return RT;
    },
    EQj: function () {
      return $h;
    },
    ov0: function () {
      return ja;
    },
    WdD: function () {
      return n.WdD;
    },
    Vj0: function () {
      return n.Vj0;
    },
    jyz: function () {
      return n.jyz;
    },
    mTM: function () {
      return Ut;
    },
    Mn1: function () {
      return Nt;
    },
    Hlq: function () {
      return zt;
    },
    Fi7: function () {
      return cu;
    },
    Tn7: function () {
      return n.Tn7;
    },
    bnF: function () {
      return n.bnF;
    },
    HW6: function () {
      return n.HW6;
    },
    oa8: function () {
      return n.oa8;
    },
    T_1: function () {
      return n.T_1;
    },
    zHJ: function () {
      return DE;
    },
    iDF: function () {
      return n.iDF;
    },
    iAb: function () {
      return n.iAb;
    },
    d4E: function () {
      return Kp;
    },
    lBg: function () {
      return TT;
    },
    JeJ: function () {
      return Jp;
    },
    FKY: function () {
      return r;
    },
    zlZ: function () {
      return y_;
    },
    vkg: function () {
      return ur;
    },
    brh: function () {
      return x_;
    },
    kZK: function () {
      return WE;
    },
    puG: function () {
      return IT;
    },
    OdW: function () {
      return n.OdW;
    },
    _YX: function () {
      return n._YX;
    },
    TUv: function () {
      return n.TUv;
    },
    Hw6: function () {
      return n.Hw6;
    },
    aLr: function () {
      return n.aLr;
    },
    Aip: function () {
      return n.Aip;
    },
    xo$: function () {
      return n.xo$;
    },
    bIn: function () {
      return bI;
    },
    $V: function () {
      return n.$V;
    },
    lDi: function () {
      return n.lDi;
    },
    gti: function () {
      return n.gti;
    },
    PMe: function () {
      return n.PMe;
    },
    iwP: function () {
      return qs;
    },
    FvO: function () {
      return n.FvO;
    },
    jyi: function () {
      return n.jyi;
    },
    xeV: function () {
      return n.xeV;
    },
    k74: function () {
      return n.k74;
    },
    RlZ: function () {
      return n.RlZ;
    },
    KhW: function () {
      return n.KhW;
    },
    HgB: function () {
      return n.HgB;
    },
    W2J: function () {
      return n.W2J;
    },
    JWc: function () {
      return n.JWc;
    },
    u37: function () {
      return n.u37;
    },
    Z6B: function () {
      return n.Z6B;
    },
    QZ1: function () {
      return n.QZ1;
    },
    Ir4: function () {
      return n.Ir4;
    },
    NwF: function () {
      return n.NwF;
    },
    Wbm: function () {
      return n.Wbm;
    },
    N4l: function () {
      return n.N4l;
    },
    ej9: function () {
      return ME;
    },
    QmN: function () {
      return n.QmN;
    },
    IOt: function () {
      return n.IOt;
    },
    NOD: function () {
      return Ku;
    },
    L5g: function () {
      return n.L5g;
    },
    H$k: function () {
      return n.H$k;
    },
    cuP: function () {
      return VE;
    },
    xEZ: function () {
      return n.xEZ;
    },
    dpR: function () {
      return n.dpR;
    },
    wOD: function () {
      return Cu;
    },
    KNb: function () {
      return eo;
    },
    IiN: function () {
      return Ip;
    },
    Cne: function () {
      return n.Cne;
    },
    XvJ: function () {
      return n.XvJ;
    },
    XZw: function () {
      return n.XZw;
    },
    FE5: function () {
      return n.FE5;
    },
    lVp: function () {
      return jc;
    },
    CJI: function () {
      return n.CJI;
    },
    z$h: function () {
      return n.z$h;
    },
    UlW: function () {
      return n.UlW;
    },
    WwZ: function () {
      return n.WwZ;
    },
    Lcc: function () {
      return n.Lcc;
    },
    WXh: function () {
      return n.WXh;
    },
    Vjr: function () {
      return TE;
    },
    LuM: function () {
      return MT;
    },
    LP5: function () {
      return pT;
    },
    xfE: function () {
      return n.xfE;
    },
    qlB: function () {
      return n.qlB;
    },
    lCJ: function () {
      return n.lCJ;
    },
    WTc: function () {
      return n.WTc;
    },
    rAo: function () {
      return n.rAo;
    },
    LZj: function () {
      return Mp;
    },
    xWb: function () {
      return n.xWb;
    },
    gH0: function () {
      return n.gH0;
    },
    rBU: function () {
      return n.rBU;
    },
    rDY: function () {
      return n.rDY;
    },
    ywz: function () {
      return n.ywz;
    },
    wJv: function () {
      return n.wJv;
    },
    JQ4: function () {
      return n.JQ4;
    },
    k0A: function () {
      return n.k0A;
    },
    irR: function () {
      return n.irR;
    },
    LsT: function () {
      return n.LsT;
    },
    q5h: function () {
      return zs;
    },
    TKh: function () {
      return Ns;
    },
    tyg: function () {
      return Us;
    },
    Ro5: function () {
      return ls;
    },
    dwk: function () {
      return n.dwk;
    },
    FM8: function () {
      return n.FM8;
    },
    Pa4: function () {
      return n.Pa4;
    },
    Ltg: function () {
      return n.Ltg;
    },
    yC1: function () {
      return n.yC1;
    },
    lHq: function () {
      return Xu;
    },
    fO1: function () {
      return n.fO1;
    },
    oMA: function () {
      return go;
    },
    JzW: function () {
      return e;
    },
    QEt: function () {
      return Fp;
    },
    b5g: function () {
      return n.b5g;
    },
    Ywn: function () {
      return n.Ywn;
    },
    GVz: function () {
      return n.GVz;
    },
    oAp: function () {
      return n.oAp;
    },
    kFz: function () {
      return n.kFz;
    },
    p7A: function () {
      return n.p7A;
    },
    dd2: function () {
      return n.dd2;
    },
    CP7: function () {
      return n.CP7;
    },
    fQK: function () {
      return n.fQK;
    },
    Wd$: function () {
      return Yp;
    },
    t1_: function () {
      return oI;
    },
    Uk6: function () {
      return n.Uk6;
    },
    _sL: function () {
      return n._sL;
    },
    Pnf: function () {
      return n.Pnf;
    },
    c8b: function () {
      return n.c8b;
    },
    _lf: function () {
      return n._lf;
    },
    ad5: function () {
      return n.ad5;
    },
    sZV: function () {
      return Ls;
    },
    TfA: function () {
      return Bs;
    },
    sKX: function () {
      return Qs;
    },
    UdM: function () {
      return Ps;
    },
    P0y: function () {
      return is;
    },
    L_r: function () {
      return n.L_r;
    },
    Bve: function () {
      return Wp;
    },
    UeO: function () {
      return En;
    },
    $nx: function () {
      return W_;
    },
    Bk6: function () {
      return an;
    },
    y4l: function () {
      return pr;
    },
    pQ0: function () {
      return Hs;
    },
    wXW: function () {
      return zx;
    },
    r5x: function () {
      return Ux;
    },
    MSI: function () {
      return Qx;
    },
    EUu: function () {
      return II;
    },
    jtH: function () {
      return Ic;
    },
    T0T: function () {
      return Lc;
    },
    gAb: function () {
      return wI;
    },
    iwT: function () {
      return ih;
    },
    je_: function () {
      return EI;
    },
    wBP: function () {
      return Rc;
    },
    LU2: function () {
      return nl;
    },
    wQL: function () {
      return kI;
    },
    Zs7: function () {
      return aw;
    },
    x7s: function () {
      return xw;
    },
    Mnd: function () {
      return BI;
    },
    A0_: function () {
      return RI;
    },
    d73: function () {
      return Cx;
    },
    HCD: function () {
      return q;
    },
    RG9: function () {
      return X;
    },
    G2P: function () {
      return el;
    },
    XLf: function () {
      return rl;
    },
    CGN: function () {
      return tl;
    },
    mvg: function () {
      return Mx;
    },
    Hiy: function () {
      return Jt;
    },
    XMc: function () {
      return Nx;
    },
    N7M: function () {
      return Ox;
    },
    iv: function () {
      return Gx;
    },
    n55: function () {
      return xt;
    },
    IaC: function () {
      return wx;
    },
    h9t: function () {
      return sl;
    },
    yDW: function () {
      return ol;
    },
    gJv: function () {
      return il;
    },
    l$g: function () {
      return iS;
    },
    vQi: function () {
      return MM;
    },
    $MY: function () {
      return fo;
    },
    wJl: function () {
      return ho;
    },
    Z7Y: function () {
      return Ja;
    },
    X7D: function () {
      return $a;
    },
    BnX: function () {
      return Za;
    },
    uZ5: function () {
      return cl;
    },
    zVI: function () {
      return kx;
    },
    DpF: function () {
      return _h;
    },
    nNb: function () {
      return Zi;
    },
    cqZ: function () {
      return $i;
    },
    pKN: function () {
      return by;
    },
    d_$: function () {
      return Yo;
    },
    DdI: function () {
      return yy;
    },
    rrX: function () {
      return xy;
    },
    KlC: function () {
      return Xo;
    },
    KVn: function () {
      return B;
    },
    oau: function () {
      return ow;
    },
    aw9: function () {
      return xe;
    },
    Aap: function () {
      return je;
    },
    Dxg: function () {
      return b;
    },
    MjT: function () {
      return Ee;
    },
    F7Q: function () {
      return Wa;
    },
    IFq: function () {
      return PI;
    },
    IJl: function () {
      return Ha;
    },
    O5A: function () {
      return At;
    },
    wCn: function () {
      return St;
    },
    gGT: function () {
      return Qa;
    },
    pEc: function () {
      return Ay;
    },
    Bi6: function () {
      return Ct;
    },
    fi_: function () {
      return Cw;
    },
    TT: function () {
      return Kx;
    },
    q2Z: function () {
      return aI;
    },
    NyK: function () {
      return J;
    },
    bgu: function () {
      return Tt;
    },
    kcS: function () {
      return Mt;
    },
    rRN: function () {
      return rS;
    },
    ivY: function () {
      return E;
    },
    _s1: function () {
      return $I;
    },
    _HO: function () {
      return Q;
    },
    tpL: function () {
      return H;
    },
    DMK: function () {
      return cc;
    },
    LjN: function () {
      return fs;
    },
    iFs: function () {
      return ms;
    },
    qTg: function () {
      return g;
    },
    Wtl: function () {
      return Qi;
    },
    DmK: function () {
      return Hi;
    },
    Htt: function () {
      return LI;
    },
    Hx7: function () {
      return De;
    },
    imt: function () {
      return Ie;
    },
    US6: function () {
      return vw;
    },
    vZs: function () {
      return Ko;
    },
    TE$: function () {
      return NI;
    },
    lmu: function () {
      return yt;
    },
    SvO: function () {
      return wt;
    },
    YQY: function () {
      return Xa;
    },
    mZN: function () {
      return Ka;
    },
    VvG: function () {
      return Ya;
    },
    omp: function () {
      return LE;
    },
    utz: function () {
      return Ix;
    },
    TFV: function () {
      return vo;
    },
    hrz: function () {
      return y;
    },
    JKM: function () {
      return Zx;
    },
    jZf: function () {
      return yI;
    },
    RjL: function () {
      return dT;
    },
    RRI: function () {
      return Aw;
    },
    RUq: function () {
      return QE;
    },
    _t4: function () {
      return ot;
    },
    YHh: function () {
      return at;
    },
    R8g: function () {
      return L;
    },
    Bbl: function () {
      return or;
    },
    V9r: function () {
      return v;
    },
    PZ2: function () {
      return A;
    },
    w7A: function () {
      return f;
    },
    N6S: function () {
      return U;
    },
    Uxp: function () {
      return N;
    },
    tAz: function () {
      return F;
    },
    R$F: function () {
      return z;
    },
    N33: function () {
      return j;
    },
    gw2: function () {
      return Zs;
    },
    KlU: function () {
      return O;
    },
    wo6: function () {
      return Bt;
    },
    H4P: function () {
      return w;
    },
    swA: function () {
      return rs;
    },
    _Z3: function () {
      return ns;
    },
    ivc: function () {
      return Zi;
    },
    rZ1: function () {
      return $i;
    },
    CpZ: function () {
      return Sw;
    },
    dyc: function () {
      return S;
    },
    MxZ: function () {
      return FE;
    },
    btp: function () {
      return UE;
    },
    mXy: function () {
      return OE;
    },
    Ej0: function () {
      return Ue;
    },
    ep4: function () {
      return ye;
    },
    DQP: function () {
      return Ne;
    },
    VNr: function () {
      return we;
    },
    V7q: function () {
      return It;
    },
    zEk: function () {
      return Ot;
    },
    qfq: function () {
      return kt;
    },
    piB: function () {
      return T;
    },
    IIc: function () {
      return MI;
    },
    rrF: function () {
      return Xi;
    },
    naq: function () {
      return Yi;
    },
    sXR: function () {
      return oc;
    },
    p5I: function () {
      return Bc;
    },
    wps: function () {
      return OI;
    },
    wuo: function () {
      return FI;
    },
    GpE: function () {
      return m;
    },
    F4b: function () {
      return lc;
    },
    t$v: function () {
      return Sx;
    },
    tdn: function () {
      return oh;
    },
    Y9t: function () {
      return ah;
    },
    GEo: function () {
      return qa;
    },
    DH3: function () {
      return jx;
    },
    uxM: function () {
      return Xy;
    },
    zH3: function () {
      return Yy;
    },
    MLs: function () {
      return no;
    },
    xXG: function () {
      return be;
    },
    YM4: function () {
      return Pc;
    },
    B3r: function () {
      return xI;
    },
    iAx: function () {
      return Ky;
    },
    lDn: function () {
      return V;
    },
    oaQ: function () {
      return Va;
    },
    CD7: function () {
      return gl;
    },
    Rc0: function () {
      return Nl;
    },
    iPG: function () {
      return ic;
    },
    TIc: function () {
      return Pt;
    },
    xsC: function () {
      return Hx;
    },
    zOc: function () {
      return Dt;
    },
    r46: function () {
      return lw;
    },
    z2C: function () {
      return M;
    },
    _X$: function () {
      return sr;
    },
    _yn: function () {
      return jt;
    },
    Dyg: function () {
      return bt;
    },
    cUc: function () {
      return Yt;
    },
    zGw: function () {
      return $l;
    },
    Ctq: function () {
      return Lx;
    },
    $ch: function () {
      return jI;
    },
    k5b: function () {
      return Px;
    },
    kZl: function () {
      return Yx;
    },
    OCg: function () {
      return nw;
    },
    YjH: function () {
      return yw;
    },
    Ui8: function () {
      return Q_;
    },
    YD2: function () {
      return _l;
    },
    vi9: function () {
      return TI;
    },
    ij3: function () {
      return Fx;
    },
    YPW: function () {
      return Bx;
    },
    Bg1: function () {
      return uI;
    },
    kon: function () {
      return x;
    },
    M3g: function () {
      return Ga;
    },
    F2z: function () {
      return Ex;
    },
    pJF: function () {
      return gE;
    },
    knz: function () {
      return n.knz;
    },
    Ejo: function () {
      return _;
    },
    BgY: function () {
      return Be;
    },
    qCG: function () {
      return Ce;
    },
    HD9: function () {
      return ke;
    },
    fEB: function () {
      return Me;
    },
    Udc: function () {
      return Fe;
    },
    ZQg: function () {
      return Oe;
    },
    ofC: function () {
      return W;
    },
    yRy: function () {
      return Rt;
    },
    _NL: function () {
      return qp;
    },
    LCA: function () {
      return Le;
    },
    j1w: function () {
      return lr;
    },
    i8J: function () {
      return tk;
    },
    p7C: function () {
      return qt;
    },
    ZAS: function () {
      return ch;
    },
    ipH: function () {
      return VI;
    },
    $TF: function () {
      return GI;
    },
    uZI: function () {
      return QI;
    },
    VWG: function () {
      return Hy;
    },
    pQ7: function () {
      return sh;
    },
    STw: function () {
      return fl;
    },
    jc8: function () {
      return Xt;
    },
    BL_: function () {
      return Tx;
    },
    S6: function () {
      return ek;
    },
    T8U: function () {
      return Es;
    },
    TD6: function () {
      return ws;
    },
    akS: function () {
      return Jy;
    },
    QKE: function () {
      return Zy;
    },
    dKx: function () {
      return C;
    },
    OvX: function () {
      return SI;
    },
    VsW: function () {
      return Dc;
    },
    YMc: function () {
      return zI;
    },
    aPg: function () {
      return Y;
    },
    LFn: function () {
      return Lt;
    },
    wey: function () {
      return xx;
    },
    MaE: function () {
      return rt;
    },
    s4x: function () {
      return it;
    },
    FJA: function () {
      return Ke;
    },
    vIA: function () {
      return tt;
    },
    Spv: function () {
      return lt;
    },
    w8l: function () {
      return st;
    },
    riG: function () {
      return nt;
    },
    Kbh: function () {
      return Ze;
    },
    t8K: function () {
      return $e;
    },
    Q7n: function () {
      return Je;
    },
    KGF: function () {
      return et;
    },
    e5: function () {
      return G;
    },
    Rik: function () {
      return Gs;
    },
    GZo: function () {
      return Vs;
    },
    Bds: function () {
      return us;
    },
    HTu: function () {
      return hs;
    },
    cTq: function () {
      return Et;
    },
    X_Y: function () {
      return po;
    },
    dA8: function () {
      return uo;
    },
    bwS: function () {
      return Rx;
    },
    Lks: function () {
      return HI;
    },
    Rvq: function () {
      return CI;
    },
    P4F: function () {
      return Oy;
    },
    Pd0: function () {
      return on;
    },
    Pjo: function () {
      return Dx;
    },
    Tum: function () {
      return ln;
    },
    dRH: function () {
      return un;
    },
    RX0: function () {
      return cn;
    },
    reQ: function () {
      return WI;
    },
    cWm: function () {
      return Vx;
    },
    NC9: function () {
      return Ly;
    },
    $Re: function () {
      return Os;
    },
    Xo9: function () {
      return Fs;
    },
    LNO: function () {
      return os;
    },
    iZP: function () {
      return as;
    }
  });
  var e,
    t = {};
  __webpackgi_require__.r(t), __webpackgi_require__.d(t, {
    AsyncCompress: function () {
      return Mf;
    },
    AsyncDecompress: function () {
      return Vf;
    },
    AsyncDeflate: function () {
      return Af;
    },
    AsyncGunzip: function () {
      return Df;
    },
    AsyncGzip: function () {
      return Mf;
    },
    AsyncInflate: function () {
      return wf;
    },
    AsyncUnzipInflate: function () {
      return _m;
    },
    AsyncUnzlib: function () {
      return Nf;
    },
    AsyncZipDeflate: function () {
      return um;
    },
    AsyncZlib: function () {
      return Lf;
    },
    Compress: function () {
      return Cf;
    },
    DecodeUTF8: function () {
      return Jf;
    },
    Decompress: function () {
      return Gf;
    },
    Deflate: function () {
      return vf;
    },
    EncodeUTF8: function () {
      return Zf;
    },
    Gunzip: function () {
      return kf;
    },
    Gzip: function () {
      return Cf;
    },
    Inflate: function () {
      return xf;
    },
    Unzip: function () {
      return gm;
    },
    UnzipInflate: function () {
      return mm;
    },
    UnzipPassThrough: function () {
      return fm;
    },
    Unzlib: function () {
      return Uf;
    },
    Zip: function () {
      return hm;
    },
    ZipDeflate: function () {
      return cm;
    },
    ZipPassThrough: function () {
      return lm;
    },
    Zlib: function () {
      return Rf;
    },
    compress: function () {
      return Tf;
    },
    compressSync: function () {
      return If;
    },
    decompress: function () {
      return Qf;
    },
    decompressSync: function () {
      return Hf;
    },
    deflate: function () {
      return bf;
    },
    deflateSync: function () {
      return yf;
    },
    gunzip: function () {
      return Pf;
    },
    gunzipSync: function () {
      return Bf;
    },
    gzip: function () {
      return Tf;
    },
    gzipSync: function () {
      return If;
    },
    inflate: function () {
      return Ef;
    },
    inflateSync: function () {
      return Sf;
    },
    strFromU8: function () {
      return em;
    },
    strToU8: function () {
      return $f;
    },
    unzip: function () {
      return vm;
    },
    unzipSync: function () {
      return Am;
    },
    unzlib: function () {
      return jf;
    },
    unzlibSync: function () {
      return zf;
    },
    zip: function () {
      return pm;
    },
    zipSync: function () {
      return dm;
    },
    zlib: function () {
      return Of;
    },
    zlibSync: function () {
      return Ff;
    }
  }), function (e) {
    e[e.Error = -2] = "Error", e[e.Destroyed = -1] = "Destroyed", e[e.None = 0] = "None", e[e.Running = 1] = "Running", e[e.Paused = 2] = "Paused";
  }(e || (e = {}));
  class r {
    constructor() {
      this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
    }
    addEventListener(e, t) {
      const r = this._eventListeners;
      void 0 === r[e] && (r[e] = []), r[e].includes(t) || r[e].push(t);
    }
    hasEventListener(e, t) {
      const r = this._eventListeners;
      return void 0 !== r[e] && r[e].includes(t);
    }
    removeEventListener(e, t) {
      const r = this._eventListeners[e];
      if (void 0 !== r) {
        const e = r.indexOf(t);
        -1 !== e && r.splice(e, 1);
      }
    }
    dispatchEvent(e) {
      const t = this._eventListeners[e.type];
      if (void 0 !== t) {
        e.target = this;
        const r = t.slice(0);
        for (let t = 0, n = r.length; t < n; t++) r[t].call(this, e);
      }
    }
  }
  var n = __webpackgi_require__(988);
  const i = {
    uniforms: {
      tDiffuse: {
        value: null
      },
      opacity: {
        value: 1
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
  };
  class s {
    constructor() {
      this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
    }
    setSize() {}
    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
  }
  const o = new n.iKG(-1, 1, 1, -1, 0, 1),
    a = new n.u9r();
  a.setAttribute("position", new n.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), a.setAttribute("uv", new n.a$l([0, 2, 0, 0, 2, 0], 2));
  class l {
    constructor(e) {
      this._mesh = new n.Kj0(a, e);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(e) {
      e.render(this._mesh, o);
    }
    get material() {
      return this._mesh.material;
    }
    set material(e) {
      this._mesh.material = e;
    }
  }
  class c extends s {
    constructor(e, t) {
      super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof n.jyz ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = n.rDY.clone(e.uniforms), this.material = new n.jyz({
        defines: Object.assign({}, e.defines),
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader
      })), this.fsQuad = new l(this.material), this.useExistingRenderTarget = !1;
    }
    render(e, t, r) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (this.useExistingRenderTarget || e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
    }
  }
  class u extends s {
    constructor(e, t) {
      super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
    }
    render(e, t, r) {
      const n = e.getContext(),
        i = e.state;
      let s, o;
      i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), i.buffers.stencil.setFunc(n.ALWAYS, s, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(!0), e.setRenderTarget(r), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), i.buffers.stencil.setLocked(!0);
    }
  }
  class h extends s {
    constructor() {
      super(), this.needsSwap = !1;
    }
    render(e) {
      e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
    }
  }
  new n.iKG(-1, 1, 1, -1, 0, 1);
  const p = new n.u9r();
  p.setAttribute("position", new n.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), p.setAttribute("uv", new n.a$l([0, 2, 0, 0, 2, 0], 2));
  class d extends class {
    constructor(e, t) {
      if (this.renderer = e, void 0 === t) {
        const r = e.getSize(new n.FM8());
        this._pixelRatio = e.getPixelRatio(), this._width = r.width, this._height = r.height, (t = new n.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
      } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;
      this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === i && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === c && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new c(i), this.clock = new n.SUY();
    }
    swapBuffers() {
      const e = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e;
    }
    addPass(e) {
      this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(e, t) {
      this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(e) {
      const t = this.passes.indexOf(e);
      -1 !== t && this.passes.splice(t, 1);
    }
    isLastEnabledPass(e) {
      for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return !1;
      return !0;
    }
    render(e) {
      void 0 === e && (e = this.clock.getDelta());
      const t = this.renderer.getRenderTarget();
      let r = !1;
      for (let t = 0, n = this.passes.length; t < n; t++) {
        const n = this.passes[t];
        if (!1 !== n.enabled) {
          if (n.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), n.render(this.renderer, this.writeBuffer, this.readBuffer, e, r), n.needsSwap) {
            if (r) {
              const t = this.renderer.getContext(),
                r = this.renderer.state.buffers.stencil;
              r.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), r.setFunc(t.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== u && (n instanceof u ? r = !0 : n instanceof h && (r = !1));
        }
      }
      this.renderer.setRenderTarget(t);
    }
    reset(e) {
      if (void 0 === e) {
        const t = this.renderer.getSize(new n.FM8());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }
    setSize(e, t) {
      this._width = e, this._height = t;
      const r = this._width * this._pixelRatio,
        n = this._height * this._pixelRatio;
      this.renderTarget1.setSize(r, n), this.renderTarget2.setSize(r, n);
      for (let e = 0; e < this.passes.length; e++) this.passes[e].setSize(r, n);
    }
    setPixelRatio(e) {
      this._pixelRatio = e, this.setSize(this._width, this._height);
    }
  } {
    constructor(e, t) {
      super(e, t);
    }
    setPixelRatio(e, t = !0) {
      const r = this.setSize;
      t || (this.setSize = () => {}), super.setPixelRatio(e), t || (this.setSize = r);
    }
  }
  function f(e, t) {
    let r;
    do {
      r = Object.getOwnPropertyDescriptor(e, t);
    } while (!r && (e = Object.getPrototypeOf(e)));
    return r;
  }
  function m(e, t, r = !1, n = !1) {
    const i = f(e, t);
    return !!(null == i ? void 0 : i.set) || r && !1 !== (null == i ? void 0 : i.writable) && void 0 === (null == i ? void 0 : i.get) || n && !i;
  }
  function _(e, t, r, n = !1, i = !1) {
    return !(!e || !m(e, t, n, i) || (e[t] = r, 0));
  }
  function g(e, t) {
    for (; e.length > 0;) {
      if (!t) return;
      const r = e.splice(0, 1)[0];
      if (!(r.length < 1)) {
        if (!(r in t)) return console.error("invalid access, check", r, t), t;
        t = t[r];
      }
    }
    return t;
  }
  function v(e, t) {
    return Object.keys(e).find(r => e[r] === t);
  }
  function A(e, ...t) {
    return "function" == typeof e && (e = e(...t)), e;
  }
  function b(e, t, r) {
    for (const n of r) {
      const r = e[n];
      void 0 !== r && _(t, n, r, !0);
    }
  }
  function y(e) {
    return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
  }
  function x(e, t, r) {
    return e.replace(new RegExp(y(t), "g"), r);
  }
  String.raw;
  const w = (e, ...t) => String.raw({
      raw: e
    }, ...t),
    E = (e, ...t) => String.raw({
      raw: e
    }, ...t),
    S = (e, ...t) => String.raw({
      raw: e
    }, ...t),
    C = (e, ...t) => {
      let r = String.raw({
        raw: e
      }, ...t);
      return r = x(r, "%", "%25"), r = x(r, "> <", "><"), r = x(r, "; }", ";}"), r = x(r, "<", "%3c"), r = x(r, ">", "%3e"), r = x(r, '"', "'"), r = x(r, "#", "%23"), r = x(r, "{", "%7b"), r = x(r, "}", "%7d"), r = x(r, "|", "%7c"), r = x(r, "^", "%5e"), r = x(r, "`", "%60"), r = x(r, "@", "%40"), r = x(r, "&", "&amp;"), r = x(r, "\n", "%0A"), "data:image/svg+xml;charset=UTF-8," + r;
    };
  function M(e) {
    if (!e) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return (t, r) => {
      let n = t[r];
      Object.defineProperty(t, r, {
        get: () => n,
        set(t) {
          var i;
          if (n === t) return;
          n = t;
          const s = [r, t];
          if ("string" == typeof e) null === (i = this[e]) || void 0 === i || i.call(this, ...s);else if ("function" == typeof e) {
            let t = !1;
            if (e.name) {
              let r = this;
              for (; r;) {
                if (r[e.name] === e) {
                  e.call(this, ...s), t = !0;
                  break;
                }
                r = Object.getPrototypeOf(r);
              }
            }
            t || (e.name && this[e.name].name === `bound ${e.name}` ? this[e.name](...s) : e(...s));
          }
        }
      });
    };
  }
  function T(e, t) {
    for (const r of t) if (!e.includes(r)) return !1;
    return !0;
  }
  String.prototype.replaceAll || (String.prototype.replaceAll = function (e, t) {
    return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e, "g"), t);
  });
  class I {
    constructor(e = 0, t = 0) {
      I.prototype.isVector2 = !0, this.x = e, this.y = t;
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x,
        r = this.y,
        n = e.elements;
      return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }
    clampLength(e, t) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        r = this.y - e.y;
      return t * t + r * r;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, r) {
      return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }
    rotateAround(e, t) {
      const r = Math.cos(t),
        n = Math.sin(t),
        i = this.x - e.x,
        s = this.y - e.y;
      return this.x = i * r - s * n + e.x, this.y = i * n + s * r + e.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class k extends n.ZzF {
    expandByObject(e, t = !1, r = !1) {
      var n;
      if (!1 === (null === (n = e.userData) || void 0 === n ? void 0 : n.bboxVisible)) return this;
      if (!e.visible && r) return this;
      e.updateWorldMatrix(!1, !1);
      const i = e.geometry;
      if (void 0 !== i) if (t && null != i.attributes && void 0 !== i.attributes.position) {
        const t = i.attributes.position;
        for (let r = 0, n = t.count; r < n; r++) P.fromBufferAttribute(t, r).applyMatrix4(e.matrixWorld), this.expandByPoint(P);
      } else null === i.boundingBox && i.computeBoundingBox(), D.copy(i.boundingBox), D.applyMatrix4(e.matrixWorld), this.union(D);
      const s = e.children;
      for (let e = 0, n = s.length; e < n; e++) this.expandByObject(s[e], t, r);
      return this;
    }
    expandByObjects(e, t = !1, r = !1) {
      for (let n = 0, i = e.length; n < i; n++) this.expandByObject(e[n], t, r);
      return this;
    }
    getPoints() {
      return [new n.Pa4(this.min.x, this.min.y, this.min.z), new n.Pa4(this.min.x, this.min.y, this.max.z), new n.Pa4(this.min.x, this.max.y, this.min.z), new n.Pa4(this.min.x, this.max.y, this.max.z), new n.Pa4(this.max.x, this.min.y, this.min.z), new n.Pa4(this.max.x, this.min.y, this.max.z), new n.Pa4(this.max.x, this.max.y, this.min.z), new n.Pa4(this.max.x, this.max.y, this.max.z)];
    }
    getScreenSpaceBounds(e) {
      const t = this.getPoints(),
        r = new n.TUj();
      for (const n of t) {
        const t = n.project(e);
        r.min.min(t), r.max.max(t);
      }
      return r;
    }
  }
  const D = new k(),
    P = new n.Pa4();
  function B(e, t) {
    let r, i;
    if (Array.isArray(e)) for (const n of e) {
      const e = B(n, t);
      void 0 === r || void 0 === i ? (r = e.min.clone(), i = e.max.clone()) : (r.min(e.min), i.max(e.max));
    }
    const s = e;
    if (void 0 !== s.geometry) {
      const o = s.geometry.vertices;
      if (void 0 === o && void 0 !== s.geometry.attributes && "position" in s.geometry.attributes) {
        const o = new n.Pa4(),
          a = s.geometry.attributes.position;
        for (let n = 0; n < a.count * a.itemSize; n += a.itemSize) {
          o.set(a.array[n], a.array[n + 1], a.array[3]);
          const s = o.applyMatrix4(e.matrixWorld).project(t),
            l = new I(s.x, s.y);
          void 0 === r || void 0 === i ? (r = l.clone(), i = l.clone()) : (r.min(l), i.max(l));
        }
      } else for (const n of o) {
        const s = n.clone().applyMatrix4(e.matrixWorld).project(t),
          o = new I(s.x, s.y);
        void 0 === r || void 0 === i ? (r = o.clone(), i = o.clone()) : (r.min(o), i.max(o));
      }
    }
    if (void 0 !== e.children) for (const n of e.children) {
      const e = B(n, t);
      void 0 === r || void 0 === i ? (r = e.min.clone(), i = e.max.clone()) : (r.min(e.min), i.max(e.max));
    }
    return new n.TUj(r, i);
  }
  const R = 3005;
  function L(e) {
    switch (e) {
      case n.rnI:
        return ["Linear", "( value )"];
      case n.knz:
        return ["sRGB", "( value )"];
      case R:
        return ["RGBM", "( value, 16.0 )"];
      default:
        return console.warn("utils: Unsupported encoding:", e), ["Linear", "( value )"];
    }
  }
  function O(e, t) {
    let r;
    return e && e.isTexture ? r = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r = e.texture.encoding) : r = n.rnI, t && e && e.isTexture && e.format === n.wk1 && e.type === n.ywz && e.encoding === n.knz && (r = n.rnI), r;
  }
  function F(e, t) {
    const r = L(t);
    return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }";
  }
  function U(e, t, r) {
    return F(e + "TexelToLinear", O(t, r)) + "\n";
  }
  function N(e, t) {
    return F(e + "TexelToLinear", t) + "\n";
  }
  function j(e, t) {
    const r = L(t);
    return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }";
  }
  function z(e, t, r) {
    return j(e, O(t, r));
  }
  function G({
    uniforms: e,
    propKey: t,
    thisTarget: r = !1
  } = {}) {
    const n = !!e,
      i = !!t,
      s = r;
    return (r, o) => {
      const a = r => {
        const a = s ? r : n ? e : r.uniforms || r._uniforms;
        let l = i ? t : o;
        s && (l = "_" + l);
        let c = a[l];
        return c || (c = {
          value: null
        }, a[l] = c), c;
      };
      Object.defineProperty(r, o, {
        get() {
          return a(this).value;
        },
        set(e) {
          a(this).value = e, _(this, "uniformsNeedUpdate", !0, !0);
        }
      });
    };
  }
  function V(e, t, r = !1, n) {
    const i = !!t,
      s = !!e;
    return (o, a) => {
      const l = r => ({
        t: i ? t : r.defines || r._defines,
        p: s ? e : a
      });
      Object.defineProperty(o, a, {
        get() {
          const {
            t: e,
            p: t
          } = l(r ? this : this.material);
          return e[t];
        },
        set(e) {
          const {
            t: t,
            p: i
          } = l(r ? this : this.material);
          if (_(t, i, e, !0), "function" == typeof n) {
            const t = [i, e];
            if (n.name) {
              const e = this[n.name];
              e === n ? n.call(this, ...t) : e.name === `bound ${n.name}` ? e(...t) : n(...t);
            } else n(...t);
          } else _(r ? this : this.material, "needsUpdate", !0, !0);
        }
      });
    };
  }
  function Q(e) {
    const t = new n.IEO(new Uint8Array([Math.floor(255 * e.r), Math.floor(255 * e.g), Math.floor(255 * e.b), 255]), 1, 1, n.wk1, n.ywz);
    return t.needsUpdate = !0, t.encoding = n.rnI, t;
  }
  function H(e) {
    const t = new n.IEO(new Uint8Array([Math.floor(255 * e.x), Math.floor(255 * e.y), Math.floor(255 * e.z), Math.floor(255 * e.w)]), 1, 1, n.wk1, n.ywz);
    return t.needsUpdate = !0, t;
  }
  function W(e, t, r) {
    const n = e.userData,
      {
        backgroundRender: i,
        transparentRender: s,
        shadowMapRender: o,
        mainRenderPass: a,
        opaqueRender: l,
        transmissionRender: c,
        sceneRender: u,
        screenSpaceRendering: h
      } = n;
    void 0 !== t.backgroundRender && (n.backgroundRender = t.backgroundRender), void 0 !== t.transparentRender && (n.transparentRender = t.transparentRender), void 0 !== t.shadowMapRender && (n.shadowMapRender = t.shadowMapRender), void 0 !== t.mainRenderPass && (n.mainRenderPass = t.mainRenderPass), void 0 !== t.opaqueRender && (n.opaqueRender = t.opaqueRender), void 0 !== t.sceneRender && (n.sceneRender = t.sceneRender), void 0 !== t.transmissionRender && (n.transmissionRender = t.transmissionRender), void 0 !== t.screenSpaceRendering && (n.screenSpaceRendering = t.screenSpaceRendering), r(), n.backgroundRender = i, n.transparentRender = s, n.shadowMapRender = o, n.mainRenderPass = a, n.opaqueRender = l, n.sceneRender = u, n.transmissionRender = c, n.screenSpaceRendering = h;
  }
  function q(e) {
    const t = new k().expandByObject(e, !0, !0).getCenter(new n.Pa4());
    e.position.sub(t), e.updateMatrix(), e.userData.autoCentered = !0;
  }
  function X(e, t) {
    const r = .5 * new k().expandByObject(e, !0, !0).getSize(new n.Pa4()).length();
    void 0 === t && (t = e.userData.autoScaleRadius || 1);
    const i = t / r;
    return isFinite(i) && (e.userData.pseudoCentered ? e.children.forEach(e => {
      e.scale.multiplyScalar(i);
    }) : e.scale.multiplyScalar(i)), e.traverse(e => {
      var t, r;
      e.isLight && (null === (r = null === (t = e.shadow) || void 0 === t ? void 0 : t.camera) || void 0 === r ? void 0 : r.right) && (e.shadow.camera.right *= i, e.shadow.camera.left *= i, e.shadow.camera.top *= i, e.shadow.camera.bottom *= i), e.isCamera && e.right && (e.right *= i, e.left *= i, e.top *= i, e.bottom *= i);
    }), e.userData.autoScaled = !0, e.userData.autoScaleRadius = t, e.dispatchEvent({
      type: "objectUpdate"
    }), e;
  }
  function Y(e, t = -1) {
    return function (e, t = 1e-4) {
      const r = t > 0;
      t = Math.max(t, Number.EPSILON);
      const i = {},
        s = e.getIndex(),
        o = e.getAttribute("position"),
        a = s ? s.count : o.count;
      let l = 0;
      const c = Object.keys(e.attributes),
        u = {},
        h = {},
        p = [],
        d = ["getX", "getY", "getZ", "getW"];
      for (let t = 0, r = c.length; t < r; t++) {
        const r = c[t];
        u[r] = [];
        const n = e.morphAttributes[r];
        n && (h[r] = new Array(n.length).fill().map(() => []));
      }
      const f = Math.log10(1 / t),
        m = Math.pow(10, f);
      for (let t = 0; t < a; t++) {
        const n = s ? s.getX(t) : t;
        let o = "";
        for (let t = 0, i = c.length; t < i && r; t++) {
          const r = c[t],
            i = e.getAttribute(r),
            s = i.itemSize;
          for (let e = 0; e < s; e++) o += ~~(i[d[e]](n) * m) + ",";
        }
        if (r && o in i) p.push(i[o]);else {
          for (let t = 0, r = c.length; t < r; t++) {
            const r = c[t],
              i = e.getAttribute(r),
              s = e.morphAttributes[r],
              o = i.itemSize,
              a = u[r],
              l = h[r];
            for (let e = 0; e < o; e++) {
              const t = d[e];
              if (a.push(i[t](n)), s) for (let e = 0, r = s.length; e < r; e++) l[e].push(s[e][t](n));
            }
          }
          r && (i[o] = l), p.push(l), l++;
        }
      }
      const _ = e.clone();
      for (let t = 0, r = c.length; t < r; t++) {
        const r = c[t],
          i = e.getAttribute(r),
          s = new i.array.constructor(u[r]),
          o = new n.TlE(s, i.itemSize, i.normalized);
        if (_.setAttribute(r, o), r in h) for (let t = 0; t < h[r].length; t++) {
          const i = e.morphAttributes[r][t],
            s = new i.array.constructor(h[r][t]),
            o = new n.TlE(s, i.itemSize, i.normalized);
          _.morphAttributes[r][t] = o;
        }
      }
      return _.setIndex(p), _;
    }(e, t);
  }
  class K extends r {
    constructor({
      animationLoop: e,
      canvas: t,
      alpha: r = !0,
      targetOptions: i
    }) {
      super(), this._isWebGL2 = !1, this._trackedTargets = [], this.dirty = !0, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = !0, this._displayCanvasScaling = 1, this._renderSize = new n.FM8(512, 512), this._frameCount = 0, this._tempTargets = {}, this.maxTempPerKey = 5, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new n.CP7({
        canvas: t,
        antialias: !0,
        alpha: r,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0
      }), this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderSize = new n.FM8(t.clientWidth, t.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = n.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputEncoding = n.rnI, this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = n._iA, this._renderer.shadowMap.autoUpdate = !1, this.resetShadows(), this._composerTarget = this.createTarget(i, !1), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new d(this._renderer, this._composerTarget), e && this.addEventListener("animationLoop", e);
    }
    get composer() {
      return this._composer;
    }
    get passes() {
      return this._passes;
    }
    get isWebGL2() {
      return this._isWebGL2;
    }
    get composerTarget() {
      return this._composerTarget;
    }
    get renderSize() {
      return this._renderSize;
    }
    get displayCanvasScaling() {
      return this._displayCanvasScaling;
    }
    set displayCanvasScaling(e) {
      e !== this._displayCanvasScaling && (this._displayCanvasScaling = e, this.setSize(void 0, void 0, !0));
    }
    get frameCount() {
      return this._frameCount;
    }
    set pipeline(e) {
      this._pipeline = e, this._passesNeedsUpdate = !0;
    }
    get pipeline() {
      return this._pipeline;
    }
    refreshPipeline() {
      var e, t, r;
      const n = this._passes,
        i = [],
        s = {};
      for (const i of n) {
        if (!1 === i.enabled) continue;
        const n = {
          after: null !== (e = i.after) && void 0 !== e ? e : [],
          before: null !== (t = i.before) && void 0 !== t ? t : [],
          dependencies: new Set(null !== (r = i.required) && void 0 !== r ? r : [])
        };
        s[i.passId] = n;
      }
      for (const [e, t] of Object.entries(s)) {
        const r = new Set([...t.after, ...t.before]);
        t.dependencies.forEach(e => r.has(e) && r.delete(e)), r.forEach(r => {
          const n = s[r];
          if (n) {
            if (n.dependencies.has(e)) throw console.error("cyclic", e, r), "Cyclic dependency";
            t.dependencies.add(r);
          }
        });
      }
      for (;;) {
        let e = !1;
        const t = [...Object.entries(s)];
        for (const [r, o] of t) if (!i.includes(r) && T(i, o.dependencies.values())) {
          const t = Math.max(-1, ...o.after.map(e => i.indexOf(e))),
            a = Math.min(i.length, ...o.before.map(e => {
              const t = i.indexOf(e);
              return t < 0 ? i.length : t;
            }));
          if (t >= a) throw console.error(o, n, i, t, a), "Not possible";
          i.splice(o.after.length > 0 ? t + 1 : a, 0, r), e = !0, delete s[r];
        }
        if (Object.keys(s).length < 1) break;
        if (!e) throw console.log(t, s, i), "Not possible 2";
      }
      return this.pipeline = i, this.pipeline;
    }
    get context() {
      return this._context;
    }
    get rendererObject() {
      return this._renderer;
    }
    _animationLoop(e, t) {
      const r = e - this._lastTime;
      this._lastTime = e, this.frameWaitTime -= r, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({
        type: "animationLoop",
        deltaTime: r,
        time: e,
        renderer: this,
        xrFrame: t
      }));
    }
    get clock() {
      return this._composer.clock;
    }
    registerPass(e, t = !0) {
      var r;
      if (t) for (const t of [...this._passes]) e.passId === t.passId && this.unregisterPass(t);
      this._passes.push(e), null === (r = e.onRegister) || void 0 === r || r.call(e, this), this._passesNeedsUpdate = !0, this._updated();
    }
    unregisterPass(e) {
      var t;
      const r = this._passes.indexOf(e);
      r >= 0 && (null === (t = e.onUnregister) || void 0 === t || t.call(e, this), this._passes.splice(r, 1), this._passesNeedsUpdate = !0, this._updated());
    }
    setSize(e, t, r = !1) {
      !r && (e ? Math.abs(e - this._renderSize.width) : 0) + (t ? Math.abs(t - this._renderSize.height) : 0) < .1 || (e && (this._renderSize.width = e), t && (this._renderSize.height = t), this.rendererObject.xr.enabled || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, !1), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach(e => {
        const t = e,
          r = t.sizeMultiplier;
        if (r) {
          const e = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * r);
          t.setSize(e.width, e.height);
        }
      }), this.dispatchEvent({
        type: "resize"
      }), this._updated(), this.reset());
    }
    blit(e, t, {
      viewport: r,
      material: i,
      shader: s,
      pass: o,
      clear: a = !0
    } = {}) {
      const l = this._composer.copyPass,
        {
          renderToScreen: c,
          material: u,
          uniforms: h,
          clear: p
        } = l;
      i && (l.material = i);
      const d = this._renderer.getViewport(new n.Ltg()),
        f = this._renderer.autoClear,
        m = this._renderer.getRenderTarget();
      r && this._renderer.setViewport(new n.Ltg().fromArray(r)), this._renderer.autoClear = !1, l.uniforms = l.material.uniforms, l.renderToScreen = !1, l.clear = a, W(this._renderer, {
        sceneRender: !0,
        opaqueRender: !0,
        shadowMapRender: !1,
        backgroundRender: !1,
        transparentRender: !0,
        transmissionRender: !1
      }, () => {
        l.render(this._renderer, null != t ? t : null, {
          texture: e
        }, 0, !1);
      }), l.renderToScreen = c, l.clear = p, l.material = u, l.uniforms = h, this._renderer.autoClear = f, r && this._renderer.setViewport(d), this._renderer.setRenderTarget(m);
    }
    clearColor({
      r: e,
      g: t,
      b: r,
      a: i,
      target: s,
      depth: o = !0,
      stencil: a = !0
    }) {
      var l;
      const c = this._renderer.getClearColor(new n.Ilk()),
        u = this._renderer.getClearAlpha();
      this._renderer.setClearAlpha(null != i ? i : u), this._renderer.setClearColor(new n.Ilk(null != e ? e : c.r, null != t ? t : c.g, null != r ? r : c.b));
      const h = this._renderer.getRenderTarget(),
        p = this._renderer.getActiveCubeFace(),
        d = this._renderer.getActiveMipmapLevel();
      this._renderer.setRenderTarget(null !== (l = s) && void 0 !== l ? l : null), this._renderer.clear(!0, o, a), this._renderer.setRenderTarget(h, p, d), this._renderer.setClearColor(c), this._renderer.setClearAlpha(u);
    }
    renderModel(e, t) {
      this._renderer.render(e.modelObject, t.cameraObject);
    }
    renderScene(e) {
      const t = e.activeCamera;
      t && this.renderModel(e, t);
    }
    _updated() {
      this.dispatchEvent({
        type: "update"
      });
    }
    render() {
      var e;
      this._passesNeedsUpdate && this.refreshPasses();
      for (const t of this._passes) t.passObject.enabled && (null === (e = t.update) || void 0 === e || e.call(t));
      this._composer.render(), this._frameCount += 1, this.dirty = !1;
    }
    updateDirty() {
      this.dirty = this.dirty || this._passes.findIndex(e => e.dirty) >= 0;
    }
    reset() {
      this._frameCount = 0, this.dirty = !0;
    }
    resetShadows() {
      this._renderer.shadowMap.needsUpdate = !0;
    }
    refreshPasses() {
      if (!this._passesNeedsUpdate) return;
      this._passesNeedsUpdate = !1;
      const e = [];
      for (const t of this._pipeline) {
        const r = this._passes.find(e => e.passId === t);
        r ? e.push(r.passObject) : console.warn("Unable to find pass: ", t);
      }
      [...this._composer.passes].forEach(e => this._composer.removePass(e)), e.forEach(e => this._composer.addPass(e)), this._updated();
    }
    dispose() {
      this._renderer.dispose();
    }
    trackTarget(e) {
      this._trackedTargets.push(e);
    }
    removeTrackedTarget(e) {
      const t = this._trackedTargets.indexOf(e);
      t >= 0 && this._trackedTargets.splice(t, 1);
    }
    createTarget({
      sizeMultiplier: e,
      samples: t = 0,
      encoding: r = n.rnI,
      type: i = n.ywz,
      format: s = n.wk1,
      depthBuffer: o = !0,
      depthTexture: a = !1,
      size: l,
      textureCount: c = 1,
      ...u
    } = {}, h = !0) {
      this.isWebGL2 || (t = 0), void 0 !== e && void 0 !== l && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), l = l || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e = e || 1));
      const p = a ? new n.$YQ(l.width, l.height, n.ywz) : void 0,
        d = this.createTargetCustom(c > 1 ? {
          width: l.width,
          height: l.height,
          count: c
        } : l, {
          samples: t,
          encoding: r,
          type: i,
          format: s,
          depthBuffer: o,
          depthTexture: p
        }, c > 1 ? n.kFz : n.dd2);
      return this._processNewTarget(d, e, h), this._setTargetOptions(d, u), d;
    }
    _processNewTarget(e, t, r) {
      return void 0 !== t && (e.sizeMultiplier = t), r && this.trackTarget(e), e;
    }
    disposeTarget(e) {
      if (e) {
        if (e.isTemporary) return this.releaseTempTarget(e);
        this.removeTrackedTarget(e), e.dispose();
      }
    }
    createTargetCustom({
      width: e,
      height: t,
      count: r
    }, i = {}, s) {
      var o;
      const a = this._processNewTarget;
      let l = [e, t];
      if (r && r > 1 && l.push(r), (null == s ? void 0 : s.prototype) === n.oAp.prototype) {
        if (e !== t) throw "Width and height of cube render target must be equal";
        l = [e];
      }
      i = {
        format: n.wk1,
        minFilter: n.wem,
        magFilter: n.wem,
        generateMipmaps: !1,
        type: n.ywz,
        encoding: n.rnI,
        ...i
      };
      const c = [...l, i];
      return new class extends (null !== (o = s) && void 0 !== o ? o : n.dd2) {
        constructor(...e) {
          super(...e), Array.isArray(this.texture) ? this.texture.forEach(e => {
            e.encoding = i.encoding, e.toJSON = () => ({});
          }) : this.texture.toJSON = () => ({});
        }
        clone(e = !0) {
          if (this.isTemporary) throw "Cloning temporary render targets not supported";
          if (Array.isArray(this.texture)) throw "Cloning multiple render targets not supported";
          const t = super.clone();
          return t.texture.isRenderTargetTexture = !0, a(t, this.sizeMultiplier || 1, e);
        }
      }(...c);
    }
    getTempTarget(e = {}) {
      var t;
      const r = J(e);
      let n;
      return (null === (t = this._tempTargets[r]) || void 0 === t ? void 0 : t.length) && (n = this._tempTargets[r].pop()), n ? this._setTargetOptions(n, e) : (n = this.createTarget(e), this._processNewTempTarget(n, r)), n;
    }
    _processNewTempTarget(e, t) {
      return e.isTemporary = !0, e.targetKey = t, void 0 === this._tempTargets[t] && (this._tempTargets[t] = []), e;
    }
    releaseTempTarget(e) {
      const t = e.targetKey;
      if (!t || !e.isTemporary) throw "Not a temp target";
      this._tempTargets[t].length > this.maxTempPerKey ? e.dispose() : this._tempTargets[t].push(e);
    }
    updateShaderProperties(e) {
      return e.uniforms.frameCount ? e.uniforms.frameCount.value = this.frameCount : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }
    _setTargetOptions(e, t) {
      var r, i, s;
      e.texture.minFilter = null !== (r = t.minFilter) && void 0 !== r ? r : n.wem, e.texture.magFilter = null !== (i = t.magFilter) && void 0 !== i ? i : n.wem, e.texture.generateMipmaps = null !== (s = t.generateMipmaps) && void 0 !== s && s, e.texture.generateMipmaps && e.texture.minFilter === n.wem && (e.texture.minFilter = n.FDw), e.texture.generateMipmaps || e.texture.minFilter !== n.FDw || (e.texture.minFilter = n.wem);
    }
  }
  function J(e = {}) {
    var t, r;
    return [e.sizeMultiplier, e.samples, e.encoding, e.type, e.format, e.depthBuffer, e.depthTexture, null === (t = e.size) || void 0 === t ? void 0 : t.width, null === (r = e.size) || void 0 === r ? void 0 : r.height].join(";");
  }
  const Z = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  function $() {
    const e = 4294967295 * Math.random() | 0,
      t = 4294967295 * Math.random() | 0,
      r = 4294967295 * Math.random() | 0,
      n = 4294967295 * Math.random() | 0;
    return (Z[255 & e] + Z[e >> 8 & 255] + Z[e >> 16 & 255] + Z[e >> 24 & 255] + "-" + Z[255 & t] + Z[t >> 8 & 255] + "-" + Z[t >> 16 & 15 | 64] + Z[t >> 24 & 255] + "-" + Z[63 & r | 128] + Z[r >> 8 & 255] + "-" + Z[r >> 16 & 255] + Z[r >> 24 & 255] + Z[255 & n] + Z[n >> 8 & 255] + Z[n >> 16 & 255] + Z[n >> 24 & 255]).toLowerCase();
  }
  function ee(e, t, r) {
    return Math.max(t, Math.min(r, e));
  }
  function te(e, t, r) {
    return (1 - r) * e + r * t;
  }
  Math.PI, Math.PI;
  const re = 0,
    ne = 1,
    ie = 3,
    se = 4,
    oe = 1006,
    ae = "srgb",
    le = "srgb-linear";
  function ce(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
  }
  function ue(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
  }
  const he = {
      [ae]: {
        [le]: ce
      },
      [le]: {
        [ae]: ue
      }
    },
    pe = {
      legacyMode: !0,
      get workingColorSpace() {
        return le;
      },
      set workingColorSpace(e) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function (e, t, r) {
        if (this.legacyMode || t === r || !t || !r) return e;
        if (he[t] && void 0 !== he[t][r]) {
          const n = he[t][r];
          return e.r = n(e.r), e.g = n(e.g), e.b = n(e.b), e;
        }
        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function (e, t) {
        return this.convert(e, this.workingColorSpace, t);
      },
      toWorkingColorSpace: function (e, t) {
        return this.convert(e, t, this.workingColorSpace);
      }
    },
    de = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    },
    fe = {
      r: 0,
      g: 0,
      b: 0
    },
    me = {
      h: 0,
      s: 0,
      l: 0
    },
    _e = {
      h: 0,
      s: 0,
      l: 0
    };
  function ge(e, t, r) {
    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - r) : e;
  }
  function ve(e, t) {
    return t.r = e.r, t.g = e.g, t.b = e.b, t;
  }
  class Ae {
    constructor(e, t, r) {
      return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === r ? this.set(e) : this.setRGB(e, t, r);
    }
    set(e) {
      return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
    }
    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }
    setHex(e, t = "srgb") {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, pe.toWorkingColorSpace(this, t), this;
    }
    setRGB(e, t, r, n = "srgb-linear") {
      return this.r = e, this.g = t, this.b = r, pe.toWorkingColorSpace(this, n), this;
    }
    setHSL(e, t, r, n = "srgb-linear") {
      if (e = function (e, t) {
        return (e % t + t) % t;
      }(e, 1), t = ee(t, 0, 1), r = ee(r, 0, 1), 0 === t) this.r = this.g = this.b = r;else {
        const n = r <= .5 ? r * (1 + t) : r + t - r * t,
          i = 2 * r - n;
        this.r = ge(i, n, e + 1 / 3), this.g = ge(i, n, e), this.b = ge(i, n, e - 1 / 3);
      }
      return pe.toWorkingColorSpace(this, n), this;
    }
    setStyle(e, t = "srgb") {
      function r(t) {
        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }
      let n;
      if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
        let e;
        const i = n[1],
          s = n[2];
        switch (i) {
          case "rgb":
          case "rgba":
            if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, pe.toWorkingColorSpace(this, t), r(e[4]), this;
            if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, pe.toWorkingColorSpace(this, t), r(e[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
              const n = parseFloat(e[1]) / 360,
                i = parseFloat(e[2]) / 100,
                s = parseFloat(e[3]) / 100;
              return r(e[4]), this.setHSL(n, i, s, t);
            }
        }
      } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const e = n[1],
          r = e.length;
        if (3 === r) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, pe.toWorkingColorSpace(this, t), this;
        if (6 === r) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, pe.toWorkingColorSpace(this, t), this;
      }
      return e && e.length > 0 ? this.setColorName(e, t) : this;
    }
    setColorName(e, t = "srgb") {
      const r = de[e.toLowerCase()];
      return void 0 !== r ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    copySRGBToLinear(e) {
      return this.r = ce(e.r), this.g = ce(e.g), this.b = ce(e.b), this;
    }
    copyLinearToSRGB(e) {
      return this.r = ue(e.r), this.g = ue(e.g), this.b = ue(e.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = "srgb") {
      return pe.fromWorkingColorSpace(ve(this, fe), e), ee(255 * fe.r, 0, 255) << 16 ^ ee(255 * fe.g, 0, 255) << 8 ^ ee(255 * fe.b, 0, 255) << 0;
    }
    getHexString(e = "srgb") {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = "srgb-linear") {
      pe.fromWorkingColorSpace(ve(this, fe), t);
      const r = fe.r,
        n = fe.g,
        i = fe.b,
        s = Math.max(r, n, i),
        o = Math.min(r, n, i);
      let a, l;
      const c = (o + s) / 2;
      if (o === s) a = 0, l = 0;else {
        const e = s - o;
        switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
          case r:
            a = (n - i) / e + (n < i ? 6 : 0);
            break;
          case n:
            a = (i - r) / e + 2;
            break;
          case i:
            a = (r - n) / e + 4;
        }
        a /= 6;
      }
      return e.h = a, e.s = l, e.l = c, e;
    }
    getRGB(e, t = "srgb-linear") {
      return pe.fromWorkingColorSpace(ve(this, fe), t), e.r = fe.r, e.g = fe.g, e.b = fe.b, e;
    }
    getStyle(e = "srgb") {
      return pe.fromWorkingColorSpace(ve(this, fe), e), e !== ae ? `color(${e} ${fe.r} ${fe.g} ${fe.b})` : `rgb(${255 * fe.r | 0},${255 * fe.g | 0},${255 * fe.b | 0})`;
    }
    offsetHSL(e, t, r) {
      return this.getHSL(me), me.h += e, me.s += t, me.l += r, this.setHSL(me.h, me.s, me.l), this;
    }
    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }
    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }
    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }
    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }
    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }
    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }
    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }
    lerpColors(e, t, r) {
      return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
    }
    lerpHSL(e, t) {
      this.getHSL(me), e.getHSL(_e);
      const r = te(me.h, _e.h, t),
        n = te(me.s, _e.s, t),
        i = te(me.l, _e.l, t);
      return this.setHSL(r, n, i), this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  function be(e, t) {
    const r = "map" === t;
    return {
      type: "folder",
      label: t + " Sampler",
      hidden: () => !e[t],
      children: [() => ({
        type: "vec2",
        label: "Repeat",
        hidden: () => !r && e.map,
        bounds: [-100, 100],
        stepSize: .001,
        property: [e[t], "repeat"],
        onChange: null == e ? void 0 : e.setDirty
      }), () => ({
        type: "vec2",
        label: "Offset",
        hidden: () => !r && e.map,
        bounds: [-2, 2],
        property: [e[t], "offset"],
        onChange: null == e ? void 0 : e.setDirty
      }), () => ({
        type: "vec2",
        label: "Center",
        hidden: () => !r && e.map,
        bounds: [-2, 2],
        property: [e[t], "center"],
        onChange: null == e ? void 0 : e.setDirty
      }), () => ({
        type: "input",
        label: "Rotation",
        hidden: () => !r && e.map,
        bounds: [-Math.PI, Math.PI],
        property: [e[t], "rotation"],
        onChange: null == e ? void 0 : e.setDirty
      }), () => ({
        type: "dropdown",
        label: "Encoding",
        property: [e[t], "encoding"],
        children: [["Linear", n.rnI], ["sRGB", n.knz]].map(e => ({
          label: e[0],
          value: e[1]
        })),
        onChange: [() => {
          const r = e[t];
          r && (r.needsUpdate = !0);
        }, null == e ? void 0 : e.setDirty]
      }), () => ({
        type: "checkbox",
        label: "Flip Y",
        getValue: () => {
          var r, n;
          return null !== (n = null === (r = e[t]) || void 0 === r ? void 0 : r.flipY) && void 0 !== n && n;
        },
        setValue: r => {
          var n;
          const i = e[t];
          if (i && i.flipY !== r) if (i.image && ImageBitmap && i.image instanceof ImageBitmap) {
            const t = i,
              n = i.source.data;
            createImageBitmap(n, {
              imageOrientation: "flipY"
            }).then(i => {
              var s;
              n.close && n.close(), t.flipY = r, t.source.data = i, t.source.needsUpdate = !0, t.needsUpdate = !0, null === (s = null == e ? void 0 : e.setDirty) || void 0 === s || s.call(e);
            });
          } else i.flipY = r, i.needsUpdate = !0, null === (n = null == e ? void 0 : e.setDirty) || void 0 === n || n.call(e);
        }
      }), () => ({
        type: "dropdown",
        label: "Wrap S",
        property: [e[t], "wrapS"],
        children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map(e => ({
          label: e[0],
          value: e[1]
        })),
        onChange: [() => {
          e[t] && (e[t].needsUpdate = !0);
        }, null == e ? void 0 : e.setDirty]
      }), () => ({
        type: "dropdown",
        label: "Wrap T",
        property: [e[t], "wrapT"],
        children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map(e => ({
          label: e[0],
          value: e[1]
        })),
        onChange: [() => {
          e[t] && (e[t].needsUpdate = !0);
        }, null == e ? void 0 : e.setDirty]
      }), () => ({
        type: "input",
        label: "Anisotropy",
        bounds: [1, 6],
        stepSize: 1,
        property: [e[t], "anisotropy"],
        onChange: [() => {
          e[t] && (e[t].needsUpdate = !0), e.needsUpdate = !0;
        }, null == e ? void 0 : e.setDirty]
      }), () => ({
        type: "dropdown",
        label: "Min Filter",
        property: [e[t], "minFilter"],
        children: [["Linear", oe], ["Nearest", n.TyD], ["NearestMipmapNearest", n.YLQ], ["NearestMipmapLinear", n.vZf], ["LinearMipmapNearest", n.qyh], ["LinearMipmapLinear", n.D1R]].map(e => ({
          label: e[0],
          value: e[1]
        })),
        onChange: [() => {
          e[t] && (e[t].needsUpdate = !0);
        }, null == e ? void 0 : e.setDirty]
      }), () => ({
        type: "dropdown",
        label: "Mag Filter",
        property: [e[t], "magFilter"],
        children: [["Linear", oe], ["Nearest", n.TyD]].map(e => ({
          label: e[0],
          value: e[1]
        })),
        onChange: [() => {
          e[t] && (e[t].needsUpdate = !0);
        }, null == e ? void 0 : e.setDirty]
      })]
    };
  }
  Ae.NAMES = de;
  const ye = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid", "iMaterial"];
  function xe(e, t) {
    if (t) for (const r of Object.keys(t)) ye.includes(r) || r.startsWith("__") || "function" != typeof e[r] && "function" != typeof t[r] && (e[r] = t[r]);
    return e;
  }
  const we = ["appliedMaterials", "uuid"];
  function Ee(e, t) {
    if (t) for (const r of Object.keys(t)) we.includes(r) || r.startsWith("__") || "function" != typeof e[r] && "function" != typeof t[r] && (e[r] = t[r]);
    return e;
  }
  const Se = new Map();
  function Ce(e) {
    return (t, r) => {
      const n = t.constructor;
      if (n === Object) throw new Error("All properties in an object are serialized by default");
      Se.has(n) || Se.set(n, []), Se.get(n).push([e || r, r]);
    };
  }
  const Me = {
      obj: (e, t) => Object.fromEntries(Object.entries(e).map(([e, r]) => [e, ke(r, !1, t)])),
      vec4: e => ({
        x: e.x,
        y: e.y,
        z: e.z,
        w: e.w,
        isVector4: !0
      }),
      vec3: e => ({
        x: e.x,
        y: e.y,
        z: e.z,
        isVector3: !0
      }),
      vec2: e => ({
        x: e.x,
        y: e.y,
        isVector2: !0
      }),
      color: e => ({
        r: e.r,
        g: e.g,
        b: e.b,
        isColor: !0
      }),
      quat: e => ({
        x: e.x,
        y: e.y,
        z: e.z,
        w: e.w,
        isQuaternion: !0
      }),
      texture: (e, t) => {
        if (!(null == e ? void 0 : e.isTexture)) throw new Error("Expected a texture");
        if (e.isRenderTargetTexture) return;
        if (null == t ? void 0 : t.textures[e.uuid]) return {
          uuid: e.uuid,
          resource: "textures"
        };
        const r = e.source.data;
        e.userData.rootPath && (e.source.data = null);
        const n = e.userData;
        e.userData = {};
        let i = e.toJSON(t);
        return e.userData = n, i.userData = ke(Ee({}, n), !1, t), e.userData.rootPath && (delete t.images[e.source.uuid], e.source.data = r), (null == t ? void 0 : t.textures) && (t.textures[i.uuid] || (t.textures[i.uuid] = i), i = {
          uuid: i.uuid,
          resource: "textures"
        }), i;
      },
      material: (e, t) => {
        var r;
        if (!(null == e ? void 0 : e.isMaterial)) throw new Error("Expected a material");
        if (null == t ? void 0 : t.materials[e.uuid]) return {
          uuid: e.uuid,
          resource: "materials"
        };
        e.userData.rootPath && console.error("TODO: handle material with root path with material inheritance/hierarchy");
        const n = null != t ? t : {
            textures: {},
            images: {}
          },
          i = {},
          s = {};
        for (const [t, o] of Object.entries(e)) if ((null === (r = o) || void 0 === r ? void 0 : r.isTexture) && !t.startsWith("__")) {
          const r = Me.texture(o, n);
          i[t] = r, s[t] = o, e[t] = r ? {
            isTexture: !0,
            toJSON: () => r
          } : null;
        }
        let o = e.toJSON(t);
        for (const [t, r] of Object.entries(s)) e[t] = r, delete s[t];
        if (t) {
          for (const [e, t] of Object.entries(i)) t && (o[e] = t);
          (null == t ? void 0 : t.materials) && (t.materials[o.uuid] || (t.materials[o.uuid] = o), o = {
            uuid: o.uuid,
            resource: "materials"
          });
        } else {
          for (const [e, t] of Object.entries(i)) o[e] = t.uuid;
          o.textures = Object.values(n.textures), o.images = Object.values(n.images);
        }
        return o;
      }
    },
    Te = e => (t, r) => {
      var n, i;
      return null !== (i = null === (n = null == r ? void 0 : r.copy) || void 0 === n ? void 0 : n.call(r, t)) && void 0 !== i ? i : new e().copy(t);
    },
    Ie = {
      obj: (e, t, r) => Object.assign(t, Object.fromEntries(Object.entries(e).map(([e, n]) => [e, De(n, null == t ? void 0 : t[e], !1, r)]))),
      vec4: Te(n.Ltg),
      vec3: Te(n.Pa4),
      vec2: Te(I),
      color: Te(Ae),
      quat: Te(n._fP)
    };
  function ke(e, t, r) {
    var n, i;
    if ("function" == typeof e) return;
    if (Array.isArray(e)) return e.map(e => ke(e, !1, r));
    if ("object" != typeof e) {
      if ("number" == typeof e) {
        if (e === 1 / 0) return "Infinity";
        if (e === -1 / 0) return "-Infinity";
        if (isNaN(e)) return "NaN";
      }
      return e;
    }
    if (!e) return e;
    let s = null !== (n = e.constructor) && void 0 !== n ? n : Object;
    if (s === Object) return Me.obj(e, r);
    if (e.isVector2) return Me.vec2(e);
    if (e.isVector3) return Me.vec3(e);
    if (e.isVector4) return Me.vec4(e);
    if (e.isColor) return Me.color(e);
    if (e.isQuaternion) return Me.quat(e);
    if (e.isTexture) return Me.texture(e, r);
    if (e.isMaterial) return Me.material(e, r);
    if (!t && "function" == typeof e.toJSON) return e.toJSON(r);
    const o = {};
    for (; s && s !== Object;) null === (i = Se.get(s)) || void 0 === i || i.forEach(([t, n]) => {
      const i = e[n];
      o[t] = ke(i, !1, r);
    }), s = Object.getPrototypeOf(s);
    return e.serializableClassId && (o.serializableClassId = e.serializableClassId), o;
  }
  function De(e, t, r, n) {
    var i, s, o;
    let a = t;
    if (void 0 === e) return a;
    if ("number" == typeof t) {
      if ("Infinity" === e) return 1 / 0;
      if ("-Infinity" === e) return -1 / 0;
      if ("NaN" === e) return NaN;
      if ("number" == typeof e || !e) return e;
    }
    if (Array.isArray(e)) {
      const t = e.length;
      Array.isArray(a) || (a = []);
      for (let r = 0; r < t; r++) {
        const t = e[r],
          i = a.length > r ? De(t, a[r], !1, n) : De(t, void 0, !1, n);
        a.length <= r ? a.push(i) : a[r] = i;
      }
      return a;
    }
    let l = !1;
    if (e && e.resource && "string" == typeof e.resource && (e = null === (i = n[e.resource]) || void 0 === i ? void 0 : i[e.uuid], l = !0), !a && e && !l) if (e.serializableClassId) {
      const t = Pe.get(e.serializableClassId);
      t && (a = new t());
    } else "object" != typeof e || e.constructor && e.constructor !== Object || (a = {});
    if ("function" == typeof a) return console.error("cannot deserialize over function", a, e), a;
    if (e && "object" == typeof e && !l) {
      if (e.isVector2) return Ie.vec2(e, a);
      if (e.isVector3) return Ie.vec3(e, a);
      if (e.isVector4) return Ie.vec4(e, a);
      if (e.isColor) return Ie.color(e, a);
      if (e.isQuaternion) return Ie.quat(e, a);
    }
    if (null == e || null == a || "object" != typeof a || a.isTexture) return l && (e ? e.__useCount = e.__useCount ? e.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e;
    let c = null !== (s = a.constructor) && void 0 !== s ? s : Object;
    if (c === Object) return Ie.obj(e, a, n);
    if (!r && "function" == typeof a.fromJSON) return a.isMaterial && (Object.entries(e).forEach(([t, r]) => {
      var i;
      if (!r || !r.resource || "string" != typeof r.resource) return;
      const s = null === (i = n[r.resource]) || void 0 === i ? void 0 : i[r.uuid];
      e[t] = s || null;
    }), e.userData && (e.userData = De(e.userData, void 0, !1, n))), a.fromJSON(e, n), a;
    for (; c && c !== Object;) null === (o = Se.get(c)) || void 0 === o || o.forEach(([t, r]) => {
      const i = a[r],
        s = De(e[t], i, !1, n);
      s !== i && _(a, r, s, !0);
    }), c = Object.getPrototypeOf(c);
    return a;
  }
  const Pe = new Map();
  function Be(e) {
    return t => (t = class extends t {
      constructor() {
        super(...arguments), this.serializableClassId = e;
      }
    }, Pe.set(e, t), t);
  }
  function Re(e, t) {
    if (e.uiConfig) return e.uiConfig;
    const r = {
        type: "folder",
        label: e.name || "unnamed",
        expanded: !0,
        limitedUi: !0,
        children: [{
          type: "checkbox",
          label: "Visible",
          property: [e, "visible"],
          limitedUi: !0
        }, {
          type: "button",
          label: "Pick/Focus",
          value: () => {
            e.dispatchEvent({
              type: "select",
              ui: !0,
              value: e,
              focusCamera: !0
            });
          }
        }, {
          type: "button",
          label: "Pick Parent",
          hidden: () => !e.parent,
          value: () => {
            const t = e.parent;
            t && t.dispatchEvent({
              type: "select",
              ui: !0,
              value: t
            });
          }
        }, {
          type: "input",
          label: "Name",
          property: [e, "name"]
        }, {
          type: "checkbox",
          label: "Casts Shadow",
          hidden: () => !e.isMesh,
          property: [e, "castShadow"]
        }, {
          type: "checkbox",
          label: "Receive Shadow",
          hidden: () => !e.isMesh,
          property: [e, "receiveShadow"]
        }, {
          type: "vec3",
          label: "Position",
          property: [e, "position"],
          limitedUi: !0
        }, {
          type: "vec3",
          label: "Rotation",
          property: [e, "rotation"],
          limitedUi: !0
        }, {
          type: "vec3",
          label: "Scale",
          property: [e, "scale"]
        }, {
          type: "button",
          label: "Auto Scale",
          prompt: ["Auto Scale Radius: Object will be scaled to the given radius", e.userData.autoScaleRadius || "2", !0],
          value: t => {
            if (!t) return;
            const r = parseFloat(t);
            Math.abs(r) > 0 && X(e, r);
          }
        }, void 0 !== e.userData.license ? {
          type: "input",
          label: "License/Credits",
          property: [e.userData, "license"],
          limitedUi: !0
        } : {}]
      },
      n = e;
    if ((null == n ? void 0 : n.isMesh) && !1 !== t) {
      const e = [() => {
        var e;
        return null === (e = n.geometry) || void 0 === e ? void 0 : e.uiConfig;
      }, () => {
        var e;
        return Array.isArray(n.material) ? n.material.length < 1 ? void 0 : {
          label: "Materials",
          type: "folder",
          children: n.material.map(e => null == e ? void 0 : e.uiConfig).filter(e => e)
        } : null === (e = n.material) || void 0 === e ? void 0 : e.uiConfig;
      }];
      r.children.push(...e);
    }
    if (null == e ? void 0 : e.isCamera) {
      const t = [{
        type: "button",
        label: "Set View",
        value: () => {
          e.dispatchEvent({
            type: "setView",
            ui: !0,
            camera: e
          });
        }
      }, {
        type: "button",
        label: "Activate main",
        hidden: () => {
          var t;
          return null === (t = e.userData.iCamera) || void 0 === t ? void 0 : t.isActiveCamera;
        },
        value: () => {
          e.dispatchEvent({
            type: "activateMain",
            ui: !0,
            camera: e
          });
        }
      }, {
        type: "button",
        label: "Deactivate main",
        hidden: () => {
          var t;
          return !(null === (t = e.userData.iCamera) || void 0 === t ? void 0 : t.isActiveCamera);
        },
        value: () => {
          e.dispatchEvent({
            type: "activateMain",
            ui: !0,
            camera: void 0
          });
        }
      }];
      r.children.push(...t);
    }
    return e.uiConfig = r, r;
  }
  function Le(e, t, r) {
    var n;
    if (!e) return void console.warn("setupIModel: object is undefined");
    if (e.__disposed && (console.warn("re-init/re-add disposed object, things might not work as intended", e), delete e.__disposed), e.userData || (e.userData = {}), e.userData.__iModelSetup && e.modelObject) return e;
    e.userData.__iModelSetup = !0;
    let i = [];
    i.push(() => {
      [...e.children].forEach(e => {
        var t;
        null === (t = null == e ? void 0 : e.dispose) || void 0 === t || t.call(e);
      }), e.children = [], e.parent && e.removeFromParent();
    }), e.isLight && !e.assetType ? (e.assetType = "light", e.lightObject = e) : e.isCamera ? (e.assetType = "camera", e.cameraObject = e) : e.assetType || (e.assetType = "model"), e.modelObject || (e.modelObject = e), e.setDirty || (e.setDirty = (t = {}) => {
      e.dispatchEvent({
        ...t,
        type: "objectUpdate",
        object: e
      });
    }, e.userData.setDirty && console.warn("userData.setDirty already defined", e.userData.setDirty, e), e.userData.setDirty = t => {
      var r;
      console.warn("userData.setDirty is deprecated, use setDirty directly"), null === (r = e.setDirty) || void 0 === r || r.call(e, t);
    });
    const s = t => {
        var r, n, i;
        const s = null !== (n = null === (r = e.parent) || void 0 === r ? void 0 : r.userData.parentRoot) && void 0 !== n ? n : e.parent;
        s !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = s;
        }), null === (i = e.setDirty) || void 0 === i || i.call(e, {
          change: "addedToParent"
        });
      },
      o = () => {
        var t;
        null === (t = e.setDirty) || void 0 === t || t.call(e, {
          change: "removedFromParent"
        }), void 0 !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = void 0;
        });
      };
    e.addEventListener("added", s), e.addEventListener("removed", o), i.push(() => {
      e.removeEventListener("added", s), e.removeEventListener("removed", o);
    });
    const a = e.dispose;
    e.dispose = () => {
      e.dispatchEvent({
        type: "dispose"
      }), null == a || a.call(e);
    }, e.userData.dispose && console.warn("userData.dispose already defined"), e.userData.dispose = () => {
      var t;
      console.warn("userData.dispose is deprecated, use dispose directly"), null === (t = e.dispose) || void 0 === t || t.call(e);
    };
    const l = e;
    !l.isMesh && !l.isLine || l.userData.__meshSetup || (l.userData.__meshSetup = !0, l.setMaterial || (l.setMaterial = e => Oe(l, e)), l.setGeometry || (l.setGeometry = (e, t = !1) => Fe(l, e, t), l.setGeometry(l.geometry, !0)), e.userData.setMaterial && console.warn("userData.setMaterial already defined"), e.userData.setMaterial = t => {
      var r;
      console.warn("userData.setMaterial is deprecated, use setMaterial directly"), null === (r = e.setMaterial) || void 0 === r || r.call(e, t);
    }, e.userData.setGeometry && console.warn("userData.setGeometry already defined"), e.userData.setGeometry = (t, ...r) => {
      var n;
      console.warn("userData.setGeometry is deprecated, use setGeometry directly"), null === (n = e.setGeometry) || void 0 === n || n.call(e, t, ...r);
    }, e.userData.__keepShadowDef || (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0), i.push(() => {
      var e, t;
      const r = (null === (e = l.setMaterial) || void 0 === e ? void 0 : e.call(l, void 0)) || [],
        n = null === (t = l.setGeometry) || void 0 === t ? void 0 : t.call(l, void 0);
      for (const e of r) e && 0 === e.userData.__appliedMeshes.size && !1 !== e.userData.disposeOnIdle && e.dispose();
      n && 0 === n.userData.__appliedMeshes.size && !1 !== n.userData.disposeOnIdle && n.dispose();
    })), e.uiConfig || "model" !== e.assetType && "camera" !== e.assetType || (Re(e), i.push(() => {
      e.uiConfig = void 0;
    }));
    const c = () => {
      var t, r;
      return null === (r = null === (t = e.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r ? void 0 : r.call(t, "postFrame", !0, 1);
    };
    e.addEventListener("objectUpdate", c), i.push(() => e.removeEventListener("objectUpdate", c)), e.userData.__autoParentDispatchEvents ? console.warn("object.userData.__autoParentDispatchEvents already set") : (e.userData.__autoParentDispatchEvents = e.userData.__autoParentDispatchEvents || ["objectUpdate", "materialUpdate", "select"], e.isCamera && e.userData.__autoParentDispatchEvents.push("activateMain", "setView")), t && (e.userData.parentRoot = t), i.push(() => {
      delete e.userData.parentRoot;
    });
    const u = e.dispatchEvent;
    e.dispatchEvent = t => {
      var r;
      (null === (r = e.userData.__autoParentDispatchEvents) || void 0 === r ? void 0 : r.includes(t.type)) && (t.parentDispatch = !0), t.parentDispatch && (t => {
        var r;
        const n = null !== (r = e.userData.parentRoot) && void 0 !== r ? r : e.parent;
        (null == n ? void 0 : n.modelObject) && n.dispatchEvent(t);
      })(t), u.call(e, t);
    }, i.push(() => {
      e.dispatchEvent = u;
    });
    const h = e.clone;
    e.clone = (...t) => {
      const n = e.userData;
      e.userData = {};
      let i = h.call(e, ...t);
      e.userData = n, je(i.userData, n);
      const s = e.userData.parentRoot;
      return s && "model" !== s.assetType && console.warn("Cloning an object with a parent that is not an IModel is not supported"), i = Le(i, s, r), i.userData.cloneParent = e.uuid, i;
    }, i.push(() => {
      e.clone = h;
    });
    const p = e.copy;
    e.copy = (t, ...r) => {
      const n = t.userData;
      t.userData = {};
      const i = p.call(e, t, ...r);
      return t.userData = n, je(e.userData, t), i;
    }, i.push(() => {
      e.copy = p;
    });
    const d = e.add;
    return e.add = (...t) => (t.forEach(t => Le(t, e.userData.parentRoot || e, r)), d.call(e, ...t)), i.push(() => {
      e.add = d;
    }), e = null !== (n = null == r ? void 0 : r(e)) && void 0 !== n ? n : e, i.push(() => {
      _(e, "modelObject", void 0, !0), e.userData = {};
    }), e.addEventListener("dispose", () => {
      e.__disposed ? console.warn("Object already disposed", e) : (e.__disposed = !0, i.forEach(e => e()), i = []);
    }), [...e.children].forEach(t => Le(t, e, r)), e;
  }
  function Oe(e, t) {
    var r, n, i, s, o;
    const a = (Array.isArray(t) ? t : [t]).map(e => null == e ? void 0 : e.materialObject).filter(e => e);
    if (e.material == a || 1 === a.length && e.material === a[0]) return [];
    e.userData.__materialUpdater || (e.userData.__materialUpdater = () => {
      e.dispatchEvent({
        type: "materialUpdate"
      });
    });
    const l = Array.isArray(e.material) ? [...e.material] : [e.material];
    for (const t of l) t && (t.removeEventListener("materialUpdate", e.userData.__materialUpdater), null === (n = null === (r = t.userData) || void 0 === r ? void 0 : r.__appliedMeshes) || void 0 === n || n.delete(e));
    const c = [];
    for (const t of a) t.userData.__appliedMeshes || (t.userData.__appliedMeshes = new Set()), c.push(t), t && (t.addEventListener("materialUpdate", e.userData.__materialUpdater), t.userData.__appliedMeshes.add(e));
    return e.material = 1 !== c.length ? c : null !== (i = c[0]) && void 0 !== i ? i : void 0, e.traverseAncestors(t => {
      t.isRootScene && t.refreshEnvMapIntensity(e);
    }), e.dispatchEvent({
      type: "materialChanged",
      material: t
    }), null === (o = null === (s = e.uiConfig) || void 0 === s ? void 0 : s.uiRefresh) || void 0 === o || o.call(s, "postFrame", !0), l;
  }
  function Fe(e, t, r = !1) {
    var n, i, s, o, a, l, c;
    e.userData.__objectUpdater || (e.userData.__objectUpdater = t => {
      e.dispatchEvent({
        ...t,
        type: "objectUpdate"
      });
    });
    let u = e.geometry;
    const h = u;
    return (u !== t || r) && (u && (u.removeEventListener("geometryUpdate", e.userData.__objectUpdater), null === (i = null === (n = u.userData) || void 0 === n ? void 0 : n.__appliedMeshes) || void 0 === i || i.delete(e)), u = t, u && !u.userData.__appliedMeshes && (u.userData.__appliedMeshes = new Set()), e.geometry = null !== (s = u) && void 0 !== s ? s : void 0, u && (u.addEventListener("geometryUpdate", e.userData.__objectUpdater), null === (a = null === (o = u.userData) || void 0 === o ? void 0 : o.__appliedMeshes) || void 0 === a || a.add(e))), t && !t.uiConfig && (t.uiConfig = function (e) {
      return {
        label: "Geometry",
        type: "folder",
        children: [{
          type: "input",
          property: [e, "uuid"],
          disabled: !0
        }, {
          type: "button",
          label: "Create uv2 from uv",
          value: () => {
            e.hasAttribute("uv2") && !confirm("uv2 already exists, replace with uv data?") || e.setAttribute("uv2", e.getAttribute("uv"));
          }
        }, {
          type: "input",
          label: "Mesh count",
          get value() {
            var t, r, n;
            return null !== (n = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.__appliedMeshes) || void 0 === r ? void 0 : r.size) && void 0 !== n ? n : 0;
          },
          set value(e) {},
          disabled: !0
        }]
      };
    }(e.geometry)), e.dispatchEvent({
      type: "geometryChanged",
      geometry: t
    }), null === (c = null === (l = e.uiConfig) || void 0 === l ? void 0 : l.uiRefresh) || void 0 === c || c.call(l, "postFrame", !0), h === u ? void 0 : h || void 0;
  }
  const Ue = ["appliedMeshes"],
    Ne = ["parentRoot", "iCamera", "iModel"];
  function je(e, t) {
    if (t) for (const r of Object.keys(t)) Ne.includes(r) || r.startsWith("__") || "function" != typeof e[r] && "function" != typeof t[r] && (e[r] = t[r]);
    return e;
  }
  var ze,
    Ge = new Uint8Array(16);
  function Ve() {
    if (!ze && !(ze = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return ze(Ge);
  }
  for (var Qe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, He = function (e) {
      return "string" == typeof e && Qe.test(e);
    }, We = [], qe = 0; qe < 256; ++qe) We.push((qe + 256).toString(16).substr(1));
  var Xe = function (e, t, r) {
    var n = (e = e || {}).random || (e.rng || Ve)();
    if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, t) {
      r = r || 0;
      for (var i = 0; i < 16; ++i) t[r + i] = n[i];
      return t;
    }
    return function (e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        r = (We[e[t + 0]] + We[e[t + 1]] + We[e[t + 2]] + We[e[t + 3]] + "-" + We[e[t + 4]] + We[e[t + 5]] + "-" + We[e[t + 6]] + We[e[t + 7]] + "-" + We[e[t + 8]] + We[e[t + 9]] + "-" + We[e[t + 10]] + We[e[t + 11]] + We[e[t + 12]] + We[e[t + 13]] + We[e[t + 14]] + We[e[t + 15]]).toLowerCase();
      if (!He(r)) throw TypeError("Stringified UUID is invalid");
      return r;
    }(n);
  };
  const Ye = new Map();
  function Ke(e, t) {
    return (r, n) => {
      const i = r.constructor;
      if (i === Object) throw new Error("All properties in an object are serialized by default");
      Ye.has(i) || Ye.set(i, []);
      const s = Ye.get(i);
      if (!(s.findIndex(e => e.propKey === n) < 0)) throw new Error(`Property ${n} already has a uiConfig decorator`);
      s.push({
        params: t || {},
        propKey: n,
        uiType: e
      });
    };
  }
  function Je(e, t) {
    return Ke("checkbox", {
      label: e,
      params: t
    });
  }
  function Ze(e, t) {
    return Ke("monitor", {
      label: e,
      params: t
    });
  }
  function $e(e, t, r, n) {
    return Ke("slider", {
      label: e,
      bounds: t,
      stepSize: r,
      params: n
    });
  }
  function et(e, t, r, n) {
    return Ke("vec", {
      label: e,
      bounds: t,
      stepSize: r,
      params: n
    });
  }
  function tt(e, t, r) {
    return Ke("dropdown", {
      label: e,
      children: t,
      params: r
    });
  }
  function rt(e, t) {
    return Ke("button", {
      label: e,
      params: t
    });
  }
  function nt(e, t) {
    return Ke("input", {
      label: e,
      params: t
    });
  }
  function it(e, t) {
    return Ke("color", {
      label: e,
      params: t
    });
  }
  function st(e, t) {
    return Ke("image", {
      label: e,
      params: t
    });
  }
  function ot(e) {
    let t = null == e ? void 0 : e.constructor;
    if (!e || !t) return [];
    const r = [],
      n = [];
    for (; t && t !== Object;) n.push(t), t = Object.getPrototypeOf(t);
    return n.reverse().forEach(t => {
      var n;
      null === (n = Ye.get(t)) || void 0 === n || n.forEach(({
        params: t,
        propKey: n,
        uiType: i
      }) => {
        var s;
        let o;
        if (i || (o = null === (s = e[n]) || void 0 === s ? void 0 : s.uiConfig), o || (o = {
          property: [e, n],
          type: i || "input"
        }), t) {
          const r = "function" == typeof t.params ? t.params(e) : t.params || {};
          delete t.params, Object.assign(o, {
            ...t,
            ...r
          });
        }
        r.push(o);
      });
    }), r;
  }
  function at(e, t, r = {}) {
    return {
      type: "folder",
      label: e,
      children: ot(t),
      uuid: Xe(),
      ...r
    };
  }
  function lt(e, t) {
    return r => class extends r {
      constructor() {
        super(...arguments), this.uiConfig = at(e, this, t || {});
      }
    };
  }
  const ct = {
      type: "change"
    },
    ut = {
      type: "start"
    },
    ht = {
      type: "end"
    };
  class pt extends n.pBf {
    constructor(e, t) {
      super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new n.Pa4(), this.minDistance = .01, this.maxDistance = 1 / 0, this.autoPushTarget = !0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.dollyZoom = !1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown"
      }, this.mouseButtons = {
        LEFT: n.RsA.ROTATE,
        MIDDLE: n.RsA.DOLLY,
        RIGHT: n.RsA.PAN
      }, this.touches = {
        ONE: n.QmN.ROTATE,
        TWO: n.QmN.DOLLY_PAN
      }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
        return a.phi;
      }, this.getAzimuthalAngle = function () {
        return a.theta;
      }, this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function (e) {
        e.addEventListener("keydown", Q), this._domElementKeyEvents = e;
      }, this.saveState = function () {
        r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom;
      }, this.reset = function () {
        r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(ct), r.update(), s = i.NONE;
      }, this.update = function () {
        const t = new n.Pa4(),
          p = new n._fP().setFromUnitVectors(e.up, new n.Pa4(0, 1, 0)),
          d = p.clone().invert(),
          f = new n.Pa4(),
          m = new n._fP(),
          _ = 2 * Math.PI;
        return function () {
          const e = r.object.position;
          t.copy(e).sub(r.target), t.applyQuaternion(p), a.setFromVector3(t), r.autoRotate && s === i.NONE && E(2 * Math.PI / 60 / 60 * r.autoRotateSpeed), r.enableDamping ? (a.theta += l.theta * r.dampingFactor, a.phi += l.phi * r.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
          let n = r.minAzimuthAngle,
            g = r.maxAzimuthAngle;
          isFinite(n) && isFinite(g) && (n < -Math.PI ? n += _ : n > Math.PI && (n -= _), g < -Math.PI ? g += _ : g > Math.PI && (g -= _), a.theta = n <= g ? Math.max(n, Math.min(g, a.theta)) : a.theta > (n + g) / 2 ? Math.max(n, a.theta) : Math.min(g, a.theta)), a.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, a.phi)), a.makeSafe(), Math.abs(l.radius) > 0 && (r.dollyZoom && (r.object.zoom = Math.max(Math.max(r.minZoom, .1), Math.min(Math.min(r.maxZoom, 20), r.object.zoom * (1 + l.radius * (r.enableDamping ? r.dampingFactor : 1)))), r.object.updateProjectionMatrix(), (r.object.zoom >= Math.min(r.maxZoom, 20) || r.object.zoom <= Math.max(r.minZoom, .1)) && (l.radius = 0)), a.radius *= 1 + l.radius * (r.enableDamping ? r.dampingFactor : 1)), Math.abs(c - 1) > 1e-5 && (r.dollyZoom && (r.object.zoom = Math.max(Math.max(r.minZoom, .1), Math.min(Math.min(r.maxZoom, 20), r.object.zoom * c)), r.object.updateProjectionMatrix(), (r.object.zoom >= Math.min(r.maxZoom, 20) || r.object.zoom <= Math.max(r.minZoom, .1)) && (c = 1)), a.radius *= c);
          let v = 0;
          r.autoPushTarget && a.radius < r.minDistance && (v = r.minDistance - a.radius), a.radius = Math.max(r.minDistance, Math.min(r.maxDistance, a.radius)), !0 === r.enableDamping ? r.target.addScaledVector(u, r.dampingFactor) : r.target.add(u), t.setFromSpherical(a), t.applyQuaternion(d), e.copy(r.target).add(t), r.target.add(t.normalize().multiplyScalar(-v)), r.object.lookAt(r.target);
          let A = !1;
          return !0 === r.enableDamping && Math.abs(l.theta) + Math.abs(l.phi) + Math.abs(l.radius) + u.length() > .001 ? (l.theta *= 1 - r.dampingFactor, l.phi *= 1 - r.dampingFactor, l.radius *= 1 - r.dampingFactor, u.multiplyScalar(1 - r.dampingFactor), A = !0) : (l.set(0, 0, 0), u.set(0, 0, 0)), c = 1, !!(h || A || f.distanceToSquared(r.object.position) > o || 8 * (1 - m.dot(r.object.quaternion)) > o) && (r.dispatchEvent(ct), f.copy(r.object.position), m.copy(r.object.quaternion), h = !1, !0);
        };
      }(), this.stopDamping = function () {
        l.set(0, 0, 0), u.set(0, 0, 0);
      }, this.dispose = function () {
        r.domElement.removeEventListener("contextmenu", H), r.domElement.removeEventListener("pointerdown", N), r.domElement.removeEventListener("pointercancel", G), r.domElement.removeEventListener("wheel", V), r.domElement.removeEventListener("pointermove", j), r.domElement.removeEventListener("pointerup", z), null !== r._domElementKeyEvents && r._domElementKeyEvents.removeEventListener("keydown", Q);
      };
      const r = this,
        i = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6
        };
      let s = i.NONE;
      const o = 1e-6,
        a = new n.$V(),
        l = new n.$V(0, 0, 0);
      let c = 1;
      const u = new n.Pa4();
      let h = !1;
      const p = new n.FM8(),
        d = new n.FM8(),
        f = new n.FM8(),
        m = new n.FM8(),
        _ = new n.FM8(),
        g = new n.FM8(),
        v = new n.FM8(),
        A = new n.FM8(),
        b = new n.FM8(),
        y = [],
        x = {};
      function w() {
        return r.enableDamping ? 1 : Math.pow(.95, r.zoomSpeed);
      }
      function E(e) {
        l.theta -= e;
      }
      function S(e) {
        l.phi -= e;
      }
      this.rotateUp = S, this.rotateLeft = E;
      const C = function () {
          const e = new n.Pa4();
          return function (t, r) {
            e.setFromMatrixColumn(r, 0), e.multiplyScalar(-t), u.add(e);
          };
        }(),
        M = function () {
          const e = new n.Pa4();
          return function (t, n) {
            !0 === r.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0), e.crossVectors(r.object.up, e)), e.multiplyScalar(t), u.add(e);
          };
        }(),
        T = function () {
          const e = new n.Pa4();
          return function (t, n) {
            const i = r.domElement;
            if (r.object.isPerspectiveCamera) {
              const s = r.object.position;
              e.copy(s).sub(r.target);
              let o = e.length();
              o *= Math.tan(r.object.fov / 2 * Math.PI / 180), C(2 * t * o / i.clientHeight, r.object.matrix), M(2 * n * o / i.clientHeight, r.object.matrix);
            } else r.object.isOrthographicCamera ? (C(t * (r.object.right - r.object.left) / r.object.zoom / i.clientWidth, r.object.matrix), M(n * (r.object.top - r.object.bottom) / r.object.zoom / i.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1);
          };
        }();
      function I(e, t = 0) {
        r.object.isPerspectiveCamera ? (c /= e, l.radius = Math.max(-r.maxZoomSpeed, Math.min(r.maxZoomSpeed, l.radius - t))) : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * e)), r.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
      }
      function k(e, t = 0) {
        r.object.isPerspectiveCamera ? (c *= e, l.radius = Math.max(-r.maxZoomSpeed, Math.min(r.maxZoomSpeed, l.radius + t))) : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / e)), r.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
      }
      function D(e) {
        p.set(e.clientX, e.clientY);
      }
      function P(e) {
        m.set(e.clientX, e.clientY);
      }
      function B() {
        if (1 === y.length) p.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
            t = .5 * (y[0].pageY + y[1].pageY);
          p.set(e, t);
        }
      }
      function R() {
        if (1 === y.length) m.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
            t = .5 * (y[0].pageY + y[1].pageY);
          m.set(e, t);
        }
      }
      function L() {
        const e = y[0].pageX - y[1].pageX,
          t = y[0].pageY - y[1].pageY,
          r = Math.sqrt(e * e + t * t);
        v.set(0, r);
      }
      function O(e) {
        if (1 == y.length) d.set(e.pageX, e.pageY);else {
          const t = X(e),
            r = .5 * (e.pageX + t.x),
            n = .5 * (e.pageY + t.y);
          d.set(r, n);
        }
        f.subVectors(d, p).multiplyScalar(r.rotateSpeed);
        const t = r.domElement;
        E(2 * Math.PI * f.x / t.clientHeight), S(2 * Math.PI * f.y / t.clientHeight), p.copy(d);
      }
      function F(e) {
        if (1 === y.length) _.set(e.pageX, e.pageY);else {
          const t = X(e),
            r = .5 * (e.pageX + t.x),
            n = .5 * (e.pageY + t.y);
          _.set(r, n);
        }
        g.subVectors(_, m).multiplyScalar(r.panSpeed), T(g.x, g.y), m.copy(_);
      }
      function U(e) {
        const t = X(e),
          n = e.pageX - t.x,
          i = e.pageY - t.y,
          s = Math.sqrt(n * n + i * i);
        A.set(0, s), b.set(0, Math.pow(A.y / v.y, r.zoomSpeed)), I(b.y), v.copy(A);
      }
      function N(e) {
        !1 !== r.enabled && (0 === y.length && (r.domElement.setPointerCapture(e.pointerId), r.domElement.addEventListener("pointermove", j), r.domElement.addEventListener("pointerup", z)), function (e) {
          y.push(e);
        }(e), "touch" === e.pointerType ? function (e) {
          switch (q(e), y.length) {
            case 1:
              switch (r.touches.ONE) {
                case n.QmN.ROTATE:
                  if (!1 === r.enableRotate) return;
                  B(), s = i.TOUCH_ROTATE;
                  break;
                case n.QmN.PAN:
                  if (!1 === r.enablePan) return;
                  R(), s = i.TOUCH_PAN;
                  break;
                default:
                  s = i.NONE;
              }
              break;
            case 2:
              switch (r.touches.TWO) {
                case n.QmN.DOLLY_PAN:
                  if (!1 === r.enableZoom && !1 === r.enablePan) return;
                  r.enableZoom && L(), r.enablePan && R(), s = i.TOUCH_DOLLY_PAN;
                  break;
                case n.QmN.DOLLY_ROTATE:
                  if (!1 === r.enableZoom && !1 === r.enableRotate) return;
                  r.enableZoom && L(), r.enableRotate && B(), s = i.TOUCH_DOLLY_ROTATE;
                  break;
                default:
                  s = i.NONE;
              }
              break;
            default:
              s = i.NONE;
          }
          s !== i.NONE && r.dispatchEvent(ut);
        }(e) : function (e) {
          let t;
          switch (e.button) {
            case 0:
              t = r.mouseButtons.LEFT;
              break;
            case 1:
              t = r.mouseButtons.MIDDLE;
              break;
            case 2:
              t = r.mouseButtons.RIGHT;
              break;
            default:
              t = -1;
          }
          switch (t) {
            case n.RsA.DOLLY:
              if (!1 === r.enableZoom) return;
              !function (e) {
                v.set(e.clientX, e.clientY);
              }(e), s = i.DOLLY;
              break;
            case n.RsA.ROTATE:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === r.enablePan) return;
                P(e), s = i.PAN;
              } else {
                if (!1 === r.enableRotate) return;
                D(e), s = i.ROTATE;
              }
              break;
            case n.RsA.PAN:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === r.enableRotate) return;
                D(e), s = i.ROTATE;
              } else {
                if (!1 === r.enablePan) return;
                P(e), s = i.PAN;
              }
              break;
            default:
              s = i.NONE;
          }
          s !== i.NONE && r.dispatchEvent(ut);
        }(e));
      }
      function j(e) {
        !1 !== r.enabled && ("touch" === e.pointerType ? function (e) {
          switch (q(e), s) {
            case i.TOUCH_ROTATE:
              if (!1 === r.enableRotate) return;
              O(e), r.update();
              break;
            case i.TOUCH_PAN:
              if (!1 === r.enablePan) return;
              F(e), r.update();
              break;
            case i.TOUCH_DOLLY_PAN:
              if (!1 === r.enableZoom && !1 === r.enablePan) return;
              !function (e) {
                r.enableZoom && U(e), r.enablePan && F(e);
              }(e), r.update();
              break;
            case i.TOUCH_DOLLY_ROTATE:
              if (!1 === r.enableZoom && !1 === r.enableRotate) return;
              !function (e) {
                r.enableZoom && U(e), r.enableRotate && O(e);
              }(e), r.update();
              break;
            default:
              s = i.NONE;
          }
        }(e) : function (e) {
          switch (s) {
            case i.ROTATE:
              if (!1 === r.enableRotate) return;
              !function (e) {
                d.set(e.clientX, e.clientY), f.subVectors(d, p).multiplyScalar(r.rotateSpeed);
                const t = r.domElement;
                E(2 * Math.PI * f.x / t.clientHeight), S(2 * Math.PI * f.y / t.clientHeight), p.copy(d), r.update();
              }(e);
              break;
            case i.DOLLY:
              if (!1 === r.enableZoom) return;
              !function (e) {
                A.set(e.clientX, e.clientY), b.subVectors(A, v), b.y > 0 ? I(w()) : b.y < 0 && k(w()), v.copy(A), r.update();
              }(e);
              break;
            case i.PAN:
              if (!1 === r.enablePan) return;
              !function (e) {
                _.set(e.clientX, e.clientY), g.subVectors(_, m).multiplyScalar(r.panSpeed), T(g.x, g.y), m.copy(_), r.update();
              }(e);
          }
        }(e));
      }
      function z(e) {
        W(e), 0 === y.length && (r.domElement.releasePointerCapture(e.pointerId), r.domElement.removeEventListener("pointermove", j), r.domElement.removeEventListener("pointerup", z)), r.dispatchEvent(ht), s = i.NONE;
      }
      function G(e) {
        W(e);
      }
      function V(e) {
        !1 !== r.enabled && !1 !== r.enableZoom && s === i.NONE && (e.preventDefault(), r.dispatchEvent(ut), function (e) {
          let t = 0;
          switch (e.deltaMode) {
            case 2:
              t += 1 * e.deltaY;
              break;
            case 1:
              t += .4 * e.deltaY;
              break;
            default:
              t += .01 * e.deltaY;
          }
          e.deltaY < 0 ? k(1, t * r.zoomSpeed) : e.deltaY > 0 && I(1, -t * r.zoomSpeed), r.update();
        }(e), r.dispatchEvent(ht));
      }
      function Q(e) {
        !1 !== r.enabled && !1 !== r.enablePan && function (e) {
          let t = !1;
          switch (e.code) {
            case r.keys.UP:
              T(0, r.keyPanSpeed), t = !0;
              break;
            case r.keys.BOTTOM:
              T(0, -r.keyPanSpeed), t = !0;
              break;
            case r.keys.LEFT:
              T(r.keyPanSpeed, 0), t = !0;
              break;
            case r.keys.RIGHT:
              T(-r.keyPanSpeed, 0), t = !0;
          }
          t && (e.preventDefault(), r.update());
        }(e);
      }
      function H(e) {
        !1 !== r.enabled && e.preventDefault();
      }
      function W(e) {
        delete x[e.pointerId];
        for (let t = 0; t < y.length; t++) if (y[t].pointerId == e.pointerId) return void y.splice(t, 1);
      }
      function q(e) {
        let t = x[e.pointerId];
        void 0 === t && (t = new n.FM8(), x[e.pointerId] = t), t.set(e.pageX, e.pageY);
      }
      function X(e) {
        const t = e.pointerId === y[0].pointerId ? y[1] : y[0];
        return x[t.pointerId];
      }
      this.zoomIn = function (e) {
        I(1, e * r.zoomSpeed);
      }, this.zoomOut = function (e) {
        k(1, e * r.zoomSpeed);
      }, r.domElement.addEventListener("contextmenu", H), r.domElement.addEventListener("pointerdown", N), r.domElement.addEventListener("pointercancel", G), r.domElement.addEventListener("wheel", V, {
        passive: !1
      }), this.update();
    }
  }
  var dt = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let ft = class extends pt {
    constructor() {
      super(...arguments), this.type = "OrbitControls", this.enabled = !0, this.dollyZoom = !1, this.enableDamping = !0, this.dampingFactor = .08, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableZoom = !0, this.zoomSpeed = .15, this.maxZoomSpeed = .2, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.panSpeed = 1, this.autoPushTarget = !1, this.minDistance = .35, this.maxDistance = 1e3, this.minZoom = .01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.screenSpacePanning = !0, this.keyPanSpeed = 7;
    }
    zoomIn(e) {
      super.zoomIn(e);
    }
    zoomOut(e) {
      super.zoomOut(e);
    }
    dispatchEvent(e) {
      super.dispatchEvent(e);
    }
  };
  dt([Ce()], ft.prototype, "type", void 0), dt([Je()], ft.prototype, "enabled", void 0), dt([Je(), Ce()], ft.prototype, "dollyZoom", void 0), dt([Je(), Ce()], ft.prototype, "enableDamping", void 0), dt([nt(), Ce()], ft.prototype, "dampingFactor", void 0), dt([Je(), Ce()], ft.prototype, "autoRotate", void 0), dt([nt(), Ce()], ft.prototype, "autoRotateSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enableZoom", void 0), dt([nt(), Ce()], ft.prototype, "zoomSpeed", void 0), dt([nt(), Ce()], ft.prototype, "maxZoomSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enableRotate", void 0), dt([nt(), Ce()], ft.prototype, "rotateSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enablePan", void 0), dt([nt(), Ce()], ft.prototype, "panSpeed", void 0), dt([nt(), Ce()], ft.prototype, "autoPushTarget", void 0), dt([nt(), Ce()], ft.prototype, "minDistance", void 0), dt([nt(), Ce()], ft.prototype, "maxDistance", void 0), dt([nt(), Ce()], ft.prototype, "minZoom", void 0), dt([nt(), Ce()], ft.prototype, "maxZoom", void 0), dt([nt(), Ce()], ft.prototype, "minPolarAngle", void 0), dt([nt(), Ce()], ft.prototype, "maxPolarAngle", void 0), dt([nt(), Ce()], ft.prototype, "minAzimuthAngle", void 0), dt([nt(), Ce()], ft.prototype, "maxAzimuthAngle", void 0), dt([Ce()], ft.prototype, "screenSpacePanning", void 0), dt([Ce()], ft.prototype, "keyPanSpeed", void 0), ft = dt([lt("Orbit Controls")], ft);
  var mt = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class _t extends r {
    constructor(e, t, r) {
      super(), this._controlsMode = "", this._isActiveCamera = !1, this.userData = {}, this._cameraObjectUpdate = e => {
        this.setDirty(e);
      }, this._interactionsEnabled = !0, this.autoLookAtTarget = !0, this.near = .01, this.far = 50, this._options = {
        type: "PerspectiveCamera",
        aspect: "auto",
        focus: 10,
        fov: 25,
        zoom: 1,
        frustumSize: 1,
        top: 1,
        bottom: -1,
        left: -1,
        right: 1,
        controlsMode: "orbit",
        controlsEnabled: !0
      }, this._position = new n.Pa4(0, 0, 10), this._target = new n.Pa4(0, 0, 0), this._controlsCtors = new Map([["orbit", (e, t) => {
        const r = new ft(e, t.ownerDocument ? t : t.documentElement);
        return r.screenSpacePanning = !0, r;
      }]]), this._camUi = [{
        type: "vec3",
        label: "Position",
        property: [this, "position"],
        onChange: () => this.positionUpdated(!0)
      }, {
        type: "vec3",
        label: "Target",
        property: [this, "target"],
        onChange: () => this.targetUpdated(!0)
      }, {
        type: "slider",
        bounds: [1, 180],
        label: "Field Of View",
        hidden: () => !this._camera.modelObject.isPerspectiveCamera,
        property: [this._options, "fov"],
        onChange: () => {
          this.refreshCameraOptions();
        },
        limitedUi: !0
      }, {
        type: "slider",
        bounds: [.001, 20],
        label: "Zoom",
        property: [this._options, "zoom"],
        onChange: () => {
          this.refreshCameraOptions();
        }
      }, () => ({
        type: "dropdown",
        label: "Controls Mode",
        property: [this._options, "controlsMode"],
        children: ["", "orbit", "firstPerson", "pointerLock", ...this._controlsCtors.keys()].map(e => ({
          label: "" === e ? "none" : e,
          value: e
        })),
        onChange: () => {
          this.refreshCameraOptions();
        }
      })], this.uiConfig = {
        type: "folder",
        label: "Camera",
        limitedUi: !0,
        children: [...this._camUi, () => {
          var e;
          return null === (e = this._controls) || void 0 === e ? void 0 : e.uiConfig;
        }, () => {
          var e;
          return (null === (e = this._controls) || void 0 === e ? void 0 : e.zoomIn) ? {
            type: "button",
            label: "Zoom in",
            value: () => {
              var e;
              null === (e = this._controls) || void 0 === e || e.zoomIn(1);
            }
          } : {};
        }, () => {
          var e;
          return (null === (e = this._controls) || void 0 === e ? void 0 : e.zoomOut) ? {
            type: "button",
            label: "Zoom out",
            value: () => {
              var e;
              null === (e = this._controls) || void 0 === e || e.zoomOut(1);
            }
          } : {};
        }]
      }, this.assetType = "model", this.uuid = $(), this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != r ? r : document.body;
      const i = null != t ? t : this._options;
      this._camera = this._setCameraObject(null != e ? e : "OrthographicCamera" === i.type ? new n.iKG(-1, 1, 1, -1) : new n.cPb()), this._camera.modelObject.userData.iCamera = this;
      const s = e;
      e && (s.isPerspectiveCamera ? (i.fov = s.fov, i.focus = s.focus, i.aspect = s.aspect <= 0 || s.userData.autoAspect ? "auto" : s.aspect, i.zoom = s.zoom) : s.isOrthographicCamera && (i.left = s.left, i.right = s.right, i.top = s.top, i.bottom = s.bottom, i.zoom = s.zoom), i.near = s.near, i.far = s.far, this._position.copy(e.position), this.refreshTarget()), this.positionUpdated(!1), e || this.targetUpdated(!1), this.setCameraOptions(i);
    }
    get controls() {
      return this._controls;
    }
    getControls() {
      return this._controls;
    }
    get isActiveCamera() {
      return this._isActiveCamera;
    }
    get target() {
      return this._target;
    }
    set target(e) {
      const t = this._target.sub(e).length() > 1e-5;
      this._target.copy(e), t && this.targetUpdated();
    }
    get position() {
      return this._position;
    }
    set position(e) {
      const t = this._position.sub(e).length() > 1e-5;
      this._position.copy(e), t && this.positionUpdated();
    }
    get name() {
      return this._camera.name;
    }
    set name(e) {
      this._camera.name = e;
    }
    getCameraOptions() {
      return {
        ...this._options,
        position: this._position.toArray(),
        target: this._target.toArray()
      };
    }
    setCameraOptions(e, t = !0) {
      var r, n;
      const i = {
        ...e
      };
      (null === (r = i.position) || void 0 === r ? void 0 : r.isVector3) && (i.position = [i.position.x, i.position.y, i.position.z]), (null === (n = i.target) || void 0 === n ? void 0 : n.isVector3) && (i.target = [i.target.x, i.target.y, i.target.z]), Object.keys(i).forEach(e => "frustumSize" !== e && void 0 === i[e] && delete i[e]), Object.assign(this._options, i), this._refreshCameraOptions(!1), this.refreshCameraControls(!1), t && this.setDirty();
    }
    _refreshCameraOptions(e = !0) {
      let t = this._camera.modelObject;
      if (this._options.type !== t.type) {
        const e = "PerspectiveCamera" === this._options.type ? new n.cPb() : new n.iKG();
        e.name = this._camera.name, e.near = this._camera.modelObject.near, e.far = this._camera.modelObject.far, e.zoom = this._camera.modelObject.zoom, e.scale.copy(this._camera.modelObject.scale);
        const r = this._isActiveCamera;
        r && this.deactivateMain(), this._camera = this._setCameraObject(e), t = this._camera.modelObject, r && this.activateMain(), this._camera.modelObject.updateProjectionMatrix();
      }
      let r = this._options.aspect;
      if ("auto" === r && (r = this._container.clientWidth / this._container.clientHeight), this._options.position && (this.position.set(...this._options.position), delete this._options.position), this._options.target && (this.target.set(...this._options.target), delete this._options.target), this.positionTargetUpdated(!1), "PerspectiveCamera" === this._options.type && (t.fov = this._options.fov, t.focus = this._options.focus, t.aspect = r), "OrthographicCamera" === this._options.type) {
        const e = this._options.frustumSize;
        void 0 !== e ? (t.top = e / 2, t.bottom = -e / 2, t.left = r * e / 2, t.right = -r * e / 2) : (t.top = this._options.top, t.bottom = this._options.bottom, t.left = this._options.left, t.right = this._options.right);
      }
      t.zoom = this._options.zoom, this._nearFarChanged(), e && this.setDirty();
    }
    _setCameraObject(e) {
      return this._camera && this._camera.removeEventListener("objectUpdate", this._cameraObjectUpdate), this._camera = Le(e), this._camera.addEventListener("objectUpdate", this._cameraObjectUpdate), this._camera;
    }
    get interactionsEnabled() {
      return this._interactionsEnabled && this._isActiveCamera && this._options.controlsEnabled;
    }
    set interactionsEnabled(e) {
      this._interactionsEnabled !== e && (this._interactionsEnabled = e, this.refreshCameraControls(!0));
    }
    _nearFarChanged() {
      this._camera && (this._camera.modelObject.near = this.near, this._camera.modelObject.far = this.far, this._camera.modelObject.updateProjectionMatrix());
    }
    refreshAspect(e = !0) {
      "auto" === this._options.aspect && this._refreshCameraOptions(e);
    }
    refreshTarget() {
      var e;
      (null === (e = this._controls) || void 0 === e ? void 0 : e.enabled) && this._controls.target ? this._target.copy(this._controls.target) : this._target.set(0, 0, -1).applyQuaternion(this._camera.modelObject.getWorldQuaternion(new n._fP()));
    }
    setControlsCtor(e, t, r = !1) {
      r || !this._controlsCtors.has(e) ? this._controlsCtors.set(e, t) : console.error(e + " already exists.");
    }
    removeControlsCtor(e) {
      this._controlsCtors.delete(e);
    }
    _initCameraControls() {
      var e, t, r;
      const n = this._options.controlsMode;
      this._controls = null !== (t = null === (e = this._controlsCtors.get(n)) || void 0 === e ? void 0 : e(this._camera.modelObject, this._container)) && void 0 !== t ? t : void 0, this._controls || console.error("Unable to create controls with mode " + n + ". Are you missing a plugin?"), null === (r = this._controls) || void 0 === r || r.addEventListener("change", this.setDirty), this._controlsMode = this._controls ? n : "";
    }
    _disposeCameraControls() {
      var e, t;
      this._controlsMode, null === (e = this._controls) || void 0 === e || e.removeEventListener("change", this.setDirty), null === (t = this._controls) || void 0 === t || t.dispose(), this._controlsMode = "", this._controls = void 0;
    }
    refreshCameraControls(e = !0) {
      var t, r;
      if (this._options.controlsEnabled) {
        const e = this._options.controlsMode;
        this._controls ? this._controlsMode === e && this._camera.modelObject === this._controls.object || (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e;
      }
      if (this._controls) {
        const e = this.interactionsEnabled;
        this._controls.enabled = e, e && this._camera.modelObject.up.copy(n.Tme.DefaultUp);
      }
      e && this.setDirty(), null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t, "postFrame", !0);
    }
    setDirty(e) {
      this._position.copy(this._camera.modelObject.position), this._controls && this._controls.enabled && this._controls.target && this._target.copy(this._controls.target), void 0 !== this._camera.modelObject.fov && (this._options.fov = this._camera.modelObject.fov), void 0 !== this._camera.modelObject.focus && (this._options.focus = this._camera.modelObject.focus), void 0 !== this._camera.modelObject.zoom && (this._options.zoom = this._camera.modelObject.zoom), this.dispatchEvent({
        ...e,
        type: "update"
      }), this._camUi.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e, "postFrame", !1, 1);
      });
    }
    activateMain(e = !0) {
      var t, r;
      this._isActiveCamera || (this._isActiveCamera = !0, this._camera.modelObject.userData.__lastScale = this._camera.modelObject.scale.clone(), this._camera.modelObject.scale.divide(this._camera.modelObject.getWorldScale(new n.Pa4())), e && (this.refreshCameraControls(!0), this.refreshAspect()), null === (r = (t = this._camera).setDirty) || void 0 === r || r.call(t, {
        change: "activateMain"
      }));
    }
    deactivateMain(e = !0) {
      this._isActiveCamera && (this._isActiveCamera = !1, this._camera.modelObject.userData.__lastScale && (this._camera.modelObject.scale.copy(this._camera.modelObject.userData.__lastScale), delete this._camera.modelObject.userData.__lastScale), e && this.refreshCameraControls(!0));
    }
    get cameraObject() {
      return this._camera.modelObject;
    }
    get modelObject() {
      return this._camera.modelObject;
    }
    dispose() {
      this._disposeCameraControls();
    }
    targetUpdated(e = !0) {
      var t, r;
      const n = this.target;
      null === (r = null === (t = this._controls) || void 0 === t ? void 0 : t.target) || void 0 === r || r.set(n.x, n.y, n.z), this._controls && this._controls.enabled && this._controls.target ? e && this.setDirty() : this._camera && (this.autoLookAtTarget && this._camera.modelObject.lookAt(n), e && this.setDirty());
    }
    positionUpdated(e = !0) {
      const t = this.position;
      this._camera.modelObject.position.set(t.x, t.y, t.z), e && this.setDirty();
    }
    positionTargetUpdated(e = !0) {
      this.positionUpdated(!1), this.targetUpdated(e);
    }
    copyFromCamera(e, t = 4) {
      e.getWorldPosition(this._position), e.getWorldDirection(this._target).multiplyScalar(t).add(this._position), this.positionTargetUpdated(!1), this.setCameraOptions({
        fov: e.fov,
        focus: e.focus,
        zoom: e.zoom,
        type: e.type
      }, !0);
    }
    updateShaderProperties(e) {
      var t;
      return (null === (t = e.uniforms.cameraPositionWorld) || void 0 === t ? void 0 : t.value) && this._camera.modelObject.getWorldPosition(e.uniforms.cameraPositionWorld.value), e.uniforms.cameraNearFar ? e.uniforms.cameraNearFar.value.set(this._camera.modelObject.near, this._camera.modelObject.far) : console.warn("BaseRenderer: no uniform: cameraNearFar"), e.uniforms.projection && (e.uniforms.projection.value = this._camera.modelObject.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.modelObject.type ? "1" : "0", e.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.modelObject.type ? "1" : "0", this;
    }
    toJSON(e) {
      return Object.assign({}, ke(this, !0, e));
    }
    fromJSON(e, t) {
      return De(e, this, !0, t), this.positionTargetUpdated(!1), this.refreshCameraOptions(), this.setDirty(), this;
    }
    refreshCameraOptions(e = !0) {
      this.setCameraOptions(this._options, e);
    }
    get visible() {
      return !0;
    }
    set visible(e) {
      console.error("Cannot set visible on camera", e);
    }
  }
  mt([Ce("camControls")], _t.prototype, "_controls", void 0), mt([Ce()], _t.prototype, "userData", void 0), mt([M(_t.prototype._nearFarChanged)], _t.prototype, "near", void 0), mt([M(_t.prototype._nearFarChanged)], _t.prototype, "far", void 0), mt([Ce("camOptions")], _t.prototype, "_options", void 0), mt([Ce("position")], _t.prototype, "_position", void 0), mt([Ce("target")], _t.prototype, "_target", void 0);
  var gt = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class vt extends n.xsS {
    constructor(e) {
      super(), this.isRootScene = !0, this.assetType = "model", this._sceneBounds = new k(), this._sceneBoundingRadius = 0, this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this._dummyCam = new _t(new n.cPb(), {
        controlsMode: "",
        controlsEnabled: !1
      }), this.environment = null, this.background = null, this.minNearDistance = .2, this.setDirty = this.setDirty.bind(this), this.updateScene = this.updateScene.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e, this.modelRoot = Le(new n.ZAu(), void 0), this.modelRoot.userData.rootSceneModelRoot = !0, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, {
        addToRoot: !0,
        autoScale: !1
      }), this.addSceneObject(this.defaultCamera, {
        addToRoot: !0
      }), this.activeCamera = this.defaultCamera, this.boxHelper = new n.GQ(this.getBounds());
    }
    refreshEnvMapIntensity(e) {
      return (null == e ? void 0 : e.isObject3D) || (e = this), (null != e ? e : this).traverse(e => {
        (Array.isArray(e.material) ? e.material : [e.material]).forEach(e => {
          e && void 0 !== e.envMapIntensity && !e.userData.separateEnvMapIntensity && (e.envMapIntensity = this.envMapIntensity, e.needsUpdate = !0);
        });
      }), this.setDirty(), this;
    }
    get activeCamera() {
      return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam;
    }
    set activeCamera(e) {
      const t = this.activeCamera;
      if (e || (e = this.defaultCamera), t !== e) {
        if (t && (t.deactivateMain(), t.removeEventListener("update", this._activeCameraUpdate)), e) {
          e.activateMain(), e.addEventListener("update", this._activeCameraUpdate);
          let t = this._cameras.indexOf(e);
          t < 0 && (this._cameras.push(e), t = this._cameras.length - 1), this._activeCamera = t;
        } else this._activeCamera = -1;
        this.dispatchEvent({
          type: "activeCameraChange",
          lastCamera: t,
          camera: e
        }), this.setDirty();
      }
    }
    get modelObject() {
      return this;
    }
    addModel(e, t = {}) {
      return "model" !== e.assetType && console.error("Invalid asset type for ", e, ", adding anyway"), this.addSceneObject(e, t);
    }
    addWidget(e, t = {}) {
      "widget" !== e.assetType && console.warn("Invalid asset type for ", e, ", adding anyway"), this.add(e.modelObject);
    }
    _addModel(e, t = {}) {
      return this._addObject3D(null == e ? void 0 : e.modelObject, t);
    }
    addSceneObject(e, t) {
      if (!e) return e;
      const r = e.assetType;
      let n = !1;
      switch (r) {
        case "model":
          n = e.modelObject.isCamera, n && (t = {
            ...t,
            autoScale: !1
          }), this._addModel(e, t);
          break;
        case "material":
          break;
        case "texture":
          this.dispatchEvent({
            type: "textureAdded",
            texture: e
          });
          break;
        case "light":
          this._addLight(e, t);
          break;
        default:
          console.warn("Unknown asset imported", e, r);
      }
      return this.dispatchEvent({
        type: "addSceneObject",
        object: e
      }), e;
    }
    _addObject3D(e, {
      autoScale: t = !0,
      autoScaleRadius: r = 2,
      addToRoot: n = !1
    } = {}) {
      const i = e;
      i ? (t && !i.userData.autoScaled && X(i, i.userData.autoScaleRadius || r), i.traverse(e => {
        e.isMesh && !e.userData.__keepShadowDef && (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0);
      }), this.refreshEnvMapIntensity(i), n ? this.modelObject.add(i) : this.modelRoot.add(i), this.setDirty()) : console.error("Invalid Model, cannot add.");
    }
    removeSceneModels() {
      this.modelRoot.clear(), this.modelRoot.children = [], this.setDirty({
        sceneUpdate: !0
      });
    }
    disposeSceneModels() {
      this.modelRoot.children.forEach(e => {
        var t, r;
        (null !== (t = e.dispose) && void 0 !== t ? t : null === (r = e.modelObject) || void 0 === r ? void 0 : r.removeFromParent)();
      }), this.setDirty({
        sceneUpdate: !0
      });
    }
    _onEnvironmentChange() {
      this.dispatchEvent({
        type: "environmentChanged",
        environment: this.getEnvironment()
      }), this._onSceneUpdate();
    }
    add(...e) {
      return super.add(...e.map(e => Le(e))), this._onSceneUpdate(), this;
    }
    setEnvironment(e) {
      if (!e) return this.environment = null, this.dispatchEvent({
        type: "environmentChanged"
      }), void this._onSceneUpdate();
      if ("texture" !== (null == e ? void 0 : e.assetType)) return void console.error("Unknown Environment type", e);
      e.mapping === n.xfE && (e.mapping = n.dSO, e.needsUpdate = !0);
      const t = e.textureObject || e;
      this.environment = t, this._onEnvironmentChange();
    }
    getEnvironment() {
      return this.environment;
    }
    setBackground(e) {
      var t;
      let r;
      if (!e || "texture" === e.assetType || e.isColor || e.isVector4) r = "texture" === (null === (t = e) || void 0 === t ? void 0 : t.assetType) && e.textureObject || e;else {
        if ("string" != typeof e && "number" != typeof e) return void console.error("Unknown Background type", e);
        r = new n.Ilk(e);
      }
      this.background = r, this._onSceneUpdate({
        geometryChanged: !1
      });
    }
    getBackground() {
      return this.background;
    }
    setDirty(e) {
      return (null == e ? void 0 : e.sceneUpdate) ? this._onSceneUpdate(e) : this.dispatchEvent({
        type: "update"
      }), this;
    }
    updateScene(e) {
      return this._onSceneUpdate(e);
    }
    _activeCameraUpdate() {
      this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({
        type: "activeCameraUpdate"
      });
    }
    _onSceneUpdate(e = {}) {
      var t, r, i;
      return !1 === e.sceneUpdate ? this.setDirty(e) : (this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(!1, !0), null === (i = null === (r = null === (t = this.boxHelper) || void 0 === t ? void 0 : t.box) || void 0 === r ? void 0 : r.copy) || void 0 === i || i.call(r, this._sceneBounds), this._sceneBoundingRadius = this._sceneBounds.getSize(new n.Pa4()).length() / 2, this.dispatchEvent({
        ...e,
        type: "sceneUpdate",
        hierarchyChanged: ["addedToParent", "removedFromParent"].includes(e.change || "")
      }), this);
    }
    _onSceneMaterialUpdate() {
      this.dispatchEvent({
        type: "sceneMaterialUpdate"
      });
    }
    dispose() {
      this.clear();
    }
    findObjectsByName(e, t) {
      const r = [];
      return (null != t ? t : this.modelObject).traverse(t => {
        t.name === e && r.push(t);
      }), r;
    }
    addLight(e, t = {}) {
      this.addSceneObject(e, t);
    }
    _addLight(e, {
      addToRoot: t = !1
    } = {}) {
      var r;
      const n = e.lightObject;
      n && (null === (r = n.children) || void 0 === r || r.length, t ? this.add(n) : this.modelRoot.add(n));
    }
    getBounds(e = !1, t = !0) {
      return new k().expandByObject(this.modelObject, e, t);
    }
    refreshActiveCameraNearFar() {
      const e = this.activeCamera;
      if (!e) return;
      const t = this.getBounds(!1),
        r = e.cameraObject.getWorldPosition(new n.Pa4()).sub(t.getCenter(new n.Pa4())),
        i = 1.5 * t.getSize(new n.Pa4()).length() / 2,
        s = r.length(),
        o = Math.max(this.minNearDistance, s - i),
        a = Math.max(o + 1, s + i);
      e.near = o, e.far = a;
    }
    updateShaderProperties(e) {
      return e.uniforms.sceneBoundingRadius ? e.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }
    toJSON(e) {
      return ke(this, !0, e);
    }
    fromJSON(e, t) {
      const r = e.environment;
      return void 0 !== r && (this.setEnvironment(De(r, this.getEnvironment(), !1, t)), delete e.environment), De(e, this, !0, t), e.environment = r, this;
    }
    addEventListener(e, t) {
      super.addEventListener(e, t);
    }
    removeEventListener(e, t) {
      super.removeEventListener(e, t);
    }
  }
  function At() {
    const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return e.style.display = "block", e;
  }
  function bt(e, t) {
    const r = t || "/";
    return new RegExp(r + "{1,}", "g"), e.join(r);
  }
  function yt(e, t) {
    const r = window.URL.createObjectURL(e),
      n = document.createElement("a");
    n.style.display = "none", n.href = r, n.download = t, document.body.appendChild(n), n.click(), setTimeout(() => {
      document.body.removeChild(n), window.URL.revokeObjectURL(r);
    }, 1e3);
  }
  async function xt(e) {
    return new Promise((t, r) => {
      const n = new FileReader();
      n.onload = e => t(n.result), n.onerror = e => r(n.error), n.onabort = e => r(new Error("Read aborted")), n.readAsDataURL(e);
    });
  }
  function wt(e, t) {
    return yt(e, null != t ? t : e.name);
  }
  async function Et(e = !1, t = !1, r) {
    const n = document.createElement("input");
    n.type = "file", n.multiple = e, n.accept = r || "*", n.webkitdirectory = t, n.style.display = "none", document.body.appendChild(n), n.click();
    const i = await new Promise(e => {
      n.onchange = t => {
        e(Array.from(n.files || []));
      };
    });
    return document.body.removeChild(n), i;
  }
  function St({
    innerHTML: e = "",
    id: t,
    classList: r,
    addToBody: n = !0,
    elementTag: i = "div"
  }) {
    const s = document.createElement(i);
    return t && (s.id = t), s.innerHTML = e, r && s.classList.add(...r), n && document.body.appendChild(s), s;
  }
  async function Ct(e) {
    return new Promise((t, r) => {
      const n = new Image();
      n.onload = () => t(n), n.onerror = r, n.crossOrigin = "anonymous", n.decoding = "sync", n.src = e;
    });
  }
  function Mt(e) {
    const t = document.createElement("style");
    return t.type = "text/css", t.innerText = e, document.head.appendChild(t), t;
  }
  async function Tt(e) {
    return new Promise((t, r) => {
      const n = document.createElement("script");
      n.setAttribute("src", e), n.addEventListener("load", t), n.addEventListener("error", r), document.body.appendChild(n);
    });
  }
  function It(e, t = 8192, r = !1) {
    var n;
    if (!e.width || !e.height) return "";
    const i = document.createElement("canvas");
    i.width = Math.min(t, e.width), i.height = Math.floor(1 + i.width * e.height / e.width);
    const s = e instanceof ImageBitmap,
      o = s && r && Math.abs(i.width - e.width) < .5 ? i.getContext("bitmaprenderer") : void 0;
    o ? o.transferFromImageBitmap(e) : null === (n = i.getContext("2d")) || void 0 === n || n.drawImage(e, 0, 0, i.width, i.height);
    const a = i.toDataURL("image/png");
    return i.remove(), s && r && e.close(), a;
  }
  async function kt(e) {
    return new Promise((t, r) => {
      const n = new Image();
      n.addEventListener("load", () => {
        const e = document.createElement("canvas");
        e.width = n.width, e.height = n.height;
        const i = e.getContext("2d");
        if (!i) return void r(new Error("Could not get 2d context"));
        i.drawImage(n, 0, 0, e.width, e.height);
        const s = i.getImageData(0, 0, e.width, e.height);
        t(s), e.remove(), n.remove();
      }, !1), n.addEventListener("error", e => {
        n.remove(), r(e);
      }, !1), n.src = e;
    });
  }
  function Dt() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  function Pt() {
    let e = !1;
    return t = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e;
    var t;
  }
  function Bt(e, t = null) {
    var r;
    return null !== (r = new URL(window.location.href).searchParams.get(e)) && void 0 !== r ? r : t;
  }
  function Rt(e, t, r = !1) {
    const n = new URLSearchParams(location.search);
    null == t ? n.has(e) && n.delete(e) : n.set(e, t), r ? window.location.search = n.toString() : window.history.replaceState({}, "", "?" + n.toString());
  }
  function Lt(e) {
    return e.replace(/\w\S*/g, function (e) {
      return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
    });
  }
  function Ot(e, {
    backgroundColor: t = "",
    displayPixelRatio: r = 1,
    width: n = 512,
    height: i = 512
  }) {
    const s = document.createElement("canvas"),
      o = s.getContext("2d"),
      a = r,
      l = n,
      c = i;
    return s.width = l * a, s.height = c * a, s.style.width = `${l}`, s.style.height = `${c}`, (null == t ? void 0 : t.length) > 0 && (o.fillStyle = t, o.fillRect(0, 0, s.width, s.height)), o.drawImage(e, 0, 0, s.width, s.height), s;
  }
  gt([Ce()], vt.prototype, "defaultCamera", void 0), gt([M(vt.prototype.refreshEnvMapIntensity), Ce()], vt.prototype, "envMapIntensity", void 0), gt([Ce()], vt.prototype, "environment", void 0), ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function (e, t) {
    const r = new Uint8Array(this);
    null == t && (t = r.length);
    const n = new ArrayBuffer(t - e),
      i = new Uint8Array(n);
    for (let t = 0; t < i.length; t++) i[t] = r[t + e];
    return n;
  });
  class Ft {
    static ApplyMaterialExtensions(e, t, r, n) {
      for (const i of r) this.ApplyMaterialExtension(e, t, i, n);
    }
    static ApplyMaterialExtension(e, t, r, n) {
      var i, s;
      let o = null !== (i = A(r.parsFragmentSnippet, n, e)) && void 0 !== i ? i : "";
      o.length && (t.fragmentShader = t.fragmentShader.replace(this.FragVoidMain, `\n${o}\n${this.FragVoidMain}`)), o = null !== (s = A(r.parsVertexSnippet, n, e)) && void 0 !== s ? s : "", o.length && (t.vertexShader = t.vertexShader.replace(this.VertVoidMain, `\n${o}\n${this.VertVoidMain}`)), r.extraUniforms && (t.uniforms = Object.assign(t.uniforms, r.extraUniforms)), r.shaderExtender && r.shaderExtender(t, e, n), e.lastShader = t;
    }
    static CacheKeyForExtensions(e, t) {
      let r = "";
      for (const n of t) r += this.CacheKeyForExtension(e, n);
      return r;
    }
    static CacheKeyForExtension(e, t) {
      let r = "";
      return t.customCacheKey && (r += t.customCacheKey), t.computeCacheKey && (r += t.computeCacheKey(e)), r;
    }
    static RegisterExtensions(e, t) {
      const r = [];
      if (t) for (const n of t) n.isCompatible && n.isCompatible(e) && (r.push(n), n.uuid || (n.uuid = Xe()), n.setDirty || (n.setDirty = () => {
        n.updateVersion || (n.updateVersion = 0), n.updateVersion++;
      }));
      return e.materialExtensions = r, e.__ext_beforeRenderListen || (e.__ext_beforeRenderListen = !0, e.addEventListener("beforeRender", t => function (e, {
        object: t,
        renderer: r
      }) {
        var n;
        null === (n = e.materialExtensions) || void 0 === n || n.forEach(n => {
          var i, s;
          null === (i = n.onObjectRender) || void 0 === i || i.call(n, t, e, r), e.lastShader && (null === (s = A(n.updaters)) || void 0 === s || s.forEach(t => null == t ? void 0 : t.updateShaderProperties(e.lastShader))), n.updateVersion !== e.materialObject.userData["_" + n.uuid + "_version"] && (e.materialObject.userData["_" + n.uuid + "_version"] = n.updateVersion, e.materialObject.needsUpdate = !0);
        });
      }(e, t))), e.__ext_afterRenderListen || (e.__ext_afterRenderListen = !0, e.addEventListener("afterRender", t => function (e, {
        object: t,
        renderer: r
      }) {
        var n;
        null === (n = e.materialExtensions) || void 0 === n || n.forEach(n => {
          var i;
          null === (i = n.onAfterRender) || void 0 === i || i.call(n, t, e, r);
        });
      }(e, t))), r;
    }
  }
  Ft.FragVoidMain = "void main() {", Ft.VertVoidMain = "void main() {";
  class Ut extends n.jyz {
    constructor(e) {
      var t;
      super(e), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : []);
    }
    registerMaterialExtensions(e) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e)];
    }
    unregisterMaterialExtensions(e) {}
    onBeforeCompile(e, t) {
      Ft.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), this.dispatchEvent({
        type: "beforeCompile",
        shader: e,
        renderer: t
      }), super.onBeforeCompile(e, t);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e, t, r, n, i) {
      super.onBeforeRender(e, t, r, n, i), this.dispatchEvent({
        type: "beforeRender",
        renderer: e,
        scene: t,
        camera: r,
        geometry: n,
        object: i
      });
    }
    onAfterRender(e, t, r, n, i) {
      super.onAfterRender(e, t, r, n, i), this.dispatchEvent({
        type: "afterRender",
        renderer: e,
        scene: t,
        camera: r,
        geometry: n,
        object: i
      });
    }
    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e) {}
  }
  class Nt extends Ut {
    constructor(e, t) {
      super(e), this.typeSlug = "shaderMat", this.textures = [], this.setTextureIds(t);
    }
    setTextureIds(e) {
      this.textures.map(e => e.id).join(";") !== e.join(";") && (this.textures = e.map(e => ({
        id: e,
        encoding: n.rnI
      })), this.setDirty());
    }
    _setUniformTexSize(e, t) {
      var r, n, i, s;
      if (!t || !e) return;
      const o = null !== (n = null === (r = t.image) || void 0 === r ? void 0 : r.width) && void 0 !== n ? n : 512,
        a = null !== (s = null === (i = t.image) || void 0 === i ? void 0 : i.height) && void 0 !== s ? s : 512,
        l = e.value;
      l.isVector2 || console.warn("uniform is not a Vector2"), l && Math.abs(l.x - o) + Math.abs(l.y - a) > .1 && (l.x = o, l.y = a, this.uniformsNeedUpdate = !0);
    }
    onBeforeRender(e, t, r, n, i) {
      var s, o;
      this._setUniformTexSize(this.uniforms.screenSize, null === (s = e.getRenderTarget()) || void 0 === s ? void 0 : s.texture);
      for (const e of this.textures) {
        const t = e.id,
          r = null === (o = this.uniforms[t]) || void 0 === o ? void 0 : o.value;
        r && (this._setUniformTexSize(this.uniforms[t + "Size"], r), r.encoding !== e.encoding && (e.encoding = r.encoding, this.needsUpdate = !0));
      }
      super.onBeforeRender(e, t, r, n, i);
    }
    onBeforeCompile(e, t) {
      e.fragmentShader = this.textures.map(e => {
        var t, r;
        return `uniform sampler2D ${e.id}; \n` + N(null !== (t = e.id) && void 0 !== t ? t : "input", null !== (r = e.encoding) && void 0 !== r ? r : n.rnI);
      }).join("\n") + e.fragmentShader, super.onBeforeCompile(e, t);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + this.textures.map(e => e.id + e.encoding).join(";");
    }
    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e) {
      this.needsUpdate = !0, this.dispatchEvent({
        ...e,
        type: "materialUpdate"
      });
    }
  }
  function jt(e, ...t) {
    const r = e.fragmentShader;
    return new Nt({
      defines: Object.assign({}, e.defines),
      uniforms: e.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: r
    }, t);
  }
  class zt extends c {
    constructor(e, ...t) {
      super(e.isMaterial ? e : jt(e, ...t), t.length < 1 ? zt.DEFAULT_TEX_ID : t[0]), this.onDirty = [], this.isShaderPass2 = !0, this.enabled = !0, this.setDirty = this.setDirty.bind(this);
    }
    dispose() {
      var e, t, r, n;
      null === (t = null === (e = this.material) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e), null === (n = null === (r = this.fsQuad) || void 0 === r ? void 0 : r.dispose) || void 0 === n || n.call(r), this.onDirty = [];
    }
    setDirty() {
      this.onDirty.forEach(e => e());
    }
    updateShaderProperties(e) {
      e && (Array.isArray(e) || (e = [e]), e.forEach(e => null == e ? void 0 : e.updateShaderProperties(this.material)));
    }
    render(e, t, r, n, i) {
      this.enabled && super.render(e, t, r, n, i);
    }
  }
  zt.DEFAULT_TEX_ID = "tDiffuse", function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Je("Enabled"), Ce()], zt.prototype, "enabled", void 0);
  class Gt extends s {
    constructor(e, t, r, i, s) {
      super(), this.scene = e, this.camera = t, this.overrideMaterial = r, this.clearColor = i, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new n.Ilk();
    }
    render(e, t, r, n, i, s) {
      const o = e.autoClear;
      let a, l;
      if (e.autoClear = !1, void 0 !== this.overrideMaterial && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : r), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, s);
      }
      if (this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, null);
      }
      this.clearColor && e.setClearColor(this._oldClearColor, a), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l), e.autoClear = o;
    }
  }
  class Vt extends zt {
    constructor(e, t = "c = a + b;", r = "", n) {
      super({
        vertexShader: i.vertexShader,
        fragmentShader: w`
                varying vec2 vUv;
                
                ${r}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${t}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: n
          },
          ...e
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }
  }
  class Qt extends n.jyz {
    constructor(e = !0) {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nout vec3 vViewPosition;void main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}",
        fragmentShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#include <packing>\nuniform float alphaTest;\n#endif\n#ifndef gl_FragColor \nlayout(location=0)out vec4 A;layout(location=1)out vec4 B;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <alphamap_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;in vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){\n#ifdef USE_ALPHAMAP\n#ifdef ALPHA_I_RGBA_PACKING\nif(1.-unpackRGBAToDepth(texture2D(alphaMap,vUv))<alphaTest)\n#else\nif(texture2D(alphaMap,vUv).g<alphaTest)\n#endif\ndiscard;\n#endif\n#include <normal_fragment_begin>\n#ifdef FORCED_LINEAR_DEPTH\nfloat linearZ=float(FORCED_LINEAR_DEPTH);\n#else\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);\n#endif\nvec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#ifndef gl_FragColor \nA=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);B=flags;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}",
        uniforms: {
          cameraNearFar: {
            value: new n.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          flags: {
            value: new n.Ltg(1, 1, 1, 1)
          }
        },
        glslVersion: e ? n.LSk : n.v9Y
      });
    }
    onBeforeRender(e, t, r, i, s) {
      var o, a, l;
      let c = s.material;
      Array.isArray(c) && (c = c[0]), this.uniforms.alphaMap.value = null !== (o = null == c ? void 0 : c.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !c || !c.alphaTest || c.alphaTest < 1e-7 ? .001 : c.alphaTest, this.uniforms.flags.value.x = !1 === (null == c ? void 0 : c.userData.postTonemap) ? 0 : 1, this.uniforms.flags.value.y = (null == c ? void 0 : c.userData._ssBevel) ? (null == c ? void 0 : c.userData._ssBevel.radius) / 255 : 0, this.uniforms.flags.value.z = ((null == c ? void 0 : c.userData.matId) ? null == c ? void 0 : c.userData.matId : 0) / 255, this.uniforms.flags.value.w = (null == c ? void 0 : c.userData.enableLUT) ? null == c ? void 0 : c.userData.enableLUT : 0, this.uniformsNeedUpdate = !0;
      let u = this.uniforms.alphaMap.value ? 1 : void 0;
      u !== this.defines.USE_ALPHAMAP && (void 0 === u ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = u, this.needsUpdate = !0), u = c.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === u ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = u, this.needsUpdate = !0), u = null !== (a = c.userData.forcedLinearDepth) && void 0 !== a ? a : void 0, u !== this.defines.FORCED_LINEAR_DEPTH && (void 0 === u ? delete this.defines.FORCED_LINEAR_DEPTH : this.defines.FORCED_LINEAR_DEPTH = u, this.needsUpdate = !0), this.side = null !== (l = c.side) && void 0 !== l ? l : n.ehD;
    }
  }
  var Ht = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET \nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nvec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn texture2D(tGBufferFlags,uv);\n#else\nreturn vec4(1.);\n#endif\n}\n#endif\n";
  const Wt = {
    name: "",
    fog: !0,
    blending: n.bdR,
    side: n.Wl3,
    vertexColors: !1,
    opacity: 1,
    transparent: !1,
    blendSrc: n.k74,
    blendDst: n.LgZ,
    blendEquation: n.bGH,
    blendSrcAlpha: null,
    blendDstAlpha: null,
    blendEquationAlpha: null,
    depthFunc: n.vCF,
    depthTest: !0,
    depthWrite: !0,
    stencilWriteMask: 255,
    stencilFunc: n.cum,
    stencilRef: 0,
    stencilFuncMask: 255,
    stencilFail: n.x5V,
    stencilZFail: n.x5V,
    stencilZPass: n.x5V,
    stencilWrite: !1,
    clippingPlanes: null,
    clipIntersection: !1,
    clipShadows: !1,
    shadowSide: null,
    colorWrite: !0,
    precision: null,
    polygonOffset: !1,
    polygonOffsetFactor: 0,
    polygonOffsetUnits: 0,
    dithering: !1,
    alphaTest: 0,
    alphaToCoverage: !1,
    premultipliedAlpha: !1,
    visible: !0,
    toneMapped: !0,
    userData: {},
    wireframeLinecap: "round",
    wireframeLinejoin: "round"
  };
  function qt(e, t, r, {
    replaceAll: n = !1,
    prepend: i = !1,
    append: s = !1
  } = {}) {
    if (!e.includes(t)) return console.error(`${t} not found in shader`), e;
    let o = r;
    return i ? o = r + t : s && (o = t + r), n ? e.replaceAll(t, o) : e.replace(t, o);
  }
  const Xt = {
      ...Wt,
      color: "#000000",
      roughness: 0,
      metalness: 0,
      map: null,
      lightMap: null,
      lightMapIntensity: 0,
      aoMap: null,
      aoMapIntensity: 0,
      emissive: "#000000",
      emissiveIntensity: 0,
      emissiveMap: null,
      bumpMap: null,
      bumpScale: 0,
      normalMap: null,
      normalMapType: n.IOt,
      normalScale: new n.FM8(1, 1),
      displacementMap: null,
      displacementScale: 0,
      displacementBias: 0,
      roughnessMap: null,
      metalnessMap: null,
      alphaMap: null,
      envMap: null,
      envMapIntensity: 0,
      refractionRatio: 0,
      wireframe: !1,
      wireframeLinewidth: 0,
      skinning: !1,
      morphTargets: !1,
      morphNormals: !1,
      flatShading: !1,
      glossiness: 0,
      glossinessMap: null,
      specularColor: new Ae(0),
      specularColorMap: null
    },
    Yt = {
      ...Xt,
      clearcoat: 0,
      clearcoatMap: null,
      clearcoatRoughness: 0,
      clearcoatRoughnessMap: null,
      clearcoatNormalScale: new n.FM8(1, 1),
      clearcoatNormalMap: null,
      reflectivity: .5,
      sheen: 0,
      sheenColor: new Ae(0),
      sheenColorMap: null,
      sheenRoughness: 1,
      sheenRoughnessMap: null,
      specularIntensity: 1,
      specularIntensityMap: null,
      specularColor: new Ae(1, 1, 1),
      specularColorMap: null,
      transmission: 0,
      transmissionMap: null,
      thickness: 0,
      thicknessMap: null,
      attenuationDistance: 0,
      attenuationColor: new Ae(1, 1, 1),
      iridescenceMap: null,
      iridescenceIOR: 1.3,
      iridescenceThicknessRange: [100, 400],
      iridescenceThicknessMap: null
    };
  class Kt extends n.EJi {
    constructor(e) {
      var t;
      super(e), this.typeSlug = Kt.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshStandardMaterial2 = !0, this.extraUniformsToUpload = {}, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = e => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e);
      }, this.fog = !1, this.userData.enableLUT = !0, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : []);
    }
    setDirty(e) {
      var t, r;
      this.needsUpdate = !0, this.dispatchEvent({
        ...e,
        type: "materialUpdate"
      }), null === (r = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0, 1);
    }
    registerMaterialExtensions(e) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e)];
    }
    unregisterMaterialExtensions(e) {}
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, {
        type: "color",
        property: [this, "color"],
        limitedUi: !0
      }, {
        type: "image",
        property: [this, "map"]
      }, be(this, "map"), {
        type: "folder",
        label: "Rough/Metal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "roughness"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "metalness"],
          limitedUi: !0
        }, {
          type: "image",
          property: [this, "roughnessMap"]
        }, be(this, "roughnessMap"), {
          type: "image",
          property: [this, "metalnessMap"]
        }, be(this, "metalnessMap")]
      }, {
        type: "folder",
        label: "Bump/Normal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, .2],
          stepSize: .001,
          property: [this, "bumpScale"],
          hidden: () => !this.bumpMap
        }, {
          type: "image",
          property: [this, "bumpMap"]
        }, be(this, "bumpMap"), {
          type: "image",
          property: [this, "normalMap"]
        }, {
          type: "vec2",
          property: [this, "normalScale"],
          hidden: () => !this.normalMap
        }, {
          type: "dropdown",
          hidden: () => !this.normalMap,
          property: [this, "normalMapType"],
          children: [["TangentSpace", n.IOt], ["ObjectSpace", n.PA7]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, be(this, "normalMap"), {
          type: "input",
          property: [this, "displacementScale"],
          hidden: () => !this.displacementMap
        }, {
          type: "image",
          property: [this, "displacementMap"]
        }, be(this, "displacementMap")]
      }, {
        type: "folder",
        label: "Sheen",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheen"]
        }, {
          type: "color",
          hidden: () => this.sheen < .001,
          property: [this, "sheenColor"]
        }, {
          type: "image",
          property: [this, "sheenColorMap"]
        }, be(this, "sheenColorMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheenRoughness"]
        }, {
          type: "image",
          property: [this, "sheenRoughnessMap"]
        }, be(this, "sheenRoughnessMap")]
      }, {
        type: "folder",
        label: "Clearcoat",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoat"]
        }, {
          type: "slider",
          bounds: [0, 1],
          hidden: () => this.clearcoat < .001,
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatMap"]
        }, be(this, "clearcoatMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatRoughnessMap"]
        }, be(this, "clearcoatRoughnessMap"), {
          type: "image",
          property: [this, "clearcoatNormalMap"]
        }, {
          type: "vec2",
          property: [this, "clearcoatNormalScale"],
          hidden: () => !this.clearcoatNormalMap
        }, be(this, "clearcoatNormalMap")]
      }, {
        type: "folder",
        label: "Emission",
        children: [{
          type: "color",
          property: [this, "emissive"]
        }, {
          type: "slider",
          bounds: [0, 10],
          property: [this, "emissiveIntensity"]
        }, {
          type: "image",
          property: [this, "emissiveMap"]
        }, be(this, "emissiveMap")]
      }, {
        type: "folder",
        label: "Refraction",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "reflectivity"]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "transmission"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          stepSize: .001,
          property: [this, "thickness"]
        }, {
          type: "image",
          property: [this, "transmissionMap"]
        }, be(this, "transmissionMap"), {
          type: "image",
          property: [this, "thicknessMap"]
        }, be(this, "thicknessMap")]
      }, {
        type: "folder",
        label: "Blending",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "opacity"]
        }, {
          type: "checkbox",
          property: [this, "transparent"],
          onChange: this.setDirty
        }, {
          type: "dropdown",
          property: [this, "depthFunc"],
          children: [["Never", n.BVF], ["Always", n.Se2], ["Less", n.Zr5], ["LessEqual", n.vCF], ["Equal", n.eD], ["GreaterEqual", n.ksN], ["Greater", n.w$m], ["NotEqual", n.M6v]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "checkbox",
          property: [this, "depthTest"],
          onChange: this.setDirty
        }, {
          type: "checkbox",
          property: [this, "depthWrite"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "alphaTest"]
        }, {
          type: "checkbox",
          property: [this, "dithering"]
        }, {
          type: "dropdown",
          label: "Blending",
          property: [this, "blending"],
          children: [["None", re], ["Normal", ne], ["Additive", n.WMw], ["Subtractive", ie], ["Multiply", se]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "image",
          property: [this, "alphaMap"]
        }, be(this, "alphaMap"), {
          type: "checkbox",
          label: "Render to Depth",
          getValue: () => !0 === this.userData.renderToDepth,
          setValue: e => {
            this.userData.renderToDepth = e || void 0, this.setDirty();
          }
        }, {
          type: "checkbox",
          label: "Inverse AlphaMap",
          hidden: () => !this.transparent,
          getValue: () => !0 === this.userData.inverseAlphaMap,
          setValue: e => {
            this.userData.inverseAlphaMap = e || void 0, this.setDirty();
          }
        }]
      }, {
        type: "folder",
        label: "AO/Lightmap",
        children: [{
          type: "slider",
          bounds: [0, 2],
          property: [this, "aoMapIntensity"]
        }, {
          type: "image",
          property: [this, "aoMap"]
        }, be(this, "aoMap"), {
          type: "slider",
          bounds: [0, 2],
          property: [this, "lightMapIntensity"]
        }, {
          type: "image",
          property: [this, "lightMap"]
        }, be(this, "lightMap")]
      }, {
        type: "dropdown",
        label: "Side",
        property: [this, "side"],
        children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map(e => ({
          label: e[0],
          value: e[1]
        }))
      }, {
        type: "checkbox",
        property: [this, "flatShading"]
      }, {
        type: "checkbox",
        label: "Enable LUT",
        getValue: () => !0 === this.userData.enableLUT,
        setValue: e => {
          this.userData.enableLUT = e || void 0, this.setDirty();
        }
      }, {
        type: "input",
        label: "Mesh count",
        getValue: () => {
          var e, t, r;
          return null !== (r = null === (t = null === (e = this.userData) || void 0 === e ? void 0 : e.__appliedMeshes) || void 0 === t ? void 0 : t.size) && void 0 !== r ? r : 0;
        },
        setValue: e => {},
        disabled: !0
      }, {
        type: "button",
        label: `Download ${this.typeSlug}`,
        value: () => {
          yt(new Blob([JSON.stringify(this.toJSON(), null, 2)], {
            type: "application/json"
          }), `physical-material.${this.typeSlug}`);
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Physical Material",
        expanded: !0,
        children: this._uiConfigChildren,
        uuid: "MSM2_" + this.uuid,
        limitedUi: !0
      }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(e => {
        var t;
        return null === (t = e.getUiConfig) || void 0 === t ? void 0 : t.call(e, this);
      })].filter(e => e), this._uiConfig;
    }
    onBeforeCompile(e, t) {
      const r = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]],
        n = [["#include <uv_vertex>", "mainStart"]];
      for (const t of n) e.vertexShader = qt(e.vertexShader, t[0], "#glMarker " + t[1] + "\n" + t[0]);
      for (const t of r) e.fragmentShader = qt(e.fragmentShader, t[0], "#glMarker " + t[1] + "\n" + t[0]);
      Ft.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), e.vertexShader = e.vertexShader.replaceAll("#glMarker", "// "), e.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e, t);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e, t, r, n, i) {
      super.onBeforeRender(e, t, r, n, i), this.dispatchEvent({
        type: "beforeRender",
        renderer: e,
        scene: t,
        camera: r,
        geometry: n,
        object: i
      });
      const s = this.userData.inverseAlphaMap ? 1 : 0;
      s !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = s, this.needsUpdate = !0);
    }
    copyProps(e, t = !1) {
      if (!t && !["MeshStandardMaterial", Kt.TYPE, "MeshPhysicalMaterial"].includes(e.type)) return console.error("Material type is not supported:", e.type), this;
      const r = {};
      b(e, r, Array.from(Object.keys(Yt)));
      const n = r.userData;
      delete r.userData;
      for (const e of Object.keys(r)) void 0 === r[e] && delete r[e];
      return this.setValues(r), n && xe(this.userData, n), this.setDirty(), this;
    }
    toJSON(e) {
      var t, r;
      const n = this.userData;
      this.userData = {};
      const i = super.toJSON(e);
      this.userData = n, i.userData = {}, xe(i.userData, n), i.userData.uuid = this.userData.uuid;
      const s = e || {
        textures: Object.fromEntries((null === (t = i.textures) || void 0 === t ? void 0 : t.map(e => [e.uuid, e])) || []),
        images: Object.fromEntries((null === (r = i.images) || void 0 === r ? void 0 : r.map(e => [e.uuid, e])) || [])
      };
      i.userData = ke(i.userData, !1, s), e || (Object.keys(s.textures).length > 0 && (i.textures = Object.values(s.textures)), Object.keys(s.images).length > 0 && (i.images = Object.values(s.images))), i.type = Kt.TYPE;
      for (const e of Object.keys(i)) void 0 === i[e] && delete i[e];
      return i;
    }
    fromJSON(e, t, r = !1) {
      return Array.isArray(e.normalScale) && (e.normalScale = new n.FM8().fromArray(e.normalScale)), Array.isArray(e.clearcoatNormalScale) && (e.clearcoatNormalScale = new n.FM8().fromArray(e.clearcoatNormalScale)), this.copyProps(e, r);
    }
    clone() {
      return super.clone();
    }
  }
  Kt.TypeSlug = "pmat", Kt.TYPE = "MeshStandardMaterial2";
  const Jt = {
    ...Wt,
    color: "#000000",
    map: null,
    lightMap: null,
    lightMapIntensity: 1,
    aoMap: null,
    aoMapIntensity: 1,
    alphaMap: null,
    envMap: null,
    combine: n.Ns1,
    reflectivity: 1,
    refractionRatio: .98,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1
  };
  class Zt extends n.vBJ {
    constructor(e) {
      var t;
      super(e), this.typeSlug = Zt.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshBasicMaterial2 = !0, this.extraUniformsToUpload = {}, this.fog = !1, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = e => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e);
      }, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : []);
    }
    setDirty(e) {
      var t, r;
      this.needsUpdate = !0, this.dispatchEvent({
        ...e,
        type: "materialUpdate"
      }), null === (r = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0, 1);
    }
    registerMaterialExtensions(e) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e)];
    }
    unregisterMaterialExtensions(e) {}
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, {
        type: "color",
        property: [this, "color"],
        limitedUi: !0
      }, {
        type: "image",
        property: [this, "map"]
      }, be(this, "map"), {
        type: "folder",
        label: "Blending",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "opacity"]
        }, {
          type: "checkbox",
          property: [this, "transparent"],
          onChange: this.setDirty
        }, {
          type: "checkbox",
          property: [this, "depthWrite"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "alphaTest"]
        }, {
          type: "checkbox",
          property: [this, "dithering"]
        }, {
          type: "dropdown",
          label: "Blending",
          property: [this, "blending"],
          children: [["None", re], ["Normal", ne], ["Additive", n.WMw], ["Subtractive", ie], ["Multiply", se]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "image",
          property: [this, "alphaMap"]
        }, be(this, "alphaMap"), {
          type: "checkbox",
          label: "Render to Depth",
          getValue: () => !0 === this.userData.renderToDepth,
          setValue: e => {
            this.userData.renderToDepth = e || void 0, this.setDirty();
          }
        }]
      }, {
        type: "folder",
        label: "AO/Lightmap",
        children: [{
          type: "slider",
          bounds: [0, 2],
          property: [this, "aoMapIntensity"]
        }, {
          type: "image",
          property: [this, "aoMap"]
        }, be(this, "aoMap"), {
          type: "slider",
          bounds: [0, 2],
          property: [this, "lightMapIntensity"]
        }, {
          type: "image",
          property: [this, "lightMap"]
        }, be(this, "lightMap")]
      }, {
        type: "dropdown",
        label: "Side",
        property: [this, "side"],
        children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map(e => ({
          label: e[0],
          value: e[1]
        }))
      }, {
        type: "input",
        label: "Mesh count",
        getValue: () => {
          var e, t, r;
          return null !== (r = null === (t = null === (e = this.userData) || void 0 === e ? void 0 : e.__appliedMeshes) || void 0 === t ? void 0 : t.size) && void 0 !== r ? r : 0;
        },
        setValue: e => {},
        disabled: !0
      }, {
        type: "button",
        label: `Download ${this.typeSlug}`,
        value: () => {
          yt(new Blob([JSON.stringify(this.toJSON(), null, 2)], {
            type: "application/json"
          }), `unlit-material.${this.typeSlug}`);
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Unlit Material",
        expanded: !0,
        children: this._uiConfigChildren,
        uuid: "MBM2_" + this.uuid,
        limitedUi: !0
      }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(e => {
        var t;
        return null === (t = e.getUiConfig) || void 0 === t ? void 0 : t.call(e, this);
      })].filter(e => e), this._uiConfig;
    }
    onBeforeCompile(e, t) {
      const r = [["vec3 outgoingLight = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["ReflectedLight reflectedLight = ", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]],
        n = [["#include <uv_vertex>", "mainStart"]];
      for (const t of n) e.vertexShader = qt(e.vertexShader, t[0], "#glMarker " + t[1] + "\n" + t[0]);
      for (const t of r) e.fragmentShader = qt(e.fragmentShader, t[0], "#glMarker " + t[1] + "\n" + t[0]);
      Ft.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), e.vertexShader = e.vertexShader.replaceAll("#glMarker", "// "), super.onBeforeCompile(e, t);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e, t, r, n, i) {
      super.onBeforeRender(e, t, r, n, i), this.dispatchEvent({
        type: "beforeRender",
        renderer: e,
        scene: t,
        camera: r,
        geometry: n,
        object: i
      });
    }
    copyProps(e, t = !1) {
      if (!t && !["MeshBasicMaterial", Zt.TYPE].includes(e.type)) return console.error("Material type is not supported:", e.type), this;
      const r = {};
      b(e, r, Array.from(Object.keys(Jt)));
      const n = r.userData;
      delete r.userData;
      for (const e of Object.keys(r)) void 0 === r[e] && delete r[e];
      return this.setValues(r), n && xe(this.userData, n), this.setDirty(), this;
    }
    toJSON(e) {
      var t, r;
      const n = this.userData;
      this.userData = {};
      const i = super.toJSON(e);
      this.userData = n, i.userData = {}, xe(i.userData, n), i.userData.uuid = this.userData.uuid;
      const s = e || {
        textures: Object.fromEntries((null === (t = i.textures) || void 0 === t ? void 0 : t.map(e => [e.uuid, e])) || []),
        images: Object.fromEntries((null === (r = i.images) || void 0 === r ? void 0 : r.map(e => [e.uuid, e])) || [])
      };
      i.userData = ke(i.userData, !1, s), e || (Object.keys(s.textures).length > 0 && (i.textures = Object.values(s.textures)), Object.keys(s.images).length > 0 && (i.images = Object.values(s.images))), i.type = Zt.TYPE;
      for (const e of Object.keys(i)) void 0 === i[e] && delete i[e];
      return i;
    }
    fromJSON(e, t, r = !1) {
      return this.copyProps(e, r);
    }
    clone() {
      return super.clone();
    }
  }
  Zt.TypeSlug = "bmat", Zt.TYPE = "MeshBasicMaterial2";
  const $t = {
      materialType: Kt.TYPE,
      name: "standard",
      color: "#ffffff"
    },
    er = {
      materialType: Zt.TYPE,
      name: "basic",
      color: "#ffffff"
    },
    tr = {
      [Kt.TYPE]: $t.name,
      MeshStandardMaterial: $t.name,
      MeshPhysicalMaterial: $t.name,
      [Zt.TYPE]: er.name,
      MeshBasicMaterial: er.name
    };
  class rr extends r {
    constructor() {
      super(), this._templates = [$t, er], this._materials = [], this._disposeMaterial = e => {
        const t = e.target;
        if (!t || "material" !== t.assetType) return;
        this._refreshTextureRefs();
        const r = this._getMapsForMaterial(t),
          n = [];
        r.forEach(e => {
          const r = e.userData.__appliedMaterials;
          null == r || r.delete(t), r && !1 !== e.userData.disposeOnIdle && 0 === r.size && n.push(e);
        }), n.forEach(e => {
          e.dispose();
        }), this.unregisterMaterial(t);
      }, this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this);
    }
    findOrCreate(e, t) {
      let r = this.findMaterial(e);
      return r || (r = this.generateFromTemplate(e, t)), r;
    }
    generateFromTemplate(e, t) {
      const r = this.findTemplate(e);
      if (r) return this._generateFromTemplate(r, null != t ? t : {});
    }
    generateFromTemplateType(e, t) {
      const r = this._templates.find(t => t.materialType === e);
      if (r) return this._generateFromTemplate(r, null != t ? t : {});
    }
    findTemplate(e) {
      return this._templates.find(t => t.name === e);
    }
    _refreshTextureRefs() {
      this.getAllMaterials().forEach(e => {
        this._getMapsForMaterial(e).forEach(t => {
          let r = t.userData.__appliedMaterials;
          r || (t.userData.__appliedMaterials = r = new Set()), r.add(e);
        });
      });
    }
    _getMapsForMaterial(e) {
      var t;
      const r = new Set();
      for (const t of Object.values(e)) t && t.isTexture && r.add(t);
      for (const n of Object.values(null !== (t = e.userData) && void 0 !== t ? t : {})) n && n.isTexture && r.add(n);
      return r;
    }
    registerMaterial(e) {
      if (this._materials.includes(e)) return;
      const t = this.findMaterial(e.uuid);
      t ? console.warn("Material UUID already exists", e, t) : (e.addEventListener("dispose", this._disposeMaterial), this._materials.push(e));
    }
    registerMaterialObject(e) {
      const t = e.materialObject ? e : Object.assign(e, {
        assetType: "material",
        materialObject: e
      });
      return this.registerMaterial(t), t;
    }
    unregisterMaterial(e) {
      this._materials = this._materials.filter(t => t.uuid !== e.uuid), e.removeEventListener("dispose", this._disposeMaterial);
    }
    registerMaterialTemplate(e) {
      e.templateUUID || (e.templateUUID = Xe());
      const t = this._templates.find(t => t.templateUUID === e.templateUUID);
      t ? console.warn("MaterialTemplate already exists", e, t) : this._templates.push(e);
    }
    unregisterMaterialTemplate(e) {
      this._templates = this._templates.filter(t => t.templateUUID !== e.templateUUID);
    }
    dispose() {}
    findMaterial(e) {
      return e ? this._materials.find(t => t.uuid === e) : void 0;
    }
    findMaterialsByName(e) {
      return this._materials.filter(t => t.name === e);
    }
    getMaterialsOfType(e) {
      return e ? this._materials.filter(t => t.typeSlug === e) : [];
    }
    getAllMaterials() {
      return [...this._materials];
    }
    processModel(e, t) {
      return _(e, "modelObject", this._processModel(e, t)), e;
    }
    _processMaterial(e, t) {
      var r, n, i;
      if (!e) return;
      if (null === (r = e.materialObject) || void 0 === r ? void 0 : r.isMaterial) return e;
      let s = e.mmMaterial;
      if (!s) {
        const r = (null === (n = e.userData) || void 0 === n ? void 0 : n.uuid) || e.uuid;
        if (s = this.findMaterial(r), s) s.copyProps(e);else {
          const r = !1 === t.useSourceMaterial || !e.isMaterial,
            n = null !== (i = t.materialTemplate) && void 0 !== i ? i : r ? "standard" : tr[e.type] || "standard";
          s = this.generateFromTemplate(n, r ? {} : e);
        }
        e.mmMaterial = s;
      }
      return s;
    }
    processMaterial(e, t) {
      return !1 !== t.register && this.registerMaterial(e), e.materialObject || (e = this._processMaterial(e, {
        ...t,
        register: !1
      })), e;
    }
    registerMaterialExtension(e) {
      this._materialExtensions.includes(e) || this._materialExtensions.push(e);
    }
    unregisterMaterialExtension(e) {
      const t = this._materialExtensions.indexOf(e);
      t >= 0 && this._materialExtensions.splice(t, 1);
    }
    exportMaterial(e, t, r = !0, n = !1) {
      const i = ke(e, !1),
        s = JSON.stringify(i, null, r ? 0 : 2),
        o = (t || e.name || "physical_material") + "." + e.typeSlug,
        a = new File([s], o, {
          type: "application/json"
        });
      return n && wt(a), a;
    }
  }
  class nr extends rr {
    _generateFromTemplate(e, t) {
      var r, n, i, s, o, a;
      let l;
      const c = {
        ...e
      };
      c.customMaterialExtensions = [...(null !== (r = c.customMaterialExtensions) && void 0 !== r ? r : []), ...this._materialExtensions];
      let u = {};
      switch (e.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
          t && b(t, c, Array.from(Object.keys(Yt))), "MeshBasicMaterial" === (null == t ? void 0 : t.type) && (c.roughness = .9, c.metalness = 0, (null === (n = c.userData) || void 0 === n ? void 0 : n.uuid) && delete c.userData.uuid), u = null === (i = c.userData) || void 0 === i ? void 0 : i.uuid, u && delete c.userData.uuid, l = new Kt({
            customMaterialExtensions: c.customMaterialExtensions
          }).fromJSON(c, void 0, !0), u && (l.uuid = u), l.userData.uuid = l.uuid, l.setDirty(), (null == t ? void 0 : t.isMaterial) && void 0 !== t.userData && (t.userData.iMaterial = l);
          break;
        case "MeshBasicMaterial2":
        case "basic":
        case "unlit":
          t && b(t, c, Array.from(Object.keys(Jt))), u = null === (s = c.userData) || void 0 === s ? void 0 : s.uuid, u && delete c.userData.uuid, l = new Zt({
            customMaterialExtensions: c.customMaterialExtensions
          }).fromJSON(c, void 0, !0), u && (l.uuid = u), l.userData.uuid = l.uuid, l.setDirty();
          break;
        case "shadow":
          throw "TODO: Not implemented shadow material";
        default:
          u = null, t && t.userData && (u = t.userData, delete t.userData), l = (null === (o = e.generator) || void 0 === o ? void 0 : o.call(e, c, t)) || void 0, t && u && (t.userData = u), u && l && (xe(l.userData, u), (null == u ? void 0 : u.uuid) && (l.uuid = u.uuid), u = null), l && (l.userData.uuid = l.uuid);
      }
      if (l) {
        t.runtimeMaterial && (l.userData.__runtimeMaterial = !0);
        const r = l;
        if (l.clone = () => {
          r.userData.cloneId || (r.userData.cloneId = "0", r.userData.cloneCount = 0), r.userData.cloneCount += 1;
          const t = this.generateFromTemplate(e.name);
          return t && (t.copyProps(r), t.userData.cloneId = t.userData.cloneId + "_" + r.userData.cloneCount, t.userData.cloneCount = 0, t.name = t.name + "_" + t.userData.cloneId), null == t ? void 0 : t.materialObject;
        }, t) {
          let e = this.findMaterial(null == t ? void 0 : t.uuid);
          e && this.unregisterMaterial(e), e = this.findMaterial(null === (a = null == t ? void 0 : t.materialObject) || void 0 === a ? void 0 : a.uuid), e && this.unregisterMaterial(e);
        }
        return this.registerMaterialObject(r);
      }
    }
    _processModel(e, t) {
      if (!e.modelObject) return console.error("MaterialManager: No modelObject found for ", e), e;
      let r = e.material;
      if (!r && e.geometry && (this._defaultMaterial || (this._defaultMaterial = this.generateFromTemplate("standard")), r = this._defaultMaterial, e.material = r), r) {
        let n = !0;
        Array.isArray(r) || (r = [r], n = !1);
        const i = [];
        for (const e of r) {
          const r = this._processMaterial(e, t);
          i.push(null == r ? void 0 : r.materialObject);
        }
        e.setMaterial && (e.modelObject.material = null, e.setMaterial(n ? i : i[0]));
      }
      if (!1 !== t.recursive) for (let r = 0; r < e.modelObject.children.length; r++) e.modelObject.children[r] = this._processModel(e.modelObject.children[r], t);
      return e;
    }
  }
  class ir {
    constructor(e, t, r, n) {
      this.cls = e, this.ext = t, this.root = r, this.onCtor = n;
    }
    ctor(e) {
      const t = this.cls && new this.cls(e.loadingManager);
      return "function" == typeof this.onCtor ? this.onCtor(t, e) : t;
    }
  }
  function sr(e) {
    var t;
    if (!e || "" === e || e.match(/__MACOSX\/.*\._/)) return "";
    const r = null !== (t = (e = e.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t ? t : "",
      n = r.lastIndexOf(".");
    return "" === r || n < 1 ? "" : r.slice(n + 1);
  }
  function or(e) {
    return e.substring(e.lastIndexOf("/") + 1);
  }
  class ar {
    constructor(e, {
      pseudoCenter: t = !1,
      autoCenter: r = !1,
      autoScale: i = !1,
      autoScaleRadius: s = 2,
      license: o = ""
    } = {}) {
      if (this.assetType = "model", this._modelObject = Le(new n.Tme()), this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), e || (e = this._modelObject), !t || e.userData.pseudoCentered || e.userData.isCentered) !r || e.userData.autoCentered || e.userData.isCentered || e.userData.pseudoCentered ? t || r || (e.userData.isCentered = !0) : q(e), this._modelObject = e;else {
        r && console.error("cannot use pseudoCenter and autoCenter at the same time");
        const t = new k().expandByObject(e, !0, !0).getCenter(new n.Pa4());
        this._modelObject.position.copy(t).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e), this._modelObject.name = e.name + "-centered", this._modelObject.userData.pseudoCentered = !0, e.userData.iModel = this;
      }
      i && !this._modelObject.userData.autoScaled ? X(this._modelObject, e.userData.autoScaleRadius || s) : this._modelObject.userData.autoScaled = !0, this._modelObject.addEventListener("dispose", () => {
        this.__disposed = !0;
      }), this._modelObject.userData.iModel = this, this.license = o;
    }
    get visible() {
      return this._modelObject.visible;
    }
    set visible(e) {
      this._modelObject.visible = e;
    }
    get uuid() {
      return this._modelObject.uuid;
    }
    get modelObject() {
      return this._modelObject;
    }
    get name() {
      return this._modelObject.name;
    }
    set name(e) {
      this._modelObject.name = e;
    }
    get license() {
      return this._modelObject.userData.license;
    }
    set license(e) {
      this._modelObject.userData.license = e;
    }
    addEventListener(e, t) {
      this._modelObject.addEventListener(e, t);
    }
    dispatchEvent(e) {
      this._modelObject.dispatchEvent(e);
    }
    hasEventListener(e, t) {
      return this._modelObject.hasEventListener(e, t);
    }
    removeEventListener(e, t) {
      this._modelObject.removeEventListener(e, t);
    }
    traverse(e) {
      this._modelObject.traverse(e);
    }
    dispose() {
      const e = this._modelObject.dispose;
      e && "function" == typeof e ? e() : (console.warn("no dispose in modelObject"), this._modelObject.removeFromParent());
    }
    setDirty(e) {
      var t, r, n, i;
      null === (r = null === (t = this._modelObject) || void 0 === t ? void 0 : t.setDirty) || void 0 === r || r.call(t, e), null === (i = null === (n = this._uiConfig) || void 0 === n ? void 0 : n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0);
    }
    setMaterial(e) {
      var t, r;
      return this._modelObject.isMesh ? (null === (r = (t = this._modelObject).setMaterial) || void 0 === r ? void 0 : r.call(t, e)) || [] : (console.error("setMaterial only works on meshes"), []);
    }
    get material() {
      return this._modelObject.material;
    }
    get geometry() {
      return this._modelObject.geometry;
    }
    setGeometry(e, t = !1) {
      var r, n;
      if (this._modelObject.isMesh) return null === (n = (r = this._modelObject).setGeometry) || void 0 === n ? void 0 : n.call(r, e, t);
      console.error("setGeometry only works on meshes");
    }
    get userData() {
      return this._modelObject.userData;
    }
    set userData(e) {
      this._modelObject.userData = e;
    }
    updateBounds() {
      console.warn("updateBounds: NOT IMPLEMENTED"), this.setDirty();
    }
    get uiConfig() {
      return this._uiConfig || (this._uiConfig = Re(this._modelObject, !1)), this._uiConfig;
    }
    clone() {
      return new ar(this._modelObject.clone(), {
        pseudoCenter: !1,
        autoScale: !1,
        autoCenter: !1,
        license: this.license
      });
    }
  }
  function lr(e, t) {
    return [e.modelObject, ...e.modelObject.children].forEach(r => {
      Le(r, r !== e.modelObject ? e : void 0, t);
    }), e;
  }
  class cr {
    constructor() {
      this._processors = new Map();
    }
    add(e, t) {
      var r;
      this._processors.has(e) || this._processors.set(e, []), null === (r = this._processors.get(e)) || void 0 === r || r.push(t);
    }
    remove(e, t) {
      const r = this._processors.get(e),
        n = (null == r ? void 0 : r.indexOf(t)) || (null == r ? void 0 : r.findIndex(e => e.process && e.process === t.process || e.processAsync && e.processAsync === t.processAsync));
      !r || !n || n < 0 || r.splice(n, 1);
    }
    get(e) {
      var t;
      return null !== (t = this._processors.get(e)) && void 0 !== t ? t : [];
    }
    async process(e, t, r) {
      var n, i, s, o;
      const a = this.get(e),
        l = t.assetType;
      for (const e of a) e.forAssetType === l && (t = null !== (i = null === (n = e.process) || void 0 === n ? void 0 : n.call(e, t, r)) && void 0 !== i ? i : t, t = null !== (o = await (null === (s = e.processAsync) || void 0 === s ? void 0 : s.call(e, t, r))) && void 0 !== o ? o : t);
      return t;
    }
    dispose() {
      this._processors.clear();
    }
  }
  class ur extends n.hH6 {
    load(e, t, r, n) {
      return super.load(e, e => {
        try {
          if ("string" != typeof e) throw new Error("Invalid JSON");
          null == t || t(JSON.parse(e));
        } catch (e) {
          null == n || n(e);
        }
      }, r, n);
    }
  }
  class hr extends n.yxD {
    constructor(e) {
      super(e), this.type = n.cLu;
    }
    parse(e) {
      const t = function (e, t) {
          switch (e) {
            case 1:
              console.error("THREE.RGBELoader Read Error: " + (t || ""));
              break;
            case 2:
              console.error("THREE.RGBELoader Write Error: " + (t || ""));
              break;
            case 3:
              console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
              break;
            default:
              console.error("THREE.RGBELoader: Error: " + (t || ""));
          }
          return -1;
        },
        r = function (e, t, r) {
          t = t || 1024;
          let n = e.pos,
            i = -1,
            s = 0,
            o = "",
            a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(n, n + 128)));
          for (; 0 > (i = a.indexOf("\n")) && s < t && n < e.byteLength;) o += a, s += a.length, n += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(n, n + 128)));
          return -1 < i && (!1 !== r && (e.pos += s + i + 1), o + a.slice(0, i));
        },
        i = function (e, t, r, n) {
          const i = e[t + 3],
            s = Math.pow(2, i - 128) / 255;
          r[n + 0] = e[t + 0] * s, r[n + 1] = e[t + 1] * s, r[n + 2] = e[t + 2] * s, r[n + 3] = 1;
        },
        s = function (e, t, r, i) {
          const s = e[t + 3],
            o = Math.pow(2, s - 128) / 255;
          r[i + 0] = n.A5E.toHalfFloat(Math.min(e[t + 0] * o, 65504)), r[i + 1] = n.A5E.toHalfFloat(Math.min(e[t + 1] * o, 65504)), r[i + 2] = n.A5E.toHalfFloat(Math.min(e[t + 2] * o, 65504)), r[i + 3] = n.A5E.toHalfFloat(1);
        },
        o = new Uint8Array(e);
      o.pos = 0;
      const a = function (e) {
        const n = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          s = /^\s*FORMAT=(\S+)\s*$/,
          o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          a = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0
          };
        let l, c;
        if (e.pos >= e.byteLength || !(l = r(e))) return t(1, "no header found");
        if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");
        for (a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = r(e), !1 !== l;) if (a.string += l + "\n", "#" !== l.charAt(0)) {
          if ((c = l.match(n)) && (a.gamma = parseFloat(c[1])), (c = l.match(i)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break;
        } else a.comments += l + "\n";
        return 2 & a.valid ? 4 & a.valid ? a : t(3, "missing image size specifier") : t(3, "missing format specifier");
      }(o);
      if (-1 !== a) {
        const e = a.width,
          r = a.height,
          l = function (e, r, n) {
            const i = r;
            if (i < 8 || i > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
            if (i !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
            const s = new Uint8Array(4 * r * n);
            if (!s.length) return t(4, "unable to allocate buffer space");
            let o = 0,
              a = 0;
            const l = 4 * i,
              c = new Uint8Array(4),
              u = new Uint8Array(l);
            let h = n;
            for (; h > 0 && a < e.byteLength;) {
              if (a + 4 > e.byteLength) return t(1);
              if (c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != i) return t(3, "bad rgbe scanline format");
              let r,
                n = 0;
              for (; n < l && a < e.byteLength;) {
                r = e[a++];
                const i = r > 128;
                if (i && (r -= 128), 0 === r || n + r > l) return t(3, "bad scanline data");
                if (i) {
                  const t = e[a++];
                  for (let e = 0; e < r; e++) u[n++] = t;
                } else u.set(e.subarray(a, a + r), n), n += r, a += r;
              }
              const p = i;
              for (let e = 0; e < p; e++) {
                let t = 0;
                s[o] = u[e + t], t += i, s[o + 1] = u[e + t], t += i, s[o + 2] = u[e + t], t += i, s[o + 3] = u[e + t], o += 4;
              }
              h--;
            }
            return s;
          }(o.subarray(o.pos), e, r);
        if (-1 !== l) {
          let t, o, c;
          switch (this.type) {
            case n.VzW:
              c = l.length / 4;
              const e = new Float32Array(4 * c);
              for (let t = 0; t < c; t++) i(l, 4 * t, e, 4 * t);
              t = e, o = n.VzW;
              break;
            case n.cLu:
              c = l.length / 4;
              const r = new Uint16Array(4 * c);
              for (let e = 0; e < c; e++) s(l, 4 * e, r, 4 * e);
              t = r, o = n.cLu;
              break;
            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }
          return {
            width: e,
            height: r,
            data: t,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            type: o
          };
        }
      }
      return null;
    }
    setDataType(e) {
      return this.type = e, this;
    }
    load(e, t, r, i) {
      return super.load(e, function (e, r) {
        switch (e.type) {
          case n.VzW:
          case n.cLu:
            e.encoding = n.rnI, e.minFilter = n.wem, e.magFilter = n.wem, e.generateMipmaps = !1, e.flipY = !0;
        }
        t && t(e, r);
      }, r, i);
    }
  }
  function pr(e) {
    Js.Importers.push(new ir(class extends hr {
      constructor(t) {
        super(t), this.setDataType(Zs(e));
      }
    }, ["hdr"], !1));
  }
  class dr extends n.aNw {
    constructor(e) {
      super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) {
        return new Ar(e);
      }), this.register(function (e) {
        return new Cr(e);
      }), this.register(function (e) {
        return new Mr(e);
      }), this.register(function (e) {
        return new yr(e);
      }), this.register(function (e) {
        return new xr(e);
      }), this.register(function (e) {
        return new wr(e);
      }), this.register(function (e) {
        return new Er(e);
      }), this.register(function (e) {
        return new vr(e);
      }), this.register(function (e) {
        return new Sr(e);
      }), this.register(function (e) {
        return new br(e);
      }), this.register(function (e) {
        return new _r(e);
      }), this.register(function (e) {
        return new Tr(e);
      });
    }
    load(e, t, r, i) {
      const s = this;
      let o;
      o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : n.Zp0.extractUrlBase(e), this.manager.itemStart(e);
      const a = function (t) {
          i ? i(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e);
        },
        l = new n.hH6(this.manager);
      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (r) {
        try {
          s.parse(r, o, function (r) {
            t(r), s.manager.itemEnd(e);
          }, a);
        } catch (e) {
          a(e);
        }
      }, r, a);
    }
    setDRACOLoader(e) {
      return this.dracoLoader = e, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(e) {
      return this.ktx2Loader = e, this;
    }
    setMeshoptDecoder(e) {
      return this.meshoptDecoder = e, this;
    }
    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }
    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }
    parse(e, t, r, i) {
      let s;
      const o = {},
        a = {};
      if ("string" == typeof e) s = e;else if (n.Zp0.decodeText(new Uint8Array(e, 0, 4)) === Ir) {
        try {
          o[mr.KHR_BINARY_GLTF] = new kr(e);
        } catch (e) {
          return void (i && i(e));
        }
        s = o[mr.KHR_BINARY_GLTF].content;
      } else s = n.Zp0.decodeText(new Uint8Array(e));
      const l = JSON.parse(s);
      if (void 0 === l.asset || l.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const c = new Zr(l, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      c.fileLoader.setRequestHeader(this.requestHeader);
      for (let e = 0; e < this.pluginCallbacks.length; e++) {
        const t = this.pluginCallbacks[e](c);
        a[t.name] = t, o[t.name] = !0;
      }
      if (l.extensionsUsed) for (let e = 0; e < l.extensionsUsed.length; ++e) {
        const t = l.extensionsUsed[e],
          r = l.extensionsRequired || [];
        switch (t) {
          case mr.KHR_MATERIALS_UNLIT:
            o[t] = new gr();
            break;
          case mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[t] = new Rr();
            break;
          case mr.KHR_DRACO_MESH_COMPRESSION:
            o[t] = new Dr(l, this.dracoLoader);
            break;
          case mr.KHR_TEXTURE_TRANSFORM:
            o[t] = new Pr();
            break;
          case mr.KHR_MESH_QUANTIZATION:
            o[t] = new Lr();
            break;
          default:
            r.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".');
        }
      }
      c.setExtensions(o), c.setPlugins(a), c.parse(r, i);
    }
    parseAsync(e, t) {
      const r = this;
      return new Promise(function (n, i) {
        r.parse(e, t, n, i);
      });
    }
  }
  function fr() {
    let e = {};
    return {
      get: function (t) {
        return e[t];
      },
      add: function (t, r) {
        e[t] = r;
      },
      remove: function (t) {
        delete e[t];
      },
      removeAll: function () {
        e = {};
      }
    };
  }
  const mr = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };
  class _r {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }
    _markDefs() {
      const e = this.parser,
        t = this.parser.json.nodes || [];
      for (let r = 0, n = t.length; r < n; r++) {
        const n = t[r];
        n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      const t = this.parser,
        r = "light:" + e;
      let i = t.cache.get(r);
      if (i) return i;
      const s = t.json,
        o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
      let a;
      const l = new n.Ilk(16777215);
      void 0 !== o.color && l.fromArray(o.color);
      const c = void 0 !== o.range ? o.range : 0;
      switch (o.type) {
        case "directional":
          a = new n.Ox3(l), a.target.position.set(0, 0, -1), a.add(a.target);
          break;
        case "point":
          a = new n.cek(l), a.distance = c;
          break;
        case "spot":
          a = new n.PMe(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
      }
      return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), i = Promise.resolve(a), t.cache.add(r, i), i;
    }
    createNodeAttachment(e) {
      const t = this,
        r = this.parser,
        n = r.json.nodes[e],
        i = (n.extensions && n.extensions[this.name] || {}).light;
      return void 0 === i ? null : this._loadLight(i).then(function (e) {
        return r._getNodeRef(t.cache, i, e);
      });
    }
  }
  class gr {
    constructor() {
      this.name = mr.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return n.vBJ;
    }
    extendParams(e, t, r) {
      const i = [];
      e.color = new n.Ilk(1, 1, 1), e.opacity = 1;
      const s = t.pbrMetallicRoughness;
      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          const t = s.baseColorFactor;
          e.color.fromArray(t), e.opacity = t[3];
        }
        void 0 !== s.baseColorTexture && i.push(r.assignTexture(e, "map", s.baseColorTexture, n.knz));
      }
      return Promise.all(i);
    }
  }
  class vr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name].emissiveStrength;
      return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
    }
  }
  class Ar {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [],
        o = i.extensions[this.name];
      if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
        const e = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new n.FM8(e, e);
      }
      return Promise.all(s);
    }
  }
  class br {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && i.push(r.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && i.push(r.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(i);
    }
  }
  class yr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [];
      t.sheenColor = new n.Ilk(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      const o = i.extensions[this.name];
      return void 0 !== o.sheenColorFactor && t.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, n.knz)), void 0 !== o.sheenRoughnessTexture && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), i.extras && void 0 !== i.extras.sheenFactor && (t.sheen = i.extras.sheenFactor, delete i.extras.sheenFactor), Promise.all(s);
    }
  }
  class xr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(r.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i);
    }
  }
  class wr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [],
        o = i.extensions[this.name];
      t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 0;
      const a = o.attenuationColor || [1, 1, 1];
      return t.attenuationColor = new n.Ilk(a[0], a[1], a[2]), Promise.all(s);
    }
  }
  class Er {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_IOR;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return t.ior = void 0 !== n.ior ? n.ior : 1.5, Promise.resolve();
    }
  }
  class Sr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [],
        o = i.extensions[this.name];
      t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const a = o.specularColorFactor || [1, 1, 1];
      return t.specularColor = new n.Ilk(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, n.knz)), Promise.all(s);
    }
  }
  class Cr {
    constructor(e) {
      this.parser = e, this.name = mr.KHR_TEXTURE_BASISU;
    }
    loadTexture(e) {
      const t = this.parser,
        r = t.json,
        n = r.textures[e];
      if (!n.extensions || !n.extensions[this.name]) return null;
      const i = n.extensions[this.name],
        s = t.options.ktx2Loader;
      if (!s) {
        if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return t.loadTextureImage(e, i.source, s);
    }
  }
  class Mr {
    constructor(e) {
      this.parser = e, this.name = mr.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e) {
      const t = this.name,
        r = this.parser,
        n = r.json,
        i = n.textures[e];
      if (!i.extensions || !i.extensions[t]) return null;
      const s = i.extensions[t],
        o = n.images[s.source];
      let a = r.textureLoader;
      if (o.uri) {
        const e = r.options.manager.getHandler(o.uri);
        null !== e && (a = e);
      }
      return this.detectSupport().then(function (i) {
        if (i) return r.loadTextureImage(e, s.source, a);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return r.loadTexture(e);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function (e) {
        const t = new Image();
        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
          e(1 === t.height);
        };
      })), this.isSupported;
    }
  }
  class Tr {
    constructor(e) {
      this.name = mr.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }
    loadBufferView(e) {
      const t = this.parser.json,
        r = t.bufferViews[e];
      if (r.extensions && r.extensions[this.name]) {
        const e = r.extensions[this.name],
          n = this.parser.getDependency("buffer", e.buffer),
          i = this.parser.options.meshoptDecoder;
        if (!i || !i.supported) {
          if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return n.then(function (t) {
          const r = e.byteOffset || 0,
            n = e.byteLength || 0,
            s = e.count,
            o = e.byteStride,
            a = new Uint8Array(t, r, n);
          return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(s, o, a, e.mode, e.filter).then(function (e) {
            return e.buffer;
          }) : i.ready.then(function () {
            const t = new ArrayBuffer(s * o);
            return i.decodeGltfBuffer(new Uint8Array(t), s, o, a, e.mode, e.filter), t;
          });
        });
      }
      return null;
    }
  }
  const Ir = "glTF";
  class kr {
    constructor(e) {
      this.name = mr.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t = new DataView(e, 0, 12);
      if (this.header = {
        magic: n.Zp0.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0)
      }, this.header.magic !== Ir) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const r = this.header.length - 12,
        i = new DataView(e, 12);
      let s = 0;
      for (; s < r;) {
        const t = i.getUint32(s, !0);
        s += 4;
        const r = i.getUint32(s, !0);
        if (s += 4, 1313821514 === r) {
          const r = new Uint8Array(e, 12 + s, t);
          this.content = n.Zp0.decodeText(r);
        } else if (5130562 === r) {
          const r = 12 + s;
          this.body = e.slice(r, r + t);
        }
        s += t;
      }
      if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class Dr {
    constructor(e, t) {
      if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = mr.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      const r = this.json,
        n = this.dracoLoader,
        i = e.extensions[this.name].bufferView,
        s = e.extensions[this.name].attributes,
        o = {},
        a = {},
        l = {};
      for (const e in s) {
        const t = Vr[e] || e.toLowerCase();
        o[t] = s[e];
      }
      for (const t in e.attributes) {
        const n = Vr[t] || t.toLowerCase();
        if (void 0 !== s[t]) {
          const i = r.accessors[e.attributes[t]],
            s = Nr[i.componentType];
          l[n] = s.name, a[n] = !0 === i.normalized;
        }
      }
      return t.getDependency("bufferView", i).then(function (e) {
        return new Promise(function (t) {
          n.decodeDracoFile(e, function (e) {
            for (const t in e.attributes) {
              const r = e.attributes[t],
                n = a[t];
              void 0 !== n && (r.normalized = n);
            }
            t(e);
          }, o, l);
        });
      });
    }
  }
  class Pr {
    constructor() {
      this.name = mr.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
    }
  }
  class Br extends n.Wid {
    constructor(e) {
      super(), this.isGLTFSpecularGlossinessMaterial = !0;
      const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
        r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
        i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
        s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
        o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
        a = {
          specular: {
            value: new n.Ilk().setHex(16777215)
          },
          glossiness: {
            value: 1
          },
          specularMap: {
            value: null
          },
          glossinessMap: {
            value: null
          }
        };
      this._extraUniforms = a, this.onBeforeCompile = function (e) {
        for (const t in a) e.uniforms[t] = a[t];
        e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", r).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o);
      }, Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (e) {
            a.specular.value = e;
          }
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (e) {
            a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
          }
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (e) {
            a.glossiness.value = e;
          }
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (e) {
            a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
          }
        }
      }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }
  }
  class Rr {
    constructor() {
      this.name = mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
    }
    getMaterialType() {
      return Br;
    }
    extendParams(e, t, r) {
      const i = t.extensions[this.name];
      e.color = new n.Ilk(1, 1, 1), e.opacity = 1;
      const s = [];
      if (Array.isArray(i.diffuseFactor)) {
        const t = i.diffuseFactor;
        e.color.fromArray(t), e.opacity = t[3];
      }
      if (void 0 !== i.diffuseTexture && s.push(r.assignTexture(e, "map", i.diffuseTexture, n.knz)), e.emissive = new n.Ilk(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new n.Ilk(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
        const t = i.specularGlossinessTexture;
        s.push(r.assignTexture(e, "glossinessMap", t)), s.push(r.assignTexture(e, "specularMap", t, n.knz));
      }
      return Promise.all(s);
    }
    createMaterial(e) {
      const t = new Br(e);
      return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = n.IOt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t;
    }
  }
  class Lr {
    constructor() {
      this.name = mr.KHR_MESH_QUANTIZATION;
    }
  }
  class Or extends n._C8 {
    constructor(e, t, r, n) {
      super(e, t, r, n);
    }
    copySampleValue_(e) {
      const t = this.resultBuffer,
        r = this.sampleValues,
        n = this.valueSize,
        i = e * n * 3 + n;
      for (let e = 0; e !== n; e++) t[e] = r[i + e];
      return t;
    }
    interpolate_(e, t, r, n) {
      const i = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize,
        a = 2 * o,
        l = 3 * o,
        c = n - t,
        u = (r - t) / c,
        h = u * u,
        p = h * u,
        d = e * l,
        f = d - l,
        m = -2 * p + 3 * h,
        _ = p - h,
        g = 1 - m,
        v = _ - h + u;
      for (let e = 0; e !== o; e++) {
        const t = s[f + e + o],
          r = s[f + e + a] * c,
          n = s[d + e + o],
          l = s[d + e] * c;
        i[e] = g * t + v * r + m * n + _ * l;
      }
      return i;
    }
  }
  const Fr = new n._fP();
  class Ur extends Or {
    interpolate_(e, t, r, n) {
      const i = super.interpolate_(e, t, r, n);
      return Fr.fromArray(i).normalize().toArray(i), i;
    }
  }
  const Nr = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    },
    jr = {
      9728: n.TyD,
      9729: n.wem,
      9984: n.YLQ,
      9985: n.qyh,
      9986: n.aH4,
      9987: n.D1R
    },
    zr = {
      33071: n.uWy,
      33648: n.OoA,
      10497: n.rpg
    },
    Gr = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    },
    Vr = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex"
    },
    Qr = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences"
    },
    Hr = {
      CUBICSPLINE: void 0,
      LINEAR: n.NMF,
      STEP: n.Syv
    };
  function Wr(e, t, r) {
    for (const n in r.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = r.extensions[n]);
  }
  function qr(e, t) {
    void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
  }
  function Xr(e, t) {
    if (e.updateMorphTargets(), void 0 !== t.weights) for (let r = 0, n = t.weights.length; r < n; r++) e.morphTargetInfluences[r] = t.weights[r];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const r = t.extras.targetNames;
      if (e.morphTargetInfluences.length === r.length) {
        e.morphTargetDictionary = {};
        for (let t = 0, n = r.length; t < n; t++) e.morphTargetDictionary[r[t]] = t;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function Yr(e) {
    const t = e.extensions && e.extensions[mr.KHR_DRACO_MESH_COMPRESSION];
    let r;
    return r = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Kr(t.attributes) : e.indices + ":" + Kr(e.attributes) + ":" + e.mode, r;
  }
  function Kr(e) {
    let t = "";
    const r = Object.keys(e).sort();
    for (let n = 0, i = r.length; n < i; n++) t += r[n] + ":" + e[r[n]] + ";";
    return t;
  }
  function Jr(e) {
    switch (e) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  class Zr {
    constructor(e = {}, t = {}) {
      this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new fr(), this.associations = new Map(), this.primitiveCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      const r = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        i = navigator.userAgent.indexOf("Firefox") > -1,
        s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || r || i && s < 98 ? this.textureLoader = new n.dpR(this.options.manager) : this.textureLoader = new n.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new n.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(e) {
      this.extensions = e;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    parse(e, t) {
      const r = this,
        n = this.json,
        i = this.extensions;
      this.cache.removeAll(), this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }), Promise.all(this._invokeAll(function (e) {
        return e.beforeRoot && e.beforeRoot();
      })).then(function () {
        return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")]);
      }).then(function (t) {
        const s = {
          scene: t[0][n.scene || 0],
          scenes: t[0],
          animations: t[1],
          cameras: t[2],
          asset: n.asset,
          parser: r,
          userData: {}
        };
        Wr(i, s, n), qr(s, n), Promise.all(r._invokeAll(function (e) {
          return e.afterRoot && e.afterRoot(s);
        })).then(function () {
          e(s);
        });
      }).catch(t);
    }
    _markDefs() {
      const e = this.json.nodes || [],
        t = this.json.skins || [],
        r = this.json.meshes || [];
      for (let r = 0, n = t.length; r < n; r++) {
        const n = t[r].joints;
        for (let t = 0, r = n.length; t < r; t++) e[n[t]].isBone = !0;
      }
      for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (r[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
      }
    }
    _addNodeRef(e, t) {
      void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }
    _getNodeRef(e, t, r) {
      if (e.refs[t] <= 1) return r;
      const n = r.clone(),
        i = (e, t) => {
          const r = this.associations.get(e);
          null != r && this.associations.set(t, r);
          for (const [r, n] of e.children.entries()) i(n, t.children[r]);
        };
      return i(r, n), n.name += "_instance_" + e.uses[t]++, n;
    }
    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);
      for (let r = 0; r < t.length; r++) {
        const n = e(t[r]);
        if (n) return n;
      }
      return null;
    }
    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const r = [];
      for (let n = 0; n < t.length; n++) {
        const i = e(t[n]);
        i && r.push(i);
      }
      return r;
    }
    getDependency(e, t) {
      const r = e + ":" + t;
      let n = this.cache.get(r);
      if (!n) {
        switch (e) {
          case "scene":
            n = this.loadScene(t);
            break;
          case "node":
            n = this.loadNode(t);
            break;
          case "mesh":
            n = this._invokeOne(function (e) {
              return e.loadMesh && e.loadMesh(t);
            });
            break;
          case "accessor":
            n = this.loadAccessor(t);
            break;
          case "bufferView":
            n = this._invokeOne(function (e) {
              return e.loadBufferView && e.loadBufferView(t);
            });
            break;
          case "buffer":
            n = this.loadBuffer(t);
            break;
          case "material":
            n = this._invokeOne(function (e) {
              return e.loadMaterial && e.loadMaterial(t);
            });
            break;
          case "texture":
            n = this._invokeOne(function (e) {
              return e.loadTexture && e.loadTexture(t);
            });
            break;
          case "skin":
            n = this.loadSkin(t);
            break;
          case "animation":
            n = this._invokeOne(function (e) {
              return e.loadAnimation && e.loadAnimation(t);
            });
            break;
          case "camera":
            n = this.loadCamera(t);
            break;
          default:
            throw new Error("Unknown type: " + e);
        }
        this.cache.add(r, n);
      }
      return n;
    }
    getDependencies(e) {
      let t = this.cache.get(e);
      if (!t) {
        const r = this,
          n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
        t = Promise.all(n.map(function (t, n) {
          return r.getDependency(e, n);
        })), this.cache.add(e, t);
      }
      return t;
    }
    loadBuffer(e) {
      const t = this.json.buffers[e],
        r = this.fileLoader;
      if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
      if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[mr.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function (e, s) {
        r.load(n.Zp0.resolveURL(t.uri, i.path), e, void 0, function () {
          s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
        });
      });
    }
    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function (e) {
        const r = t.byteLength || 0,
          n = t.byteOffset || 0;
        return e.slice(n, n + r);
      });
    }
    loadAccessor(e) {
      const t = this,
        r = this.json,
        i = this.json.accessors[e];
      if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
      const s = [];
      return void 0 !== i.bufferView ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), void 0 !== i.sparse && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function (e) {
        const s = e[0],
          o = Gr[i.type],
          a = Nr[i.componentType],
          l = a.BYTES_PER_ELEMENT,
          c = l * o,
          u = i.byteOffset || 0,
          h = void 0 !== i.bufferView ? r.bufferViews[i.bufferView].byteStride : void 0,
          p = !0 === i.normalized;
        let d, f;
        if (h && h !== c) {
          const e = Math.floor(u / h),
            r = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
          let c = t.cache.get(r);
          c || (d = new a(s, e * h, i.count * h / l), c = new n.vpT(d, h / l), t.cache.add(r, c)), f = new n.kB5(c, o, u % h / l, p);
        } else d = null === s ? new a(i.count * o) : new a(s, u, i.count * o), f = new n.TlE(d, o, p);
        if (void 0 !== i.sparse) {
          const t = Gr.SCALAR,
            r = Nr[i.sparse.indices.componentType],
            l = i.sparse.indices.byteOffset || 0,
            c = i.sparse.values.byteOffset || 0,
            u = new r(e[1], l, i.sparse.count * t),
            h = new a(e[2], c, i.sparse.count * o);
          null !== s && (f = new n.TlE(f.array.slice(), f.itemSize, f.normalized));
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            if (f.setX(t, h[e * o]), o >= 2 && f.setY(t, h[e * o + 1]), o >= 3 && f.setZ(t, h[e * o + 2]), o >= 4 && f.setW(t, h[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return f;
      });
    }
    loadTexture(e) {
      const t = this.json,
        r = this.options,
        n = t.textures[e].source,
        i = t.images[n];
      let s = this.textureLoader;
      if (i.uri) {
        const e = r.manager.getHandler(i.uri);
        null !== e && (s = e);
      }
      return this.loadTextureImage(e, n, s);
    }
    loadTextureImage(e, t, r) {
      const i = this,
        s = this.json,
        o = s.textures[e],
        a = s.images[t],
        l = (a.uri || a.bufferView) + ":" + o.sampler;
      if (this.textureCache[l]) return this.textureCache[l];
      const c = this.loadImageSource(t, r).then(function (t) {
        o.name && (t.name = o.name);
        const r = (s.samplers || {})[o.sampler] || {};
        return t.magFilter = jr[r.magFilter] || n.wem, t.minFilter = jr[r.minFilter] || n.D1R, t.wrapS = zr[r.wrapS] || n.rpg, t.wrapT = zr[r.wrapT] || n.rpg, r.extras && void 0 !== r.extras.uuid && (t.uuid = r.extras.uuid), i.associations.set(t, {
          textures: e
        }), t;
      }).catch(function () {
        return null;
      });
      return this.textureCache[l] = c, c;
    }
    loadImageSource(e, t) {
      const r = this,
        i = this.json,
        s = this.options;
      if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then(e => e.clone());
      const o = i.images[e],
        a = self.URL || self.webkitURL;
      let l = o.uri || "",
        c = !1;
      if (void 0 !== o.bufferView) l = r.getDependency("bufferView", o.bufferView).then(function (e) {
        c = !0;
        const t = new Blob([e], {
          type: o.mimeType
        });
        return l = a.createObjectURL(t), l;
      });else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
      const u = Promise.resolve(l).then(function (e) {
        return new Promise(function (i, o) {
          let a = i;
          !0 === t.isImageBitmapLoader && (a = function (e) {
            const t = new n.xEZ(e);
            t.needsUpdate = !0, i(t);
          }), t.load(n.Zp0.resolveURL(e, s.path), a, void 0, function (l) {
            !0 === t.isImageBitmapLoader ? (t = new n.dpR(r.options.manager), a = i, t.setCrossOrigin(r.options.crossOrigin), t.setRequestHeader(r.options.requestHeader), t.load(n.Zp0.resolveURL(e, s.path), a, void 0, o)) : o(l);
          });
        });
      }).then(function (e) {
        var r;
        if (!0 === c && a.revokeObjectURL(l), e.userData.mimeType = o.mimeType || ((r = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === r.search(/^data\:image\/jpeg/) ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || 0 === r.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e.flipY = !1, o.extras) {
          if (void 0 !== o.extras.flipY) {
            if (!0 === t.isImageBitmapLoader && void 0 !== typeof createImageBitmap) {
              const t = e,
                r = o.extras.flipY && !t.flipY;
              createImageBitmap(t.source.data, {
                imageOrientation: r ? "flipY" : "none"
              }).then(function (e) {
                t.source.data.close && t.source.data.close(), t.source.data = e, t.source.needsUpdate = !0, t.needsUpdate = !0;
              });
            }
            e.flipY = o.extras.flipY, e.needsUpdate = !0, delete o.extras.flipY;
          }
          void 0 !== o.extras.uuid && (e.source.uuid = o.extras.uuid), void 0 !== o.extras.t_uuid && (e.uuid = o.extras.t_uuid);
        }
        return o.uri && "string" == typeof o.uri && (e.userData.rootPath = o.uri), e;
      }).catch(function (e) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", l), e;
      });
      return this.sourceCache[e] = u, u;
    }
    assignTexture(e, t, r, n) {
      const i = this;
      return this.getDependency("texture", r.index).then(function (s) {
        if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), i.extensions[mr.KHR_TEXTURE_TRANSFORM]) {
          const e = void 0 !== r.extensions ? r.extensions[mr.KHR_TEXTURE_TRANSFORM] : void 0;
          if (e) {
            const t = i.associations.get(s);
            s = i.extensions[mr.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), i.associations.set(s, t);
          }
        }
        return void 0 !== n && (s.encoding = n), e[t] = s, s;
      });
    }
    assignFinalMaterial(e) {
      const t = e.geometry;
      let r = e.material;
      const i = void 0 === t.attributes.tangent,
        s = void 0 !== t.attributes.color,
        o = void 0 === t.attributes.normal;
      if (e.isPoints) {
        const e = "PointsMaterial:" + r.uuid;
        let t = this.cache.get(e);
        t || (t = new n.UY4(), n.F5T.prototype.copy.call(t, r), t.color.copy(r.color), t.map = r.map, t.sizeAttenuation = !1, this.cache.add(e, t)), r = t;
      } else if (e.isLine) {
        const e = "LineBasicMaterial:" + r.uuid;
        let t = this.cache.get(e);
        t || (t = new n.nls(), n.F5T.prototype.copy.call(t, r), t.color.copy(r.color), this.cache.add(e, t)), r = t;
      }
      if (i || s || o) {
        let e = "ClonedMaterial:" + r.uuid + ":";
        r.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), o && (e += "flat-shading:");
        let t = this.cache.get(e);
        t || (t = r.clone(), s && (t.vertexColors = !0), o && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(r))), r = t;
      }
      r.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = r;
    }
    getMaterialType() {
      return n.Wid;
    }
    loadMaterial(e) {
      const t = this,
        r = this.json,
        i = this.extensions,
        s = r.materials[e];
      let o;
      const a = {},
        l = s.extensions || {},
        c = [];
      if (l[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const e = i[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else if (l[mr.KHR_MATERIALS_UNLIT]) {
        const e = i[mr.KHR_MATERIALS_UNLIT];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else {
        const r = s.pbrMetallicRoughness || {};
        if (a.color = new n.Ilk(1, 1, 1), a.opacity = 1, Array.isArray(r.baseColorFactor)) {
          const e = r.baseColorFactor;
          a.color.fromArray(e), a.opacity = e[3];
        }
        void 0 !== r.baseColorTexture && c.push(t.assignTexture(a, "map", r.baseColorTexture, n.knz)), a.metalness = void 0 !== r.metallicFactor ? r.metallicFactor : 1, a.roughness = void 0 !== r.roughnessFactor ? r.roughnessFactor : 1, void 0 !== r.metallicRoughnessTexture && (c.push(t.assignTexture(a, "metalnessMap", r.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", r.metallicRoughnessTexture))), o = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        }), c.push(Promise.all(this._invokeAll(function (t) {
          return t.extendMaterialParams && t.extendMaterialParams(e, a);
        })));
      }
      !0 === s.doubleSided && (a.side = n.ehD);
      const u = s.alphaMode || "OPAQUE";
      if ("BLEND" === u ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === u && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== n.vBJ && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new n.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
        const e = s.normalTexture.scale;
        a.normalScale.set(e, e);
      }
      return void 0 !== s.occlusionTexture && o !== n.vBJ && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== n.vBJ && (a.emissive = new n.Ilk().fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== n.vBJ && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, n.knz)), Promise.all(c).then(function () {
        let r;
        return r = o === Br ? i[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new o(a), s.name && (r.name = s.name), qr(r, s), t.associations.set(r, {
          materials: e
        }), s.extensions && Wr(i, r, s), r;
      });
    }
    createUniqueName(e) {
      const t = n.iUV.sanitizeNodeName(e || "");
      let r = t;
      for (let e = 1; this.nodeNamesUsed[r]; ++e) r = t + "_" + e;
      return this.nodeNamesUsed[r] = !0, r;
    }
    loadGeometries(e) {
      const t = this,
        r = this.extensions,
        i = this.primitiveCache;
      function s(e) {
        return r[mr.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (r) {
          return en(r, e, t);
        });
      }
      const o = [];
      for (let r = 0, a = e.length; r < a; r++) {
        const a = e[r],
          l = Yr(a),
          c = i[l];
        if (c) o.push(c.promise);else {
          let e;
          e = a.extensions && a.extensions[mr.KHR_DRACO_MESH_COMPRESSION] ? s(a) : en(new n.u9r(), a, t), i[l] = {
            primitive: a,
            promise: e
          }, o.push(e);
        }
      }
      return Promise.all(o);
    }
    loadMesh(e) {
      const t = this,
        r = this.json,
        i = this.extensions,
        s = r.meshes[e],
        o = s.primitives,
        a = [];
      for (let e = 0, t = o.length; e < t; e++) {
        const t = void 0 === o[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new n.Wid({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: n.Wl3
        })), l.DefaultMaterial) : this.getDependency("material", o[e].material);
        a.push(t);
      }
      var l;
      return a.push(t.loadGeometries(o)), Promise.all(a).then(function (r) {
        const a = r.slice(0, r.length - 1),
          l = r[r.length - 1],
          c = [];
        for (let r = 0, u = l.length; r < u; r++) {
          const u = l[r],
            h = o[r];
          let p;
          const d = a[r];
          if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode) p = !0 === s.isSkinnedMesh ? new n.TUv(u, d) : new n.Kj0(u, d), !0 !== p.isSkinnedMesh || p.geometry.attributes.skinWeight.normalized || p.normalizeSkinWeights(), 5 === h.mode ? p.geometry = tn(p.geometry, n.UlW) : 6 === h.mode && (p.geometry = tn(p.geometry, n.z$h));else if (1 === h.mode) p = new n.ejS(u, d);else if (3 === h.mode) p = new n.x12(u, d);else if (2 === h.mode) p = new n.blk(u, d);else {
            if (0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
            p = new n.woe(u, d);
          }
          Object.keys(p.geometry.morphAttributes).length > 0 && Xr(p, s), p.name = t.createUniqueName(s.name || "mesh_" + e), qr(p, s), h.extensions && Wr(i, p, h), t.assignFinalMaterial(p), c.push(p);
        }
        s.extensions && c.forEach(e => Wr(i, e, s));
        for (let r = 0, n = c.length; r < n; r++) t.associations.set(c[r], {
          meshes: e,
          primitives: r
        });
        if (1 === c.length) return c[0];
        const u = new n.ZAu();
        t.associations.set(u, {
          meshes: e
        });
        for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);
        return u;
      });
    }
    loadCamera(e) {
      let t;
      const r = this.json.cameras[e],
        i = r[r.type];
      if (i) return "perspective" === r.type ? t = new n.cPb(n.M8C.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === r.type && (t = new n.iKG(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (t.name = this.createUniqueName(r.name)), qr(t, r), Promise.resolve(t);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(e) {
      const t = this.json.skins[e],
        r = {
          joints: t.joints
        };
      return void 0 === t.inverseBindMatrices ? Promise.resolve(r) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) {
        return r.inverseBindMatrices = e, r;
      });
    }
    loadAnimation(e) {
      const t = this.json.animations[e],
        r = [],
        i = [],
        s = [],
        o = [],
        a = [];
      for (let e = 0, n = t.channels.length; e < n; e++) {
        const n = t.channels[e],
          l = t.samplers[n.sampler],
          c = n.target,
          u = c.node,
          h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
          p = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
        r.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), s.push(this.getDependency("accessor", p)), o.push(l), a.push(c);
      }
      return Promise.all([Promise.all(r), Promise.all(i), Promise.all(s), Promise.all(o), Promise.all(a)]).then(function (r) {
        const i = r[0],
          s = r[1],
          o = r[2],
          a = r[3],
          l = r[4],
          c = [];
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e],
            r = s[e],
            u = o[e],
            h = a[e],
            p = l[e];
          if (void 0 === t) continue;
          let d;
          switch (t.updateMatrix(), Qr[p.path]) {
            case Qr.weights:
              d = n.dUE;
              break;
            case Qr.rotation:
              d = n.iLg;
              break;
            default:
              d = n.yC1;
          }
          const f = t.name ? t.name : t.uuid,
            m = void 0 !== h.interpolation ? Hr[h.interpolation] : n.NMF,
            _ = [];
          Qr[p.path] === Qr.weights ? t.traverse(function (e) {
            e.morphTargetInfluences && _.push(e.name ? e.name : e.uuid);
          }) : _.push(f);
          let g = u.array;
          if (u.normalized) {
            const e = Jr(g.constructor),
              t = new Float32Array(g.length);
            for (let r = 0, n = g.length; r < n; r++) t[r] = g[r] * e;
            g = t;
          }
          for (let e = 0, t = _.length; e < t; e++) {
            const t = new d(_[e] + "." + Qr[p.path], r.array, g, m);
            "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function (e) {
              return new (this instanceof n.iLg ? Ur : Or)(this.times, this.values, this.getValueSize() / 3, e);
            }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t);
          }
        }
        const u = t.name ? t.name : "animation_" + e;
        return new n.m7l(u, void 0, c);
      });
    }
    createNodeMesh(e) {
      const t = this.json,
        r = this,
        n = t.nodes[e];
      return void 0 === n.mesh ? null : r.getDependency("mesh", n.mesh).then(function (e) {
        const t = r._getNodeRef(r.meshCache, n.mesh, e);
        return void 0 !== n.weights && t.traverse(function (e) {
          if (e.isMesh) for (let t = 0, r = n.weights.length; t < r; t++) e.morphTargetInfluences[t] = n.weights[t];
        }), t;
      });
    }
    loadNode(e) {
      const t = this.json,
        r = this.extensions,
        i = this,
        s = t.nodes[e],
        o = s.name ? i.createUniqueName(s.name) : "";
      return function () {
        const t = [],
          r = i._invokeOne(function (t) {
            return t.createNodeMesh && t.createNodeMesh(e);
          });
        return r && t.push(r), void 0 !== s.camera && t.push(i.getDependency("camera", s.camera).then(function (e) {
          return i._getNodeRef(i.cameraCache, s.camera, e);
        })), i._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        }).forEach(function (e) {
          t.push(e);
        }), Promise.all(t);
      }().then(function (t) {
        let a;
        if (a = !0 === s.isBone ? new n.N$j() : t.length > 1 ? new n.ZAu() : 1 === t.length ? t[0] : new n.Tme(), a !== t[0]) for (let e = 0, r = t.length; e < r; e++) a.add(t[e]);
        if (s.name && (a.userData.name = s.name, a.name = o), qr(a, s), s.extensions && Wr(r, a, s), void 0 !== s.matrix) {
          const e = new n.yGw();
          e.fromArray(s.matrix), a.applyMatrix4(e);
        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
        return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = e, a;
      });
    }
    loadScene(e) {
      const t = this.json,
        r = this.extensions,
        i = this.json.scenes[e],
        s = this,
        o = new n.ZAu();
      i.name && (o.name = s.createUniqueName(i.name)), qr(o, i), i.extensions && Wr(r, o, i);
      const a = i.nodes || [],
        l = [];
      for (let e = 0, r = a.length; e < r; e++) l.push($r(a[e], o, t, s));
      return Promise.all(l).then(function () {
        return s.associations = (e => {
          const t = new Map();
          for (const [e, r] of s.associations) (e instanceof n.F5T || e instanceof n.xEZ) && t.set(e, r);
          return e.traverse(e => {
            const r = s.associations.get(e);
            null != r && t.set(e, r);
          }), t;
        })(o), o;
      });
    }
  }
  function $r(e, t, r, i) {
    const s = r.nodes[e];
    return i.getDependency("node", e).then(function (e) {
      if (void 0 === s.skin) return e;
      let t;
      return i.getDependency("skin", s.skin).then(function (e) {
        t = e;
        const r = [];
        for (let e = 0, n = t.joints.length; e < n; e++) r.push(i.getDependency("node", t.joints[e]));
        return Promise.all(r);
      }).then(function (r) {
        return e.traverse(function (e) {
          if (!e.isMesh) return;
          const i = [],
            s = [];
          for (let e = 0, o = r.length; e < o; e++) {
            const o = r[e];
            if (o) {
              i.push(o);
              const r = new n.yGw();
              void 0 !== t.inverseBindMatrices && r.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(r);
            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]);
          }
          e.bind(new n.OdW(i, s), e.matrixWorld);
        }), e;
      });
    }).then(function (e) {
      t.add(e);
      const n = [];
      if (s.children) {
        const t = s.children;
        for (let s = 0, o = t.length; s < o; s++) {
          const o = t[s];
          n.push($r(o, e, r, i));
        }
      }
      return Promise.all(n);
    });
  }
  function en(e, t, r) {
    const i = t.attributes,
      s = [];
    function o(t, n) {
      return r.getDependency("accessor", t).then(function (t) {
        e.setAttribute(n, t);
      });
    }
    for (const t in i) {
      const r = Vr[t] || t.toLowerCase();
      r in e.attributes || s.push(o(i[t], r));
    }
    if (void 0 !== t.indices && !e.index) {
      const n = r.getDependency("accessor", t.indices).then(function (t) {
        e.setIndex(t);
      });
      s.push(n);
    }
    return qr(e, t), function (e, t, r) {
      const i = t.attributes,
        s = new n.ZzF();
      if (void 0 === i.POSITION) return;
      {
        const e = r.json.accessors[i.POSITION],
          t = e.min,
          o = e.max;
        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (s.set(new n.Pa4(t[0], t[1], t[2]), new n.Pa4(o[0], o[1], o[2])), e.normalized) {
          const t = Jr(Nr[e.componentType]);
          s.min.multiplyScalar(t), s.max.multiplyScalar(t);
        }
      }
      const o = t.targets;
      if (void 0 !== o) {
        const e = new n.Pa4(),
          t = new n.Pa4();
        for (let n = 0, i = o.length; n < i; n++) {
          const i = o[n];
          if (void 0 !== i.POSITION) {
            const n = r.json.accessors[i.POSITION],
              s = n.min,
              o = n.max;
            if (void 0 !== s && void 0 !== o) {
              if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), n.normalized) {
                const e = Jr(Nr[n.componentType]);
                t.multiplyScalar(e);
              }
              e.max(t);
            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
        s.expandByVector(e);
      }
      e.boundingBox = s;
      const a = new n.aLr();
      s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = a;
    }(e, t, r), Promise.all(s).then(function () {
      return void 0 !== t.targets ? function (e, t, r) {
        let n = !1,
          i = !1,
          s = !1;
        for (let e = 0, r = t.length; e < r; e++) {
          const r = t[e];
          if (void 0 !== r.POSITION && (n = !0), void 0 !== r.NORMAL && (i = !0), void 0 !== r.COLOR_0 && (s = !0), n && i && s) break;
        }
        if (!n && !i && !s) return Promise.resolve(e);
        const o = [],
          a = [],
          l = [];
        for (let c = 0, u = t.length; c < u; c++) {
          const u = t[c];
          if (n) {
            const t = void 0 !== u.POSITION ? r.getDependency("accessor", u.POSITION) : e.attributes.position;
            o.push(t);
          }
          if (i) {
            const t = void 0 !== u.NORMAL ? r.getDependency("accessor", u.NORMAL) : e.attributes.normal;
            a.push(t);
          }
          if (s) {
            const t = void 0 !== u.COLOR_0 ? r.getDependency("accessor", u.COLOR_0) : e.attributes.color;
            l.push(t);
          }
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (t) {
          const r = t[0],
            o = t[1],
            a = t[2];
          return n && (e.morphAttributes.position = r), i && (e.morphAttributes.normal = o), s && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e;
        });
      }(e, t.targets, r) : e;
    });
  }
  function tn(e, t) {
    let r = e.getIndex();
    if (null === r) {
      const t = [],
        n = e.getAttribute("position");
      if (void 0 === n) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
      for (let e = 0; e < n.count; e++) t.push(e);
      e.setIndex(t), r = e.getIndex();
    }
    const i = r.count - 2,
      s = [];
    if (t === n.z$h) for (let e = 1; e <= i; e++) s.push(r.getX(0)), s.push(r.getX(e)), s.push(r.getX(e + 1));else for (let e = 0; e < i; e++) e % 2 == 0 ? (s.push(r.getX(e)), s.push(r.getX(e + 1)), s.push(r.getX(e + 2))) : (s.push(r.getX(e + 2)), s.push(r.getX(e + 1)), s.push(r.getX(e)));
    s.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o = e.clone();
    return o.setIndex(s), o;
  }
  class rn extends dr {
    constructor(e) {
      super(e), this.isGLTFLoader2 = !0;
    }
    async loadAsync(e, t) {
      const r = await super.loadAsync(e, t),
        n = r ? r.scene || r.scenes && r.scenes.length > 0 && r.scenes[0] : void 0;
      return n && r.animations.length > 0 && (n.animations = r.animations), n.traverse(e => {
        e.userData.gltfUUID && (e.uuid = e.userData.gltfUUID, delete e.userData.gltfUUID);
      }), n;
    }
    register(e) {
      return super.register(e);
    }
  }
  class nn extends n.hH6 {
    constructor(e) {
      super(e), this.type = n.cLu;
    }
    async loadAsync(e, t) {
      const r = await this.parseAsync(e, t, !1),
        i = new n.IEO(r.data, r.width, r.height, n.wk1, this.type);
      return i.needsUpdate = !0, i.flipY = !0, i.encoding = n.rnI, i.minFilter = n.wem, i.magFilter = n.wem, i.source.data.complete = !0, i;
    }
    async parseAsync(e, t, r = !1) {
      if (!e.startsWith("data:")) {
        this.responseType = "blob";
        const r = await super.loadAsync(e, t);
        e = (e = await xt(r)).replace("application/octet-stream", "image/png");
      }
      const i = await kt(e);
      let s = Uint8Array;
      this.type === n.cLu ? s = Uint16Array : this.type === n.VzW && (s = Uint32Array);
      const o = function (e, t = 3, r = Uint16Array, i = !1) {
        let s;
        const o = e.byteLength >> 2,
          a = new r(o * t);
        for (let r = 0; r < o; r++) s = Math.pow(2, e[4 * r + 3] - 136), i ? (a[r * t] = Math.min(e[4 * r] * s, 65504), a[r * t + 1] = Math.min(e[4 * r + 1] * s, 65504), a[r * t + 2] = Math.min(e[4 * r + 2] * s, 65504)) : (a[r * t] = n.A5E.toHalfFloat(Math.min(e[4 * r] * s, 65504)), a[r * t + 1] = n.A5E.toHalfFloat(Math.min(e[4 * r + 1] * s, 65504)), a[r * t + 2] = n.A5E.toHalfFloat(Math.min(e[4 * r + 2] * s, 65504))), 4 === t && (a[r * t + 3] = n.A5E.toHalfFloat(1));
        return a;
      }(i.data, 4, s, r);
      return {
        data: o,
        width: i.width,
        height: i.height
      };
    }
    setDataType(e) {
      return this.type = e, this;
    }
  }
  class sn extends n.Gql {
    constructor(e) {
      super(e), this._imageLoader = new n.S3k(e);
    }
    parseTextures2(e, t, r) {
      var i;
      for (const s of e) {
        const e = null === (i = null == s ? void 0 : s.userData) || void 0 === i ? void 0 : i.rootPath;
        if (e && (!s.image || !t[s.image])) {
          const i = new n.Hw6(this._imageLoader.load(e, r));
          if (!i) continue;
          s.image && (i.uuid = s.image), t[i.uuid] = i, s.image = i.uuid;
        }
        s.userData = De(s.userData, void 0, !1, {
          images: t
        });
      }
      return super.parseTextures(e, t);
    }
    parseMaterials2(e, t, r) {
      const n = {};
      return e.forEach(e => {
        if (!e) return;
        const i = {
            ...e
          },
          s = Object.keys(i);
        for (const e of s) if ("map" === e || e.endsWith("Map")) {
          const r = i[e];
          "string" == typeof r && (t[r] ? i[e] = t[r] : (console.warn(`Texture ${r} not found`), delete i[e]));
        }
        i.userData && (i.userData = De(i.userData, void 0, !1, {
          textures: t
        }));
        const o = r.generateFromTemplateType(i.type, i);
        o && (n[e.uuid] = o);
      }), n;
    }
  }
  const on = "WEBGI_viewer";
  function an(e) {
    Js.Importers.push(new ir(rn, ["gltf", "glb", "data:model/gltf"], !0, (t, r) => {
      if (!t) return t;
      const n = t,
        i = new sn(r.loadingManager);
      return n.register(pn(i, e)), n.register(hn(i)), n.register(dn(i)), n.register(e => new An(e)), n.register(e => new bn(e)), n.register(e => new yn(e)), n.register(e => new xn(e)), n.register(t => {
        var s, o, a, l, c, u, h, p, d;
        const f = Xe() + ".drc",
          m = Xe() + ".ktx2",
          _ = null === (a = null === (o = null === (s = t.json) || void 0 === s ? void 0 : s.extensionsRequired) || void 0 === o ? void 0 : o.includes) || void 0 === a ? void 0 : a.call(o, "KHR_draco_mesh_compression");
        if (_) {
          const e = r.registerFile(f);
          e && n.setDRACOLoader(e);
        }
        (null === (u = null === (c = null === (l = t.json) || void 0 === l ? void 0 : l.extensionsUsed) || void 0 === c ? void 0 : c.includes) || void 0 === u ? void 0 : u.call(c, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (n.setMeshoptDecoder(window.MeshoptDecoder), t.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
        const g = null === (d = null === (p = null === (h = t.json) || void 0 === h ? void 0 : h.extensionsUsed) || void 0 === p ? void 0 : p.includes) || void 0 === d ? void 0 : d.call(p, "KHR_texture_basisu");
        if (g) {
          const e = r.registerFile(m);
          e && (n.setKTX2Loader(e), t.options.ktx2Loader = e);
        }
        return {
          name: "GLTF2_HELPER_PLUGIN",
          afterRoot: async n => {
            _ && r.unregisterFile(f), g && r.unregisterFile(m);
            const s = await fn(t, e, i);
            n.scene.__importedViewerConfig = s;
          }
        };
      }), n;
    }));
  }
  const ln = "WEBGI_light_extras",
    cn = "WEBGI_object3d_extras",
    un = "WEBGI_material_extras",
    hn = e => e => ({
      name: "__" + cn,
      afterRoot: async e => {
        (e.scenes || (e.scene ? [e.scene] : [])).forEach(e => {
          e.traverse(e => {
            var t, r;
            if (!e.isObject3D) return;
            const n = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === r ? void 0 : r[cn];
            if (!n) return void (e.isLight && !e.isAmbientLight && (e.castShadow = !0));
            const i = void 0 !== n.castShadow || void 0 !== n.receiveShadow;
            void 0 !== n.castShadow && (e.castShadow = n.castShadow), void 0 !== n.receiveShadow && (e.receiveShadow = n.receiveShadow), void 0 !== n.visible && (e.visible = n.visible), void 0 !== n.frustumCulled && (e.frustumCulled = n.frustumCulled), void 0 !== n.renderOrder && (e.renderOrder = n.renderOrder), void 0 !== n.layers && (e.layers.mask = n.layers), i && (e.userData.__keepShadowDef = !0), delete e.userData.gltfExtensions[cn];
          });
        });
      }
    }),
    pn = (e, t) => e => ({
      name: "__" + un,
      afterRoot: async e => {
        var r, n, i;
        const s = e.scenes || (e.scene ? [e.scene] : []);
        for (const e of s) {
          const s = null === (n = null === (r = e.userData) || void 0 === r ? void 0 : r.gltfExtensions) || void 0 === n ? void 0 : n[un],
            o = s && (await (null === (i = t.getPlugin(to)) || void 0 === i ? void 0 : i.importConfigResources(s.resources || {}))) || {};
          e.traverse(e => {
            var t, r;
            const n = null == e ? void 0 : e.material;
            if (!(null == n ? void 0 : n.isMaterial)) return;
            const i = null === (r = null === (t = n.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === r ? void 0 : r[un];
            i && (void 0 !== i.emissiveIntensity && (n.emissiveIntensity = i.emissiveIntensity), void 0 !== i.fog && (n.fog = i.fog), void 0 !== i.flatShading && (n.flatShading = i.flatShading), void 0 !== i.blending && (n.blending = i.blending), void 0 !== i.side && (n.side = i.side), void 0 !== i.shadowSide && (n.shadowSide = i.shadowSide), void 0 !== i.depthFunc && (n.depthFunc = i.depthFunc), void 0 !== i.depthTest && (n.depthTest = i.depthTest), void 0 !== i.depthWrite && (n.depthWrite = i.depthWrite), void 0 !== i.colorWrite && (n.colorWrite = i.colorWrite), void 0 !== i.wireframe && (n.wireframe = i.wireframe), void 0 !== i.wireframeLinewidth && (n.wireframeLinewidth = i.wireframeLinewidth), void 0 !== i.wireframeLinecap && (n.wireframeLinecap = i.wireframeLinecap), void 0 !== i.wireframeLinejoin && (n.wireframeLinejoin = i.wireframeLinejoin), void 0 !== i.rotation && (n.rotation = i.rotation), void 0 !== i.polygonOffset && (n.polygonOffset = i.polygonOffset), void 0 !== i.polygonOffsetFactor && (n.polygonOffsetFactor = i.polygonOffsetFactor), void 0 !== i.polygonOffsetUnits && (n.polygonOffsetUnits = i.polygonOffsetUnits), void 0 !== i.dithering && (n.dithering = i.dithering), void 0 !== i.alphaToCoverage && (n.alphaToCoverage = i.alphaToCoverage), void 0 !== i.premultipliedAlpha && (n.premultipliedAlpha = i.premultipliedAlpha), void 0 !== i.toneMapped && (n.toneMapped = i.toneMapped), void 0 !== i.reflectivity && (n.reflectivity = i.reflectivity), Object.entries(i).forEach(([e, t]) => {
              e.startsWith("_") || t && t.resource && "string" == typeof t.resource && (n[e] = De(t, n[e], !1, o));
            }), delete n.userData.gltfExtensions[un]);
          }), s && delete e.userData.gltfExtensions[un];
        }
      }
    }),
    dn = e => t => ({
      name: "__" + ln,
      afterRoot: async t => {
        (t.scenes || (t.scene ? [t.scene] : [])).forEach(t => {
          t.traverse(t => {
            var r, n;
            if (!t.isLight) return;
            const i = null === (n = null === (r = t.userData) || void 0 === r ? void 0 : r.gltfExtensions) || void 0 === n ? void 0 : n[ln];
            i && (!t.shadow && i.shadow && console.error("Light has no shadow, cannot import", t, i), i.shadow && t.shadow && (void 0 !== i.shadow.bias && (t.shadow.bias = i.shadow.bias), void 0 !== i.shadow.normalBias && (t.shadow.normalBias = i.shadow.normalBias), void 0 !== i.shadow.radius && (t.shadow.radius = i.shadow.radius), void 0 !== i.shadow.mapSize && t.shadow.mapSize.fromArray(i.shadow.mapSize), void 0 !== i.shadow.camera && (t.shadow.camera = e.parseObject(i.shadow.camera))), delete t.userData.gltfExtensions[ln]);
          });
        });
      }
    });
  async function fn(e, t, r, n) {
    var i;
    if (!n) {
      const r = e.json.scenes || [];
      if (1 !== r.length) {
        for (const n of r) await fn(e, t, n);
        return;
      }
      n = r[0];
    }
    const s = null === (i = n.extensions) || void 0 === i ? void 0 : i[on];
    if (!s) return;
    const o = [];
    Object.values(s.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && o.push(e.url), "Uint8Array" === e.url.type && e.url.data && o.push(e.url));
      });
    });
    for (const t of o) {
      const r = t.data.image,
        n = e.json.images[r],
        i = await e.getDependency("bufferView", n.bufferView);
      if (n.mimeType.startsWith("image/") && "Uint16Array" === t.type && "rgbe" === t.encoding) {
        const e = new Blob([i], {
            type: n.mimeType
          }),
          r = "data:image/png;base64," + btoa(await e.text());
        t.data = (await new nn().parseAsync(r, void 0, !0)).data, delete t.encoding;
      } else t.data = i;
    }
    const a = {
      textures: {}
    };
    if (s.resources.textures && e.json.textures) for (const [t, r] of Object.entries(s.resources.textures)) {
      if (r.uuid || !t) continue;
      delete s.resources.textures[t];
      const n = e.json.textures.findIndex(r => {
        var n, i, s, o, a, l, c;
        return (null === (n = r.extras) || void 0 === n ? void 0 : n.uuid) === t || (null === (o = null === (s = null === (i = e.json.samplers) || void 0 === i ? void 0 : i[r.sampler]) || void 0 === s ? void 0 : s.extras) || void 0 === o ? void 0 : o.uuid) === t || (null === (c = null === (l = null === (a = e.json.images) || void 0 === a ? void 0 : a[r.source]) || void 0 === l ? void 0 : l.extras) || void 0 === c ? void 0 : c.t_uuid) === t;
      });
      n >= 0 && (a.textures[t] = await e.getDependency("texture", n));
    }
    if (s.resources.materials && e.json.materials) for (const [t, r] of Object.entries(s.resources.materials)) {
      if (r.uuid || !t) continue;
      delete s.resources.materials[t];
      const n = e.json.materials.findIndex(e => {
        var r;
        return (null === (r = e.extras) || void 0 === r ? void 0 : r.uuid) === t;
      });
      n >= 0 && (a.materials[t] = await e.getDependency("material", n));
    }
    return s.resources = await t.getPlugin(to).importConfigResources(s.resources || {}, r, a), s;
  }
  const mn = "WEBGI_materials_bumpmap",
    _n = "WEBGI_materials_displacementmap",
    gn = "WEBGI_materials_alphamap",
    vn = "WEBGI_materials_lightmap";
  class An {
    constructor(e) {
      this.parser = e, this.name = mn;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.bumpScale && (t.bumpScale = s.bumpScale), void 0 !== s.bumpTexture && i.push(r.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(i);
    }
  }
  class bn {
    constructor(e) {
      this.parser = e, this.name = _n;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.displacementScale && (t.displacementScale = s.displacementScale), void 0 !== s.displacementBias && (t.displacementBias = s.displacementBias), void 0 !== s.displacementTexture && i.push(r.assignTexture(t, "displacementMap", s.displacementTexture)), Promise.all(i);
    }
  }
  class yn {
    constructor(e) {
      this.parser = e, this.name = vn;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.lightMapIntensity && (t.lightMapIntensity = s.lightMapIntensity), void 0 !== s.lightMapTexture && i.push(r.assignTexture(t, "lightMap", s.lightMapTexture)), Promise.all(i);
    }
  }
  class xn {
    constructor(e) {
      this.parser = e, this.name = gn;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        s = n.extensions[this.name];
      return void 0 !== s.alphaTexture && i.push(r.assignTexture(t, "alphaMap", s.alphaTexture)), Promise.all(i);
    }
  }
  var wn = __webpackgi_require__(23);
  function En() {
    Js.Importers.push(new ir(wn.Q, ["drc"], !0));
  }
  var Sn = {},
    Cn = Uint8Array,
    Mn = Uint16Array,
    Tn = Uint32Array,
    In = new Cn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    kn = new Cn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
    Dn = new Cn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    Pn = function (e, t) {
      for (var r = new Mn(31), n = 0; n < 31; ++n) r[n] = t += 1 << e[n - 1];
      var i = new Tn(r[30]);
      for (n = 1; n < 30; ++n) for (var s = r[n]; s < r[n + 1]; ++s) i[s] = s - r[n] << 5 | n;
      return [r, i];
    },
    Bn = Pn(In, 2),
    Rn = Bn[0],
    Ln = Bn[1];
  Rn[28] = 258, Ln[258] = 28;
  for (var On = Pn(kn, 0), Fn = On[0], Un = On[1], Nn = new Mn(32768), jn = 0; jn < 32768; ++jn) {
    var zn = (43690 & jn) >>> 1 | (21845 & jn) << 1;
    zn = (61680 & (zn = (52428 & zn) >>> 2 | (13107 & zn) << 2)) >>> 4 | (3855 & zn) << 4, Nn[jn] = ((65280 & zn) >>> 8 | (255 & zn) << 8) >>> 1;
  }
  var Gn = function (e, t, r) {
      for (var n = e.length, i = 0, s = new Mn(t); i < n; ++i) ++s[e[i] - 1];
      var o,
        a = new Mn(t);
      for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;
      if (r) {
        o = new Mn(1 << t);
        var l = 15 - t;
        for (i = 0; i < n; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], h = a[e[i] - 1]++ << u, p = h | (1 << u) - 1; h <= p; ++h) o[Nn[h] >>> l] = c;
      } else for (o = new Mn(n), i = 0; i < n; ++i) e[i] && (o[i] = Nn[a[e[i] - 1]++] >>> 15 - e[i]);
      return o;
    },
    Vn = new Cn(288);
  for (jn = 0; jn < 144; ++jn) Vn[jn] = 8;
  for (jn = 144; jn < 256; ++jn) Vn[jn] = 9;
  for (jn = 256; jn < 280; ++jn) Vn[jn] = 7;
  for (jn = 280; jn < 288; ++jn) Vn[jn] = 8;
  var Qn = new Cn(32);
  for (jn = 0; jn < 32; ++jn) Qn[jn] = 5;
  var Hn = Gn(Vn, 9, 0),
    Wn = Gn(Vn, 9, 1),
    qn = Gn(Qn, 5, 0),
    Xn = Gn(Qn, 5, 1),
    Yn = function (e) {
      for (var t = e[0], r = 1; r < e.length; ++r) e[r] > t && (t = e[r]);
      return t;
    },
    Kn = function (e, t, r) {
      var n = t / 8 | 0;
      return (e[n] | e[n + 1] << 8) >> (7 & t) & r;
    },
    Jn = function (e, t) {
      var r = t / 8 | 0;
      return (e[r] | e[r + 1] << 8 | e[r + 2] << 16) >> (7 & t);
    },
    Zn = function (e) {
      return (e / 8 | 0) + (7 & e && 1);
    },
    $n = function (e, t, r) {
      (null == t || t < 0) && (t = 0), (null == r || r > e.length) && (r = e.length);
      var n = new (e instanceof Mn ? Mn : e instanceof Tn ? Tn : Cn)(r - t);
      return n.set(e.subarray(t, r)), n;
    },
    ei = function (e, t, r) {
      var n = e.length;
      if (!n || r && !r.l && n < 5) return t || new Cn(0);
      var i = !t || r,
        s = !r || r.i;
      r || (r = {}), t || (t = new Cn(3 * n));
      var o = function (e) {
          var r = t.length;
          if (e > r) {
            var n = new Cn(Math.max(2 * r, e));
            n.set(t), t = n;
          }
        },
        a = r.f || 0,
        l = r.p || 0,
        c = r.b || 0,
        u = r.l,
        h = r.d,
        p = r.m,
        d = r.n,
        f = 8 * n;
      do {
        if (!u) {
          r.f = a = Kn(e, l, 1);
          var m = Kn(e, l + 1, 3);
          if (l += 3, !m) {
            var _ = e[(M = Zn(l) + 4) - 4] | e[M - 3] << 8,
              g = M + _;
            if (g > n) {
              if (s) throw "unexpected EOF";
              break;
            }
            i && o(c + _), t.set(e.subarray(M, g), c), r.b = c += _, r.p = l = 8 * g;
            continue;
          }
          if (1 == m) u = Wn, h = Xn, p = 9, d = 5;else {
            if (2 != m) throw "invalid block type";
            var v = Kn(e, l, 31) + 257,
              A = Kn(e, l + 10, 15) + 4,
              b = v + Kn(e, l + 5, 31) + 1;
            l += 14;
            for (var y = new Cn(b), x = new Cn(19), w = 0; w < A; ++w) x[Dn[w]] = Kn(e, l + 3 * w, 7);
            l += 3 * A;
            var E = Yn(x),
              S = (1 << E) - 1,
              C = Gn(x, E, 1);
            for (w = 0; w < b;) {
              var M,
                T = C[Kn(e, l, S)];
              if (l += 15 & T, (M = T >>> 4) < 16) y[w++] = M;else {
                var I = 0,
                  k = 0;
                for (16 == M ? (k = 3 + Kn(e, l, 3), l += 2, I = y[w - 1]) : 17 == M ? (k = 3 + Kn(e, l, 7), l += 3) : 18 == M && (k = 11 + Kn(e, l, 127), l += 7); k--;) y[w++] = I;
              }
            }
            var D = y.subarray(0, v),
              P = y.subarray(v);
            p = Yn(D), d = Yn(P), u = Gn(D, p, 1), h = Gn(P, d, 1);
          }
          if (l > f) {
            if (s) throw "unexpected EOF";
            break;
          }
        }
        i && o(c + 131072);
        for (var B = (1 << p) - 1, R = (1 << d) - 1, L = l;; L = l) {
          var O = (I = u[Jn(e, l) & B]) >>> 4;
          if ((l += 15 & I) > f) {
            if (s) throw "unexpected EOF";
            break;
          }
          if (!I) throw "invalid length/literal";
          if (O < 256) t[c++] = O;else {
            if (256 == O) {
              L = l, u = null;
              break;
            }
            var F = O - 254;
            if (O > 264) {
              var U = In[w = O - 257];
              F = Kn(e, l, (1 << U) - 1) + Rn[w], l += U;
            }
            var N = h[Jn(e, l) & R],
              j = N >>> 4;
            if (!N) throw "invalid distance";
            if (l += 15 & N, P = Fn[j], j > 3 && (U = kn[j], P += Jn(e, l) & (1 << U) - 1, l += U), l > f) {
              if (s) throw "unexpected EOF";
              break;
            }
            i && o(c + 131072);
            for (var z = c + F; c < z; c += 4) t[c] = t[c - P], t[c + 1] = t[c + 1 - P], t[c + 2] = t[c + 2 - P], t[c + 3] = t[c + 3 - P];
            c = z;
          }
        }
        r.l = u, r.p = L, r.b = c, u && (a = 1, r.m = p, r.d = h, r.n = d);
      } while (!a);
      return c == t.length ? t : $n(t, 0, c);
    },
    ti = function (e, t, r) {
      r <<= 7 & t;
      var n = t / 8 | 0;
      e[n] |= r, e[n + 1] |= r >>> 8;
    },
    ri = function (e, t, r) {
      r <<= 7 & t;
      var n = t / 8 | 0;
      e[n] |= r, e[n + 1] |= r >>> 8, e[n + 2] |= r >>> 16;
    },
    ni = function (e, t) {
      for (var r = [], n = 0; n < e.length; ++n) e[n] && r.push({
        s: n,
        f: e[n]
      });
      var i = r.length,
        s = r.slice();
      if (!i) return [ui, 0];
      if (1 == i) {
        var o = new Cn(r[0].s + 1);
        return o[r[0].s] = 1, [o, 1];
      }
      r.sort(function (e, t) {
        return e.f - t.f;
      }), r.push({
        s: -1,
        f: 25001
      });
      var a = r[0],
        l = r[1],
        c = 0,
        u = 1,
        h = 2;
      for (r[0] = {
        s: -1,
        f: a.f + l.f,
        l: a,
        r: l
      }; u != i - 1;) a = r[r[c].f < r[h].f ? c++ : h++], l = r[c != u && r[c].f < r[h].f ? c++ : h++], r[u++] = {
        s: -1,
        f: a.f + l.f,
        l: a,
        r: l
      };
      var p = s[0].s;
      for (n = 1; n < i; ++n) s[n].s > p && (p = s[n].s);
      var d = new Mn(p + 1),
        f = ii(r[u - 1], d, 0);
      if (f > t) {
        n = 0;
        var m = 0,
          _ = f - t,
          g = 1 << _;
        for (s.sort(function (e, t) {
          return d[t.s] - d[e.s] || e.f - t.f;
        }); n < i; ++n) {
          var v = s[n].s;
          if (!(d[v] > t)) break;
          m += g - (1 << f - d[v]), d[v] = t;
        }
        for (m >>>= _; m > 0;) {
          var A = s[n].s;
          d[A] < t ? m -= 1 << t - d[A]++ - 1 : ++n;
        }
        for (; n >= 0 && m; --n) {
          var b = s[n].s;
          d[b] == t && (--d[b], ++m);
        }
        f = t;
      }
      return [new Cn(d), f];
    },
    ii = function (e, t, r) {
      return -1 == e.s ? Math.max(ii(e.l, t, r + 1), ii(e.r, t, r + 1)) : t[e.s] = r;
    },
    si = function (e) {
      for (var t = e.length; t && !e[--t];);
      for (var r = new Mn(++t), n = 0, i = e[0], s = 1, o = function (e) {
          r[n++] = e;
        }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
        if (!i && s > 2) {
          for (; s > 138; s -= 138) o(32754);
          s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
        } else if (s > 3) {
          for (o(i), --s; s > 6; s -= 6) o(8304);
          s > 2 && (o(s - 3 << 5 | 8208), s = 0);
        }
        for (; s--;) o(i);
        s = 1, i = e[a];
      }
      return [r.subarray(0, n), t];
    },
    oi = function (e, t) {
      for (var r = 0, n = 0; n < t.length; ++n) r += e[n] * t[n];
      return r;
    },
    ai = function (e, t, r) {
      var n = r.length,
        i = Zn(t + 2);
      e[i] = 255 & n, e[i + 1] = n >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
      for (var s = 0; s < n; ++s) e[i + s + 4] = r[s];
      return 8 * (i + 4 + n);
    },
    li = function (e, t, r, n, i, s, o, a, l, c, u) {
      ti(t, u++, r), ++i[256];
      for (var h = ni(i, 15), p = h[0], d = h[1], f = ni(s, 15), m = f[0], _ = f[1], g = si(p), v = g[0], A = g[1], b = si(m), y = b[0], x = b[1], w = new Mn(19), E = 0; E < v.length; ++E) w[31 & v[E]]++;
      for (E = 0; E < y.length; ++E) w[31 & y[E]]++;
      for (var S = ni(w, 7), C = S[0], M = S[1], T = 19; T > 4 && !C[Dn[T - 1]]; --T);
      var I,
        k,
        D,
        P,
        B = c + 5 << 3,
        R = oi(i, Vn) + oi(s, Qn) + o,
        L = oi(i, p) + oi(s, m) + o + 14 + 3 * T + oi(w, C) + (2 * w[16] + 3 * w[17] + 7 * w[18]);
      if (B <= R && B <= L) return ai(t, u, e.subarray(l, l + c));
      if (ti(t, u, 1 + (L < R)), u += 2, L < R) {
        I = Gn(p, d, 0), k = p, D = Gn(m, _, 0), P = m;
        var O = Gn(C, M, 0);
        for (ti(t, u, A - 257), ti(t, u + 5, x - 1), ti(t, u + 10, T - 4), u += 14, E = 0; E < T; ++E) ti(t, u + 3 * E, C[Dn[E]]);
        u += 3 * T;
        for (var F = [v, y], U = 0; U < 2; ++U) {
          var N = F[U];
          for (E = 0; E < N.length; ++E) {
            var j = 31 & N[E];
            ti(t, u, O[j]), u += C[j], j > 15 && (ti(t, u, N[E] >>> 5 & 127), u += N[E] >>> 12);
          }
        }
      } else I = Hn, k = Vn, D = qn, P = Qn;
      for (E = 0; E < a; ++E) if (n[E] > 255) {
        j = n[E] >>> 18 & 31, ri(t, u, I[j + 257]), u += k[j + 257], j > 7 && (ti(t, u, n[E] >>> 23 & 31), u += In[j]);
        var z = 31 & n[E];
        ri(t, u, D[z]), u += P[z], z > 3 && (ri(t, u, n[E] >>> 5 & 8191), u += kn[z]);
      } else ri(t, u, I[n[E]]), u += k[n[E]];
      return ri(t, u, I[256]), u + k[256];
    },
    ci = new Tn([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
    ui = new Cn(0),
    hi = function (e, t, r, n, i, s) {
      var o = e.length,
        a = new Cn(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(n, a.length - i),
        c = 0;
      if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
        var h = u + 65535;
        h < o ? c = ai(l, c, e.subarray(u, h)) : (l[u] = s, c = ai(l, c, e.subarray(u, o)));
      } else {
        for (var p = ci[t - 1], d = p >>> 13, f = 8191 & p, m = (1 << r) - 1, _ = new Mn(32768), g = new Mn(m + 1), v = Math.ceil(r / 3), A = 2 * v, b = function (t) {
            return (e[t] ^ e[t + 1] << v ^ e[t + 2] << A) & m;
          }, y = new Tn(25e3), x = new Mn(288), w = new Mn(32), E = 0, S = 0, C = (u = 0, 0), M = 0, T = 0; u < o; ++u) {
          var I = b(u),
            k = 32767 & u,
            D = g[I];
          if (_[k] = D, g[I] = k, M <= u) {
            var P = o - u;
            if ((E > 7e3 || C > 24576) && P > 423) {
              c = li(e, l, 0, y, x, w, S, C, T, u - T, c), C = E = S = 0, T = u;
              for (var B = 0; B < 286; ++B) x[B] = 0;
              for (B = 0; B < 30; ++B) w[B] = 0;
            }
            var R = 2,
              L = 0,
              O = f,
              F = k - D & 32767;
            if (P > 2 && I == b(u - F)) for (var U = Math.min(d, P) - 1, N = Math.min(32767, u), j = Math.min(258, P); F <= N && --O && k != D;) {
              if (e[u + R] == e[u + R - F]) {
                for (var z = 0; z < j && e[u + z] == e[u + z - F]; ++z);
                if (z > R) {
                  if (R = z, L = F, z > U) break;
                  var G = Math.min(F, z - 2),
                    V = 0;
                  for (B = 0; B < G; ++B) {
                    var Q = u - F + B + 32768 & 32767,
                      H = Q - _[Q] + 32768 & 32767;
                    H > V && (V = H, D = Q);
                  }
                }
              }
              F += (k = D) - (D = _[k]) + 32768 & 32767;
            }
            if (L) {
              y[C++] = 268435456 | Ln[R] << 18 | Un[L];
              var W = 31 & Ln[R],
                q = 31 & Un[L];
              S += In[W] + kn[q], ++x[257 + W], ++w[q], M = u + R, ++E;
            } else y[C++] = e[u], ++x[e[u]];
          }
        }
        c = li(e, l, s, y, x, w, S, C, T, u - T, c), !s && 7 & c && (c = ai(l, c + 1, ui));
      }
      return $n(a, 0, n + Zn(c) + i);
    },
    pi = function () {
      for (var e = new Int32Array(256), t = 0; t < 256; ++t) {
        for (var r = t, n = 9; --n;) r = (1 & r && -306674912) ^ r >>> 1;
        e[t] = r;
      }
      return e;
    }(),
    di = function () {
      var e = -1;
      return {
        p: function (t) {
          for (var r = e, n = 0; n < t.length; ++n) r = pi[255 & r ^ t[n]] ^ r >>> 8;
          e = r;
        },
        d: function () {
          return ~e;
        }
      };
    },
    fi = function () {
      var e = 1,
        t = 0;
      return {
        p: function (r) {
          for (var n = e, i = t, s = r.length, o = 0; o != s;) {
            for (var a = Math.min(o + 2655, s); o < a; ++o) i += n += r[o];
            n = (65535 & n) + 15 * (n >> 16), i = (65535 & i) + 15 * (i >> 16);
          }
          e = n, t = i;
        },
        d: function () {
          return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
        }
      };
    },
    mi = function (e, t, r, n, i) {
      return hi(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, r, n, !i);
    },
    _i = function (e, t) {
      var r = {};
      for (var n in e) r[n] = e[n];
      for (var n in t) r[n] = t[n];
      return r;
    },
    gi = function (e, t, r) {
      for (var n = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < n.length; ++o) {
        var a = n[o],
          l = s[o];
        if ("function" == typeof a) {
          t += ";" + l + "=";
          var c = a.toString();
          if (a.prototype) {
            if (-1 != c.indexOf("[native code]")) {
              var u = c.indexOf(" ", 8) + 1;
              t += c.slice(u, c.indexOf("(", u));
            } else for (var h in t += c, a.prototype) t += ";" + l + ".prototype." + h + "=" + a.prototype[h].toString();
          } else t += c;
        } else r[l] = a;
      }
      return [t, r];
    },
    vi = [],
    Ai = function (e, t, r, n) {
      var i;
      if (!vi[r]) {
        for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = gi(e[l], s, o))[0], o = i[1];
        vi[r] = gi(e[a], s, o);
      }
      var c = _i({}, vi[r][1]);
      return function (e, t, r, n, i) {
        var s = new Worker(Sn[t] || (Sn[t] = URL.createObjectURL(new Blob([e], {
          type: "text/javascript"
        }))));
        return s.onerror = function (e) {
          return i(e.error, null);
        }, s.onmessage = function (e) {
          return i(null, e.data);
        }, s.postMessage(r, n), s;
      }(vi[r][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", r, c, function (e) {
        var t = [];
        for (var r in e) (e[r] instanceof Cn || e[r] instanceof Mn || e[r] instanceof Tn) && t.push((e[r] = new e[r].constructor(e[r])).buffer);
        return t;
      }(c), n);
    },
    bi = function () {
      return [Cn, Mn, Tn, In, kn, Dn, Rn, Fn, Wn, Xn, Nn, Gn, Yn, Kn, Jn, Zn, $n, ei, Yi, Ci, Mi];
    },
    yi = function () {
      return [Cn, Mn, Tn, In, kn, Dn, Ln, Un, Hn, Vn, qn, Qn, Nn, ci, ui, Gn, ti, ri, ni, ii, si, oi, ai, li, Zn, $n, hi, mi, Hi, Ci];
    },
    xi = function () {
      return [Li, Ui, Ri, di, pi];
    },
    wi = function () {
      return [Oi, Fi];
    },
    Ei = function () {
      return [Ni, Ri, fi];
    },
    Si = function () {
      return [ji];
    },
    Ci = function (e) {
      return postMessage(e, [e.buffer]);
    },
    Mi = function (e) {
      return e && e.size && new Cn(e.size);
    },
    Ti = function (e, t, r, n, i, s) {
      var o = Ai(r, n, i, function (e, t) {
        o.terminate(), s(e, t);
      });
      return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
        o.terminate();
      };
    },
    Ii = function (e) {
      return e.ondata = function (e, t) {
        return postMessage([e, t], [e.buffer]);
      }, function (t) {
        return e.push(t.data[0], t.data[1]);
      };
    },
    ki = function (e, t, r, n, i) {
      var s,
        o = Ai(e, n, i, function (e, r) {
          e ? (o.terminate(), t.ondata.call(t, e)) : (r[1] && o.terminate(), t.ondata.call(t, e, r[0], r[1]));
        });
      o.postMessage(r), t.push = function (e, r) {
        if (s) throw "stream finished";
        if (!t.ondata) throw "no stream handler";
        o.postMessage([e, s = r], [e.buffer]);
      }, t.terminate = function () {
        o.terminate();
      };
    },
    Di = function (e, t) {
      return e[t] | e[t + 1] << 8;
    },
    Pi = function (e, t) {
      return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
    },
    Bi = function (e, t) {
      return Pi(e, t) + 4294967296 * Pi(e, t + 4);
    },
    Ri = function (e, t, r) {
      for (; r; ++t) e[t] = r, r >>>= 8;
    },
    Li = function (e, t) {
      var r = t.filename;
      if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Ri(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), r) {
        e[3] = 8;
        for (var n = 0; n <= r.length; ++n) e[n + 10] = r.charCodeAt(n);
      }
    },
    Oi = function (e) {
      if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
      var t = e[3],
        r = 10;
      4 & t && (r += e[10] | 2 + (e[11] << 8));
      for (var n = (t >> 3 & 1) + (t >> 4 & 1); n > 0; n -= !e[r++]);
      return r + (2 & t);
    },
    Fi = function (e) {
      var t = e.length;
      return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
    },
    Ui = function (e) {
      return 10 + (e.filename && e.filename.length + 1 || 0);
    },
    Ni = function (e, t) {
      var r = t.level,
        n = 0 == r ? 0 : r < 6 ? 1 : 9 == r ? 3 : 2;
      e[0] = 120, e[1] = n << 6 | (n ? 32 - 2 * n : 1);
    },
    ji = function (e) {
      if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
      if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
    };
  function zi(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }
  var Gi = function () {
      function e(e, t) {
        t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
      }
      return e.prototype.p = function (e, t) {
        this.ondata(mi(e, this.o, 0, 0, !t), t);
      }, e.prototype.push = function (e, t) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        this.d = t, this.p(e, t || !1);
      }, e;
    }(),
    Vi = function () {
      return function (e, t) {
        ki([yi, function () {
          return [Ii, Gi];
        }], this, zi.call(this, e, t), function (e) {
          var t = new Gi(e.data);
          onmessage = Ii(t);
        }, 6);
      };
    }();
  function Qi(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [yi], function (e) {
      return Ci(Hi(e.data[0], e.data[1]));
    }, 0, r);
  }
  function Hi(e, t) {
    return mi(e, t || {}, 0, 0);
  }
  var Wi = function () {
      function e(e) {
        this.s = {}, this.p = new Cn(0), this.ondata = e;
      }
      return e.prototype.e = function (e) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        var t = this.p.length,
          r = new Cn(t + e.length);
        r.set(this.p), r.set(e, t), this.p = r;
      }, e.prototype.c = function (e) {
        this.d = this.s.i = e || !1;
        var t = this.s.b,
          r = ei(this.p, this.o, this.s);
        this.ondata($n(r, t, this.s.b), this.d), this.o = $n(r, this.s.b - 32768), this.s.b = this.o.length, this.p = $n(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      }, e.prototype.push = function (e, t) {
        this.e(e), this.c(t);
      }, e;
    }(),
    qi = function () {
      return function (e) {
        this.ondata = e, ki([bi, function () {
          return [Ii, Wi];
        }], this, 0, function () {
          var e = new Wi();
          onmessage = Ii(e);
        }, 7);
      };
    }();
  function Xi(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [bi], function (e) {
      return Ci(Yi(e.data[0], Mi(e.data[1])));
    }, 1, r);
  }
  function Yi(e, t) {
    return ei(e, t);
  }
  var Ki = function () {
      function e(e, t) {
        this.c = di(), this.l = 0, this.v = 1, Gi.call(this, e, t);
      }
      return e.prototype.push = function (e, t) {
        Gi.prototype.push.call(this, e, t);
      }, e.prototype.p = function (e, t) {
        this.c.p(e), this.l += e.length;
        var r = mi(e, this.o, this.v && Ui(this.o), t && 8, !t);
        this.v && (Li(r, this.o), this.v = 0), t && (Ri(r, r.length - 8, this.c.d()), Ri(r, r.length - 4, this.l)), this.ondata(r, t);
      }, e;
    }(),
    Ji = function () {
      return function (e, t) {
        ki([yi, xi, function () {
          return [Ii, Gi, Ki];
        }], this, zi.call(this, e, t), function (e) {
          var t = new Ki(e.data);
          onmessage = Ii(t);
        }, 8);
      };
    }();
  function Zi(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [yi, xi, function () {
      return [$i];
    }], function (e) {
      return Ci($i(e.data[0], e.data[1]));
    }, 2, r);
  }
  function $i(e, t) {
    t || (t = {});
    var r = di(),
      n = e.length;
    r.p(e);
    var i = mi(e, t, Ui(t), 8),
      s = i.length;
    return Li(i, t), Ri(i, s - 8, r.d()), Ri(i, s - 4, n), i;
  }
  var es = function () {
      function e(e) {
        this.v = 1, Wi.call(this, e);
      }
      return e.prototype.push = function (e, t) {
        if (Wi.prototype.e.call(this, e), this.v) {
          var r = this.p.length > 3 ? Oi(this.p) : 4;
          if (r >= this.p.length && !t) return;
          this.p = this.p.subarray(r), this.v = 0;
        }
        if (t) {
          if (this.p.length < 8) throw "invalid gzip stream";
          this.p = this.p.subarray(0, -8);
        }
        Wi.prototype.c.call(this, t);
      }, e;
    }(),
    ts = function () {
      return function (e) {
        this.ondata = e, ki([bi, wi, function () {
          return [Ii, Wi, es];
        }], this, 0, function () {
          var e = new es();
          onmessage = Ii(e);
        }, 9);
      };
    }();
  function rs(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [bi, wi, function () {
      return [ns];
    }], function (e) {
      return Ci(ns(e.data[0]));
    }, 3, r);
  }
  function ns(e, t) {
    return ei(e.subarray(Oi(e), -8), t || new Cn(Fi(e)));
  }
  var is = function () {
      function e(e, t) {
        this.c = fi(), this.v = 1, Gi.call(this, e, t);
      }
      return e.prototype.push = function (e, t) {
        Gi.prototype.push.call(this, e, t);
      }, e.prototype.p = function (e, t) {
        this.c.p(e);
        var r = mi(e, this.o, this.v && 2, t && 4, !t);
        this.v && (Ni(r, this.o), this.v = 0), t && Ri(r, r.length - 4, this.c.d()), this.ondata(r, t);
      }, e;
    }(),
    ss = function () {
      return function (e, t) {
        ki([yi, Ei, function () {
          return [Ii, Gi, is];
        }], this, zi.call(this, e, t), function (e) {
          var t = new is(e.data);
          onmessage = Ii(t);
        }, 10);
      };
    }();
  function os(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [yi, Ei, function () {
      return [as];
    }], function (e) {
      return Ci(as(e.data[0], e.data[1]));
    }, 4, r);
  }
  function as(e, t) {
    t || (t = {});
    var r = fi();
    r.p(e);
    var n = mi(e, t, 2, 4);
    return Ni(n, t), Ri(n, n.length - 4, r.d()), n;
  }
  var ls = function () {
      function e(e) {
        this.v = 1, Wi.call(this, e);
      }
      return e.prototype.push = function (e, t) {
        if (Wi.prototype.e.call(this, e), this.v) {
          if (this.p.length < 2 && !t) return;
          this.p = this.p.subarray(2), this.v = 0;
        }
        if (t) {
          if (this.p.length < 4) throw "invalid zlib stream";
          this.p = this.p.subarray(0, -4);
        }
        Wi.prototype.c.call(this, t);
      }, e;
    }(),
    cs = function () {
      return function (e) {
        this.ondata = e, ki([bi, Si, function () {
          return [Ii, Wi, ls];
        }], this, 0, function () {
          var e = new ls();
          onmessage = Ii(e);
        }, 11);
      };
    }();
  function us(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return Ti(e, t, [bi, Si, function () {
      return [hs];
    }], function (e) {
      return Ci(hs(e.data[0], Mi(e.data[1])));
    }, 5, r);
  }
  function hs(e, t) {
    return ei((ji(e), e.subarray(2, -4)), t);
  }
  var ps = function () {
      function e(e) {
        this.G = es, this.I = Wi, this.Z = ls, this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no stream handler";
        if (this.s) this.s.push(e, t);else {
          if (this.p && this.p.length) {
            var r = new Cn(this.p.length + e.length);
            r.set(this.p), r.set(e, this.p.length);
          } else this.p = e;
          if (this.p.length > 2) {
            var n = this,
              i = function () {
                n.ondata.apply(n, arguments);
              };
            this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
          }
        }
      }, e;
    }(),
    ds = function () {
      function e(e) {
        this.G = ts, this.I = qi, this.Z = cs, this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        ps.prototype.push.call(this, e, t);
      }, e;
    }();
  function fs(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? rs(e, t, r) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Xi(e, t, r) : us(e, t, r);
  }
  function ms(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? ns(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Yi(e, t) : hs(e, t);
  }
  var _s = function (e, t, r, n) {
      for (var i in e) {
        var s = e[i],
          o = t + i;
        s instanceof Cn ? r[o] = [s, n] : Array.isArray(s) ? r[o] = [s[0], _i(n, s[1])] : _s(s, o + "/", r, n);
      }
    },
    gs = "undefined" != typeof TextEncoder && new TextEncoder(),
    vs = "undefined" != typeof TextDecoder && new TextDecoder(),
    As = 0;
  try {
    vs.decode(ui, {
      stream: !0
    }), As = 1;
  } catch (ru) {}
  var bs = function (e) {
      for (var t = "", r = 0;;) {
        var n = e[r++],
          i = (n > 127) + (n > 223) + (n > 239);
        if (r + i > e.length) return [t, $n(e, r - 1)];
        i ? 3 == i ? (n = ((15 & n) << 18 | (63 & e[r++]) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) - 65536, t += String.fromCharCode(55296 | n >> 10, 56320 | 1023 & n)) : t += 1 & i ? String.fromCharCode((31 & n) << 6 | 63 & e[r++]) : String.fromCharCode((15 & n) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) : t += String.fromCharCode(n);
      }
    },
    ys = function () {
      function e(e) {
        this.ondata = e, As ? this.t = new TextDecoder() : this.p = ui;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (t = !!t, this.t) {
          if (this.ondata(this.t.decode(e, {
            stream: !0
          }), t), t) {
            if (this.t.decode().length) throw "invalid utf-8 data";
            this.t = null;
          }
        } else {
          if (!this.p) throw "stream finished";
          var r = new Cn(this.p.length + e.length);
          r.set(this.p), r.set(e, this.p.length);
          var n = bs(r),
            i = n[0],
            s = n[1];
          if (t) {
            if (s.length) throw "invalid utf-8 data";
            this.p = null;
          } else this.p = s;
          this.ondata(i, t);
        }
      }, e;
    }(),
    xs = function () {
      function e(e) {
        this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (this.d) throw "stream finished";
        this.ondata(ws(e), this.d = t || !1);
      }, e;
    }();
  function ws(e, t) {
    if (t) {
      for (var r = new Cn(e.length), n = 0; n < e.length; ++n) r[n] = e.charCodeAt(n);
      return r;
    }
    if (gs) return gs.encode(e);
    var i = e.length,
      s = new Cn(e.length + (e.length >> 1)),
      o = 0,
      a = function (e) {
        s[o++] = e;
      };
    for (n = 0; n < i; ++n) {
      if (o + 5 > s.length) {
        var l = new Cn(o + 8 + (i - n << 1));
        l.set(s), s = l;
      }
      var c = e.charCodeAt(n);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++n)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }
    return $n(s, 0, o);
  }
  function Es(e, t) {
    if (t) {
      for (var r = "", n = 0; n < e.length; n += 16384) r += String.fromCharCode.apply(null, e.subarray(n, n + 16384));
      return r;
    }
    if (vs) return vs.decode(e);
    var i = bs(e),
      s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }
  var Ss = function (e) {
      return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
    },
    Cs = function (e, t) {
      return t + 30 + Di(e, t + 26) + Di(e, t + 28);
    },
    Ms = function (e, t, r) {
      var n = Di(e, t + 28),
        i = Es(e.subarray(t + 46, t + 46 + n), !(2048 & Di(e, t + 8))),
        s = t + 46 + n,
        o = Pi(e, t + 20),
        a = r && 4294967295 == o ? Ts(e, s) : [o, Pi(e, t + 24), Pi(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
      return [Di(e, t + 10), l, c, i, s + Di(e, t + 30) + Di(e, t + 32), u];
    },
    Ts = function (e, t) {
      for (; 1 != Di(e, t); t += 4 + Di(e, t + 2));
      return [Bi(e, t + 12), Bi(e, t + 4), Bi(e, t + 20)];
    },
    Is = function (e) {
      var t = 0;
      if (e) for (var r in e) {
        var n = e[r].length;
        if (n > 65535) throw "extra field too long";
        t += n + 4;
      }
      return t;
    },
    ks = function (e, t, r, n, i, s, o, a) {
      var l = n.length,
        c = r.extra,
        u = a && a.length,
        h = Is(c);
      Ri(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = r.os), e[t] = 20, t += 2, e[t++] = r.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & r.compression, e[t++] = r.compression >> 8;
      var p = new Date(null == r.mtime ? Date.now() : r.mtime),
        d = p.getFullYear() - 1980;
      if (d < 0 || d > 119) throw "date not in range 1980-2099";
      if (Ri(e, t, d << 25 | p.getMonth() + 1 << 21 | p.getDate() << 16 | p.getHours() << 11 | p.getMinutes() << 5 | p.getSeconds() >>> 1), t += 4, null != s && (Ri(e, t, r.crc), Ri(e, t + 4, s), Ri(e, t + 8, r.size)), Ri(e, t + 12, l), Ri(e, t + 14, h), t += 16, null != o && (Ri(e, t, u), Ri(e, t + 6, r.attrs), Ri(e, t + 10, o), t += 14), e.set(n, t), t += l, h) for (var f in c) {
        var m = c[f],
          _ = m.length;
        Ri(e, t, +f), Ri(e, t + 2, _), e.set(m, t + 4), t += 4 + _;
      }
      return u && (e.set(a, t), t += u), t;
    },
    Ds = function (e, t, r, n, i) {
      Ri(e, t, 101010256), Ri(e, t + 8, r), Ri(e, t + 10, r), Ri(e, t + 12, n), Ri(e, t + 16, i);
    },
    Ps = function () {
      function e(e) {
        this.filename = e, this.c = di(), this.size = 0, this.compression = 0;
      }
      return e.prototype.process = function (e, t) {
        this.ondata(null, e, t);
      }, e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
        this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
      }, e;
    }(),
    Bs = function () {
      function e(e, t) {
        var r = this;
        t || (t = {}), Ps.call(this, e), this.d = new Gi(t, function (e, t) {
          r.ondata(null, e, t);
        }), this.compression = 8, this.flag = Ss(t.level);
      }
      return e.prototype.process = function (e, t) {
        try {
          this.d.push(e, t);
        } catch (e) {
          this.ondata(e, null, t);
        }
      }, e.prototype.push = function (e, t) {
        Ps.prototype.push.call(this, e, t);
      }, e;
    }(),
    Rs = function () {
      function e(e, t) {
        var r = this;
        t || (t = {}), Ps.call(this, e), this.d = new Vi(t, function (e, t, n) {
          r.ondata(e, t, n);
        }), this.compression = 8, this.flag = Ss(t.level), this.terminate = this.d.terminate;
      }
      return e.prototype.process = function (e, t) {
        this.d.push(e, t);
      }, e.prototype.push = function (e, t) {
        Ps.prototype.push.call(this, e, t);
      }, e;
    }(),
    Ls = function () {
      function e(e) {
        this.ondata = e, this.u = [], this.d = 1;
      }
      return e.prototype.add = function (e) {
        var t = this;
        if (2 & this.d) throw "stream finished";
        var r = ws(e.filename),
          n = r.length,
          i = e.comment,
          s = i && ws(i),
          o = n != e.filename.length || s && i.length != s.length,
          a = n + Is(e.extra) + 30;
        if (n > 65535) throw "filename too long";
        var l = new Cn(a);
        ks(l, 0, e, r, o);
        var c = [l],
          u = function () {
            for (var e = 0, r = c; e < r.length; e++) {
              var n = r[e];
              t.ondata(null, n, !1);
            }
            c = [];
          },
          h = this.d;
        this.d = 0;
        var p = this.u.length,
          d = _i(e, {
            f: r,
            u: o,
            o: s,
            t: function () {
              e.terminate && e.terminate();
            },
            r: function () {
              if (u(), h) {
                var e = t.u[p + 1];
                e ? e.r() : t.d = 1;
              }
              h = 1;
            }
          }),
          f = 0;
        e.ondata = function (r, n, i) {
          if (r) t.ondata(r, n, i), t.terminate();else if (f += n.length, c.push(n), i) {
            var s = new Cn(16);
            Ri(s, 0, 134695760), Ri(s, 4, e.crc), Ri(s, 8, f), Ri(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, h && d.r(), h = 1;
          } else h && u();
        }, this.u.push(d);
      }, e.prototype.end = function () {
        var e = this;
        if (2 & this.d) {
          if (1 & this.d) throw "stream finishing";
          throw "stream finished";
        }
        this.d ? this.e() : this.u.push({
          r: function () {
            1 & e.d && (e.u.splice(-1, 1), e.e());
          },
          t: function () {}
        }), this.d = 3;
      }, e.prototype.e = function () {
        for (var e = 0, t = 0, r = 0, n = 0, i = this.u; n < i.length; n++) r += 46 + (l = i[n]).f.length + Is(l.extra) + (l.o ? l.o.length : 0);
        for (var s = new Cn(r + 22), o = 0, a = this.u; o < a.length; o++) {
          var l = a[o];
          ks(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + Is(l.extra) + (l.o ? l.o.length : 0), t += l.b;
        }
        Ds(s, e, this.u.length, r, t), this.ondata(null, s, !0), this.d = 2;
      }, e.prototype.terminate = function () {
        for (var e = 0, t = this.u; e < t.length; e++) t[e].t();
        this.d = 2;
      }, e;
    }();
  function Os(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    var n = {};
    _s(e, "", n, t);
    var i = Object.keys(n),
      s = i.length,
      o = 0,
      a = 0,
      l = s,
      c = new Array(s),
      u = [],
      h = function () {
        for (var e = 0; e < u.length; ++e) u[e]();
      },
      p = function () {
        var e = new Cn(a + 22),
          t = o,
          n = a - o;
        a = 0;
        for (var i = 0; i < l; ++i) {
          var s = c[i];
          try {
            var u = s.c.length;
            ks(e, a, s, s.f, s.u, u);
            var h = 30 + s.f.length + Is(s.extra),
              p = a + h;
            e.set(s.c, p), ks(e, o, s, s.f, s.u, u, a, s.m), o += 16 + h + (s.m ? s.m.length : 0), a = p + u;
          } catch (e) {
            return r(e, null);
          }
        }
        Ds(e, o, c.length, n, t), r(null, e);
      };
    s || p();
    for (var d = function (e) {
        var t = i[e],
          l = n[t],
          d = l[0],
          f = l[1],
          m = di(),
          _ = d.length;
        m.p(d);
        var g = ws(t),
          v = g.length,
          A = f.comment,
          b = A && ws(A),
          y = b && b.length,
          x = Is(f.extra),
          w = 0 == f.level ? 0 : 8,
          E = function (n, i) {
            if (n) h(), r(n, null);else {
              var l = i.length;
              c[e] = _i(f, {
                size: _,
                crc: m.d(),
                c: i,
                f: g,
                m: b,
                u: v != t.length || b && A.length != y,
                compression: w
              }), o += 30 + v + x + l, a += 76 + 2 * (v + x) + (y || 0) + l, --s || p();
            }
          };
        if (v > 65535 && E("filename too long", null), w) {
          if (_ < 16e4) try {
            E(null, Hi(d, f));
          } catch (e) {
            E(e, null);
          } else u.push(Qi(d, f, E));
        } else E(null, d);
      }, f = 0; f < l; ++f) d(f);
    return h;
  }
  function Fs(e, t) {
    t || (t = {});
    var r = {},
      n = [];
    _s(e, "", r, t);
    var i = 0,
      s = 0;
    for (var o in r) {
      var a = r[o],
        l = a[0],
        c = a[1],
        u = 0 == c.level ? 0 : 8,
        h = (w = ws(o)).length,
        p = c.comment,
        d = p && ws(p),
        f = d && d.length,
        m = Is(c.extra);
      if (h > 65535) throw "filename too long";
      var _ = u ? Hi(l, c) : l,
        g = _.length,
        v = di();
      v.p(l), n.push(_i(c, {
        size: l.length,
        crc: v.d(),
        c: _,
        f: w,
        m: d,
        u: h != o.length || d && p.length != f,
        o: i,
        compression: u
      })), i += 30 + h + m + g, s += 76 + 2 * (h + m) + (f || 0) + g;
    }
    for (var A = new Cn(s + 22), b = i, y = s - i, x = 0; x < n.length; ++x) {
      var w = n[x];
      ks(A, w.o, w, w.f, w.u, w.c.length);
      var E = 30 + w.f.length + Is(w.extra);
      A.set(w.c, w.o + E), ks(A, i, w, w.f, w.u, w.c.length, w.o, w.m), i += 16 + E + (w.m ? w.m.length : 0);
    }
    return Ds(A, i, n.length, y, b), A;
  }
  var Us = function () {
      function e() {}
      return e.prototype.push = function (e, t) {
        this.ondata(null, e, t);
      }, e.compression = 0, e;
    }(),
    Ns = function () {
      function e() {
        var e = this;
        this.i = new Wi(function (t, r) {
          e.ondata(null, t, r);
        });
      }
      return e.prototype.push = function (e, t) {
        try {
          this.i.push(e, t);
        } catch (r) {
          this.ondata(r, e, t);
        }
      }, e.compression = 8, e;
    }(),
    js = function () {
      function e(e, t) {
        var r = this;
        t < 32e4 ? this.i = new Wi(function (e, t) {
          r.ondata(null, e, t);
        }) : (this.i = new qi(function (e, t, n) {
          r.ondata(e, t, n);
        }), this.terminate = this.i.terminate);
      }
      return e.prototype.push = function (e, t) {
        this.i.terminate && (e = $n(e, 0)), this.i.push(e, t);
      }, e.compression = 8, e;
    }(),
    zs = function () {
      function e(e) {
        this.onfile = e, this.k = [], this.o = {
          0: Us
        }, this.p = ui;
      }
      return e.prototype.push = function (e, t) {
        var r = this;
        if (!this.onfile) throw "no callback";
        if (!this.p) throw "stream finished";
        if (this.c > 0) {
          var n = Math.min(this.c, e.length),
            i = e.subarray(0, n);
          if (this.c -= n, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(n)).length) return this.push(e, t);
        } else {
          var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
          this.p.length ? e.length ? ((l = new Cn(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
          for (var c = l.length, u = this.c, h = u && this.d, p = function () {
              var e,
                t = Pi(l, o);
              if (67324752 == t) {
                s = 1, a = o, d.d = null, d.c = 0;
                var n = Di(l, o + 6),
                  i = Di(l, o + 8),
                  h = 2048 & n,
                  p = 8 & n,
                  f = Di(l, o + 26),
                  m = Di(l, o + 28);
                if (c > o + 30 + f + m) {
                  var _ = [];
                  d.k.unshift(_), s = 2;
                  var g,
                    v = Pi(l, o + 18),
                    A = Pi(l, o + 22),
                    b = Es(l.subarray(o + 30, o += 30 + f), !h);
                  4294967295 == v ? (e = p ? [-2] : Ts(l, o), v = e[0], A = e[1]) : p && (v = -1), o += m, d.c = v;
                  var y = {
                    name: b,
                    compression: i,
                    start: function () {
                      if (!y.ondata) throw "no callback";
                      if (v) {
                        var e = r.o[i];
                        if (!e) throw "unknown compression type " + i;
                        (g = v < 0 ? new e(b) : new e(b, v, A)).ondata = function (e, t, r) {
                          y.ondata(e, t, r);
                        };
                        for (var t = 0, n = _; t < n.length; t++) {
                          var s = n[t];
                          g.push(s, !1);
                        }
                        r.k[0] == _ && r.c ? r.d = g : g.push(ui, !0);
                      } else y.ondata(null, ui, !0);
                    },
                    terminate: function () {
                      g && g.terminate && g.terminate();
                    }
                  };
                  v >= 0 && (y.size = v, y.originalSize = A), d.onfile(y);
                }
                return "break";
              }
              if (u) {
                if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
                if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
              }
            }, d = this; o < c - 4 && "break" !== p(); ++o);
          if (this.p = ui, u < 0) {
            var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == Pi(l, a - 16) && 4)) : l.subarray(0, o);
            h ? h.push(f, !!s) : this.k[+(2 == s)].push(f);
          }
          if (2 & s) return this.push(l.subarray(o), t);
          this.p = l.subarray(o);
        }
        if (t) {
          if (this.c) throw "invalid zip file";
          this.p = null;
        }
      }, e.prototype.register = function (e) {
        this.o[e.compression] = e;
      }, e;
    }();
  function Gs(e, t) {
    if ("function" != typeof t) throw "no callback";
    for (var r = [], n = function () {
        for (var e = 0; e < r.length; ++e) r[e]();
      }, i = {}, s = e.length - 22; 101010256 != Pi(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);
    var o = Di(e, s + 8);
    o || t(null, {});
    var a = o,
      l = Pi(e, s + 16),
      c = 4294967295 == l;
    if (c) {
      if (s = Pi(e, s - 12), 101075792 != Pi(e, s)) return void t("invalid zip file", null);
      a = o = Pi(e, s + 32), l = Pi(e, s + 48);
    }
    for (var u = function (s) {
        var a = Ms(e, l, c),
          u = a[0],
          h = a[1],
          p = a[2],
          d = a[3],
          f = a[4],
          m = a[5],
          _ = Cs(e, m);
        l = f;
        var g = function (e, r) {
          e ? (n(), t(e, null)) : (i[d] = r, --o || t(null, i));
        };
        if (u) {
          if (8 == u) {
            var v = e.subarray(_, _ + h);
            if (h < 32e4) try {
              g(null, Yi(v, new Cn(p)));
            } catch (e) {
              g(e, null);
            } else r.push(Xi(v, {
              size: p
            }, g));
          } else g("unknown compression type " + u, null);
        } else g(null, $n(e, _, _ + h));
      }, h = 0; h < a; ++h) u();
    return n;
  }
  function Vs(e) {
    for (var t = {}, r = e.length - 22; 101010256 != Pi(e, r); --r) if (!r || e.length - r > 65558) throw "invalid zip file";
    var n = Di(e, r + 8);
    if (!n) return {};
    var i = Pi(e, r + 16),
      s = 4294967295 == i;
    if (s) {
      if (r = Pi(e, r - 12), 101075792 != Pi(e, r)) throw "invalid zip file";
      n = Pi(e, r + 32), i = Pi(e, r + 48);
    }
    for (var o = 0; o < n; ++o) {
      var a = Ms(e, i, s),
        l = a[0],
        c = a[1],
        u = a[2],
        h = a[3],
        p = a[4],
        d = a[5],
        f = Cs(e, d);
      if (i = p, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[h] = Yi(e.subarray(f, f + c), new Cn(u));
      } else t[h] = $n(e, f, f + c);
    }
    return t;
  }
  class Qs extends n.hH6 {
    load(e, t, r, n) {
      return this.setResponseType("arraybuffer"), super.load(e, e => {
        const r = Vs(new Uint8Array(e)),
          n = new Map(Object.entries(r).map(([e, t]) => [e, new File([t], e)]));
        null == t || t(n);
      }, r, n);
    }
  }
  function Hs() {
    Js.Importers.push(new ir(Qs, ["zip"], !0));
  }
  class Ws extends n.Ox3 {
    constructor(e, t) {
      super(), this.assetType = "light", this.isDirectionalLight2 = !0, this.color = new n.Ilk(e), this.intensity = t || 1, this.target.position.set(0, 0, -1), this.add(this.target);
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e, t) {
      const r = this.target,
        n = e.userData;
      return e.userData = {}, super.copy(e, t), je(this.userData, n), r.position.copy(this.target.position), r.updateMatrixWorld(), this.target = r, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Directional Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [-.1, .1],
          stepSize: .005,
          label: "Shadow Normal Bias",
          property: [null == this ? void 0 : this.shadow, "normalBias"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [.1, 50],
          label: "Shadow frustum",
          getValue: () => 2 * this.shadow.camera.right,
          setValue: e => {
            this.shadow.camera.left = -e / 2, this.shadow.camera.right = e / 2, this.shadow.camera.top = e / 2, this.shadow.camera.bottom = -e / 2;
          },
          onChange: this.setDirty
        }]
      };
    }
    toJSON(e) {
      const {
        userData: t,
        children: r
      } = this;
      this.userData = {}, this.children = [];
      const n = super.toJSON(e);
      return n.userData = ke(je({}, t), !1), this.userData = {}, this.children = r, n.type = "DirectionalLight2", n.target = this.target.position.toArray(), Object.assign(n, ke(this, !0, e));
    }
    fromJSON(e, t) {
      if ("DirectionalLight2" !== e.type) return null;
      const r = e.target,
        n = e.object;
      return e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld(), delete e.target), e.object && delete e.object, De(e, this, !0, t), r && (e.target = r), n && (void 0 !== n.color && this.color.set(n.color), void 0 !== n.intensity && (this.intensity = n.intensity), e.object = n), this;
    }
  }
  class qs extends n.PMe {
    constructor(e, t, r, n, i, s) {
      super(e, t, r, n, i, s), this.assetType = "light", this.target.position.set(0, 0, -1), this.add(this.target);
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e, t) {
      const r = this.target,
        n = e.userData;
      return e.userData = {}, super.copy(e, t), je(this.userData, n), r.position.copy(this.target.position), r.updateMatrixWorld(), this.target = r, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Spot Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 30],
          property: [this, "intensity"]
        }, {
          type: "slider",
          bounds: [0, 2],
          property: [this, "angle"]
        }, {
          type: "slider",
          bounds: [0, .9999],
          property: [this, "penumbra"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.setDirty
        }]
      };
    }
    toJSON(e) {
      const {
        userData: t,
        children: r
      } = this;
      this.userData = {}, this.children = [];
      const n = super.toJSON(e);
      return n.userData = ke(je({}, t), !1), this.userData = {}, this.children = r, n.type = "SpotLight2", n.target = this.target.position.toArray(), Object.assign(n, ke(this, !0, e));
    }
    fromJSON(e, t) {
      return "SpotLight2" !== e.type ? null : (e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld()), e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), void 0 !== e.object.distance && (this.distance = e.object.distance), void 0 !== e.object.angle && (this.angle = e.object.angle), void 0 !== e.object.decay && (this.decay = e.object.decay), void 0 !== e.object.penumbra && (this.penumbra = e.object.penumbra), De(e, this, !0, t), this) : this);
    }
  }
  class Xs extends n.cek {
    constructor(e, t, r, n) {
      super(e, t, r, n), this.assetType = "light";
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e, t) {
      const r = e.userData;
      return e.userData = {}, super.copy(e, t), je(this.userData, r), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Point Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 30],
          property: [this, "intensity"]
        }, {
          type: "input",
          label: "Distance",
          property: [this, "distance"]
        }, {
          type: "input",
          property: [this, "decay"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.setDirty
        }]
      };
    }
    toJSON(e) {
      const {
        userData: t
      } = this;
      this.userData = {};
      const r = super.toJSON(e);
      return r.userData = ke(je({}, t), !1), this.userData = {}, r.type = "PointLight2", Object.assign(r, ke(this, !0, e));
    }
    fromJSON(e, t) {
      return "PointLight2" !== e.type ? null : e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), void 0 !== e.object.distance && (this.distance = e.object.distance), void 0 !== e.object.decay && (this.decay = e.object.decay), De(e, this, !0, t), this) : this;
    }
  }
  class Ys extends n.Mig {
    constructor(e, t) {
      super(e, t), this.assetType = "light";
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e, t) {
      const r = e.userData;
      return e.userData = {}, super.copy(e, t), je(this.userData, r), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ambient Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }]
      };
    }
    toJSON(e) {
      const {
        userData: t
      } = this;
      this.userData = {};
      const r = super.toJSON(e);
      return r.userData = ke(je({}, t), !1), this.userData = {}, r.type = "AmbientLight2", Object.assign(r, ke(this, !0, e));
    }
    fromJSON(e, t) {
      return "AmbientLight2" !== e.type ? null : e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), De(e, this, !0, t), this) : this;
    }
  }
  class Ks extends n.aNw {
    load(e, t, r, i) {
      const s = new n.hH6(this.manager);
      s.setPath(this.path), s.setResponseType("text"), s.load(e, r => {
        try {
          t(this.parse(r));
        } catch (t) {
          i ? i(t) : console.error(t), this.manager.itemError(e);
        }
      }, r, i);
    }
    parse(e) {
      e = e.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
      let t = null,
        r = null;
      const i = new n.Pa4(0, 0, 0),
        s = new n.Pa4(1, 1, 1),
        o = e.split(/[\n\r]+/g);
      let a = null,
        l = 0;
      for (let e = 0, n = o.length; e < n; e++) {
        const n = o[e].trim(),
          c = n.split(/\s/g);
        switch (c[0]) {
          case "TITLE":
            t = n.substring(7, n.length - 1);
            break;
          case "LUT_3D_SIZE":
            const e = c[1];
            r = parseFloat(e), a = new Uint8Array(r * r * r * 4);
            break;
          case "DOMAIN_MIN":
            i.x = parseFloat(c[1]), i.y = parseFloat(c[2]), i.z = parseFloat(c[3]);
            break;
          case "DOMAIN_MAX":
            s.x = parseFloat(c[1]), s.y = parseFloat(c[2]), s.z = parseFloat(c[3]);
            break;
          default:
            const o = parseFloat(c[0]),
              u = parseFloat(c[1]),
              h = parseFloat(c[2]);
            if (o > 1 || o < 0 || u > 1 || u < 0 || h > 1 || h < 0) throw new Error("LUTCubeLoader : Non normalized values not supported.");
            a[l + 0] = 255 * o, a[l + 1] = 255 * u, a[l + 2] = 255 * h, a[l + 3] = 255, l += 4;
        }
      }
      const c = new n.IEO();
      c.image.data = a, c.image.width = r, c.image.height = r * r, c.type = n.ywz, c.magFilter = n.wem, c.minFilter = n.wem, c.wrapS = n.uWy, c.wrapT = n.uWy, c.generateMipmaps = !1, c.needsUpdate = !0;
      const u = new n.JUT();
      return u.image.data = a, u.image.width = r, u.image.height = r, u.image.depth = r, u.type = n.ywz, u.magFilter = n.wem, u.minFilter = n.wem, u.wrapS = n.uWy, u.wrapT = n.uWy, u.wrapR = n.uWy, u.generateMipmaps = !1, u.needsUpdate = !0, {
        title: t,
        size: r,
        domainMin: i,
        domainMax: s,
        texture: c,
        texture3D: u
      };
    }
  }
  class Js extends r {
    constructor(e, t = !1) {
      super(), this._processors = new cr(), this._logger = console.log, this._loaderCache = [], this._fileDatabase = new Map(), this._cachedAssets = [], t || (this._logger = () => {}), this._viewer = e, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new n.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), Hs(), pr(e.renderer.rendererObject), an(e), En();
    }
    get processors() {
      return this._processors;
    }
    get loadingManager() {
      return this._loadingManager;
    }
    _onLoad() {
      this.dispatchEvent({
        type: "onLoad"
      });
    }
    _onProgress(e, t, r) {
      this.dispatchEvent({
        type: "onProgress",
        url: e,
        loaded: t,
        total: r
      });
    }
    _onError(e) {
      this.dispatchEvent({
        type: "onError",
        url: e
      });
    }
    _onStart(e, t, r) {
      this.dispatchEvent({
        type: "onStart",
        url: e,
        loaded: t,
        total: r
      });
    }
    _urlModifier(e) {
      var t;
      let r = decodeURI(e);
      const n = null === (t = this._rootContext) || void 0 === t ? void 0 : t.rootUrl;
      r.includes("://") || !n || r.startsWith(n) || (r = n + r), r = r.replace("./", ""), r = r.replace(/^(\/\/)/, "/"), r = r.replace(/\?.*$/, "");
      const i = this._fileDatabase.get(r);
      return i ? i.ext ? (i.objectUrl || (i.objectUrl = URL.createObjectURL(i) + "#" + r), i.objectUrl) : (console.error("Unable to determine file extension", i), e) : e;
    }
    _createLoader(e) {
      const t = this._getImporter(e),
        r = null == t ? void 0 : t.ctor(this);
      return r && (null == t || t.ext.forEach(e => {
        const t = new RegExp(e.startsWith("data:") ? "^" + e + "\\/" : "\\." + e + "$", "i");
        this._loadingManager.addHandler(t, r);
      })), r && (this._loaderCache.push({
        loader: r,
        files: []
      }), this.dispatchEvent({
        type: "loaderCreate",
        loader: r
      })), r;
    }
    async importFiles(e, t = {}) {
      const r = new Map();
      let {
        allowedExtensions: n
      } = t;
      if (n && n.length < 1 && (n = void 0), 0 === e.size) return r;
      this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "start"
      });
      const i = [],
        s = [];
      if (e.forEach((e, t) => {
        var r;
        this.registerFile(t, e);
        const o = e.ext;
        o && (null === (r = null == n ? void 0 : n.includes(o.toLowerCase())) || void 0 === r || r) && (this._isRootFileExtension(o) ? i.push(t) : s.push(t));
      }), i.length > 0) for (const e of i) {
        let n = await this._importFile(e, void 0, t);
        n && (n = await this.processImported(n, t)), r.set(e, n);
      } else for (const e of s) {
        let n = await this._importFile(e, void 0, t);
        n && (n = await this.processImported(n, t)), r.set(e, n);
      }
      return this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "end"
      }), e.forEach((e, t) => {
        this.unregisterFile(t);
      }), r;
    }
    registerFile(e, t) {
      var r, n, i;
      e = e.replace(/\?.*$/, "");
      const s = null !== (r = null == t ? void 0 : t.ext) && void 0 !== r ? r : null === (i = sr(null !== (n = null == t ? void 0 : t.name) && void 0 !== n ? n : e)) || void 0 === i ? void 0 : i.toLowerCase();
      t && (t.ext || (t.ext = s), this._fileDatabase.set(e, t));
      let o = this._getLoader(e);
      if (o || (o = this._createLoader(null != t ? t : {
        name: e,
        ext: s
      })), o) for (const t of this._loaderCache) if (t.loader === o) {
        t.files.push(e);
        break;
      }
      return o;
    }
    unregisterFile(e) {
      e = e.replace(/\?.*$/, "");
      const t = this._fileDatabase.get(e);
      (null == t ? void 0 : t.objectUrl) && (URL.revokeObjectURL(t.objectUrl), t.objectUrl = void 0), t && this._fileDatabase.delete(e);
    }
    _isRootFileExtension(e) {
      return null != Js.Importers.find(t => t.root && t.ext.includes(e.toLowerCase()));
    }
    resolveURL(e) {
      return this._loadingManager.resolveURL(e);
    }
    async _importFile(e, t, r = {}, i) {
      var s, o;
      if (null === (s = t) || void 0 === s ? void 0 : s.__imported) return t.__imported;
      let a;
      this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "downloading",
        progress: 0
      });
      try {
        this.registerFile(e, t), r.rootPath = e;
        const s = this.resolveURL(e),
          l = e.replace(/\?.*$/, ""),
          c = null !== (o = r.fileHandler) && void 0 !== o ? o : (await this._loadingManager.getHandler(l)) || (t ? await this._loadingManager.getHandler(t.name || t.ext || "") : void 0);
        if (!c) throw new Error("AssetImporter: Unable to find loader for " + e);
        this._rootContext = {
          path: e,
          url: s,
          rootUrl: n.Zp0.extractUrlBase(e),
          baseUrl: n.Zp0.extractUrlBase(s)
        }, a = await c.loadAsync(e + (r.queryString ? (e.includes("?") ? "&" : "?") + r.queryString : ""), t => {
          i && i(t), this.dispatchEvent({
            type: "importFile",
            path: e,
            state: "downloading",
            progress: t.loaded / t.total
          });
        }), this._rootContext = void 0, this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "downloading",
          progress: 1
        }), this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "adding"
        }), t ? this._logger("AssetImporter: loaded", e) : this._logger("AssetImporter: downloaded", e), t && this.unregisterFile(e);
      } catch (r) {
        return console.error("AssetImporter: Unable to import file", e, t), console.error(r), console.error(null == r ? void 0 : r.stack), this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "error",
          error: r
        }), [];
      }
      return this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "done"
      }), t && (t.__imported = a), a;
    }
    _getImporter(e, t = !1) {
      return Js.Importers.find(r => {
        if (t && !r.root) return !1;
        const n = r.ext.find(t => {
          var r, n, i;
          return e.ext && t === e.ext.toLowerCase() || (null === (n = null === (r = e.name) || void 0 === r ? void 0 : r.toLowerCase()) || void 0 === n ? void 0 : n.endsWith("." + t.toLowerCase())) || (null == t ? void 0 : t.startsWith("data:")) && (null === (i = e.name) || void 0 === i ? void 0 : i.startsWith(t));
        });
        return !!n && (e.ext = n, !0);
      });
    }
    _getLoader(e) {
      var t;
      return null !== (t = this._loadingManager.getHandler(e)) && void 0 !== t ? t : void 0;
    }
    async importAsset(e, t = {}, r) {
      var n;
      if (!e) return [];
      if (!this._cachedAssets.includes(e)) {
        if (1 === Object.entries(e).length && e.path) {
          const t = this._cachedAssets.find(t => t.path === e.path);
          t && Object.assign(e, t);
        }
        const t = this._cachedAssets.findIndex(t => t.path === e.path);
        t >= 0 && this._cachedAssets.splice(t, 1), this._cachedAssets.push(e);
      }
      let i;
      if ((null == e ? void 0 : e.preImported) && (i = await e.preImported), !t.forceImport && i) {
        const e = await this.processImported(i, t);
        let r = !1;
        for (const t of e) if (t.__disposed) {
          r = !0;
          break;
        }
        if (!r || !1 === t.reimportDisposed) return e;
      }
      return e.preImported = this._importFile(t.pathOverride || e.path, "function" == typeof (null === (n = e.file) || void 0 === n ? void 0 : n.arrayBuffer) ? e.file : void 0, t, r), i = await e.preImported, i && (i = await this.processImported(i, t)), i;
    }
    async importSingle(e, t = {}) {
      var r;
      return null === (r = await this.importAsset(e, t)) || void 0 === r ? void 0 : r[0];
    }
    async importSinglePath(e, t) {
      var r;
      return null === (r = await this.importPath(e, t)) || void 0 === r ? void 0 : r[0];
    }
    async importPath(e, t = {}) {
      const r = {
        ...t
      };
      delete r.pathOverride, delete r.forceImport, delete r.reimportDisposed;
      const n = JSON.stringify(r);
      let i;
      return i = this._cachedAssets.find(t => t.path === e && t._options === n) || {
        path: e
      }, i._options = n, await this.importAsset(i, t);
    }
    async processImportedSingle(e, t = {}) {
      return (await this.processImported(e, t))[0];
    }
    async processImported(e, t = {}) {
      var r, i, s, o, a, l, c, u;
      let h = e;
      if (!h) return [];
      if (!1 === t.processImported) return [h];
      if (Array.isArray(h)) {
        const e = [];
        for (const r of h) e.push(...(await this.processImported(r, t)));
        return e;
      }
      if (null === (r = h.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) {
        if (t._rootSceneImported = !0, h.__processedChildren && !t.forceImporterReprocess) return h.__processedChildren;
        if (!(h.children.length < 1)) return h.animations && (h.children[0].animations || (h.children[0].animations = []), h.children[0].animations.push(...h.animations)), h.__importedViewerConfig && (h.children[0].__importedViewerConfig = h.__importedViewerConfig), h.__processedChildren = await this.processImported([...h.children], t), h.__processedChildren;
        if ((null === (i = h.animations) || void 0 === i ? void 0 : i.length) > 0 && console.error("AssetImporter: animations in empty scene not supported yet. animations will be ignored", h.animations), !h.__importedViewerConfig) return [];
        h = h.__importedViewerConfig;
      }
      if ((null === (s = h.userData) || void 0 === s ? void 0 : s.iModel) && (h = h.userData.iModel), (null === (o = h.userData) || void 0 === o ? void 0 : o.iMaterial) && (h = h.userData.iMaterial), h.assetImporterProcessed && !t.forceImporterReprocess) return [h];
      if (!h.assetType) {
        if (h.isBufferGeometry && (h = new n.Kj0(h, new n.Wid())), h.isObject3D) {
          if (h.isLight) h = $s(h);else {
            const e = [];
            h.traverse(t => {
              t !== h && t.isLight && e.push(t);
            });
            for (const t of e) $s(t);
            h = new ar(h, t);
          }
          !t.rootPath || h.modelObject.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (h.modelObject.userData.rootPath = t.rootPath);
        }
        h.isTexture && (h.assetType = "texture", t._testDataTextureComplete && (h.isDataTexture && (null === (a = h.image) || void 0 === a ? void 0 : a.data) && (h.image.complete = !0), (null === (l = h.image) || void 0 === l ? void 0 : l.complete) && (h.needsUpdate = !0)), void 0 !== t.generateMipmaps && (h.generateMipmaps = t.generateMipmaps), h.generateMipmaps || h.isRenderTargetTexture || (h.minFilter = h.minFilter === n.D1R ? n.wem : h.minFilter, h.magFilter = h.magFilter === n.D1R ? n.wem : h.magFilter), !t.rootPath || h.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (h.userData.rootPath = t.rootPath)), h.isMaterial && (h.assetType = "material", !t.rootPath || h.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (h.userData.rootPath = t.rootPath));
      }
      if (null != h.assetType) return h = await this._processors.process(h.assetType, h, {}), h.assetImporterProcessed = !0, [h];
      if (h instanceof Map) return [...(await this.importFiles(h, t)).values()].flat();
      if (h.type) {
        const e = this._viewer.getPluginByType(h.type);
        if (e) {
          let t = h._importedResources || {};
          return h.resources && (t = await (null === (c = this._viewer.getManager()) || void 0 === c ? void 0 : c.importConfigResources(h.resources)), delete h.resources, h._importedResources = t), "function" == typeof e.fromJSON && (await Promise.resolve(e.fromJSON(h, t)), h.assetImporterProcessed = !1), [];
        }
      } else if (h.plugins) return h.resources = await (null === (u = this._viewer.getManager()) || void 0 === u ? void 0 : u.importConfigResources(h.resources)), await this._viewer.getManager().importViewerConfig(h), h.assetImporterProcessed = !1, [];
      return console.warn("unknown asset type: ", h), [h];
    }
    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }
  }
  function Zs(e) {
    if (!e) return n.ywz;
    const t = e.extensions.has("EXT_color_buffer_half_float") || e.capabilities.isWebGL2 && e.extensions.has("EXT_color_buffer_float"),
      r = e.capabilities.isWebGL2 || e.extensions.has("OES_texture_float") || e.extensions.has("WEBGL_color_buffer_float");
    return t ? n.cLu : r ? n.VzW : n.ywz;
  }
  function $s(e) {
    var t, r, n;
    if (!e.isLight) return e;
    if ("light" === e.assetType) return e;
    if (e.uiConfig) return console.warn("ui config already exists, not supported", e), e;
    let i;
    if (e.children.length, e.isDirectionalLight && (i = new Ws()), e.isAmbientLight && (i = new Ys()), e.isSpotLight && (i = new qs()), e.isPointLight && (i = new Xs()), i) {
      null === (r = (t = i.lightObject).copy) || void 0 === r || r.call(t, e);
      const s = e.parent;
      (null === (n = s) || void 0 === n ? void 0 : n.isObject3D) && (s.remove(e), e.dispose(), e.userData.iModel = i, s.add(i.lightObject), i.uuid = e.uuid), Le(i.lightObject, s);
    } else console.warn("unknown light type: ", e);
    return i;
  }
  Js.Importers = [new ir(ur, ["json"], !1), new ir(n.hH6, ["txt"], !1), new ir(nn, ["rgbe.png", "hdr.png", "hdrpng"], !1), new ir(n.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], !1), new ir(Ks, ["CUBE"], !1)];
  class eo extends n.u7G {
    constructor(e) {
      super(e);
    }
    async loadAsync(e, t) {
      var r;
      const i = new n.hH6(this.manager);
      i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
      const s = await i.loadAsync(e, t);
      try {
        const e = JSON.parse(s);
        if (e.images && this.importer) {
          const t = {};
          let i = e.images;
          Array.isArray(i) || (i = Object.values(i));
          for (const i of e.images) {
            if (!i.url || !i.uuid) continue;
            const e = null === (r = await this.importer.importPath(i.url, {
                processImported: !1
              })) || void 0 === r ? void 0 : r[0],
              s = null == e ? void 0 : e.source;
            if (!e || !s) continue;
            const o = new n.Hw6(s.data);
            o.uuid = i.uuid, t[o.uuid] = o, e.dispose();
          }
          return this.parse(e, t);
        }
        return this.parse(e);
      } catch (t) {
        throw console.error(t), this.manager.itemError(e), t;
      }
    }
    parse(e, t) {
      var r, i;
      let s;
      const o = {
        p: new Promise(e => {
          s = e;
        })
      };
      if (e.images || e.textures) {
        const r = new sn(this.manager);
        let n = {};
        const i = e => {
          s(), o.p = void 0, Object.values(n).forEach(e => {
            var t;
            e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
          });
        };
        let a = e.images || [];
        Array.isArray(a) || (a = Object.values(a));
        const l = t || r.parseImages(a, i);
        let c = e.textures;
        Array.isArray(c) || (c = Object.values(c)), n = r.parseTextures2(c, l, i), this.setTextures(n);
      }
      this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
      const a = {
        ...e
      };
      if (Object.entries(a).forEach(([e, t]) => {
        t && "string" == typeof t && this.textures[t] && (a[e] = this.textures[t]);
      }), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), void 0 !== e.normalScale) {
        let t = e.normalScale;
        !1 === Array.isArray(t) && (t = [t, t]), a.normalScale = new n.FM8().fromArray(t);
      }
      let l = e.type;
      "MeshPhysicalMaterial" !== l && "MeshStandardMaterial" !== l || (l = Kt.TYPE), a.userData = De(a.userData, void 0, !1, this);
      const c = null !== (i = null === (r = this.materials) || void 0 === r ? void 0 : r.generateFromTemplateType(l, a)) && void 0 !== i ? i : super.parse(e);
      return this.setTextures({}), c.userData.imageLoadAwaiter = o, c;
    }
  }
  class to extends r {
    constructor(e, t, {
      simpleCache: r = !1,
      storage: i
    } = {}) {
      if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (r || i) && (r && (n.CtF.enabled = !0), i && window.Cache && "function" == typeof window.Cache && i instanceof window.Cache)) {
        const e = {
          ...n.CtF
        };
        n.CtF.get = (t, r, n) => r ? t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") ? Promise.resolve(void 0) : i.match(t).then(e => {
          if (e) switch (r) {
            case "arraybuffer":
              return e.arrayBuffer();
            case "blob":
              return e.blob();
            case "document":
              return e.text().then(e => new DOMParser().parseFromString(e, null != n ? n : "text/html"));
            case "json":
              return e.json();
            default:
              if (void 0 === n) return e.text();
              {
                const t = /charset="?([^;"\s]*)"?/i.exec(n),
                  r = t && t[1] ? t[1].toLowerCase() : void 0,
                  i = new TextDecoder(r);
                return e.arrayBuffer().then(e => i.decode(e));
              }
          }
        }) : e.get(t), n.CtF.add = (t, r, n) => {
          n || e.add(t, r), t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") || i.put(t, new Response(r, {
            status: 200
          }));
        }, n.CtF.remove = (t, r) => {
          r || e.remove(t), i.delete(t);
        };
      }
      this._importer = e, this._materials = t;
    }
    async addAsset(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const r = await this._importer.importAsset(e, t);
      return r ? (this.addProcessedAssets(r, t), r) : (console.warn("Unable to import", e, r), []);
    }
    async addFromPath(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const r = await this._importer.importPath(e, t);
      return r ? (this.addProcessedAssets(r, t), r) : (console.warn("Unable to import", e, r), []);
    }
    addProcessedAssets(e, t) {
      return e.map(e => {
        var r;
        return null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.addSceneObject(e, t);
      });
    }
    async addAssetSingle(e, t = {}) {
      var r;
      return e ? null === (r = await ("string" == typeof e ? this.addFromPath : this.addAsset)(e, t)) || void 0 === r ? void 0 : r[0] : void 0;
    }
    async addImported(e, t = {}) {
      var r;
      return null === (r = this._importer) || void 0 === r ? void 0 : r.processImported(e, t).then(e => (this.addProcessedAssets(e, t), e));
    }
    async addImportedSingle(e, t = {}) {
      return this.addImported(e, t).then(e => null == e ? void 0 : e[0]);
    }
    _sceneUpdated(e) {
      var t;
      if ("addSceneObject" === e.type) {
        const r = e.object;
        "material" === r.assetType && (null === (t = this._materials) || void 0 === t || t.processMaterial(r, {}));
      } else console.error("Unexpected");
    }
    async onAdded(e) {
      this._viewer = e, this._materials || (this._materials = new nr(), this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new Js(e, !!e.getPluginByType("debug")), this._importer.processors.add("model", {
        forAssetType: "model",
        process: (e, t) => (lr(e, e => {
          var t;
          return null === (t = this._materials) || void 0 === t ? void 0 : t.processModel(e, {
            recursive: !1
          });
        }), e)
      }), this._importer.processors.add("model", {
        forAssetType: "model",
        process: this._materials.processModel
      }), this._importer.processors.add("material", {
        forAssetType: "material",
        process: (e, t) => {
          var r;
          return (null === (r = this.materials) || void 0 === r ? void 0 : r.findMaterial(e.uuid)) && (console.warn("imported material uuid already exists, creating new uuid"), e.uuid = $(), e.userData.uuid && (e.userData.uuid = e.uuid)), this._materials.processMaterial(e, t);
        }
      })), Js.Importers.push(new ir(eo, [Kt.TypeSlug], !1, e => (e && (e.materials = this._materials), e && (e.importer = this._importer), e)));
      const t = this.importViewerConfig.bind(this);
      Js.Importers.push(new ir(class extends ur {
        async loadAsync(e, r) {
          return t(await super.loadAsync(e, r));
        }
      }, [to.ViewerTypeSlug], !0));
    }
    async onDispose(e) {}
    async onRemove(e) {
      var t, r;
      e === this._viewer && (null === (t = this._importer) || void 0 === t || t.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (r = this._materials) || void 0 === r || r.dispose(), this._materials = void 0);
    }
    get importer() {
      return this._importer;
    }
    get exporter() {
      var e, t;
      return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("AssetExporterPlugin")) || void 0 === t ? void 0 : t.exporter;
    }
    get materials() {
      return this._materials;
    }
    exportViewerConfig(e) {
      if (!this._viewer) return {};
      const t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          ...e
        },
        r = this._viewer.toJSON(t);
      return r.resources = t, r;
    }
    exportPluginPresets(e) {
      var t;
      const r = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      return {
        plugins: null === (t = this._viewer) || void 0 === t ? void 0 : t.serializePlugins(r, e),
        resources: r
      };
    }
    exportPluginPreset(e) {
      if (!e.toJSON) return;
      const t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {}
        },
        r = e.toJSON(t);
      return r.resources = t, r;
    }
    async importPluginPreset(e, t) {
      var r;
      const n = e.type;
      if (!(t = t || (null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType(n)))) return void console.warn(`No plugin found for type ${n} to import preset`);
      if (!t.fromJSON) return void console.warn(`Plugin ${n} does not support importing presets`);
      const i = e.resources || {};
      return e.resources && delete e.resources, await t.fromJSON(e, i), i && (e.resources = i), t;
    }
    async importViewerConfig(e, t) {
      if (!this._viewer || !this._importer) return void console.warn("No viewer or importer");
      const r = await this.importConfigResources(e.resources || {}, t);
      this.applyViewerConfig(e, r);
    }
    applyViewerConfig(e, t) {
      var r;
      if (this._viewer && this._importer) {
        if ((t = t || e.resources).__isLoadedResources) {
          this._viewer.fromJSON(e, t);
          for (const e of Object.values(t.materials)) e.__useCount ? delete e.__useCount : null === (r = this._materials) || void 0 === r || r.unregisterMaterial(e);
          for (const e of Object.values(t.textures)) e.__useCount && delete e.__useCount;
        } else console.error("Cannot load viewer config: resources not loaded", e);
      } else console.warn("No viewer or importer");
    }
    async importConfigResources(e, t, r) {
      var i, s, o;
      if (!this._importer) throw "Importer not initialized yet.";
      if (e.__isLoadedResources) return e;
      const a = {};
      t = null != t ? t : new sn(this._importer.loadingManager), a.animations = e.animations ? t.parseAnimations(e.animations) : {}, r && r.animations && (a.animations = {
        ...a.animations,
        ...r.animations
      }), a.shapes = e.shapes ? t.parseShapes(e.shapes) : {}, r && r.shapes && (a.shapes = {
        ...a.shapes,
        ...r.shapes
      }), a.geometries = e.geometries ? t.parseGeometries(e.geometries, a.shapes) : {}, r && r.geometries && (a.geometries = {
        ...a.geometries,
        ...r.geometries
      }), a.images = e.images ? await t.parseImagesAsync(Object.values(e.images)) : {}, r && r.images && (a.images = {
        ...a.images,
        ...r.images
      });
      for (const t of Object.values(e.textures)) {
        const e = null === (i = null == t ? void 0 : t.userData) || void 0 === i ? void 0 : i.rootPath;
        if (e && (!t.image || !a.images[t.image])) {
          const r = null === (s = await this._importer.importPath(e, {
              processImported: !1
            })) || void 0 === s ? void 0 : s[0],
            i = null == r ? void 0 : r.source;
          if (!r || !i) continue;
          const o = new n.Hw6(i.data);
          t.image && (o.uuid = t.image), a.images[o.uuid] = o, t.image = o.uuid, r.dispose();
        }
      }
      a.textures = e.textures ? t.parseTextures2(Object.values(e.textures), a.images, () => {
        Object.values(a.textures).forEach(e => {
          var t;
          e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
        });
      }) : {};
      for (const e of Object.entries(a.textures)) e[1] = null === (o = await this._importer.processImported(e[1], {})) || void 0 === o ? void 0 : o[0], e[1] ? a.textures[e[0]] = e[1] : delete a.textures[e[0]];
      r && r.textures && (a.textures = {
        ...a.textures,
        ...r.textures
      });
      const l = e.materials ? Object.values(e.materials) : [];
      for (const e of l) Object.entries(e).forEach(([t, r]) => {
        r && r.resource && r.uuid && "textures" === r.resource && (e[t] = r.uuid);
      });
      return a.materials = t.parseMaterials2(l, a.textures, this._materials), r && r.materials && (a.materials = {
        ...a.materials,
        ...r.materials
      }), e.object && (a.object = t.parseObject(e.object, a.geometries, a.materials, a.textures, a.animations), e.skeletons && (a.skeletons = t.parseSkeletons(e.skeletons, a.object), t.bindSkeletons(a.object, a.skeletons))), a.__isLoadedResources = !0, a;
    }
  }
  to.PluginType = "AssetManager", to.ViewerTypeSlug = "vjson";
  class ro extends r {
    constructor() {
      super(...arguments), this._dirty = !1;
    }
    get dirty() {
      return this._dirty;
    }
    set dirty(e) {
      this._dirty = e;
    }
    async onAdded(e) {
      this._viewer = e;
    }
    async onDispose(e) {}
    async onRemove(e) {
      this._viewer !== e && console.error("Wrong viewer"), this._viewer = void 0;
    }
    toJSON(e) {
      const t = ke(this, !0, e);
      return t.type = this.constructor.PluginType, this.dispatchEvent({
        type: "serialize",
        data: t
      }), t;
    }
    fromJSON(e, t) {
      return e.type !== this.constructor.PluginType ? null : (De(e, this, !0, t), this.dispatchEvent({
        type: "deserialize",
        data: e
      }), this);
    }
  }
  function no(e, t, r) {
    return {
      ...t,
      get dirty() {
        return t.dirty || !1;
      },
      set dirty(e) {
        _(t, "dirty", e, !0);
      },
      update() {
        var e, n, i;
        this.passObject.enabled && (null === (n = (e = this.passObject).updateShaderProperties) || void 0 === n || n.call(e, A(r)), null === (i = t.update) || void 0 === i || i.call(this));
      },
      onRegister(r) {
        var n, i, s;
        this.passObject.materialExtension && (null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.materials) || void 0 === i || i.registerMaterialExtension(this.passObject.materialExtension)), null === (s = t.onRegister) || void 0 === s || s.call(this, r);
      },
      onUnregister(r) {
        var n, i, s;
        this.passObject.materialExtension && (null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.materials) || void 0 === i || i.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s = t.onUnregister) || void 0 === s || s.call(this, r);
      },
      dispose() {
        var e, r, n;
        null === (r = (e = this.passObject).dispose) || void 0 === r || r.call(e), null === (n = t.dispose) || void 0 === n || n.call(this);
      }
    };
  }
  class io extends ro {
    constructor() {
      super(), this._enabledTemp = !0;
    }
    _update(e) {
      var t;
      return (null === (t = this._pass) || void 0 === t ? void 0 : t.enabled) && this.enabled || !1;
    }
    get enabled() {
      var e, t;
      return (null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || this._enabledTemp;
    }
    set enabled(e) {
      var t;
      (null === (t = this._pass) || void 0 === t ? void 0 : t.passObject) && (this._pass.passObject.enabled = e), this._enabledTemp = e;
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = {
        enabled: !0,
        passId: this.passId,
        passObject: this.passCtor(e),
        after: this._afterFilters,
        before: this._beforeFilters,
        required: this._requiredFilters,
        set dirty(t) {
          t && e.setDirty();
        },
        get dirty() {
          return !1;
        },
        update: () => this._update(e)
      };
      this._pass = no(e, t), void 0 !== t.passObject.onDirty && t.passObject.onDirty.push(() => t.dirty = !0), e.renderer.registerPass(this._pass), this.enabled = this._enabledTemp;
    }
    async onRemove(e) {
      var t, r;
      this._pass && e.renderer.unregisterPass(this._pass), null === (r = null === (t = this._pass) || void 0 === t ? void 0 : t.dispose) || void 0 === r || r.call(t), this._pass = void 0, await super.onRemove(e);
    }
    get pass() {
      return this._pass;
    }
    toJSON(e) {
      var t, r;
      const n = super.toJSON(e);
      if (!n.type) return n;
      const i = this.pass;
      return i && (n.pass = ke(null !== (r = null === (t = i) || void 0 === t ? void 0 : t.passObject) && void 0 !== r ? r : i, !1, e)), n;
    }
    fromJSON(e, t) {
      var r, n;
      if (!super.fromJSON(e, t)) return null;
      if (e.pass) {
        const i = this.pass;
        i && De(e.pass, null !== (n = null === (r = i) || void 0 === r ? void 0 : r.passObject) && void 0 !== n ? n : i, !1, t);
      }
      return this;
    }
  }
  !function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Ce()], io.prototype, "enabled", null);
  const so = new Set(),
    oo = new Set();
  class ao extends Gt {
    constructor(e, t, r, n) {
      super(void 0, void 0, t, new Ae(1, 1, 1), 1), this.target = e;
    }
    render(e, t, r, n, i) {
      const s = e.getRenderTarget(),
        o = e.getActiveCubeFace(),
        a = e.getActiveMipmapLevel();
      this.scene.traverse(({
        material: e
      }) => {
        e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (so.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (oo.add([e, e.transmission]), e.transmission = 0));
      }), W(e, {
        shadowMapRender: !1,
        backgroundRender: !1,
        opaqueRender: !0,
        transparentRender: !1,
        transmissionRender: !1,
        mainRenderPass: !1
      }, () => super.render(e, t, this.target, n, i)), so.forEach(e => e.transparent = !e.transparent), so.clear(), oo.forEach(([e, t]) => e.transmission = t), oo.clear(), e.setRenderTarget(s, o, a);
    }
  }
  class lo extends io {
    constructor(e = !0) {
      super(), this.renderFlagsBuffer = e, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = [];
    }
    passCtor(e) {
      var t, r;
      const i = (null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.isWebGL2) && this.renderFlagsBuffer,
        s = e.renderer.createTarget({
          depthBuffer: !0,
          type: n.ywz,
          textureCount: i ? 2 : 1
        });
      Array.isArray(s.texture) ? (s.texture[0].name = "gbufferDepthNormal", s.texture[1].name = "gbufferFlags", this._gbufferTextures = s.texture) : (s.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(s.texture)), this._gbufferTarget = s;
      const o = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("debug");
      return o && (o.addTexture("gbuffer depth normal", () => this.getDepthNormal(), [40, 110, 300, 200]), this._gbufferTextures.length > 1 && o.addTexture("gbuffer flags", () => this.getFlagsTexture(), [40, 310, 200, 100])), new ao(s, new Qt(i));
    }
    _update(e) {
      if (!super._update(e)) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }
    getDepthNormal() {
      return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0;
    }
    getFlagsTexture() {
      return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0;
    }
    async onDispose(e) {}
    async onRemove(e) {
      return this._gbufferTarget && (e.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e);
    }
    getTarget() {
      return this._gbufferTarget;
    }
    getUnpackSnippet() {
      return Ht;
    }
    updateShaderProperties(e) {
      var t, r;
      if (e.uniforms.tNormalDepth ? e.uniforms.tNormalDepth.value = null !== (t = this.getDepthNormal()) && void 0 !== t ? t : void 0 : console.warn("BaseRenderer: no uniform: tNormalDepth"), e.uniforms.tGBufferFlags) {
        e.uniforms.tGBufferFlags.value = null !== (r = this.getFlagsTexture()) && void 0 !== r ? r : void 0;
        const t = e.uniforms.tGBufferFlags.value ? 1 : 0;
        t !== e.defines.GBUFFER_HAS_FLAGS && (e.defines.GBUFFER_HAS_FLAGS = t, e.needsUpdate = !0);
      }
      return this;
    }
  }
  lo.PluginType = "GBuffer";
  class co extends Gt {
    constructor(e, t = !0) {
      super(), this.blurTransmissionTarget = !1, this._viewer = e, this._doTransmissionFix = t, this.clear = !0, this.clearColor = new Ae(0, 0, 0), this.clearAlpha = 0, this.clearDepth = !1, this._blendPass = new Vt({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);");
    }
    get transparentTarget() {
      return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        samples: this._viewer.renderer.composerTarget.samples || 0,
        encoding: n.rnI,
        type: n.cLu,
        format: n.wk1,
        minFilter: n.wem,
        magFilter: n.wem,
        depthBuffer: !1
      })), this._transparentTarget;
    }
    _releaseTransparentTarget() {
      this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
    }
    render(e, t, r, n, i) {
      var s;
      let o = !1;
      if (e.userData.mainRenderPass = !0, !this._doTransmissionFix) return super.render(e, t, r, n, i), this.needsSwap = o, void (e.userData.mainRenderPass = void 0);
      const a = e.userData;
      a || console.error("threejs is not patched?");
      const l = this._viewer.useGBufferDepth;
      let c;
      if (l) {
        const t = null === (s = this._viewer.getPlugin(lo)) || void 0 === s ? void 0 : s.getTarget();
        if (t) {
          const r = e.properties.get(t);
          c = r.__webglDepthRenderbuffer || r.__webglDepthbuffer;
        } else console.warn("No Gbuffer present for depth prepass.");
      }
      let u = () => {
        super.render(e, void 0, r, n, i, c);
      };
      if (this._viewer.useRgbm) {
        if (this._viewer.useRgbm) {
          if (o = !1, !e.info.autoReset) throw "renderer.info.autoReset must be true";
          {
            const t = e.autoClearDepth;
            e.autoClearDepth = !l, W(e, {
              shadowMapRender: !0,
              backgroundRender: !0,
              opaqueRender: !0,
              transparentRender: !1,
              transmissionRender: !1
            }, u), e.autoClearDepth = t;
          }
          if (!l) {
            const t = e.properties.get(r);
            c = t.__webglDepthRenderbuffer || t.__webglDepthbuffer;
          }
          u = () => {
            super.render(e, void 0, this.transparentTarget, n, i, c);
          };
          {
            const t = this.clear,
              r = e.autoClearDepth;
            e.autoClearDepth = !1, this.clear = !0, W(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !0,
              transmissionRender: !1
            }, u), this.clear = t, e.autoClearDepth = r;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, r, n, i), o = !0);
          {
            const n = this.clear;
            this.clear = !1, a.transmissionRenderTarget = o ? t : r, a.blurTransmissionTarget = this.blurTransmissionTarget, W(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !1,
              transmissionRender: !0
            }, u), a.blurTransmissionTarget = void 0, a.transmissionRenderTarget = void 0, this.clear = n;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, r, n, i), o = !0);
        }
      } else {
        {
          const t = this.clear,
            r = e.autoClearDepth;
          e.autoClearDepth = !l, this.clear = !0, W(e, {
            shadowMapRender: !0,
            backgroundRender: !0,
            opaqueRender: !0,
            transparentRender: !0,
            transmissionRender: !1
          }, u), this.clear = t, e.autoClearDepth = r;
        }
        {
          this._viewer.renderer.blit(r.texture, t, {
            clear: !0
          });
          const n = this.clear;
          this.clear = !1, a.transmissionRenderTarget = t, a.blurTransmissionTarget = this.blurTransmissionTarget, W(e, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !1,
            transparentRender: !1,
            transmissionRender: !0
          }, u), a.blurTransmissionTarget = void 0, a.transmissionRenderTarget = void 0, this.clear = n;
        }
        o = !1;
      }
      this._releaseTransparentTarget(), this.needsSwap = o, e.userData.mainRenderPass = void 0;
    }
  }
  function uo(e, t) {
    return e.multiplyScalar(e.w * t), e.w = 1, e;
  }
  function ho(e, t) {
    return uo(e, t), new Ae(e.x, e.y, e.z);
  }
  function po(e, t) {
    const r = Math.max(e.x, Math.max(e.y, e.z));
    let n = Math.max(Math.min(r / t, 1), 0);
    return n = Math.ceil(255 * n) / 255, e.divideScalar(n * t), e.w = n, e;
  }
  function fo(e, t) {
    return po(new n.Ltg(e.r, e.g, e.b, 1), t);
  }
  var mo = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  function _o(e) {
    return Object.getPrototypeOf(e).constructor.PluginType;
  }
  n.Vj0.background.fragmentShader = n.Vj0.background.fragmentShader.replace("uniform sampler2D t2D;", "uniform sampler2D t2D;\nuniform float intensity;"), n.Vj0.background.fragmentShader = n.Vj0.background.fragmentShader.replace("texture2D( t2D, vUv )", "texture2D( t2D, vUv )*intensity");
  class go extends r {
    constructor({
      isAntialiased: t = !1,
      useRgbm: r = !0,
      useGBufferDepth: i = !1,
      screenShader: s = "",
      ...o
    }) {
      var a;
      super(), this.console = console, this._state = e.None, this.plugins = {}, this._needsResize = !1, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(e => this.resize()) : void 0, this._lastSize = new n.FM8(), this._onContextRestore = e => {
        this.enabled = !0, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({
          sceneUpdate: !0,
          frameFade: !1
        });
      }, this._onContextLost = e => {
        this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = !1;
      }, this.resize = () => {
        this._needsResize = !0, this.setDirty();
      }, this._needsReset = !0, this.enabled = !0, this.renderEnabled = !0, this._isRenderingFrame = !1, this.maxFramePerLoop = 1, this._rawBackground = null, this.backgroundIntensity = 1, this._sceneEnvironmentChanged = () => {
        this._rawBackground === vo && this.scene.setBackground(this.scene.getEnvironment());
      }, this._addSceneObject = e => {
        var t;
        if (!e || !e.object) return;
        const r = e.object.__importedViewerConfig || (null === (t = e.object.modelObject) || void 0 === t ? void 0 : t.__importedViewerConfig);
        if (!r) return;
        const n = this.getManager();
        n ? n.applyViewerConfig(r, r.resources) : this.fromJSON(r, r.resources);
      }, this.alert = async e => alert(e), this.confirm = async e => confirm(e), this.prompt = async (e, t, r = !0) => prompt(e, t), this._useRgbm = r, this._useGBufferDepth = i, this._screenShader = s, this._canvas = o.canvas || At();
      let l = o.container;
      if (l && !o.canvas && l.appendChild(this._canvas), l || (l = null !== (a = this._canvas.parentElement) && void 0 !== a ? a : void 0), !l) throw new Error("No container.");
      this._container = l, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), this._setActiveCameraView = this._setActiveCameraView.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function () {
        try {
          const e = window.location.href;
          if (e.startsWith("http://localhost:8062") || e.startsWith("https://localhost:8062")) return !0;
          const t = "https://europe-west1-pixotronics-320918.cloudfunctions.net/viewer-hit-test";
          await fetch(t + "/?u=" + encodeURIComponent(e), {
            mode: "no-cors",
            method: "POST",
            credentials: "omit",
            cache: "no-store",
            keepalive: !1,
            referrer: "about:client",
            referrerPolicy: "unsafe-url"
          });
        } catch (e) {
          return !1;
        }
      }(), async function () {
        var e;
        const t = window.location.href,
          r = "https://dev-sandbox.pixotronics.com/webgi/";
        if (!t.startsWith(r)) return !0;
        if (null !== Bt("noUpdate")) return !0;
        const n = null === (e = t.match(/\/webgi\/([0-9.a-zA-Z]+)/)) || void 0 === e ? void 0 : e[1],
          i = (await (await fetch(r + "version.txt")).text()).split("\n")[0];
        if (n && n !== i) {
          if (confirm(`New version ${i} is available, do you want to open?`)) {
            const e = window.location.href.replace(n, i);
            return window.location.href = e, !1;
          }
          window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate");
        }
      }();
      const c = new _t(void 0, void 0, this._canvas);
      this.addEventListener("postFrame", () => {
        var e, t;
        const r = h.scene.activeCamera;
        if (r && r.interactionsEnabled) {
          if (0 === (null === (e = this.getPluginByType("Progressive")) || void 0 === e ? void 0 : e.postFrameConvergedRecordingDelta())) return;
          null === (t = r.controls) || void 0 === t || t.update();
        }
      }), this.scene = new vt(c), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this.scene.addEventListener("addSceneObject", this._addSceneObject), this.scene.addEventListener("setView", this._setActiveCameraView), this.scene.addEventListener("activateMain", this._setActiveCameraView), this._renderer = new K({
        canvas: this._canvas,
        animationLoop: this._animationLoop,
        targetOptions: {
          samples: t ? 4 : 0,
          encoding: r ? R : n.rnI,
          type: r ? n.ywz : n.cLu,
          depthBuffer: !i
        }
      }), this._isAntialiased = t && this._renderer.isWebGL2;
      let u = !0;
      this._renderer.rendererObject.userData || (u = !1, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !u;
      const h = this;
      this.renderFilter = {
        passId: "render",
        passObject: new co(this, u),
        update() {
          const e = this.passObject;
          e.scene = h.scene.modelObject, e.camera = h.scene.activeCamera.cameraObject;
        }
      };
      const p = {
        passId: "screen",
        after: ["render"],
        required: ["render"],
        passObject: Ao(s)
      };
      [this.renderFilter, p].forEach(e => this._renderer.registerPass(e)), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("sceneMaterialUpdate", e => this.setDirty(this.scene, e)), this.scene.addEventListener("sceneUpdate", e => {
        this.setDirty(this.scene, e), !1 !== e.geometryChanged && this.renderer.resetShadows();
      }), this.scene.addEventListener("update", e => this.setDirty(this.scene, e)), this._renderer.addEventListener("update", e => this.setDirty(this._renderer, e)), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1), this.renderer.addEventListener("resize", () => {
        this.scene.activeCamera.refreshAspect();
      }), this.setBackground("#ffffff"), this.console.log("WebGi Viewer instance initialized, version: ", go.VERSION);
    }
    get useRgbm() {
      return this._useRgbm;
    }
    get screenShader() {
      return this._screenShader;
    }
    get useGBufferDepth() {
      return this._useGBufferDepth;
    }
    get isAntialiased() {
      return this._isAntialiased;
    }
    setDirty(e, t) {
      this._needsReset = !0, e = null != e ? e : this, this.dispatchEvent({
        ...(null != t ? t : {}),
        type: "update",
        source: e
      });
    }
    get renderer() {
      return this._renderer;
    }
    dispose() {
      var e;
      this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1), null === (e = window.webGiViewers) || void 0 === e || e.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({
        type: "dispose"
      });
    }
    _animationLoop({
      time: e,
      deltaTime: t,
      xrFrame: r
    }) {
      var n, i;
      if (this.enabled && this.renderEnabled) if (this._isRenderingFrame) this.console.warn("animation loop: frame skip");else {
        this._isRenderingFrame = !0;
        for (let s = 0; s < this.maxFramePerLoop; s++) {
          if (this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._needsResize) {
            const e = [this._canvas.clientWidth, this._canvas.clientHeight];
            if (r) {
              const t = null === (i = null === (n = this._renderer.rendererObject.xr.getCamera()) || void 0 === n ? void 0 : n.cameras[0]) || void 0 === i ? void 0 : i.viewport;
              t ? (0 === t.x && 0 === t.y || this.console.warn("x and y must be 0?"), e[0] = t.width, e[1] = t.height, this.console.log("resize for xr", e)) : this._needsResize = !1;
            }
            this._needsResize && (this._renderer.setSize(...e), this._needsResize = !1);
          }
          this.dispatchEvent({
            type: "preFrame",
            target: this,
            time: e,
            deltaTime: t,
            xrFrame: r
          });
          const s = Object.values(this.plugins).filter(e => e.dirty);
          s.length > 0 && this.setDirty(s), this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._renderer.updateDirty();
          const o = this._renderer.dirty;
          if (o) {
            this.dispatchEvent({
              type: "preRender",
              target: this
            });
            try {
              this._renderer.render();
            } catch (e) {
              this.console.error(e), this.enabled = !1;
            }
            this.dispatchEvent({
              type: "postRender",
              target: this
            });
          }
          if (this.dispatchEvent({
            type: "postFrame",
            target: this
          }), !o) break;
        }
        this._isRenderingFrame = !1;
      }
    }
    get state() {
      return this._state;
    }
    get container() {
      return this._container;
    }
    get canvas() {
      return this._canvas;
    }
    getPlugin(e) {
      return this.plugins[e.PluginType];
    }
    getPluginByType(e) {
      return this.plugins[e];
    }
    async addPlugin(e, ...t) {
      var r;
      let n;
      n = e.prototype ? new e(...t) : e;
      const i = _o(n);
      return i ? (null === (r = n.dependencies) || void 0 === r || r.forEach(e => {
        this.getPlugin(e) || (this.console.log("Adding plugin dependency", e.name, "for", i), this.addPlugin(e));
      }), this.plugins[i] && this.console.error(`Plugin of type ${i} already exists`, this.plugins[i], n), this.plugins[i] = n, await n.onAdded(this), this.dispatchEvent({
        type: "addPlugin",
        target: this,
        plugin: n
      }), this.setDirty(n), n) : (this.console.error("PluginType is not defined for", n), n);
    }
    async removePlugin(e, t = !0) {
      const r = _o(e);
      this.plugins[r] && (await e.onRemove(this), delete this.plugins[r], t && (await e.onDispose(this)), this.setDirty(e));
    }
    createCamera(e) {
      var t;
      const r = null !== (t = e.userData.iCamera) && void 0 !== t ? t : new _t(e, {
        controlsMode: "",
        controlsEnabled: !1
      }, this._canvas);
      return r.autoLookAtTarget = !1, r;
    }
    setSize(e) {
      this._canvas.style.width = (null == e ? void 0 : e.width) ? e.width + "px" : "100%", this._canvas.style.height = (null == e ? void 0 : e.height) ? e.height + "px" : "100%", this.resize();
    }
    _backgroundIntensityChanged() {
      var e, t, r, i;
      const s = null !== (i = null === (r = null === (t = null === (e = this._renderer) || void 0 === e ? void 0 : e.rendererObject) || void 0 === t ? void 0 : t.background.getPlaneMesh()) || void 0 === r ? void 0 : r.material.uniforms) && void 0 !== i ? i : n.Vj0.background.uniforms;
      s.intensity || (s.intensity = {
        value: 1
      }), s.intensity.value = this.backgroundIntensity, this.setDirty();
    }
    setBackgroundColor(e) {
      const t = new Ae().set(e).convertSRGBToLinear();
      return this.setBackground(t);
    }
    setBackground(e) {
      if (this._rawBackground = e, null != e && ("string" == typeof e || "number" == typeof e || e.isVector4 || e.isColor)) {
        if (e === vo) return this._sceneEnvironmentChanged();
        const t = e.isVector4 ? H(e) : Q(e.isColor ? e : new Ae(e));
        return t.assetType = "texture", this.scene.setBackground(t);
      }
      return !e && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode"), this.scene.setBackground(e);
    }
    getBackground(e = !1) {
      var t, r, n;
      if (e) return this._rawBackground;
      let i = null !== (t = this._rawBackground) && void 0 !== t ? t : this.scene.getBackground();
      return i ? ((null === (r = i) || void 0 === r ? void 0 : r.isVector4) && (i = ho(i, 7).getHexString()), (null === (n = i) || void 0 === n ? void 0 : n.isColor) ? i.getHexString() : this._rawBackground === vo ? this.scene.getEnvironment() : i) : null;
    }
    getManager() {
      return this.getPluginByType("AssetManager");
    }
    resetCamera({
      rootObject: e,
      centerOffset: t = new n.Pa4(1, 1, 1),
      targetOffset: r = new n.Pa4(0, 0, 0),
      ...i
    } = {}) {
      if (this.scene.activeCamera) {
        this.scene.matrixWorldNeedsUpdate = !0, this.scene.updateMatrixWorld(!0);
        const i = e ? new k().expandByObject(e, !0, !0) : this.scene.getBounds(!0),
          s = i.getCenter(new n.Pa4()),
          o = .5 * i.getSize(new n.Pa4()).length();
        s.add(r.clone().multiplyScalar(o)), this.scene.activeCamera.position = new n.Pa4(s.x + t.x * o, s.y + t.y * o, s.z + t.z * o), this.scene.activeCamera.target = s, this.setDirty();
      }
    }
    async createObject3D(e) {
      var t;
      return null === (t = this.getManager()) || void 0 === t ? void 0 : t.addImportedSingle(e || new n.Tme(), {
        autoScale: !1,
        pseudoCenter: !1
      });
    }
    createPhysicalMaterial(e) {
      return this.createMaterial("standard", e);
    }
    createMaterial(e, t) {
      var r, n, i, s, o;
      if (null === (r = t) || void 0 === r ? void 0 : r.isMaterial) {
        const e = null === (i = null === (n = this.getManager()) || void 0 === n ? void 0 : n.materials) || void 0 === i ? void 0 : i.findMaterial(t.uuid);
        if (e) return e;
      }
      return null === (o = null === (s = this.getManager()) || void 0 === s ? void 0 : s.materials) || void 0 === o ? void 0 : o.generateFromTemplate(e, t);
    }
    serializePlugins(e, t) {
      return Object.entries(this.plugins).map(r => {
        var n, i;
        if (!t || t.includes(r[1].constructor.PluginType)) return !1 !== r[1].serializeWithViewer ? null === (i = (n = r[1]).toJSON) || void 0 === i ? void 0 : i.call(n, e) : void 0;
      }).filter(e => !!e);
    }
    deserializePlugins(e, t) {
      return e.forEach(e => {
        var r;
        if (!e.type) return void this.console.warn("Invalid plugin to import ", e);
        const n = this.getPluginByType(e.type);
        n && (null === (r = n.fromJSON) || void 0 === r || r.call(n, e, t));
      }), this;
    }
    traverseSceneObjects(e) {
      this.scene.modelRoot.modelObject.traverse(e);
    }
    toJSON(e, t) {
      return Object.assign({
        version: go.VERSION,
        plugins: this.serializePlugins(e, t)
      }, ke(this, !0, e));
    }
    fromJSON(e, t) {
      return De(e, this, !0, t), Array.isArray(e.plugins) && this.deserializePlugins(e.plugins, t), this.setBackground(this._rawBackground), this;
    }
    _setActiveCameraView(e = {}) {
      if ("setView" === e.type) {
        if (!e.camera) return void console.warn("Cannot find camera", e);
        this.scene.activeCamera.copyFromCamera(e.camera);
      } else "activateMain" === e.type && (this.scene.activeCamera = e.camera ? this.createCamera(e.camera) : void 0);
    }
  }
  go.VERSION = "0.5.5", mo([Ce()], go.prototype, "scene", void 0), mo([Ce("background")], go.prototype, "_rawBackground", void 0), mo([Ce(), M(go.prototype._backgroundIntensityChanged)], go.prototype, "backgroundIntensity", void 0);
  const vo = "envMapBackground";
  function Ao(e) {
    var t, r, n;
    return (null === (t = e) || void 0 === t ? void 0 : t.isShaderPass2) ? e : new zt({
      ...i,
      fragmentShader: `\n                       varying vec2 vUv;\n                       \n                       ${Array.isArray(e) ? e[0] : (null === (r = e) || void 0 === r ? void 0 : r.pars) || ""}\n                       \n                       void main() {\n\n                            gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));\n                            \n                            ${Array.isArray(e) ? e[1] : "string" == typeof e ? e : (null === (n = e) || void 0 === n ? void 0 : n.main) || ""}\n                            \n                        }`,
      uniforms: {
        tDiffuse: {
          value: null
        }
      }
    }, "tDiffuse");
  }
  var bo = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let yo = class extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = !0, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = e => {
        var t;
        if (this.isFullScreen()) this.dispatchEvent({
          type: "enter"
        });else {
          const e = this._lastFsElement || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
          e && (e.style.width = this._lastSize[0], e.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1), this.dispatchEvent({
            type: "exit"
          });
        }
      }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
    }
    async enter(e) {
      var t;
      if (this.isFullScreen()) return;
      const r = e || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
      return r ? (this._lastFsElement = r, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("fullscreenchange", this._fsChangeHandler, !1), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)), this._lastSize = [r.style.width, r.style.height], r.style.width = "100%", r.style.height = "100%", r.requestFullscreen ? r.requestFullscreen() : r.mozRequestFullScreen ? r.mozRequestFullScreen() : r.webkitRequestFullscreen ? r.webkitRequestFullscreen() : r.msRequestFullscreen ? r.msRequestFullscreen() : void 0) : void 0;
    }
    async exit() {
      return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0;
    }
    async toggle(e) {
      return this.isFullScreen() ? this.exit() : this.enter(e);
    }
    isFullScreen() {
      return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement;
    }
  };
  yo.PluginType = "FullScreenPlugin", bo([rt("Enter FullScreen")], yo.prototype, "enter", null), bo([rt("Exit FullScreen")], yo.prototype, "exit", null), bo([rt("Toggle FullScreen")], yo.prototype, "toggle", null), yo = bo([lt("Full Screen")], yo);
  class xo {
    constructor(e, t, r) {
      this._el = e, this._inputEl = t, this._listeners = {
        drop: [],
        dropstart: [],
        droperror: []
      }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e || e.addEventListener("dragover", this._onDragover, !1), null == e || e.addEventListener("drop", this._onDrop, !1), null == t || t.addEventListener("change", this._onSelect), r && Object.entries(r).forEach(([e, t]) => t && this.on(e, t));
    }
    get inputEl() {
      return this._inputEl;
    }
    get el() {
      return this._el;
    }
    on(e, t) {
      return this._listeners[e].push(t), this;
    }
    _emit(e, t) {
      return this._listeners[e].forEach(e => e(t)), this;
    }
    destroy() {
      const e = this._el,
        t = this._inputEl;
      null == e || e.removeEventListener("dragover", this._onDragover), null == e || e.removeEventListener("drop", this._onDrop), null == t || t.removeEventListener("change", this._onSelect);
    }
    _onDrop(e) {
      var t, r;
      e.stopPropagation(), e.preventDefault(), this._emit("dropstart");
      const n = Array.from((null === (t = e.dataTransfer) || void 0 === t ? void 0 : t.files) || []),
        i = Array.from((null === (r = e.dataTransfer) || void 0 === r ? void 0 : r.items) || []);
      if (0 !== n.length || 0 !== i.length) {
        if (i.length > 0) {
          const e = i.map(e => e.webkitGetAsEntry());
          this._loadNextEntry(new Map(), e);
        } else this._emit("drop", {
          files: new Map(n.map(e => (e.filePath = e.name, [e.filePath, e])))
        });
      } else this._fail("Required drag-and-drop APIs are not supported in this browser.");
    }
    _onDragover(e) {
      e.stopPropagation(), e.preventDefault(), e.dataTransfer && (e.dataTransfer.dropEffect = "copy");
    }
    _onSelect(e) {
      var t;
      if (!this._inputEl) return void console.warn("Invalid Dropzone event ", e);
      this._emit("dropstart");
      const r = [].slice.call(null !== (t = this._inputEl.files) && void 0 !== t ? t : new FileList()),
        n = new Map();
      r.forEach(e => {
        e.filePath = e.webkitRelativePath || e.name, n.set(e.filePath, e);
      }), this._emit("drop", {
        files: n
      });
    }
    _loadNextEntry(e, t) {
      const r = t.pop();
      if (r) {
        if (r.isFile) r.file(n => {
          n.filePath = r.fullPath, e.set(r.fullPath, n), this._loadNextEntry(e, t);
        }, () => console.error("Could not load file: %s", r.fullPath));else if (r.isDirectory) {
          const n = r.createReader(),
            i = r => {
              r.length ? (t = t.concat(r), n.readEntries(i)) : this._loadNextEntry(e, t);
            };
          n.readEntries(i);
        } else console.warn("Unknown asset type: " + r.fullPath), this._loadNextEntry(e, t);
      } else this._emit("drop", {
        files: e
      });
    }
    _fail(e) {
      this._emit("droperror", {
        message: e
      });
    }
  }
  class wo extends r {
    constructor(e) {
      super(), this._domElement = e, this._allowedExtensions = void 0, this.importerParams = {
        autoScale: !0,
        autoScaleRadius: 2,
        pseudoCenter: !0,
        autoCenter: !1,
        autoImport: !0,
        autoAdd: !0,
        centerOffset: new n.Pa4(.5, .5, 3)
      }, this.dependencies = [to], this.uiConfig = {
        type: "folder",
        label: "Drop Options",
        children: [{
          label: "Auto Center",
          type: "checkbox",
          property: [this.importerParams, "pseudoCenter"],
          limitedUi: !0
        }, {
          label: "Auto Scale",
          type: "checkbox",
          property: [this.importerParams, "autoScale"],
          limitedUi: !0
        }, {
          label: "Auto scale radius",
          type: "slider",
          bounds: [.5, 100],
          property: [this.importerParams, "autoScaleRadius"]
        }]
      };
    }
    async onAdded(e) {
      this._inputEl = document.createElement("input"), this._viewer = e, this._inputEl.type = "file", this._dropzone = new xo(this._domElement || e.canvas, this._inputEl, {
        drop: this._onFileDrop.bind(this)
      });
    }
    async _onFileDrop({
      files: e
    }) {
      var t, r, n, i, s, o;
      if (!e) return;
      const a = this._viewer;
      if (!a) return;
      if (void 0 !== this._allowedExtensions) for (const n of e.keys()) this._allowedExtensions.includes(null !== (r = null === (t = n.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase()) && void 0 !== r ? r : "") || e.delete(n);
      if (e.size < 1) return;
      const l = a.getPlugin(to),
        c = {
          type: "drop",
          files: e
        };
      if (this.importerParams.autoImport) {
        const t = {
          allowedExtensions: this.allowedExtensions,
          ...this.importerParams
        };
        if (c.imported = await (null === (n = l.importer) || void 0 === n ? void 0 : n.importFiles(e, t)), this.importerParams.autoAdd) {
          const e = null !== (o = [...(null !== (s = null === (i = c.imported) || void 0 === i ? void 0 : i.values()) && void 0 !== s ? s : [])].flat(2).filter(e => !!e)) && void 0 !== o ? o : [];
          if (c.assets = l.addProcessedAssets(e, {
            ...this.importerParams
          }), !t._rootSceneImported) for (const e of c.assets) e.modelObject && e.modelObject.dispatchEvent({
            type: "select",
            value: e.modelObject
          });
        }
      }
      this.dispatchEvent(c);
    }
    promptForFile() {
      var e;
      null === (e = this._inputEl) || void 0 === e || e.click();
    }
    async onDispose(e) {}
    async onRemove(e) {
      var t;
      null === (t = this._dropzone) || void 0 === t || t.destroy(), this._dropzone = void 0, this._viewer = void 0;
    }
    get allowedExtensions() {
      return this._allowedExtensions;
    }
    set allowedExtensions(e) {
      this._allowedExtensions = e, this._inputEl && (this._inputEl.accept = e ? e.map(e => "." + e).join(", ") : "");
    }
  }
  wo.PluginType = "Dropzone";
  class Eo extends zt {
    constructor(e) {
      super({
        vertexShader: i.vertexShader,
        fragmentShader: w`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: e
          },
          weight: {
            value: new n.Ltg(1, 1, 1, 1)
          },
          weight2: {
            value: new n.Ltg(1, 1, 1, 1)
          }
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }
    set weights2(e) {
      this.uniforms.weight2.value.copy(e);
    }
    get weights2() {
      return this.uniforms.weight2.value;
    }
    set weights1(e) {
      this.uniforms.weight.value.copy(e);
    }
    get weights1() {
      return this.uniforms.weight.value;
    }
    set blendTexture(e) {
      this.uniforms.tDiffuse2.value = e;
    }
  }
  class So extends ro {
    constructor() {
      super(), this._pipeline = [];
    }
    get passes() {
      if (!this._passes) throw "Plugin not yet added to the viewer";
      return this._passes;
    }
    get pipeline() {
      return this._pipeline;
    }
    set pipeline(e) {
      this._pipeline = e;
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = this.createPasses(e);
      this._passes = Object.fromEntries(t.map(t => (t.passId || (console.warn("no id found for pass", t), t.passId = Xe()), e.renderer.registerPass(t, !0), [t.passId, t])));
    }
    async onRemove(e) {
      var t;
      if (this._passes) {
        for (const r of [...Object.values(this._passes)]) {
          const n = r;
          e.renderer.unregisterPass(n), null === (t = null == n ? void 0 : n.dispose) || void 0 === t || t.call(n);
        }
        this._passes = void 0;
      }
      await super.onRemove(e);
    }
    toJSON(e) {
      var t, r;
      const n = super.toJSON(e);
      if (!n.type) return n;
      const i = Object.entries(this.passes);
      n.passes = {};
      for (const [s, o] of i) n.passes[s] = ke(null !== (r = null === (t = o) || void 0 === t ? void 0 : t.passObject) && void 0 !== r ? r : o, !1, e);
      return n;
    }
    fromJSON(e, t) {
      var r, n;
      if (!super.fromJSON(e, t)) return null;
      if (e.passes) {
        const i = Object.entries(this.passes);
        for (const [s, o] of i) De(e.passes[s], null !== (n = null === (r = o) || void 0 === r ? void 0 : r.passObject) && void 0 !== n ? n : o, !1, t);
      }
      return this;
    }
  }
  var Co = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const Mo = [{
    x: 0,
    y: 0
  }, {
    x: -.5,
    y: 0
  }, {
    x: -.375,
    y: -.25
  }, {
    x: -.1875,
    y: -.125
  }, {
    x: -.125,
    y: -.375
  }, {
    x: .0625,
    y: -.0625
  }, {
    x: .125,
    y: -.3125
  }, {
    x: .375,
    y: -.4375
  }, {
    x: .3125,
    y: -.1875
  }, {
    x: .25,
    y: .0625
  }, {
    x: .4375,
    y: .25
  }, {
    x: .1875,
    y: .3125
  }, {
    x: 0,
    y: .4375
  }, {
    x: -.0625,
    y: .1875
  }, {
    x: -.25,
    y: .375
  }, {
    x: -.4375,
    y: .5
  }, {
    x: -.3125,
    y: .125
  }];
  class To extends So {
    constructor(e = 2 * Mo.length) {
      super(), this.enabled = !0, this.jitter = !0, this._hasSetOffset = !1, this.trackedJitterCameras = new Set(), this._addSceneObject = e => {
        const t = e.object;
        (t.modelObject || t.lightObject) && (t.modelObject || t.lightObject).traverse(e => {
          var t;
          (null === (t = null == e ? void 0 : e.shadow) || void 0 === t ? void 0 : t.camera) && e.shadow.mapSize && this.trackedJitterCameras.add([e.shadow.camera, e.shadow.mapSize]);
        });
      }, this._jitterCamera = e => {
        var t;
        const r = e.target;
        if (this.jitter && r.renderer.frameCount > 2) {
          const e = (e, t) => {
              const n = {
                ...Mo[r.renderer.frameCount % Mo.length]
              };
              e.setViewOffset(t.width, t.height, n.x, n.y, t.width, t.height);
            },
            n = r.scene.activeCamera.cameraObject;
          e(n, {
            width: r.canvas.clientWidth * r.renderer.displayCanvasScaling,
            height: r.canvas.clientHeight * r.renderer.displayCanvasScaling
          }), this.trackedJitterCameras.forEach(t => e(...t)), this._hasSetOffset = !0, null === (t = this._viewer) || void 0 === t || t.renderer.resetShadows();
        }
      }, this._resetCameraJitter = e => {
        const t = e.target;
        this._hasSetOffset && (t.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = !1);
      }, this.uiConfig = at("Progressive", this), this.maxFrameCount = e;
    }
    async onAdded(e) {
      return this._lastFrame = e.renderer.composerTarget.clone(!0), await super.onAdded(e);
    }
    async onRemove(e) {
      e.removeEventListener("preRender", this._jitterCamera), e.removeEventListener("postRender", this._resetCameraJitter), e.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrame && e.renderer.disposeTarget(this._lastFrame), this._lastFrame = void 0, await super.onRemove(e);
    }
    get lastFrame() {
      return this._lastFrame;
    }
    createPasses(e) {
      e.addEventListener("preRender", this._jitterCamera), e.addEventListener("postRender", this._resetCameraJitter), e.scene.addEventListener("addSceneObject", this._addSceneObject);
      const t = this,
        r = no(e, {
          passId: "progressive",
          get dirty() {
            var e;
            return t.jitter && ((null === (e = t._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) || 0) < t.maxFrameCount;
          },
          after: ["render"],
          before: ["combinedPost", "screen"],
          required: ["render"],
          passObject: new class extends Eo {
            render(r, n, i, s, o) {
              if (e.renderer.frameCount < 1) return this.needsSwap = !1, void ((null == i ? void 0 : i.texture) && e.renderer.blit(i.texture, t.lastFrame, {}));
              this.needsSwap = !0, super.render(r, n, i, s, o), e.renderer.blit(n.texture, t.lastFrame, {});
            }
          }(),
          update() {
            if (!t.lastFrame) return void console.error("lastFrame render target undefined");
            let r = 1 / (Math.max(e.renderer.frameCount, 0) + 1);
            this.passObject.weights1.set(r, r, r, r), r = 1 - r, this.passObject.weights2.set(r, r, r, r), this.passObject.blendTexture = t.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = !0;
          }
        });
      return [r];
    }
    isConverged(e = !1) {
      var t;
      return ((null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e ? 1 : 0);
    }
    updateShaderProperties(e) {
      var t, r;
      return e.uniforms.tLastFrame && (e.uniforms.tLastFrame.value = null !== (r = null === (t = this.lastFrame) || void 0 === t ? void 0 : t.texture) && void 0 !== r ? r : void 0), this;
    }
    postFrameConvergedRecordingDelta(e = "CanvasRecorder") {
      const t = this._viewer.getPluginByType(e);
      return t && t.isRecording() && t.convergeMode ? this.isConverged(!0) ? 1 / t.videoFrameRate : 0 : -1;
    }
  }
  To.PluginType = "Progressive", Co([Ce(), nt("Frame count")], To.prototype, "maxFrameCount", void 0), Co([Ce(), Je("Jitter")], To.prototype, "jitter", void 0);
  var Io = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}",
    ko = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS \nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED \n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n",
    Do = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS \nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n",
    Po = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS \nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n",
    Bo = "#define PI  3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}",
    Ro = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP \n#define pow2(a)a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH  1.0\n#define LOD_COLOR  5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n",
    Lo = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}",
    Oo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS \n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n",
    Fo = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Uo = class extends zt {
    constructor(e, t, r, i = !0) {
      super({
        vertexShader: Io,
        fragmentShader: `\n\nvarying vec2 vUv;\n\n${Do}\n${ko}\n${Po}\n${Bo}\n${r}\n\n${Ro}\n\n${Lo}\n\nuniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}\n#include <encodings_fragment>\n}\n\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 0
          },
          boost: {
            value: new n.Pa4(0, 0, 0)
          },
          objectRadius: {
            value: 0
          },
          autoRadius: {
            value: !1
          },
          power: {
            value: 0
          },
          maskFrontFactor: {
            value: -.1
          },
          tolerance: {
            value: 0
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new n.yGw()
          },
          cameraPositionWorld: {
            value: new n.Pa4()
          },
          cameraNearFar: {
            value: new n.FM8(.1, 1e3)
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSR_STEP_COUNT: 16,
          SSR_LOW_QUALITY_FRAMES: 2,
          SSR_MASK_FRONT_RAYS: !0,
          SSR_INLINE: i ? "1" : "0",
          SSR_NON_PHYSICAL: "0"
        }
      }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = {
        shaderExtender: (e, t, r) => {
          if (!e.defines.SSR_ENABLED) return;
          const n = "#glMarker beforeModulation";
          e.fragmentShader = e.fragmentShader.replace(n, `\n\n            \n            #if defined(SSR_ENABLED) && SSR_ENABLED > 0\nvec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;\n#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0\nalphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);\n#endif\n#ifdef USE_TRANSMISSION\nalphaModifier*=1.-transmission;\n#endif\nfloat vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){\n#if defined(SSR_INLINE) && SSR_INLINE > 0\nssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);\n#else\nssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));\n#endif \n}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);\n#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0\ndiffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=diffuseColor.rgb*(1.-ssrColor.a);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);\n#else\nreflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${n}`);
        },
        onObjectRender: (e, t, r) => {
          var n, i, s, o;
          let a = this.enabled && !1 !== r.userData.screenSpaceRendering && !(null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n.ssreflDisabled) ? 1 : 0;
          t.materialObject.defines.SSR_ENABLED !== a && (t.materialObject.defines.SSR_ENABLED = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_STEP_COUNT, t.materialObject.defines.SSR_STEP_COUNT !== a && (t.materialObject.defines.SSR_STEP_COUNT = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_LOW_QUALITY_FRAMES, t.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== a && (t.materialObject.defines.SSR_LOW_QUALITY_FRAMES = a, t.materialObject.needsUpdate = !0), a = this.material.defines.PERSPECTIVE_CAMERA, t.materialObject.defines.PERSPECTIVE_CAMERA !== a && (t.materialObject.defines.PERSPECTIVE_CAMERA = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_INLINE, t.materialObject.defines.SSR_INLINE !== a && (t.materialObject.defines.SSR_INLINE = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t.materialObject.defines.SSR_MASK_FRONT_RAYS !== a && (t.materialObject.defines.SSR_MASK_FRONT_RAYS = a, t.materialObject.needsUpdate = !0), a = (null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssreflNonPhysical) ? "1" : "0", t.materialObject.defines.SSR_NON_PHYSICAL !== a && (t.materialObject.defines.SSR_NON_PHYSICAL = a, t.materialObject.needsUpdate = !0), a = null !== (o = null === (s = this._target) || void 0 === s ? void 0 : s.texture) && void 0 !== o ? o : null, this.materialExtension.extraUniforms.tSSRMap.value !== a && (this.materialExtension.extraUniforms.tSSRMap.value = a, t.materialObject.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + U("tSSRMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2) + U("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e.capabilities.isWebGL2) + (this._inline ? `\n#if 1\n// #if SSR_INLINE\n    ${Do}\n    \n    #define THREE_PACKING_INCLUDED\n    ${ko}\n    \n    ${Po}\n    ${Bo}\n    ${Ht}\n    \n    ${Ro}\n    \n    ${Lo}\n// #endif // SSR_INLINE\n#endif\n` : "") + `\n\n${Oo}\n\n        `;
        },
        extraUniforms: {
          tSSRMap: {
            value: null
          },
          ssrPower: this.material.uniforms.power,
          ssrIntensity: this.material.uniforms.intensity,
          ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor,
          ssrBoost: this.material.uniforms.boost,
          tNormalDepth: this.material.uniforms.tNormalDepth,
          tLastFrame: this.material.uniforms.tLastFrame,
          objectRadius: this.material.uniforms.objectRadius,
          autoRadius: this.material.uniforms.autoRadius,
          tolerance: this.material.uniforms.tolerance,
          frameCount: this.material.uniforms.frameCount,
          projection: this.material.uniforms.projection,
          cameraPositionWorld: this.material.uniforms.cameraPositionWorld,
          cameraNearFar: this.material.uniforms.cameraNearFar,
          sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius
        },
        computeCacheKey: e => {
          var t, r;
          return this.enabled ? "1" : "0" + (null === (r = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === r ? void 0 : r.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssreflDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 1, this.boost = new n.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = !0, this.power = 1.1, this.tolerance = .5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = !0, this.maskFrontFactor = -.2, this._renderer = e, this._target = t, this.needsSwap = !1, this._inline = i;
    }
    render(e, t, r, n, i) {
      if (this._inline) this.needsSwap = !1;else {
        if (!this._target) throw "Target must be set when inline = false";
        this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, r, n, i), this.needsSwap = !1;
      }
    }
  };
  Fo([$e("Intensity", [0, 4]), Ce(), G()], Uo.prototype, "intensity", void 0), Fo([et("Boost"), Ce(), G()], Uo.prototype, "boost", void 0), Fo([$e("Object Radius", [.01, 2]), Ce(), G()], Uo.prototype, "objectRadius", void 0), Fo([Je("Auto radius"), Ce(), G()], Uo.prototype, "autoRadius", void 0), Fo([$e("Power", [0, 3]), Ce(), G()], Uo.prototype, "power", void 0), Fo([$e("Tolerance", [.1, 5]), Ce(), G()], Uo.prototype, "tolerance", void 0), Fo([$e("Step count", [1, 32], 1), Ce(), V("SSR_STEP_COUNT")], Uo.prototype, "stepCount", void 0), Fo([$e("Low Quality Frames", [0, 4], 1), Ce(), V("SSR_LOW_QUALITY_FRAMES")], Uo.prototype, "lowQualityFrames", void 0), Fo([Je("Ignore front rays"), Ce(), V("SSR_MASK_FRONT_RAYS")], Uo.prototype, "maskFrontRays", void 0), Fo([$e("Mask front rays factor", [-1, 1], .01, e => ({
    hidden: () => !e.maskFrontRays
  })), Ce(), G()], Uo.prototype, "maskFrontFactor", void 0), Uo = Fo([lt("Screen Space Reflections")], Uo);
  class No extends So {
    constructor() {
      super(), this.dependencies = [to, lo, To], this.inlineSSR = !0, this.setDirty = this.setDirty.bind(this);
    }
    get ssrTarget() {
      return this._ssrTarget;
    }
    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }
    set enabled(e) {
      var t;
      (null === (t = this.passes.ssr) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssr.passObject.enabled = e);
    }
    async onAdded(e) {
      var t, r;
      e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e), null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t, "postFrame", !0);
    }
    createPasses(e) {
      var t, r;
      return this._ssrTarget = this.inlineSSR ? void 0 : e.renderer.createTarget({
        sizeMultiplier: 1
      }), [no(e, {
        passId: "ssr",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new Uo(e.renderer, this._ssrTarget, null !== (r = null === (t = e.getPlugin(lo)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== r ? r : "", this.inlineSSR)
      }, () => [e.getPlugin(lo), e.getPlugin(To), e.scene.activeCamera, e.renderer, e.scene])];
    }
    async onRemove(e) {
      return this._ssrTarget && e.renderer.disposeTarget(this._ssrTarget), super.onRemove(e);
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    get uiConfig() {
      var e, t, r, n, i;
      const s = null !== (r = null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== r ? r : {};
      return null === (i = null === (n = s.children) || void 0 === n ? void 0 : n.map(e => A(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }
  }
  No.PluginType = "SSReflection";
  var jo = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class zo extends zt {
    constructor(e, t, r = "rgba") {
      super({
        vertexShader: i.vertexShader,
        fragmentShader: t + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}",
        uniforms: {
          bilDirection: {
            value: new n.FM8(1, 0)
          },
          tNormalDepth: {
            value: null
          },
          tDiffuse: {
            value: e.texture
          },
          tDiffuseSize: {
            value: new n.FM8()
          }
        },
        defines: {
          B_SRC_ACCESSOR: r
        }
      }, "tDiffuse"), this.smoothEnabled = !0, this.edgeSharpness = .1, this._target = e, this.clear = !1, this.needsSwap = !1;
    }
    render(e, t, r, n, i) {
      var s, o, a, l;
      this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s = this.uniforms.tDiffuse.value) || void 0 === s ? void 0 : s.image.width) || 0, (null === (o = this.uniforms.tDiffuse.value) || void 0 === o ? void 0 : o.image.height) || 0), super.render(e, t, this._target, n, i), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t.texture, this.uniforms.tDiffuseSize.value.set((null === (a = this.uniforms.tDiffuse.value) || void 0 === a ? void 0 : a.image.width) || 0, (null === (l = this.uniforms.tDiffuse.value) || void 0 === l ? void 0 : l.image.height) || 0), super.render(e, this._target, t, n, i));
    }
  }
  jo([Ce(), G()], zo.prototype, "smoothEnabled", void 0), jo([Ce(), G()], zo.prototype, "edgeSharpness", void 0);
  var Go = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class Vo extends zt {
    constructor(e, t, r) {
      super({
        defines: {
          LINEAR_DEPTH: 1,
          NUM_SAMPLES: 11,
          NUM_SPIRAL_TURNS: 3,
          DEPTH_NORMAL_TEXTURE: 1,
          DEPTH_PACKING_MODE: 2,
          PERSPECTIVE_CAMERA: 1
        },
        uniforms: {
          tLastThis: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          screenSize: {
            value: new n.FM8(512, 512)
          },
          saoData: {
            value: new n.Ltg()
          },
          frameCount: {
            value: 0
          },
          cameraNearFar: {
            value: new n.FM8(.1, 1e3)
          },
          projection: {
            value: new n.yGw()
          },
          saoBiasEpsilon: {
            value: new n.Pa4(1, 1, 1)
          }
        },
        vertexShader: Io,
        fragmentShader: `\n\n${Po}\n\n${r}\n\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);float getViewZFromNDCZ(const in float depth){\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;\n#if DEPTH_PACKING_MODE == 2\nuncodedDepth=texture2D(tNormalDepth,uv);\n#else\nuncodedDepth=texture2D(tDepth,uv);\n#endif\n#if DEPTH_PACKING_MODE == 0\nreturn uncodedDepth.x;\n#elif DEPTH_PACKING_MODE == 1\n#if LINEAR_DEPTH == 1\nreturn pow2(unpackRGBAToDepth(uncodedDepth));\n#else\nreturn unpackRGBAToDepth(uncodedDepth);\n#endif\n#else\nreturn pow2(unpack16(uncodedDepth.xy));\n#endif\n}vec3 getPositionFromOffset(const in vec2 uv,const in vec2 offset,const in float screenSpaceRadius){vec2 uvOffset=uv+floor(screenSpaceRadius*offset)/screenSize;float d=decodeDepth(uvOffset);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);\n#else\nd=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);\n#endif\n}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 offset=vec2(cos(angle),sin(angle));vec3 samplePosition=getPositionFromOffset(uv,offset,screenSpaceRadius);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(centerDepth);\n#else\nfloat centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);\n#endif\nvec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#if NUM_SAMPLES > 1\nsum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 2\nsum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 3\nsum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 4\nsum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 5\nsum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 6\nsum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 7\nsum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 8\nsum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 9\nsum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 10\nsum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\nfloat aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}\n\n            `
      }, "tDiffuse"), this.parameters = {
        intensity: .25,
        occlusionWorldRadius: 1,
        bias: .001,
        falloff: 1,
        edgeSharpness: .3,
        blurEnabled: !0
      }, this._smoothEnabled = !0, this.materialExtension = {
        shaderExtender: (e, t, r) => {
          e.defines.SSAO_ENABLED && (e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif\n#endif\n"));
        },
        onObjectRender: (e, t, r) => {
          var n, i;
          this.materialExtension.extraUniforms.tSSAOMap.value = null === (n = this._target) || void 0 === n ? void 0 : n.texture;
          const s = t.materialObject,
            o = !s.transparent && s.transmission < .001;
          let a = this.enabled && o && !1 !== r.userData.screenSpaceRendering && !(null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssaoDisabled) ? 1 : 0;
          s.defines.SSAO_ENABLED !== a && (s.defines.SSAO_ENABLED = a, s.needsUpdate = !0), a = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== a && (this.materialExtension.extraUniforms.tSSAOMap.value = a, s.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return w`
             uniform sampler2D tSSAOMap;
             ${U("tSSAOMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}
            ${Oo}
        `;
        },
        extraUniforms: {
          tSSAOMap: {
            value: null
          }
        },
        computeCacheKey: e => {
          var t, r;
          return this.enabled ? "1" : "0" + (null === (r = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === r ? void 0 : r.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this._renderer = e, this._target = t, this.needsSwap = !1, this.clear = !0, this.bilateralPass = new zo(this._target, r, "rrrr");
    }
    get smoothEnabled() {
      return this._smoothEnabled;
    }
    set smoothEnabled(e) {
      this._smoothEnabled = e, this.bilateralPass.enabled = e, this.bilateralPass.uniforms.smoothEnabled.value = e;
    }
    render(e, t, r, n, i) {
      this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, r, n, i), this._smoothEnabled && this.bilateralPass.render(e, t, r, n, i));
    }
    _updateParameters() {
      const e = this.material.uniforms.saoData.value;
      e.y = this.parameters.intensity, e.z = this.parameters.occlusionWorldRadius;
      const t = this.material.uniforms.saoBiasEpsilon.value;
      t.x = this.parameters.bias, t.y = .001, t.z = this.parameters.falloff;
    }
  }
  Go([Ce()], Vo.prototype, "bilateralPass", void 0), Go([Ce()], Vo.prototype, "parameters", void 0);
  class Qo extends So {
    constructor() {
      super(), this.dependencies = [to, lo], this.setDirty = this.setDirty.bind(this);
    }
    get aoTarget() {
      return this._aoTarget;
    }
    async onAdded(e) {
      return e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), super.onAdded(e);
    }
    createPasses(e) {
      var t, r;
      return this._aoTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      }), [no(e, {
        passId: "ssao",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer"],
        passObject: new Vo(e.renderer, this._aoTarget, null !== (r = null === (t = e.getPlugin(lo)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== r ? r : ""),
        update() {
          this.passObject.bilateralPass.updateShaderProperties([e.getPlugin(lo)]);
        }
      }, () => [e.getPlugin(lo), e.scene.activeCamera, e.renderer])];
    }
    async onRemove(e) {
      return e.renderer.disposeTarget(this._aoTarget), super.onRemove(e);
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssao) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }
    set enabled(e) {
      var t;
      (null === (t = this.passes.ssao) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssao.passObject.enabled = e);
    }
    get uiConfig() {
      var e;
      if (this._uiConfig) return this._uiConfig;
      const t = this,
        r = t.passes.ssao.passObject;
      return this._uiConfig = {
        type: "folder",
        label: "SS Ambient Occlusion",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [r, "enabled"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 4],
          property: [r.parameters, "intensity"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Radius",
          bounds: [.1, 8],
          property: [r.parameters, "occlusionWorldRadius"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Bias",
          bounds: [1e-5, .01],
          property: [r.parameters, "bias"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Falloff",
          bounds: [.01, 3],
          property: [r.parameters, "falloff"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Num samples",
          stepSize: 1,
          bounds: [1, 11],
          property: [null === (e = r.material) || void 0 === e ? void 0 : e.defines, "NUM_SAMPLES"],
          onChange: [() => r.material.needsUpdate = !0, t.setDirty]
        }, {
          type: "checkbox",
          property: [r.bilateralPass, "smoothEnabled"],
          onChange: t.setDirty
        }, {
          type: "vec4",
          property: [r.bilateralPass, "edgeSharpness"],
          onChange: t.setDirty
        }]
      };
    }
  }
  Qo.PluginType = "SSAO";
  class Ho {
    constructor(e) {
      this._normalsCache = {}, this._renderer = e, this._scene = new n.xsS(), this._mesh = new n.Kj0(), this._mesh.frustumCulled = !1, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Wo();
    }
    dispose() {
      this._mesh.material.dispose();
    }
    captureNormalMap(e, t, r = 512) {
      if (!e) throw "No geometry";
      if (e.userData._normalsCaptureMap) return !1;
      const i = null == t ? void 0 : t.split(";").find(e => this._normalsCache[e]);
      if (i) {
        const n = this._normalsCache[i];
        return null == t || t.split(";").forEach(e => e !== i && (this._normalsCache[e] = n)), n.width !== r && console.warn("last cacheKey normalMapRes mismatch, check model", r), e.userData._normalsCaptureMap = n, !1;
      }
      const s = this._renderer.createTargetCustom({
        width: r,
        height: r
      }, {
        minFilter: n.TyD,
        magFilter: n.TyD,
        generateMipmaps: !1,
        type: n.cLu
      }, n.oAp);
      if (!s) throw "Unable to create render target";
      null == t || t.split(";").forEach(e => this._normalsCache[e] = s), s.addEventListener("dispose", () => delete this._normalsCache[t]);
      const o = new n._am(1e-4, 100, s);
      this._scene.add(o);
      const a = e.userData._normalsCaptureOffsets;
      return void 0 !== a.center && this._mesh.material.uniforms.offsetCenter.value.copy(a.center), void 0 !== a.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.copy(a.offsetMatrixInv), void 0 !== a.radius && (this._mesh.material.uniforms.radius.value = a.radius), this._mesh.geometry = e, o.update(this._renderer.rendererObject, this._scene), this._scene.remove(o), this._mesh.geometry = void 0, e.userData._normalsCaptureMap = s, !0;
    }
  }
  class Wo extends n.jyz {
    constructor() {
      super({
        vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);vecPosition=(modelMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.);}",
        fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}",
        side: n.ehD,
        clipping: !1,
        uniforms: {
          radius: {
            value: 1
          },
          offsetMatrixInv: {
            value: new n.yGw().identity()
          },
          offsetCenter: {
            value: new n.Pa4()
          }
        }
      });
    }
  }
  var qo = __webpackgi_require__(654);
  function Xo(e) {
    const t = new n.Pa4(0, 0, 0),
      r = new n.Pa4(0, 0, 0),
      i = new n.Pa4(0, 0, 0),
      s = new n.Pa4(0, 0, 0),
      o = e.getAttribute("position"),
      a = e.index;
    if (a) for (let n = Math.max(0, e.drawRange.start), l = Math.min(a.count, e.drawRange.start + e.drawRange.count) - 1; n < l / 3; n += 3) {
      const e = a.getX(n),
        l = a.getX(n + 1),
        c = a.getX(n + 2);
      r.set(o.getX(e), o.getY(e), o.getZ(e)), i.set(o.getX(l), o.getY(l), o.getZ(l)), s.set(o.getX(c), o.getY(c), o.getZ(c)), i.sub(r), s.sub(r), s.cross(i), s.normalize(), t.add(s);
    } else for (let e = 0; e < o.count; e += 3) r.set(o.getX(e), o.getY(e), o.getZ(e)), i.set(o.getX(e + 1), o.getY(e + 1), o.getZ(e + 1)), s.set(o.getX(e + 2), o.getY(e + 2), o.getZ(e + 2)), i.sub(r), s.sub(r), s.cross(i), s.normalize(), t.add(s);
    t.normalize();
    let l = !1,
      c = 0;
    for (; !l;) {
      const e = c / 3,
        n = a ? a.getX(e) : e,
        s = a ? a.getX(e + 1) : e + 1;
      r.set(o.getX(n), o.getY(n), o.getZ(n)), i.set(o.getX(s), o.getY(s), o.getZ(s)), r.sub(i), r.normalize();
      const u = t.dot(r);
      Math.abs(u - 1) > .001 && r.length() > .5 && (l = !0), c += 3;
    }
    i.crossVectors(r, t), i.normalize(), r.crossVectors(t, i), r.normalize();
    const u = new n.yGw();
    u.elements[0] = r.x, u.elements[1] = r.y, u.elements[2] = r.z, u.elements[3] = 0, u.elements[4] = t.x, u.elements[5] = t.y, u.elements[6] = t.z, u.elements[7] = 0, u.elements[8] = i.x, u.elements[9] = i.y, u.elements[10] = i.z, u.elements[11] = 0, u.elements[12] = 0, u.elements[13] = 0, u.elements[14] = 0, u.elements[15] = 1, e.computeBoundingSphere();
    const h = e.boundingSphere.radius,
      p = new n.yGw().makeScale(h, h, h);
    return u.multiply(p), u;
  }
  function Yo(e) {
    const t = e.getAttribute("position");
    if (t.count > 0) return Xo(e);
    const r = new n.Pa4(0, 0, 0),
      i = new n.Pa4(0, 0, 0),
      s = new n.Pa4(0, 0, 0),
      o = e.index,
      a = [];
    if (o) for (let n = Math.max(0, e.drawRange.start), l = Math.min(o.count, e.drawRange.start + e.drawRange.count) - 1; n < l / 3; n += 3) {
      const e = o.getX(n),
        l = o.getX(n + 1),
        c = o.getX(n + 2);
      r.set(t.getX(e), t.getY(e), t.getZ(e)), i.set(t.getX(l), t.getY(l), t.getZ(l)), s.set(t.getX(c), t.getY(c), t.getZ(c)), a.push(r.toArray(), i.toArray(), s.toArray());
    } else for (let e = 0; e < t.count; e++) r.set(t.getX(e), t.getY(e), t.getZ(e)), a.push(r.toArray());
    const l = (0, qo.getEigenVectors)(a),
      c = new n.yGw();
    c.elements[0] = l[0].vector[0], c.elements[1] = l[0].vector[1], c.elements[2] = l[0].vector[2], c.elements[3] = 0, c.elements[4] = l[1].vector[0], c.elements[5] = l[1].vector[1], c.elements[6] = l[1].vector[2], c.elements[7] = 0, c.elements[8] = l[2].vector[0], c.elements[9] = l[2].vector[1], c.elements[10] = l[2].vector[2], c.elements[11] = 0, c.elements[12] = 0, c.elements[13] = 0, c.elements[14] = 0, c.elements[15] = 1, console.log(c.determinant()), e.computeBoundingSphere();
    const u = e.boundingSphere.radius,
      h = new n.yGw().makeScale(u, u, u);
    return c.multiply(h), c;
  }
  const Ko = {
    ...Wt,
    color: new Ae(1, 1, 1),
    envMapIntensity: 1,
    envMapRotation: 0,
    dispersion: .012,
    squashFactor: .98,
    geometryFactor: .5,
    gammaFactor: 1,
    absorptionFactor: 1,
    reflectivity: .5,
    refractiveIndex: 2.4,
    boostFactors: new n.Pa4(.892, .892, .98595025),
    envMap: null,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1,
    transmission: 0,
    morphTargets: !1,
    morphNormals: !1,
    rayBounces: 1,
    diamondOrientedEnvMap: 0
  };
  var Jo = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class Zo extends n.jyz {
    constructor(e) {
      super({
        side: n.ehD,
        defines: {
          DIA_ORIENT_ENVMAP: 0,
          RAY_BOUNCES: 5,
          ENV_MAP_TYPE: 0,
          PI: 3.1428
        },
        vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP  \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;void main(){vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;}",
        fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform mat4 modelMatrix;uniform mat4 inverseModelMatrix;uniform mat4 offsetMatrixInv;uniform mat4 offsetMatrix;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float radius;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform vec3 centerOffset;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.z*=-1.;\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){return envMapIntensity*(sampleEnvMap(direction));}uniform mat4 projectionMatrix;vec4 SampleSpecularContribution(vec3 direction){direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=centerOffset;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+centerOffset+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-centerOffset);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=centerOffset+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-centerOffset);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=centerOffset+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 traceRay(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 reflectedDirection=reflect(direction,normal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normal,vec3(f0),0.);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);outColor+=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;int count=0;newDirection=(offsetMatrixInv*inverseModelMatrix*vec4(newDirection,0.)).xyz;newDirection=normalize(newDirection);origin=(offsetMatrixInv*inverseModelMatrix*vec4(origin,1.)).xyz;vec3 origin2=origin;origin2=(modelMatrix*offsetMatrix*vec4(origin2,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-centerOffset);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;origin2=(modelMatrix*offsetMatrix*vec4(intersectedPos,1.)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(oldDir,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(DIA_ORIENT_ENVMAP<1?d1:newDirection).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(newDirection,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);\n#if DIA_ORIENT_ENVMAP < 1\ndir0=d1;dir1=(modelMatrix*offsetMatrix*vec4(dir1,0.)).xyz;dir2=(modelMatrix*offsetMatrix*vec4(dir2,0.)).xyz;\n#endif\noutColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);vec3 color=traceRay(vWorldPosition,viewVector,normalizedNormal);gl_FragColor=vec4(color.rgb,1.);\n#include <encodings_fragment>\n}",
        uniforms: {
          envMap: {
            value: e.envMap || null
          },
          envMapRotation: {
            value: 0
          },
          transmission: {
            value: 0
          },
          transmissionSamplerMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new n.FM8()
          },
          normalOffset: {
            value: 0
          },
          distanceOffset: {
            value: 0
          },
          colorCorrection: {
            value: new n.Pa4(1, 1, 1)
          }
        }
      }), this.typeSlug = Zo.TypeSlug, this.assetType = "material", this.__envMap = null, this.isDiamondMaterial = !0, this.color = new Ae(1, 1, 1), this.envMapIntensity = 1, this.dispersion = .012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = .98, this.geometryFactor = .5, this.gammaFactor = 1, this.boostFactors = new n.Pa4(.892, .892, .98595025), this.transmission = 0, this.reflectivity = .5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = {
        inverseModelMatrix: {
          value: new n.yGw().identity()
        },
        radius: {
          value: 1
        },
        centerOffset: {
          value: new n.Pa4(0, 0, 0)
        },
        offsetMatrix: {
          value: new n.yGw().identity()
        },
        offsetMatrixInv: {
          value: new n.yGw().identity()
        }
      }, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = e => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e);
      }, this.userData.separateEnvMapIntensity = !0, this.userData.enableLUT = !0, this.setValues(e);
    }
    get mmMaterial() {
      return this;
    }
    get materialObject() {
      return this;
    }
    onBeforeRender(e, t, r, n, i) {
      var s, o;
      super.onBeforeRender(e, t, r, n, i), this.uniforms.envMapRotation.value = (null === (s = this.envMap) || void 0 === s ? void 0 : s.rotation) || 0, this.extraUniformsToUpload.inverseModelMatrix.value.copy(i.matrixWorld).invert();
      const a = n.userData._normalsCaptureOffsets;
      a && (this.extraUniformsToUpload.centerOffset.value.copy(a.centerOffset), this.extraUniformsToUpload.offsetMatrix.value.copy(a.offsetMatrix), this.extraUniformsToUpload.offsetMatrixInv.value.copy(a.offsetMatrixInv), this.extraUniformsToUpload.radius.value = a.radius);
      const l = null === (o = n.userData._normalsCaptureMap) || void 0 === o ? void 0 : o.texture;
      this.normalsCaptureMap !== l && (this.normalsCaptureMap = l);
    }
    setDirty(e) {
      var t, r;
      this.needsUpdate = !0, this.dispatchEvent({
        ...e,
        type: "materialUpdate"
      }), null === (r = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0, 1);
    }
    set envMap(e) {
      var t;
      this.__envMap = e, this.uniforms.envMap.value = this.__envMap, (null === (t = this.__envMap) || void 0 === t ? void 0 : t.isCubeTexture) ? (this.defines.ENV_MAP_TYPE = 0, this.needsUpdate = !0) : (this.defines.ENV_MAP_TYPE = 1, this.needsUpdate = !0);
    }
    get envMap() {
      return this.__envMap;
    }
    clone() {
      return super.clone();
    }
    toJSON(e) {
      const t = {};
      return t.name = this.name, t.uuid = this.uuid, t.color = this.color.getHex(), t.envMapIntensity = this.envMapIntensity, t.dispersion = this.dispersion, t.squashFactor = this.squashFactor, t.geometryFactor = this.geometryFactor, t.gammaFactor = this.gammaFactor, t.absorptionFactor = this.absorptionFactor, t.reflectivity = this.reflectivity, t.refractiveIndex = this.refractiveIndex, t.rayBounces = this.rayBounces, t.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t.boostFactors = {
        x: this.boostFactors.x,
        y: this.boostFactors.y,
        z: this.boostFactors.z,
        isVector3: !0
      }, t.transmission = this.transmission, t.isDiamondMaterialParameters = !0, t.type = Zo.TYPE, t.userData = {}, xe(t.userData, this.userData), t.userData.uuid = this.userData.uuid, t;
    }
    get uiConfig() {
      const e = this;
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, ...ot(this), {
        type: "input",
        label: "Mesh count",
        get value() {
          var t, r, n;
          return null !== (n = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.__appliedMeshes) || void 0 === r ? void 0 : r.size) && void 0 !== n ? n : 0;
        },
        set value(e) {},
        disabled: !0
      }, {
        type: "checkbox",
        label: "Enable LUT",
        getValue: () => !0 === this.userData.enableLUT,
        setValue: e => {
          this.userData.enableLUT = e || void 0, this.setDirty();
        }
      }, {
        type: "input",
        label: "uuid",
        get value() {
          return e.uuid;
        },
        set value(e) {},
        disabled: !0
      }, {
        type: "checkbox",
        label: "Render to Depth",
        hidden: () => 0 === this.transmission,
        get value() {
          return !0 === e.userData.renderToDepth;
        },
        set value(t) {
          e.userData.renderToDepth = t || void 0;
        }
      }, {
        type: "button",
        label: "Download .dmat",
        value: () => {
          yt(new Blob([JSON.stringify(e.toJSON(), null, 2)], {
            type: "application/json"
          }), "diamond-material.dmat");
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Diamond Material",
        expanded: !0,
        children: this._uiConfigChildren,
        limitedUi: !0
      }), this._uiConfig;
    }
    copyProps(e) {
      if (!e.isDiamondMaterialParameters && !e.isDiamondMaterial && !e.isDiamond && e.type !== Zo.TYPE) return console.warn("Material type is not supported", e), this;
      const t = {};
      b(e, t, Array.from(Object.keys(Ko)));
      const r = t.userData;
      return delete t.userData, this.setValues(t), xe(this.userData, r), this.setDirty(), this;
    }
    fromJSON(e, t) {
      return this.copyProps(e);
    }
  }
  Zo.TypeSlug = "dmat", Zo.TYPE = "DiamondMaterial", Jo([it("Color", {
    limitedUi: !0
  }), G()], Zo.prototype, "color", void 0), Jo([$e("Env Intensity", [0, 5], .01, {
    limitedUi: !0
  }), G()], Zo.prototype, "envMapIntensity", void 0), Jo([$e("Dispersion", [0, .1], 1e-4, {
    limitedUi: !0
  }), G({
    propKey: "rIndexDelta"
  })], Zo.prototype, "dispersion", void 0), Jo([$e("Absorption", [0, 15], .01, {
    limitedUi: !0
  }), G()], Zo.prototype, "absorptionFactor", void 0), Jo([$e("Refractive Index", [0, 4], .01, {
    limitedUi: !0
  }), G()], Zo.prototype, "refractiveIndex", void 0), Jo([G()], Zo.prototype, "squashFactor", void 0), Jo([G()], Zo.prototype, "geometryFactor", void 0), Jo([G()], Zo.prototype, "gammaFactor", void 0), Jo([et("RGB Boost", void 0, void 0, {
    limitedUi: !0
  }), G()], Zo.prototype, "boostFactors", void 0), Jo([$e("Transmission", [0, 1], .01, {
    limitedUi: !0
  }), G()], Zo.prototype, "transmission", void 0), Jo([$e("Reflectivity", [0, 2], .01, {
    limitedUi: !0
  }), G()], Zo.prototype, "reflectivity", void 0), Jo([V("RAY_BOUNCES", void 0, !0), $e("Ray Bounces", [1, 16], 1)], Zo.prototype, "rayBounces", void 0), Jo([V("DIA_ORIENT_ENVMAP", void 0, !0), $e("Diamond Oriented Lighting", [0, 1], 1)], Zo.prototype, "diamondOrientedEnvMap", void 0), Jo([G({
    propKey: "tCubeMapNormals"
  })], Zo.prototype, "normalsCaptureMap", void 0);
  class $o extends r {
    constructor(e, t, r, i) {
      super(), this._scene = e, this._camera = null != r ? r : this._scene.activeCamera, this.domElement = t, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != i ? i : e => !1 !== e.userData.userSelectable && !1 !== e.userData.bboxVisible && null != e.material && "ShadowMaterial" !== e.material.type, this.raycaster = new n.iMs(), this.mouse = new n.FM8(), this._selected = [], this._hovering = [], this.cursorStyles = {
        default: "grab",
        down: "grabbing"
      }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", e => this.onPointerMove(e)), this.domElement.addEventListener("pointerleave", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointerout", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointercancel", e => this.onPointerCancel(e)), this.domElement.addEventListener("pointerenter", e => this.onPointerEnter(e)), this.domElement.addEventListener("pointerdown", e => this.onPointerDown(e)), this.domElement.addEventListener("pointerup", e => this.onPointerUp(e));
    }
    get scene() {
      return this._scene;
    }
    set scene(e) {
      var t;
      null === (t = this._scene) || void 0 === t || t.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e, this._scene.addEventListener("activeCameraChange", this._activeCameraChange);
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera;
    }
    get camera() {
      return this._camera;
    }
    set camera(e) {
      this._camera = e;
    }
    get selectedObject() {
      return this._selected.length > 0 ? this._selected[0] : null;
    }
    set selectedObject(e) {
      1 === this._selected.length && this._selected[0] === e || (this._selected = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "selectedObjectChanged",
        object: this.selectedObject
      }));
    }
    get hoverObject() {
      return this._hovering.length > 0 ? this._hovering[0] : null;
    }
    set hoverObject(e) {
      this._hovering = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "hoverObjectChanged",
        object: this.hoverObject
      });
    }
    get time() {
      return this._time = Dt(), this._time;
    }
    get isMouseDown() {
      return this.mouseDownDeltaTime < 0;
    }
    get mouseDownDeltaTime() {
      return this._mouseUpTime - this._mouseDownTime;
    }
    onPointerMove(e) {
      !1 !== e.isPrimary && this.updateMouseFromEvent(e);
    }
    onPointerLeave(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this.hoverObject = null);
    }
    onPointerEnter(e) {}
    onPointerCancel(e) {}
    updateMouseFromEvent(e) {
      const t = this.domElement.getBoundingClientRect();
      this.mouse.x = (e.clientX - t.x) / t.width * 2 - 1, this.mouse.y = -(e.clientY - t.y) / t.height * 2 + 1;
    }
    onPointerDown(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time);
    }
    onPointerUp(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time, this.mouseDownDeltaTime < 200 && this.onPointerClick(e));
    }
    onPointerClick(e) {
      if (!1 === e.isPrimary) return;
      this.updateMouseFromEvent(e);
      const t = this.checkIntersection();
      t && this.dispatchEvent({
        type: "hitObject",
        time: this._mouseUpTime,
        intersects: t
      }), this.selectedObject = (null == t ? void 0 : t.selectedObject) || null;
    }
    addPasses() {}
    checkIntersection() {
      var e;
      const t = null === (e = this._camera) || void 0 === e ? void 0 : e.cameraObject;
      if (!t) return null;
      this.raycaster.setFromCamera(this.mouse, t);
      const r = this.raycaster.intersectObject(this._scene.modelRoot.modelObject, !0),
        n = this.selectedObject;
      if (n) {
        const e = r.length - 1 - [...r].reverse().findIndex(e => {
          let t = e.object;
          for (; t;) {
            if (e.object === n) return !0;
            t = t.parent;
          }
          return !1;
        });
        e >= 0 && r.splice(0, e + 1);
      }
      if (r.length > 0) {
        for (const e of r) {
          let t = e.object;
          for (; !(null == t || t.visible && this.selectionCondition(t));) t = t.parent;
          if (t) return {
            selectedObject: t,
            intersect: e,
            intersects: r,
            mouse: this.mouse.toArray()
          };
        }
        return null;
      }
      return null;
    }
    refreshOutlinePass() {
      var e;
      null !== (e = this.hoverObject) && void 0 !== e || this.selectedObject;
    }
    isHovering() {
      return null != this.hoverObject;
    }
    isSelected() {
      return null != this.selectedObject;
    }
  }
  const ea = new n.iMs(),
    ta = new n.Pa4(),
    ra = new n.Pa4(),
    na = new n._fP(),
    ia = {
      X: new n.Pa4(1, 0, 0),
      Y: new n.Pa4(0, 1, 0),
      Z: new n.Pa4(0, 0, 1)
    },
    sa = {
      type: "change"
    },
    oa = {
      type: "mouseDown"
    },
    aa = {
      type: "mouseUp",
      mode: null
    },
    la = {
      type: "objectChange"
    };
  class ca extends n.Tme {
    constructor(e, t) {
      super(), void 0 === t && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
      const r = new ka();
      this._gizmo = r, this.add(r);
      const i = new Da();
      this._plane = i, this.add(i);
      const s = this;
      function o(e, t) {
        let n = t;
        Object.defineProperty(s, e, {
          get: function () {
            return void 0 !== n ? n : t;
          },
          set: function (t) {
            n !== t && (n = t, i[e] = t, r[e] = t, s.dispatchEvent({
              type: e + "-changed",
              value: t
            }), s.dispatchEvent(sa));
          }
        }), s[e] = t, i[e] = t, r[e] = t;
      }
      o("camera", e), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0);
      const a = new n.Pa4(),
        l = new n.Pa4(),
        c = new n._fP(),
        u = new n._fP(),
        h = new n.Pa4(),
        p = new n._fP(),
        d = new n.Pa4(),
        f = new n.Pa4(),
        m = new n.Pa4(),
        _ = new n.Pa4();
      o("worldPosition", a), o("worldPositionStart", l), o("worldQuaternion", c), o("worldQuaternionStart", u), o("cameraPosition", h), o("cameraQuaternion", p), o("pointStart", d), o("pointEnd", f), o("rotationAxis", m), o("rotationAngle", 0), o("eye", _), this._offset = new n.Pa4(), this._startNorm = new n.Pa4(), this._endNorm = new n.Pa4(), this._cameraScale = new n.Pa4(), this._parentPosition = new n.Pa4(), this._parentQuaternion = new n._fP(), this._parentQuaternionInv = new n._fP(), this._parentScale = new n.Pa4(), this._worldScaleStart = new n.Pa4(), this._worldQuaternionInv = new n._fP(), this._worldScale = new n.Pa4(), this._positionStart = new n.Pa4(), this._quaternionStart = new n._fP(), this._scaleStart = new n.Pa4(), this._getPointer = ua.bind(this), this._onPointerDown = pa.bind(this), this._onPointerHover = ha.bind(this), this._onPointerMove = da.bind(this), this._onPointerUp = fa.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
    }
    updateMatrixWorld() {
      void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
    }
    pointerHover(e) {
      if (void 0 === this.object || !0 === this.dragging) return;
      ea.setFromCamera(e, this.camera);
      const t = ma(this._gizmo.picker[this.mode], ea);
      this.axis = t ? t.object.name : null;
    }
    pointerDown(e) {
      if (void 0 !== this.object && !0 !== this.dragging && 0 === e.button && null !== this.axis) {
        ea.setFromCamera(e, this.camera);
        const t = ma(this._plane, ea, !0);
        t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, oa.mode = this.mode, this.dispatchEvent(oa);
      }
    }
    pointerMove(e) {
      const t = this.axis,
        r = this.mode,
        n = this.object;
      let i = this.space;
      if ("scale" === r ? i = "local" : "E" !== t && "XYZE" !== t && "XYZ" !== t || (i = "world"), void 0 === n || null === t || !1 === this.dragging || -1 !== e.button) return;
      ea.setFromCamera(e, this.camera);
      const s = ma(this._plane, ea, !0);
      if (s) {
        if (this.pointEnd.copy(s.point).sub(this.worldPositionStart), "translate" === r) this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i && "XYZ" !== t && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t.indexOf("X") && (this._offset.x = 0), -1 === t.indexOf("Y") && (this._offset.y = 0), -1 === t.indexOf("Z") && (this._offset.z = 0), "local" === i && "XYZ" !== t ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i && (n.position.applyQuaternion(na.copy(this._quaternionStart).invert()), -1 !== t.search("X") && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.position.applyQuaternion(this._quaternionStart)), "world" === i && (n.parent && n.position.add(ta.setFromMatrixPosition(n.parent.matrixWorld)), -1 !== t.search("X") && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.parent && n.position.sub(ta.setFromMatrixPosition(n.parent.matrixWorld))));else if ("scale" === r) {
          if (-1 !== t.search("XYZ")) {
            let e = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (e *= -1), ra.set(e, e, e);
          } else ta.copy(this.pointStart), ra.copy(this.pointEnd), ta.applyQuaternion(this._worldQuaternionInv), ra.applyQuaternion(this._worldQuaternionInv), ra.divide(ta), -1 === t.search("X") && (ra.x = 1), -1 === t.search("Y") && (ra.y = 1), -1 === t.search("Z") && (ra.z = 1);
          n.scale.copy(this._scaleStart).multiply(ra), this.scaleSnap && (-1 !== t.search("X") && (n.scale.x = Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Y") && (n.scale.y = Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Z") && (n.scale.z = Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if ("rotate" === r) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);
          const e = 20 / this.worldPosition.distanceTo(ta.setFromMatrixPosition(this.camera.matrixWorld));
          "E" === t ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(ta.copy(this.rotationAxis).cross(this.eye)) * e) : "X" !== t && "Y" !== t && "Z" !== t || (this.rotationAxis.copy(ia[t]), ta.copy(ia[t]), "local" === i && ta.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(ta.cross(this.eye).normalize()) * e), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i && "E" !== t && "XYZE" !== t ? (n.quaternion.copy(this._quaternionStart), n.quaternion.multiply(na.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n.quaternion.copy(na.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n.quaternion.multiply(this._quaternionStart).normalize());
        }
        this.dispatchEvent(sa), this.dispatchEvent(la);
      }
    }
    pointerUp(e) {
      0 === e.button && (this.dragging && null !== this.axis && (aa.mode = this.mode, this.dispatchEvent(aa)), this.dragging = !1, this.axis = null);
    }
    dispose() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
    }
    attach(e) {
      return this.object = e, this.visible = !0, this;
    }
    detach() {
      return this.object = void 0, this.visible = !1, this.axis = null, this;
    }
    reset() {
      this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(sa), this.dispatchEvent(la), this.pointStart.copy(this.pointEnd));
    }
    getRaycaster() {
      return ea;
    }
    getMode() {
      return this.mode;
    }
    setMode(e) {
      this.mode = e;
    }
    setTranslationSnap(e) {
      this.translationSnap = e;
    }
    setRotationSnap(e) {
      this.rotationSnap = e;
    }
    setScaleSnap(e) {
      this.scaleSnap = e;
    }
    setSize(e) {
      this.size = e;
    }
    setSpace(e) {
      this.space = e;
    }
  }
  function ua(e) {
    if (this.domElement.ownerDocument.pointerLockElement) return {
      x: 0,
      y: 0,
      button: e.button
    };
    {
      const t = this.domElement.getBoundingClientRect();
      return {
        x: (e.clientX - t.left) / t.width * 2 - 1,
        y: -(e.clientY - t.top) / t.height * 2 + 1,
        button: e.button
      };
    }
  }
  function ha(e) {
    if (this.enabled) switch (e.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(e));
    }
  }
  function pa(e) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e)), this.pointerDown(this._getPointer(e)));
  }
  function da(e) {
    this.enabled && this.pointerMove(this._getPointer(e));
  }
  function fa(e) {
    this.enabled && (this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e)));
  }
  function ma(e, t, r) {
    const n = t.intersectObject(e, !0);
    for (let e = 0; e < n.length; e++) if (n[e].object.visible || r) return n[e];
    return !1;
  }
  const _a = new n.USm(),
    ga = new n.Pa4(0, 1, 0),
    va = new n.Pa4(0, 0, 0),
    Aa = new n.yGw(),
    ba = new n._fP(),
    ya = new n._fP(),
    xa = new n.Pa4(),
    wa = new n.yGw(),
    Ea = new n.Pa4(1, 0, 0),
    Sa = new n.Pa4(0, 1, 0),
    Ca = new n.Pa4(0, 0, 1),
    Ma = new n.Pa4(),
    Ta = new n.Pa4(),
    Ia = new n.Pa4();
  class ka extends n.Tme {
    constructor() {
      super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
      const e = new n.vBJ({
          depthTest: !1,
          depthWrite: !1,
          fog: !1,
          toneMapped: !1,
          transparent: !0
        }),
        t = new n.nls({
          depthTest: !1,
          depthWrite: !1,
          fog: !1,
          toneMapped: !1,
          transparent: !0
        }),
        r = e.clone();
      r.opacity = .15;
      const i = t.clone();
      i.opacity = .5;
      const s = e.clone();
      s.color.setHex(16711680);
      const o = e.clone();
      o.color.setHex(65280);
      const a = e.clone();
      a.color.setHex(255);
      const l = e.clone();
      l.color.setHex(16711680), l.opacity = .5;
      const c = e.clone();
      c.color.setHex(65280), c.opacity = .5;
      const u = e.clone();
      u.color.setHex(255), u.opacity = .5;
      const h = e.clone();
      h.opacity = .25;
      const p = e.clone();
      p.color.setHex(16776960), p.opacity = .25, e.clone().color.setHex(16776960);
      const d = e.clone();
      d.color.setHex(7895160);
      const f = new n.fHI(0, .04, .1, 12);
      f.translate(0, .05, 0);
      const m = new n.DvJ(.08, .08, .08);
      m.translate(0, .04, 0);
      const _ = new n.u9r();
      _.setAttribute("position", new n.a$l([0, 0, 0, 1, 0, 0], 3));
      const g = new n.fHI(.0075, .0075, .5, 3);
      function v(e, t) {
        const r = new n.XvJ(e, .0075, 3, 64, t * Math.PI * 2);
        return r.rotateY(Math.PI / 2), r.rotateX(Math.PI / 2), r;
      }
      g.translate(0, .25, 0);
      const A = {
          X: [[new n.Kj0(f, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(f, s), [-.5, 0, 0], [0, 0, Math.PI / 2]], [new n.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]]],
          Y: [[new n.Kj0(f, o), [0, .5, 0]], [new n.Kj0(f, o), [0, -.5, 0], [Math.PI, 0, 0]], [new n.Kj0(g, o)]],
          Z: [[new n.Kj0(f, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new n.Kj0(f, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]], [new n.Kj0(g, a), null, [Math.PI / 2, 0, 0]]],
          XYZ: [[new n.Kj0(new n.pQR(.1, 0), h.clone()), [0, 0, 0]]],
          XY: [[new n.Kj0(new n.DvJ(.15, .15, .01), u.clone()), [.15, .15, 0]]],
          YZ: [[new n.Kj0(new n.DvJ(.15, .15, .01), l.clone()), [0, .15, .15], [0, Math.PI / 2, 0]]],
          XZ: [[new n.Kj0(new n.DvJ(.15, .15, .01), c.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
        },
        b = {
          X: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
          Y: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, .3, 0]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, -.3, 0], [0, 0, Math.PI]]],
          Z: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, 0, .3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
          XYZ: [[new n.Kj0(new n.pQR(.2, 0), r)]],
          XY: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [.15, .15, 0]]],
          YZ: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [0, .15, .15], [0, Math.PI / 2, 0]]],
          XZ: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
        },
        y = {
          START: [[new n.Kj0(new n.pQR(.01, 2), i), null, null, null, "helper"]],
          END: [[new n.Kj0(new n.pQR(.01, 2), i), null, null, null, "helper"]],
          DELTA: [[new n.x12(function () {
            const e = new n.u9r();
            return e.setAttribute("position", new n.a$l([0, 0, 0, 1, 1, 1], 3)), e;
          }(), i), null, null, null, "helper"]],
          X: [[new n.x12(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
          Y: [[new n.x12(_, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
          Z: [[new n.x12(_, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
        },
        x = {
          XYZE: [[new n.Kj0(v(.5, 1), d), null, [0, Math.PI / 2, 0]]],
          X: [[new n.Kj0(v(.5, .5), s)]],
          Y: [[new n.Kj0(v(.5, .5), o), null, [0, 0, -Math.PI / 2]]],
          Z: [[new n.Kj0(v(.5, .5), a), null, [0, Math.PI / 2, 0]]],
          E: [[new n.Kj0(v(.75, 1), p), null, [0, Math.PI / 2, 0]]]
        },
        w = {
          AXIS: [[new n.x12(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
        },
        E = {
          XYZE: [[new n.Kj0(new n.xo$(.25, 10, 8), r)]],
          X: [[new n.Kj0(new n.XvJ(.5, .1, 4, 24), r), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
          Y: [[new n.Kj0(new n.XvJ(.5, .1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]]],
          Z: [[new n.Kj0(new n.XvJ(.5, .1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]]],
          E: [[new n.Kj0(new n.XvJ(.75, .1, 2, 24), r)]]
        },
        S = {
          X: [[new n.Kj0(m, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(m, s), [-.5, 0, 0], [0, 0, Math.PI / 2]]],
          Y: [[new n.Kj0(m, o), [0, .5, 0]], [new n.Kj0(g, o)], [new n.Kj0(m, o), [0, -.5, 0], [0, 0, Math.PI]]],
          Z: [[new n.Kj0(m, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new n.Kj0(g, a), [0, 0, 0], [Math.PI / 2, 0, 0]], [new n.Kj0(m, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]]],
          XY: [[new n.Kj0(new n.DvJ(.15, .15, .01), u), [.15, .15, 0]]],
          YZ: [[new n.Kj0(new n.DvJ(.15, .15, .01), l), [0, .15, .15], [0, Math.PI / 2, 0]]],
          XZ: [[new n.Kj0(new n.DvJ(.15, .15, .01), c), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
          XYZ: [[new n.Kj0(new n.DvJ(.1, .1, .1), h.clone())]]
        },
        C = {
          X: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
          Y: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, .3, 0]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, -.3, 0], [0, 0, Math.PI]]],
          Z: [[new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, 0, .3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(.2, 0, .6, 4), r), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
          XY: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [.15, .15, 0]]],
          YZ: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [0, .15, .15], [0, Math.PI / 2, 0]]],
          XZ: [[new n.Kj0(new n.DvJ(.2, .2, .01), r), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
          XYZ: [[new n.Kj0(new n.DvJ(.2, .2, .2), r), [0, 0, 0]]]
        },
        M = {
          X: [[new n.x12(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
          Y: [[new n.x12(_, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
          Z: [[new n.x12(_, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
        };
      function T(e) {
        const t = new n.Tme();
        for (const r in e) for (let n = e[r].length; n--;) {
          const i = e[r][n][0].clone(),
            s = e[r][n][1],
            o = e[r][n][2],
            a = e[r][n][3],
            l = e[r][n][4];
          i.name = r, i.tag = l, s && i.position.set(s[0], s[1], s[2]), o && i.rotation.set(o[0], o[1], o[2]), a && i.scale.set(a[0], a[1], a[2]), i.updateMatrix();
          const c = i.geometry.clone();
          c.applyMatrix4(i.matrix), i.geometry = c, i.renderOrder = 1 / 0, i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), t.add(i);
        }
        return t;
      }
      this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = T(A)), this.add(this.gizmo.rotate = T(x)), this.add(this.gizmo.scale = T(S)), this.add(this.picker.translate = T(b)), this.add(this.picker.rotate = T(E)), this.add(this.picker.scale = T(C)), this.add(this.helper.translate = T(y)), this.add(this.helper.rotate = T(w)), this.add(this.helper.scale = T(M)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
    }
    updateMatrixWorld(e) {
      const t = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : ya;
      this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
      let r = [];
      r = r.concat(this.picker[this.mode].children), r = r.concat(this.gizmo[this.mode].children), r = r.concat(this.helper[this.mode].children);
      for (let e = 0; e < r.length; e++) {
        const n = r[e];
        let i;
        if (n.visible = !0, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition), i = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(i * this.size / 4), "helper" !== n.tag) {
          if (n.quaternion.copy(t), "translate" === this.mode || "scale" === this.mode) {
            const e = .99,
              r = .2;
            "X" === n.name && Math.abs(ga.copy(Ea).applyQuaternion(t).dot(this.eye)) > e && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "Y" === n.name && Math.abs(ga.copy(Sa).applyQuaternion(t).dot(this.eye)) > e && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "Z" === n.name && Math.abs(ga.copy(Ca).applyQuaternion(t).dot(this.eye)) > e && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "XY" === n.name && Math.abs(ga.copy(Ca).applyQuaternion(t).dot(this.eye)) < r && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "YZ" === n.name && Math.abs(ga.copy(Ea).applyQuaternion(t).dot(this.eye)) < r && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "XZ" === n.name && Math.abs(ga.copy(Sa).applyQuaternion(t).dot(this.eye)) < r && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1);
          } else "rotate" === this.mode && (ba.copy(t), ga.copy(this.eye).applyQuaternion(na.copy(t).invert()), -1 !== n.name.search("E") && n.quaternion.setFromRotationMatrix(Aa.lookAt(this.eye, va, Sa)), "X" === n.name && (na.setFromAxisAngle(Ea, Math.atan2(-ga.y, ga.z)), na.multiplyQuaternions(ba, na), n.quaternion.copy(na)), "Y" === n.name && (na.setFromAxisAngle(Sa, Math.atan2(ga.x, ga.z)), na.multiplyQuaternions(ba, na), n.quaternion.copy(na)), "Z" === n.name && (na.setFromAxisAngle(Ca, Math.atan2(ga.y, ga.x)), na.multiplyQuaternions(ba, na), n.quaternion.copy(na)));
          n.visible = n.visible && (-1 === n.name.indexOf("X") || this.showX), n.visible = n.visible && (-1 === n.name.indexOf("Y") || this.showY), n.visible = n.visible && (-1 === n.name.indexOf("Z") || this.showZ), n.visible = n.visible && (-1 === n.name.indexOf("E") || this.showX && this.showY && this.showZ), n.material._color = n.material._color || n.material.color.clone(), n.material._opacity = n.material._opacity || n.material.opacity, n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled && this.axis && (n.name === this.axis || this.axis.split("").some(function (e) {
            return n.name === e;
          })) && (n.material.color.setHex(16776960), n.material.opacity = 1);
        } else n.visible = !1, "AXIS" === n.name ? (n.position.copy(this.worldPositionStart), n.visible = !!this.axis, "X" === this.axis && (na.setFromEuler(_a.set(0, 0, 0)), n.quaternion.copy(t).multiply(na), Math.abs(ga.copy(Ea).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), "Y" === this.axis && (na.setFromEuler(_a.set(0, 0, Math.PI / 2)), n.quaternion.copy(t).multiply(na), Math.abs(ga.copy(Sa).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), "Z" === this.axis && (na.setFromEuler(_a.set(0, Math.PI / 2, 0)), n.quaternion.copy(t).multiply(na), Math.abs(ga.copy(Ca).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), "XYZE" === this.axis && (na.setFromEuler(_a.set(0, Math.PI / 2, 0)), ga.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(Aa.lookAt(va, ga, Sa)), n.quaternion.multiply(na), n.visible = this.dragging), "E" === this.axis && (n.visible = !1)) : "START" === n.name ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : "END" === n.name ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : "DELTA" === n.name ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), ta.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), ta.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(ta), n.visible = this.dragging) : (n.quaternion.copy(t), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = -1 !== this.axis.search(n.name)));
      }
      super.updateMatrixWorld(e);
    }
  }
  class Da extends n.Kj0 {
    constructor() {
      super(new n._12(1e5, 1e5, 2, 2), new n.vBJ({
        visible: !1,
        wireframe: !0,
        side: n.ehD,
        transparent: !0,
        opacity: .1,
        toneMapped: !1
      })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
    }
    updateMatrixWorld(e) {
      let t = this.space;
      switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t = "local"), Ma.copy(Ea).applyQuaternion("local" === t ? this.worldQuaternion : ya), Ta.copy(Sa).applyQuaternion("local" === t ? this.worldQuaternion : ya), Ia.copy(Ca).applyQuaternion("local" === t ? this.worldQuaternion : ya), ga.copy(Ta), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              ga.copy(this.eye).cross(Ma), xa.copy(Ma).cross(ga);
              break;
            case "Y":
              ga.copy(this.eye).cross(Ta), xa.copy(Ta).cross(ga);
              break;
            case "Z":
              ga.copy(this.eye).cross(Ia), xa.copy(Ia).cross(ga);
              break;
            case "XY":
              xa.copy(Ia);
              break;
            case "YZ":
              xa.copy(Ma);
              break;
            case "XZ":
              ga.copy(Ia), xa.copy(Ta);
              break;
            case "XYZ":
            case "E":
              xa.set(0, 0, 0);
          }
          break;
        default:
          xa.set(0, 0, 0);
      }
      0 === xa.length() ? this.quaternion.copy(this.cameraQuaternion) : (wa.lookAt(ta.set(0, 0, 0), xa, ga), this.quaternion.setFromRotationMatrix(wa)), super.updateMatrixWorld(e);
    }
  }
  const Pa = new n.ZzF(),
    Ba = new n.Pa4();
  class Ra extends n.L5s {
    constructor() {
      super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new n.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new n.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
    }
    applyMatrix4(e) {
      const t = this.attributes.instanceStart,
        r = this.attributes.instanceEnd;
      return void 0 !== t && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    setPositions(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const r = new n.$TI(t, 6, 1);
      return this.setAttribute("instanceStart", new n.kB5(r, 3, 0)), this.setAttribute("instanceEnd", new n.kB5(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }
    setColors(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const r = new n.$TI(t, 6, 1);
      return this.setAttribute("instanceColorStart", new n.kB5(r, 3, 0)), this.setAttribute("instanceColorEnd", new n.kB5(r, 3, 3)), this;
    }
    fromWireframeGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }
    fromEdgesGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }
    fromMesh(e) {
      return this.fromWireframeGeometry(new n.Uk6(e.geometry)), this;
    }
    fromLineSegments(e) {
      const t = e.geometry;
      return this.setPositions(t.attributes.position.array), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new n.ZzF());
      const e = this.attributes.instanceStart,
        t = this.attributes.instanceEnd;
      void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), Pa.setFromBufferAttribute(t), this.boundingBox.union(Pa));
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new n.aLr()), null === this.boundingBox && this.computeBoundingBox();
      const e = this.attributes.instanceStart,
        t = this.attributes.instanceEnd;
      if (void 0 !== e && void 0 !== t) {
        const r = this.boundingSphere.center;
        this.boundingBox.getCenter(r);
        let n = 0;
        for (let i = 0, s = e.count; i < s; i++) Ba.fromBufferAttribute(e, i), n = Math.max(n, r.distanceToSquared(Ba)), Ba.fromBufferAttribute(t, i), n = Math.max(n, r.distanceToSquared(Ba));
        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
    toJSON() {}
    applyMatrix(e) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
    }
  }
  class La extends Ra {
    constructor(e) {
      super(), this.isWireframeGeometry2 = !0, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new n.Uk6(e));
    }
  }
  n.rBU.line = {
    worldUnits: {
      value: 1
    },
    linewidth: {
      value: 1
    },
    resolution: {
      value: new n.FM8(1, 1)
    },
    dashOffset: {
      value: 0
    },
    dashScale: {
      value: 1
    },
    dashSize: {
      value: 1
    },
    gapSize: {
      value: 1
    }
  }, n.Vj0.line = {
    uniforms: n.rDY.merge([n.rBU.common, n.rBU.fog, n.rBU.line]),
    vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
    fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
  };
  class Oa extends n.jyz {
    constructor(e) {
      super({
        type: "LineMaterial",
        uniforms: n.rDY.clone(n.Vj0.line.uniforms),
        vertexShader: n.Vj0.line.vertexShader,
        fragmentShader: n.Vj0.line.fragmentShader,
        clipping: !0
      }), this.isLineMaterial = !0, Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (e) {
            this.uniforms.diffuse.value = e;
          }
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (e) {
            !0 === e ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
          }
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (e) {
            this.uniforms.linewidth.value = e;
          }
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_DASH" in this.defines);
          },
          set(e) {
            Boolean(e) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === e ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
          }
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (e) {
            this.uniforms.dashScale.value = e;
          }
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (e) {
            this.uniforms.dashSize.value = e;
          }
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (e) {
            this.uniforms.dashOffset.value = e;
          }
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (e) {
            this.uniforms.gapSize.value = e;
          }
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (e) {
            this.uniforms.opacity.value = e;
          }
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (e) {
            this.uniforms.resolution.value.copy(e);
          }
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
          },
          set: function (e) {
            Boolean(e) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === e ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
          }
        }
      }), this.setValues(e);
    }
  }
  const Fa = new n.Pa4(),
    Ua = new n.Pa4();
  class Na extends n.Kj0 {
    constructor(e = new Ra(), t = new Oa({
      color: 16777215 * Math.random()
    })) {
      super(e, t), this.isWireframe = !0, this.type = "Wireframe";
    }
    computeLineDistances() {
      const e = this.geometry,
        t = e.attributes.instanceStart,
        r = e.attributes.instanceEnd,
        i = new Float32Array(2 * t.count);
      for (let e = 0, n = 0, s = t.count; e < s; e++, n += 2) Fa.fromBufferAttribute(t, e), Ua.fromBufferAttribute(r, e), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + Fa.distanceTo(Ua);
      const s = new n.$TI(i, 2, 1);
      return e.setAttribute("instanceDistanceStart", new n.kB5(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new n.kB5(s, 1, 1)), this;
    }
  }
  class ja extends n.ZAu {
    constructor() {
      super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = !1, this.renderOrder = 1, this.userData.bboxVisible = !1, this._updater = this._updater.bind(this);
    }
    _updater() {
      const e = this._object;
      if (e) {
        const t = new k().expandByObject(e, !1);
        t.getCenter(this.position);
        const r = t.getBoundingSphere(new n.aLr()).radius;
        this.scale.setScalar(r * this.boundingScaleMultiplier), this.setVisible(!0);
      } else this.setVisible(!1);
    }
    _initGeometry(e) {
      if (this._geometry) return;
      const t = new La(e);
      this._geometry = t;
      const r = new Oa({
          color: "#ff2222",
          transparent: !0,
          opacity: .9,
          linewidth: 5,
          resolution: new n.FM8(1024, 1024),
          dashed: !1,
          toneMapped: !1
        }),
        i = new Na(t, r);
      i.computeLineDistances(), i.scale.set(1, 1, 1), i.visible = !0, this.add(i);
    }
    setVisible(e) {
      var t;
      e !== this.visible && (this.visible = e, null === (t = this.setDirty) || void 0 === t || t.call(this, {
        sceneUpdate: !1
      }));
    }
    attach(e) {
      return this.detach(), e ? (this._object = e, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this;
    }
    detach() {
      var e;
      return this._object ? (null === (e = this._object) || void 0 === e || e.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this;
    }
    get object() {
      return this._object;
    }
  }
  class za extends ja {
    constructor() {
      super(), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new n.DvJ(2, 2, 2, 1, 1, 1));
    }
    _updater() {
      super._updater();
      const e = this.object;
      e && (new k().expandByObject(e, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(.1, 100), this.setVisible(!0));
    }
  }
  var Ga = function (e) {
      return function (t) {
        return 1 - e(1 - t);
      };
    },
    Va = function (e) {
      return function (t) {
        return t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2;
      };
    },
    Qa = function (e) {
      return function (t) {
        return Math.pow(t, e);
      };
    },
    Ha = function (e) {
      return function (t) {
        return t * t * ((e + 1) * t - e);
      };
    },
    Wa = function (e) {
      var t = Ha(e);
      return function (e) {
        return (e *= 2) < 1 ? .5 * t(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)));
      };
    },
    qa = function (e) {
      return e;
    },
    Xa = Qa(2),
    Ya = Ga(Xa),
    Ka = Va(Xa),
    Ja = function (e) {
      return 1 - Math.sin(Math.acos(e));
    },
    Za = Ga(Ja),
    $a = Va(Za),
    el = Ha(1.525),
    tl = Ga(el),
    rl = Va(el),
    nl = Wa(1.525),
    il = function (e) {
      if (1 === e || 0 === e) return e;
      var t = e * e;
      return e < .36363636363636365 ? 7.5625 * t : e < .7272727272727273 ? 9.075 * t - 9.9 * e + 3.4 : e < .9 ? 12.066481994459833 * t - 19.63545706371191 * e + 8.898060941828255 : 10.8 * e * e - 20.52 * e + 10.72;
    },
    sl = Ga(il),
    ol = function (e) {
      return e < .5 ? .5 * (1 - il(1 - 2 * e)) : .5 * il(2 * e - 1) + .5;
    },
    al = function () {
      return al = Object.assign || function (e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e;
      }, al.apply(this, arguments);
    };
  function ll(e, t) {
    var r = {};
    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
    }
    return r;
  }
  Object.create, Object.create;
  var cl = function (e, t, r) {
    return Math.min(Math.max(r, e), t);
  };
  function ul(e, t) {
    return e * Math.sqrt(1 - t * t);
  }
  var hl = ["duration", "bounce"],
    pl = ["stiffness", "damping", "mass"];
  function dl(e, t) {
    return t.some(function (t) {
      return void 0 !== e[t];
    });
  }
  function fl(e) {
    var t = e.from,
      r = void 0 === t ? 0 : t,
      n = e.to,
      i = void 0 === n ? 1 : n,
      s = e.restSpeed,
      o = void 0 === s ? 2 : s,
      a = e.restDelta,
      l = ll(e, ["from", "to", "restSpeed", "restDelta"]),
      c = {
        done: !1,
        value: r
      },
      u = function (e) {
        var t = al({
          velocity: 0,
          stiffness: 100,
          damping: 10,
          mass: 1,
          isResolvedFromDuration: !1
        }, e);
        if (!dl(e, pl) && dl(e, hl)) {
          var r = function (e) {
            var t,
              r,
              n = e.duration,
              i = void 0 === n ? 800 : n,
              s = e.bounce,
              o = void 0 === s ? .25 : s,
              a = e.velocity,
              l = void 0 === a ? 0 : a,
              c = e.mass,
              u = void 0 === c ? 1 : c,
              h = 1 - o;
            h = cl(.05, 1, h), i = cl(.01, 10, i / 1e3), h < 1 ? (t = function (e) {
              var t = e * h,
                r = t * i;
              return .001 - (t - l) / ul(e, h) * Math.exp(-r);
            }, r = function (e) {
              var r = e * h * i,
                n = r * l + l,
                s = Math.pow(h, 2) * Math.pow(e, 2) * i,
                o = Math.exp(-r),
                a = ul(Math.pow(e, 2), h);
              return (.001 - t(e) > 0 ? -1 : 1) * ((n - s) * o) / a;
            }) : (t = function (e) {
              return Math.exp(-e * i) * ((e - l) * i + 1) - .001;
            }, r = function (e) {
              return Math.exp(-e * i) * (i * i * (l - e));
            });
            var p = function (e, t, r) {
              for (var n = r, i = 1; i < 12; i++) n -= e(n) / t(n);
              return n;
            }(t, r, 5 / i);
            if (i *= 1e3, isNaN(p)) return {
              stiffness: 100,
              damping: 10,
              duration: i
            };
            var d = Math.pow(p, 2) * u;
            return {
              stiffness: d,
              damping: 2 * h * Math.sqrt(u * d),
              duration: i
            };
          }(e);
          (t = al(al(al({}, t), r), {
            velocity: 0,
            mass: 1
          })).isResolvedFromDuration = !0;
        }
        return t;
      }(l),
      h = u.stiffness,
      p = u.damping,
      d = u.mass,
      f = u.velocity,
      m = u.duration,
      _ = u.isResolvedFromDuration,
      g = ml,
      v = ml;
    function A() {
      var e = f ? -f / 1e3 : 0,
        t = i - r,
        n = p / (2 * Math.sqrt(h * d)),
        s = Math.sqrt(h / d) / 1e3;
      if (null != a || (a = Math.abs(i - r) <= 1 ? .01 : .4), n < 1) {
        var o = ul(s, n);
        g = function (r) {
          var a = Math.exp(-n * s * r);
          return i - a * ((e + n * s * t) / o * Math.sin(o * r) + t * Math.cos(o * r));
        }, v = function (r) {
          var i = Math.exp(-n * s * r);
          return n * s * i * (Math.sin(o * r) * (e + n * s * t) / o + t * Math.cos(o * r)) - i * (Math.cos(o * r) * (e + n * s * t) - o * t * Math.sin(o * r));
        };
      } else if (1 === n) g = function (r) {
        return i - Math.exp(-s * r) * (t + (e + s * t) * r);
      };else {
        var l = s * Math.sqrt(n * n - 1);
        g = function (r) {
          var o = Math.exp(-n * s * r),
            a = Math.min(l * r, 300);
          return i - o * ((e + n * s * t) * Math.sinh(a) + l * t * Math.cosh(a)) / l;
        };
      }
    }
    return A(), {
      next: function (e) {
        var t = g(e);
        if (_) c.done = e >= m;else {
          var r = 1e3 * v(e),
            n = Math.abs(r) <= o,
            s = Math.abs(i - t) <= a;
          c.done = n && s;
        }
        return c.value = c.done ? i : t, c;
      },
      flipTarget: function () {
        var e;
        f = -f, r = (e = [i, r])[0], i = e[1], A();
      }
    };
  }
  fl.needsInterpolation = function (e, t) {
    return "string" == typeof e || "string" == typeof t;
  };
  var ml = function (e) {
      return 0;
    },
    _l = function (e, t, r) {
      var n = t - e;
      return 0 === n ? 1 : (r - e) / n;
    },
    gl = function (e, t, r) {
      return -r * e + r * t + e;
    },
    vl = function (e, t) {
      return function (r) {
        return Math.max(Math.min(r, t), e);
      };
    },
    Al = function (e) {
      return e % 1 ? Number(e.toFixed(5)) : e;
    },
    bl = /(-)?([\d]*\.?[\d])+/g,
    yl = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi,
    xl = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function wl(e) {
    return "string" == typeof e;
  }
  var El = {
      test: function (e) {
        return "number" == typeof e;
      },
      parse: parseFloat,
      transform: function (e) {
        return e;
      }
    },
    Sl = al(al({}, El), {
      transform: vl(0, 1)
    }),
    Cl = (al(al({}, El), {
      default: 1
    }), function (e, t) {
      return function (r) {
        return Boolean(wl(r) && xl.test(r) && r.startsWith(e) || t && Object.prototype.hasOwnProperty.call(r, t));
      };
    }),
    Ml = function (e, t, r) {
      return function (n) {
        var i;
        if (!wl(n)) return n;
        var s = n.match(bl),
          o = s[0],
          a = s[1],
          l = s[2],
          c = s[3];
        return (i = {})[e] = parseFloat(o), i[t] = parseFloat(a), i[r] = parseFloat(l), i.alpha = void 0 !== c ? parseFloat(c) : 1, i;
      };
    },
    Tl = vl(0, 255),
    Il = al(al({}, El), {
      transform: function (e) {
        return Math.round(Tl(e));
      }
    }),
    kl = {
      test: Cl("rgb", "red"),
      parse: Ml("red", "green", "blue"),
      transform: function (e) {
        var t = e.red,
          r = e.green,
          n = e.blue,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
        return "rgba(" + Il.transform(t) + ", " + Il.transform(r) + ", " + Il.transform(n) + ", " + Al(Sl.transform(s)) + ")";
      }
    },
    Dl = {
      test: Cl("#"),
      parse: function (e) {
        var t = "",
          r = "",
          n = "",
          i = "";
        return e.length > 5 ? (t = e.substr(1, 2), r = e.substr(3, 2), n = e.substr(5, 2), i = e.substr(7, 2)) : (t = e.substr(1, 1), r = e.substr(2, 1), n = e.substr(3, 1), i = e.substr(4, 1), t += t, r += r, n += n, i += i), {
          red: parseInt(t, 16),
          green: parseInt(r, 16),
          blue: parseInt(n, 16),
          alpha: i ? parseInt(i, 16) / 255 : 1
        };
      },
      transform: kl.transform
    },
    Pl = function (e) {
      return {
        test: function (t) {
          return wl(t) && t.endsWith(e) && 1 === t.split(" ").length;
        },
        parse: parseFloat,
        transform: function (t) {
          return "" + t + e;
        }
      };
    },
    Bl = (Pl("deg"), Pl("%")),
    Rl = (Pl("px"), Pl("vh"), Pl("vw"), al(al({}, Bl), {
      parse: function (e) {
        return Bl.parse(e) / 100;
      },
      transform: function (e) {
        return Bl.transform(100 * e);
      }
    }), {
      test: Cl("hsl", "hue"),
      parse: Ml("hue", "saturation", "lightness"),
      transform: function (e) {
        var t = e.hue,
          r = e.saturation,
          n = e.lightness,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
        return "hsla(" + Math.round(t) + ", " + Bl.transform(Al(r)) + ", " + Bl.transform(Al(n)) + ", " + Al(Sl.transform(s)) + ")";
      }
    }),
    Ll = function (e, t, r) {
      var n = e * e,
        i = t * t;
      return Math.sqrt(Math.max(0, r * (i - n) + n));
    },
    Ol = [Dl, kl, Rl],
    Fl = function (e) {
      return Ol.find(function (t) {
        return t.test(e);
      });
    },
    Ul = function (e) {
      return "'" + e + "' is not an animatable color. Use the equivalent color code instead.";
    },
    Nl = function (e, t) {
      var r = Fl(e),
        n = Fl(t);
      Ul(e), Ul(t), r.transform, n.transform;
      var i = r.parse(e),
        s = n.parse(t),
        o = al({}, i),
        a = r === Rl ? gl : Ll;
      return function (e) {
        for (var t in o) "alpha" !== t && (o[t] = a(i[t], s[t], e));
        return o.alpha = gl(i.alpha, s.alpha, e), r.transform(o);
      };
    },
    jl = function (e) {
      return kl.test(e) || Dl.test(e) || Rl.test(e);
    },
    zl = function (e) {
      return kl.test(e) ? kl.parse(e) : Rl.test(e) ? Rl.parse(e) : Dl.parse(e);
    },
    Gl = function (e) {
      return wl(e) ? e : e.hasOwnProperty("red") ? kl.transform(e) : Rl.transform(e);
    },
    Vl = "${c}",
    Ql = "${n}";
  function Hl(e) {
    var t = [],
      r = 0,
      n = e.match(yl);
    n && (r = n.length, e = e.replace(yl, Vl), t.push.apply(t, n.map(zl)));
    var i = e.match(bl);
    return i && (e = e.replace(bl, Ql), t.push.apply(t, i.map(El.parse))), {
      values: t,
      numColors: r,
      tokenised: e
    };
  }
  function Wl(e) {
    return Hl(e).values;
  }
  function ql(e) {
    var t = Hl(e),
      r = t.values,
      n = t.numColors,
      i = t.tokenised,
      s = r.length;
    return function (e) {
      for (var t = i, r = 0; r < s; r++) t = t.replace(r < n ? Vl : Ql, r < n ? Gl(e[r]) : Al(e[r]));
      return t;
    };
  }
  var Xl = function (e) {
      return "number" == typeof e ? 0 : e;
    },
    Yl = {
      test: function (e) {
        var t, r, n, i;
        return isNaN(e) && wl(e) && (null !== (r = null === (t = e.match(bl)) || void 0 === t ? void 0 : t.length) && void 0 !== r ? r : 0) + (null !== (i = null === (n = e.match(yl)) || void 0 === n ? void 0 : n.length) && void 0 !== i ? i : 0) > 0;
      },
      parse: Wl,
      createTransformer: ql,
      getAnimatableNone: function (e) {
        var t = Wl(e);
        return ql(e)(t.map(Xl));
      }
    },
    Kl = {
      x: 0,
      y: 0,
      z: 0
    },
    Jl = function (e) {
      return "number" == typeof e;
    },
    Zl = function (e, t) {
      return function (r) {
        return t(e(r));
      };
    },
    $l = function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      return e.reduce(Zl);
    };
  function ec(e, t) {
    return Jl(e) ? function (r) {
      return gl(e, t, r);
    } : jl(e) ? Nl(e, t) : ic(e, t);
  }
  var tc = function (e, t) {
      var r = function (e, t) {
          for (var r = 0, n = t.length, i = e.length; r < n; r++, i++) e[i] = t[r];
          return e;
        }([], e),
        n = r.length,
        i = e.map(function (e, r) {
          return ec(e, t[r]);
        });
      return function (e) {
        for (var t = 0; t < n; t++) r[t] = i[t](e);
        return r;
      };
    },
    rc = function (e, t) {
      var r = al(al({}, e), t),
        n = {};
      for (var i in r) void 0 !== e[i] && void 0 !== t[i] && (n[i] = ec(e[i], t[i]));
      return function (e) {
        for (var t in n) r[t] = n[t](e);
        return r;
      };
    };
  function nc(e) {
    for (var t = Yl.parse(e), r = t.length, n = 0, i = 0, s = 0, o = 0; o < r; o++) n || "number" == typeof t[o] ? n++ : void 0 !== t[o].hue ? s++ : i++;
    return {
      parsed: t,
      numNumbers: n,
      numRGB: i,
      numHSL: s
    };
  }
  var ic = function (e, t) {
      var r = Yl.createTransformer(t),
        n = nc(e),
        i = nc(t);
      return n.numHSL === i.numHSL && n.numRGB === i.numRGB && (n.numNumbers, i.numNumbers), $l(tc(n.parsed, i.parsed), r);
    },
    sc = function (e, t) {
      return function (r) {
        return gl(e, t, r);
      };
    };
  function oc(e, t, r) {
    var n = void 0 === r ? {} : r,
      i = n.clamp,
      s = void 0 === i || i,
      o = n.ease,
      a = n.mixer,
      l = e.length;
    t.length, !o || !Array.isArray(o) || o.length, e[0] > e[l - 1] && (e = [].concat(e), t = [].concat(t), e.reverse(), t.reverse());
    var c = function (e, t, r) {
        for (var n = [], i = r || ("number" == typeof (c = e[0]) ? sc : "string" == typeof c ? jl(c) ? Nl : ic : Array.isArray(c) ? tc : "object" == typeof c ? rc : void 0), s = e.length - 1, o = 0; o < s; o++) {
          var a = i(e[o], e[o + 1]);
          if (t) {
            var l = Array.isArray(t) ? t[o] : t;
            a = $l(l, a);
          }
          n.push(a);
        }
        var c;
        return n;
      }(t, o, a),
      u = 2 === l ? function (e, t) {
        var r = e[0],
          n = e[1],
          i = t[0];
        return function (e) {
          return i(_l(r, n, e));
        };
      }(e, c) : function (e, t) {
        var r = e.length,
          n = r - 1;
        return function (i) {
          var s = 0,
            o = !1;
          if (i <= e[0] ? o = !0 : i >= e[n] && (s = n - 1, o = !0), !o) {
            for (var a = 1; a < r && !(e[a] > i || a === n); a++);
            s = a - 1;
          }
          var l = _l(e[s], e[s + 1], i);
          return t[s](l);
        };
      }(e, c);
    return s ? function (t) {
      return u(cl(e[0], e[l - 1], t));
    } : u;
  }
  function ac(e, t) {
    return e.map(function () {
      return t || Ka;
    }).splice(0, e.length - 1);
  }
  function lc(e) {
    var t = e.from,
      r = void 0 === t ? 0 : t,
      n = e.to,
      i = void 0 === n ? 1 : n,
      s = e.ease,
      o = e.offset,
      a = e.duration,
      l = void 0 === a ? 300 : a,
      c = {
        done: !1,
        value: r
      },
      u = Array.isArray(i) ? i : [r, i],
      h = function (e, t) {
        return e.map(function (e) {
          return e * t;
        });
      }(o && o.length === u.length ? o : function (e) {
        var t = e.length;
        return e.map(function (e, r) {
          return 0 !== r ? r / (t - 1) : 0;
        });
      }(u), l);
    function p() {
      return oc(h, u, {
        ease: Array.isArray(s) ? s : ac(u, s)
      });
    }
    var d = p();
    return {
      next: function (e) {
        return c.value = d(e), c.done = e >= l, c;
      },
      flipTarget: function () {
        u.reverse(), d = p();
      }
    };
  }
  function cc(e) {
    var t = e.velocity,
      r = void 0 === t ? 0 : t,
      n = e.from,
      i = void 0 === n ? 0 : n,
      s = e.power,
      o = void 0 === s ? .8 : s,
      a = e.timeConstant,
      l = void 0 === a ? 350 : a,
      c = e.restDelta,
      u = void 0 === c ? .5 : c,
      h = e.modifyTarget,
      p = {
        done: !1,
        value: i
      },
      d = o * r,
      f = i + d,
      m = void 0 === h ? f : h(f);
    return m !== f && (d = m - i), {
      next: function (e) {
        var t = -d * Math.exp(-e / l);
        return p.done = !(t > u || t < -u), p.value = p.done ? m : m + t, p;
      },
      flipTarget: function () {}
    };
  }
  var uc = {
      keyframes: lc,
      spring: fl,
      decay: cc
    },
    hc = 1 / 60 * 1e3,
    pc = "undefined" != typeof performance ? function () {
      return performance.now();
    } : function () {
      return Date.now();
    },
    dc = "undefined" != typeof window ? function (e) {
      return window.requestAnimationFrame(e);
    } : function (e) {
      return setTimeout(function () {
        return e(pc());
      }, hc);
    },
    fc = !0,
    mc = !1,
    _c = !1,
    gc = {
      delta: 0,
      timestamp: 0
    },
    vc = ["read", "update", "preRender", "render", "postRender"],
    Ac = vc.reduce(function (e, t) {
      return e[t] = function (e) {
        var t = [],
          r = [],
          n = 0,
          i = !1,
          s = new WeakSet(),
          o = {
            schedule: function (e, o, a) {
              void 0 === o && (o = !1), void 0 === a && (a = !1);
              var l = a && i,
                c = l ? t : r;
              return o && s.add(e), -1 === c.indexOf(e) && (c.push(e), l && i && (n = t.length)), e;
            },
            cancel: function (e) {
              var t = r.indexOf(e);
              -1 !== t && r.splice(t, 1), s.delete(e);
            },
            process: function (a) {
              var l;
              if (i = !0, t = (l = [r, t])[0], (r = l[1]).length = 0, n = t.length) for (var c = 0; c < n; c++) {
                var u = t[c];
                u(a), s.has(u) && (o.schedule(u), e());
              }
              i = !1;
            }
          };
        return o;
      }(function () {
        return mc = !0;
      }), e;
    }, {}),
    bc = vc.reduce(function (e, t) {
      var r = Ac[t];
      return e[t] = function (e, t, n) {
        return void 0 === t && (t = !1), void 0 === n && (n = !1), mc || Ec(), r.schedule(e, t, n);
      }, e;
    }, {}),
    yc = vc.reduce(function (e, t) {
      return e[t] = Ac[t].cancel, e;
    }, {}),
    xc = function (e) {
      return Ac[e].process(gc);
    },
    wc = function (e) {
      mc = !1, gc.delta = fc ? hc : Math.max(Math.min(e - gc.timestamp, 40), 1), gc.timestamp = e, _c = !0, vc.forEach(xc), _c = !1, mc && (fc = !1, dc(wc));
    },
    Ec = function () {
      mc = !0, fc = !0, _c || dc(wc);
    },
    Sc = function () {
      return gc;
    },
    Cc = bc;
  function Mc(e, t, r) {
    return void 0 === r && (r = 0), e - t - r;
  }
  var Tc = function (e) {
    var t = function (t) {
      var r = t.delta;
      return e(r);
    };
    return {
      start: function () {
        return Cc.update(t, !0);
      },
      stop: function () {
        return yc.update(t);
      }
    };
  };
  function Ic(e) {
    var t,
      r,
      n,
      i,
      s,
      o = e.from,
      a = e.autoplay,
      l = void 0 === a || a,
      c = e.driver,
      u = void 0 === c ? Tc : c,
      h = e.elapsed,
      p = void 0 === h ? 0 : h,
      d = e.repeat,
      f = void 0 === d ? 0 : d,
      m = e.repeatType,
      _ = void 0 === m ? "loop" : m,
      g = e.repeatDelay,
      v = void 0 === g ? 0 : g,
      A = e.onPlay,
      b = e.onStop,
      y = e.onComplete,
      x = e.onRepeat,
      w = e.onUpdate,
      E = ll(e, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]),
      S = E.to,
      C = 0,
      M = E.duration,
      T = !1,
      I = !0,
      k = function (e) {
        if (Array.isArray(e.to)) return lc;
        if (uc[e.type]) return uc[e.type];
        var t = new Set(Object.keys(e));
        return t.has("ease") || t.has("duration") && !t.has("dampingRatio") ? lc : t.has("dampingRatio") || t.has("stiffness") || t.has("mass") || t.has("damping") || t.has("restSpeed") || t.has("restDelta") ? fl : lc;
      }(E);
    (null === (r = (t = k).needsInterpolation) || void 0 === r ? void 0 : r.call(t, o, S)) && (s = oc([0, 100], [o, S], {
      clamp: !1
    }), o = 0, S = 100);
    var D = k(al(al({}, E), {
      from: o,
      to: S
    }));
    return l && (null == A || A(), (n = u(function (e) {
      if (I || (e = -e), p += e, !T) {
        var t = D.next(Math.max(0, p));
        i = t.value, s && (i = s(i)), T = I ? t.done : p <= 0;
      }
      null == w || w(i), T && (0 === C && (null != M || (M = p)), C < f ? function (e, t, r, n) {
        return n ? e >= t + r : e <= -r;
      }(p, M, v, I) && (C++, "reverse" === _ ? p = function (e, t, r, n) {
        return void 0 === r && (r = 0), void 0 === n && (n = !0), n ? Mc(t + -e, t, r) : t - (e - t) + r;
      }(p, M, v, I = C % 2 == 0) : (p = Mc(p, M, v), "mirror" === _ && D.flipTarget()), T = !1, x && x()) : (n.stop(), y && y()));
    })).start()), {
      stop: function () {
        null == b || b(), n.stop();
      }
    };
  }
  const kc = {
    linear: qa,
    easeIn: Xa,
    easeOut: Ya,
    easeInOut: Ka,
    circIn: Ja,
    circOut: Za,
    circInOut: $a,
    backIn: el,
    backOut: tl,
    backInOut: rl,
    anticipate: nl,
    bounceOut: il,
    bounceIn: sl,
    bounceInOut: ol,
    easeInOutSine: function (e) {
      return -(Math.cos(Math.PI * e) - 1) / 2;
    }
  };
  async function Dc(e) {
    return new Promise(t => setTimeout(t, Math.max(0, e)));
  }
  function Pc(e, t, r) {
    const n = e[t],
      i = () => {
        "function" == typeof (null == e ? void 0 : e.setDirty) && e.setDirty(), null == r || r();
      };
    return n.isVector3 || n.isVector2 || n.isVector4 ? e => {
      n.copy(e), i();
    } : r => {
      e[t] = r, i();
    };
  }
  function Bc(e) {
    return "boolean" != typeof e;
  }
  async function Rc(e, t, r) {
    t in e || console.error("invalid key", t, e);
    const n = Pc(e, t),
      i = e[t],
      s = e => {
        var t;
        n(e), null === (t = r.onUpdate) || void 0 === t || t.call(r, e);
      };
    if (Bc(i)) return "function" == typeof r.to && (r = {
      ...r,
      to: r.to(i, e)
    }), Lc({
      ...r,
      from: i,
      onUpdate: s
    });
    {
      const {
        duration: e
      } = r;
      return Dc(null != e ? e : 0).then(() => s(r.to));
    }
  }
  async function Lc(e) {
    return new Promise((t, r) => {
      Ic({
        onComplete: () => {
          var r;
          null === (r = e.onComplete) || void 0 === r || r.call(e), t();
        },
        onStop: () => {
          var r;
          null === (r = e.onStop) || void 0 === r || r.call(e), t();
        },
        ...e
      });
    });
  }
  class Oc extends io {
    constructor() {
      super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = !1, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [To], this.fadeOnActiveCameraChange = !0, this.fadeOnMaterialUpdate = !0, this.fadeOnSceneUpdate = !0, this.pointerEnabled = !0, this._fadeCam = e => !1 !== e.frameFade && this.fadeOnActiveCameraChange && this.startTransition(1e3), this._fadeMat = e => {
        !1 !== e.frameFade && this.fadeOnMaterialUpdate && this.startTransition(200);
      }, this._fadeScene = e => {
        !1 !== e.frameFade && this.fadeOnSceneUpdate && this.startTransition(500);
      }, this._onPointerMove = e => {
        var t;
        const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas;
        if (!r) return void (this.pointerEnabled = !1);
        if (!e.buttons || e.target !== r) return void (this.pointerEnabled = !0);
        const n = r.getBoundingClientRect(),
          i = (e.clientX - n.left) / n.width,
          s = (e.clientY - n.top) / n.height;
        this.pointerEnabled = i < 0 || i > 1 || s < 0 || s > 1;
      }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this);
    }
    async startTransition(e) {
      this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        minFilter: n.wem,
        magFilter: n.wem,
        encoding: this._viewer.renderer.composerTarget.texture.encoding
      })), this._fadeTimeState = Math.max(e, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this._toSaveFrame = !0, this.setDirty(), await Dc(e));
    }
    stopTransition() {
      this._fadeTimeState = 0;
    }
    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("activeCameraChange", this._fadeCam), e.scene.addEventListener("activeCameraUpdate", this.stopTransition), e.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("activeCameraChange", this._fadeCam), e.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e);
    }
    passCtor(e) {
      const t = this,
        r = e.getPlugin(To),
        n = new class extends Eo {
          constructor() {
            super(...arguments), this._lastTime = 0, this.uiConfig = at("Frame Fade", this);
          }
          render(n, i, s, o, a) {
            this.needsSwap = !1;
            const l = t._target;
            if (!l || !t.pointerEnabled || !this.enabled || !t.dirty || t._fadeTimeState < .001) return;
            t._toSaveFrame && r.lastFrame && (e.renderer.blit(r.lastFrame.texture, l), this._lastTime = 0, t._toSaveFrame = !1), this.blendTexture = null == l ? void 0 : l.texture;
            const c = t._fadeTimeState / t._fadeTime;
            this.weights2.setScalar(c), this.weights2.w = 1, this.weights1.setScalar(1 - c), this.weights1.w = 1, super.render(n, i, s, o, a), this.needsSwap = !0;
            const u = Dt();
            this._lastTime < 10 && (this._lastTime = u - 10);
            const h = u - this._lastTime;
            this._lastTime = u, t._fadeTimeState -= h;
          }
        }();
      return n.enabled = !0, n;
    }
    setDirty() {
      var e;
      this.enabled && (null === (e = this._viewer) || void 0 === e || e.setDirty());
    }
    get dirty() {
      return this.enabled && this._fadeTimeState > 0;
    }
    set dirty(e) {
      console.warn("FrameFadePlugin.dirty is readonly");
    }
    _update(e) {
      return !!super._update(e) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < .001 && (this._toSaveFrame = !1, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), !0);
    }
    get uiConfig() {
      var e, t;
      return null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
    }
    disable(e) {
      this._disabledBy.includes(e) || this._disabledBy.push(e);
    }
    enable(e) {
      const t = this._disabledBy.indexOf(e);
      t >= 0 && this._disabledBy.splice(t, 1);
    }
    isDisabled() {
      return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled;
    }
  }
  Oc.PluginType = "FrameFade";
  var Fc = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    },
    Uc = n.M8C.degToRad;
  class Nc extends ro {
    constructor(e = za, t = !1, r = !0, n = !1) {
      super(), this.enabled = !0, this.autoFocus = !1, this._onObjectHit = e => {
        this._viewer && (this.enabled ? this.dispatchEvent(e) : e.intersects.selectedObject = null);
      }, this._uiConfigChildren = [{
        label: "AutoFocus",
        type: "checkbox",
        property: [this, "autoFocus"],
        onChange: () => {
          const e = this.getSelectedObject();
          this.autoFocus && e && this.setSelectedObject(e, !0);
        }
      }], e && (this._widget = new e()), this._controls = t, this._pickUi = r, this.autoFocus = n;
    }
    get picker() {
      return this._picker;
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    getSelectedObject() {
      var e;
      if (this.enabled) return (null === (e = this._picker) || void 0 === e ? void 0 : e.selectedObject) || void 0;
    }
    setSelectedObject(e, t = !1) {
      if (!this.enabled) return;
      if (!this._picker) return;
      const r = this.autoFocus;
      this.autoFocus = !1, this._picker.selectedObject = e || null, this.autoFocus = r, (r || t) && this.focusObject(e);
    }
    async onAdded(e) {
      await super.onAdded(e), this._picker = new $o(e.scene, e.canvas, void 0, e => {
        var t, r;
        if (!e.material) return !1;
        let n = e,
          i = !1;
        for (; n;) {
          if (!n.visible) return !1;
          if ("model" === (null !== (t = n.userData.iModel) && void 0 !== t ? t : n).assetType && (i = !0), "widget" === (null !== (r = n.userData.iModel) && void 0 !== r ? r : n).assetType) return !1;
          if (!1 === n.userData.userSelectable) return !1;
          if (!1 === n.userData.bboxVisible) return !1;
          n = n.parent;
        }
        return i;
      }), this._widget && e.scene.addWidget(this._widget), this._transformControls = new jc(e), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", t => {
        var r, n, i, s;
        this.dispatchEvent(t);
        const o = (null === (r = this._picker) || void 0 === r ? void 0 : r.selectedObject) || void 0;
        if (this._pickUi) {
          const e = null === (n = o) || void 0 === n ? void 0 : n.uiConfig,
            t = this.uiConfig;
          t.children = [...this._uiConfigChildren], e && t.children.push(e), null === (i = t.uiRefresh) || void 0 === i || i.call(t);
        }
        const a = this._widget;
        a && (o ? a.attach(o) : a.detach());
        const l = this._transformControls;
        l && (null === (s = this._viewer) || void 0 === s ? void 0 : s.scene.activeCamera.controls) && (o && l.enabled ? l.attach(o) : l.detach()), e.setDirty(), this.autoFocus && this.focusObject(o);
      }), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this._onObjectHit), e.scene.addEventListener("select", e => {
        e.value ? this.setSelectedObject(e.value, this.autoFocus || e.focusCamera) : console.warn("e.value must be set for picking");
      }), e.scene.addEventListener("addSceneObject", async t => {
        var r, n, i;
        const s = t.object,
          o = this.getSelectedObject();
        if (o && "material" === (null == s ? void 0 : s.assetType) && "function" == typeof (null == o ? void 0 : o.setMaterial) && (null === (r = null == o ? void 0 : o.modelObject) || void 0 === r ? void 0 : r.isMesh) && (await e.confirm("Applying material: Apply material to the selected object?"))) {
          const t = o.material;
          if (Array.isArray(t)) console.warn("Dropping on material array not yet fully supported."), o.setMaterial(s);else {
            let r = Array.from(null !== (n = null == t ? void 0 : t.userData.__appliedMeshes) && void 0 !== n ? n : []);
            (r.length > 1 ? !(await e.confirm("Applying material: Apply to all objects using this material?")) : r.length < 1) && (r = [o]);
            for (const e of r) e && (null === (i = e.setMaterial) || void 0 === i || i.call(e, s));
          }
        }
      }), e.scene.addEventListener("sceneUpdate", t => {
        if (!t.hierarchyChanged) return;
        const r = this.getSelectedObject();
        let n = !1;
        null == r || r.traverseAncestors(t => {
          t === e.scene.modelObject && (n = !0);
        }), n || this.setSelectedObject(void 0);
      });
    }
    async focusObject(e) {
      var t, r, n, i;
      const s = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("CameraViews");
      await (null == s ? void 0 : s.animateToObject(e, 4, 1e3, "easeOut", {
        min: (null !== (i = null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.activeCamera.getControls()) || void 0 === n ? void 0 : n.minDistance) && void 0 !== i ? i : .5) + .5,
        max: 5
      }));
    }
    get uiConfig() {
      return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Picker",
        expanded: !0,
        children: [...this._uiConfigChildren]
      } : {};
    }
    get transformControls() {
      return this._transformControls;
    }
    get widget() {
      return this._widget;
    }
  }
  Nc.PluginType = "Picking", Fc([Ce(), Je()], Nc.prototype, "enabled", void 0), Fc([Ce()], Nc.prototype, "autoFocus", void 0);
  class jc extends ca {
    constructor(e) {
      super(e.scene.activeCamera.cameraObject, e.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = !1, this.userData.bboxVisible = !1, this.addEventListener("objectChange", () => {
        var e;
        null === (e = null == this ? void 0 : this.object) || void 0 === e || e.dispatchEvent({
          type: "objectUpdate",
          fadeFrame: !1
        });
      }), this.addEventListener("dragging-changed", t => {
        const r = null == e ? void 0 : e.getPlugin(Oc);
        r && (r.enabled = !t.value), this._scene.activeCamera.interactionsEnabled = !t.value;
      }), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this);
    }
    _keyDownListener(e) {
      if (this.enabled && this.object) {
        switch (e.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;
          case 16:
            this.setTranslationSnap(100), this.setRotationSnap(Uc(15)), this.setScaleSnap(.25);
            break;
          case 87:
            this.setMode("translate");
            break;
          case 69:
            this.setMode("rotate");
            break;
          case 82:
            this.setMode("scale");
            break;
          case 187:
          case 107:
            this.setSize(this.size + .1);
            break;
          case 189:
          case 109:
            this.setSize(Math.max(this.size - .1, .1));
            break;
          case 88:
            this.showX = !this.showX;
            break;
          case 89:
            this.showY = !this.showY;
            break;
          case 90:
            this.showZ = !this.showZ;
            break;
          case 32:
            this.enabled = !this.enabled;
            break;
          default:
            return;
        }
        this._scene.setDirty({
          sceneUpdate: !0,
          frameFade: !0
        });
      }
    }
    _keyUpListener(e) {
      this.enabled && (16 === e.keyCode && (this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null)), this.object && e.keyCode);
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera.cameraObject;
    }
    dispose() {
      window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose();
    }
  }
  var zc = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class Gc extends ro {
    constructor() {
      super(), this.offsetCache = {}, this.enabled = !0, this.envMap = null, this.forceSceneEnvMap = !1, this.getEnvMap = () => {
        var e;
        return !this.forceSceneEnvMap && this.envMap ? this.envMap : (null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || null;
      }, this._modelProcessor = {
        forAssetType: "model",
        processAsync: async (e, t) => {
          const r = [];
          return e.modelObject.traverse(e => {
            var t, n, i, s;
            const o = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[Gc.DIAMOND_GLTF_EXTENSION];
            o && e.geometry && (this.prepareDiamondMesh(e, o), delete e.userData.gltfExtensions[Gc.DIAMOND_GLTF_EXTENSION]), e.material && !r.includes(e.material) && (null === (s = null === (i = e.material.userData) || void 0 === i ? void 0 : i.gltfExtensions) || void 0 === s ? void 0 : s[Gc.DIAMOND_GLTF_EXTENSION]) && (e.material.materialObject || console.warn("material not processed", e.material), r.push(e.material));
          }), r.forEach(e => {
            const t = e.userData.gltfExtensions[Gc.DIAMOND_GLTF_EXTENSION];
            t && this._convertToDiamondMaterial(e, t);
          }), e;
        }
      }, this.uiConfig = {
        type: "folder",
        label: "Diamonds",
        children: [{
          type: "toggle",
          label: "Use Scene Environment",
          property: [this, "forceSceneEnvironment"],
          limitedUi: !0
        }, {
          type: "image",
          label: "Environment",
          hidden: () => this.forceSceneEnvMap,
          property: [this, "envMap"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 2 * Math.PI],
          hidden: () => this.forceSceneEnvMap,
          label: "Env Rotation",
          property: [this, "envMapRotation"],
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Diamond",
          hidden: () => {
            var e, t, r;
            const n = null === (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === r ? void 0 : r.material;
            return !!Array.isArray(n) || (null == n ? void 0 : n.typeSlug) !== Kt.TypeSlug;
          },
          value: async () => {
            var e, t, r, n, i, s;
            const o = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
            if (!(null == o ? void 0 : o.material)) return;
            const a = await (null === (r = this._viewer) || void 0 === r ? void 0 : r.prompt("Cache key: Enter optional cache key unique to the diamond shape.", "", !1));
            let l = parseInt((await (null === (n = this._viewer) || void 0 === n ? void 0 : n.prompt("Cache size: Enter size of the cache [64-1024]", "512", !1))) || "512");
            isFinite(l) || (l = 512), l < 64 && (l = 64), (null === (i = o.material.userData) || void 0 === i ? void 0 : i.__appliedMeshes.size) > 1 && (await (null === (s = this._viewer) || void 0 === s ? void 0 : s.confirm("Convert all: Apply diamond material to all the meshes with the same material?"))) ? this.makeDiamond(o.material, {
              cacheKey: a || void 0,
              normalMapRes: l
            }, {}) : this.makeDiamondMesh(o, {
              cacheKey: a || void 0,
              normalMapRes: l
            }, {}), this.refreshUi();
          },
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Standard",
          hidden: () => {
            var e, t, r;
            const n = null === (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === r ? void 0 : r.material;
            return !!Array.isArray(n) || (null == n ? void 0 : n.typeSlug) !== Zo.TypeSlug;
          },
          value: async () => {
            var e, t, r, n, i, s, o, a;
            const l = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject(),
              c = null == l ? void 0 : l.material;
            if (!c) return;
            const u = c.userData._baseMaterial;
            let h = null === (i = null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.getManager()) || void 0 === n ? void 0 : n.materials) || void 0 === i ? void 0 : i.findMaterial(u);
            if (h && !h.isDiamondMaterial || (h = null === (s = this._viewer) || void 0 === s ? void 0 : s.createPhysicalMaterial({
              color: c.color
            })), h) {
              const e = c.userData.__appliedMeshes.size > 1 && (await (null === (o = this._viewer) || void 0 === o ? void 0 : o.confirm("Convert all with this material?"))) ? Array.from(c.userData.__appliedMeshes) : [l];
              for (const t of e) null === (a = null == t ? void 0 : t.setMaterial) || void 0 === a || a.call(t, h);
            }
            this.refreshUi();
          },
          limitedUi: !0
        }]
      }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this);
    }
    get envMapRotation() {
      var e, t;
      return null !== (t = null === (e = this.envMap) || void 0 === e ? void 0 : e.rotation) && void 0 !== t ? t : 0;
    }
    set envMapRotation(e) {
      var t;
      const r = this.envMap;
      r && (r.rotation = e, null === (t = this._viewer) || void 0 === t || t.scene.setDirty());
    }
    refreshEnvMaps() {
      var e, t, r;
      if (!this._viewer) return;
      const n = this.getEnvMap(),
        i = (null === (t = null === (e = this._viewer.getPlugin(to)) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.getMaterialsOfType(Zo.TypeSlug)) || [];
      for (const e of i) e && e.envMap !== n && (e.envMap = n, e.needsUpdate = !0);
      null === (r = this._viewer) || void 0 === r || r.scene.setDirty();
    }
    refreshUi() {
      var e, t, r;
      null === (e = this._viewer) || void 0 === e || e.setDirty(), null === (r = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0);
    }
    async onAdded(e) {
      var t, r, n, i, s, o;
      this._normalCapture = new Ho(e.renderer), this.offsetCache = {}, e.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
      const a = e.getPlugin(to);
      null === (t = null == a ? void 0 : a.importer) || void 0 === t || t.processors.add("model", this._modelProcessor), null === (r = e.getPlugin(Nc)) || void 0 === r || r.addEventListener("selectedObjectChanged", this.refreshUi);
      const l = this.getEnvMap,
        c = new ir(class extends ur {
          async loadAsync(e, t) {
            var r;
            const n = await super.loadAsync(e, t);
            return n.type === Zo.TYPE || n.isDiamondMaterialParameters ? (n.envMap = l(), null === (r = null == a ? void 0 : a.materials) || void 0 === r ? void 0 : r.generateFromTemplate("diamond", n)) : (console.error("Invalid material type for Diamond Material.", n), null);
          }
        }, [Zo.TypeSlug], !1);
      return Js.Importers.push(c), null === (s = null === (i = null === (n = null == a ? void 0 : a.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Vc), null === (o = null == a ? void 0 : a.materials) || void 0 === o || o.registerMaterialTemplate({
        name: "diamond",
        materialType: Zo.TYPE,
        isDiamondMaterialParameters: !0,
        generator: (e, t) => {
          const r = new Zo(e);
          return r.envMap = l(), t && t !== {} && r.copyProps(t), r;
        }
      }), super.onAdded(e);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (t = this._normalCapture) || void 0 === t || t.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (n = null === (r = e.getPlugin(to)) || void 0 === r ? void 0 : r.importer) || void 0 === n || n.processors.remove("model", this._modelProcessor), null === (i = e.getPlugin(Nc)) || void 0 === i || i.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e);
    }
    prepareDiamondMesh(e, {
      cacheKey: t,
      normalMapRes: r
    }) {
      var n, i, s;
      e.userData._diamondCacheKey = null != t ? t : e.userData._diamondCacheKey, e.userData._diamondNormalMapRes = null != r ? r : e.userData._diamondNormalMapRes, t = t && t.length > 0 ? t.includes(";" + e.geometry.uuid) ? t : t + ";" + e.geometry.uuid : e.geometry.uuid, this._computeOffsets(e.geometry, e.geometry.uuid);
      const o = null !== (i = null === (n = this._normalCapture) || void 0 === n ? void 0 : n.captureNormalMap(e.geometry, t, r)) && void 0 !== i ? i : [void 0, !1],
        a = null === (s = this._viewer) || void 0 === s ? void 0 : s.getPluginByType("debug");
      a && o && (a.counters.normalsCapture || (a.counters.normalsCapture = 0), a.counters.normalsCapture++, console.log("DEBUG: new normal map captured", a.counters.normalsCapture, t), a.addTexture("normal" + a.counters.normalsCapture, () => {
        var t;
        return null === (t = e.geometry.userData._normalsCaptureMap) || void 0 === t ? void 0 : t.texture;
      }, [40, 110 * a.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", !0));
    }
    makeDiamond(e, t, r) {
      var n, i;
      Array.from(null !== (n = null == e ? void 0 : e.userData.__appliedMeshes) && void 0 !== n ? n : []).forEach(e => {
        (null == e ? void 0 : e.isMesh) && e.geometry && this.prepareDiamondMesh(e, t);
      }), this._convertToDiamondMaterial(e, r), null === (i = this._viewer) || void 0 === i || i.setDirty();
    }
    makeDiamondMesh(e, t, r) {
      if (!e.modelObject.isMesh || !e.geometry || !e.setMaterial) return;
      this.prepareDiamondMesh(e.modelObject, t);
      const n = Array.isArray(e.material) ? e.material[0] : e.material,
        i = this._convertToDiamondMaterial(n, r, !1);
      e.setMaterial(i);
    }
    _convertToDiamondMaterial(e, t = {
      isDiamond: !0
    }, r = !0) {
      var i, s, o, a, l, c, u;
      let h = {
        ...(null != t ? t : {})
      };
      h.isDiamond || h.isDiamondMaterialParameters ? Array.isArray(h.boostFactors) && (h.boostFactors = new n.Pa4().fromArray(h.boostFactors)) : h = {
        isDiamondMaterialParameters: !0
      }, h.color = null !== (o = null !== (i = h.color) && void 0 !== i ? i : null === (s = null == e ? void 0 : e.materialObject) || void 0 === s ? void 0 : s.color) && void 0 !== o ? o : new Ae(1, 1, 1);
      const p = null === (c = null === (l = null === (a = this._viewer) || void 0 === a ? void 0 : a.getManager()) || void 0 === l ? void 0 : l.materials) || void 0 === c ? void 0 : c.generateFromTemplate("diamond", h);
      if (p && e && !e.isDiamondMaterial && (p.userData._baseMaterial = e.uuid), r) {
        const r = e => {
          var t;
          return null !== (t = e.setMaterial) && void 0 !== t ? t : t => {
            e.material = t.materialObject;
          };
        };
        Array.from(null !== (u = null == e ? void 0 : e.userData.__appliedMeshes) && void 0 !== u ? u : []).forEach(e => {
          r(e)(p), this.prepareDiamondMesh(e, t);
        });
      }
      return p;
    }
    _computeOffsets(e, t, r = !1) {
      const i = t.split(";").find(e => this.offsetCache[e]);
      if (i && !r) {
        const r = this.offsetCache[i];
        return t.split(";").forEach(e => e !== i && (this.offsetCache[e] = r)), e.userData._normalsCaptureOffsets = r, r;
      }
      e.computeBoundingBox();
      const s = e.boundingBox.getCenter(new n.Pa4()),
        o = Yo(e),
        a = o.clone().invert(),
        l = {
          center: s,
          offsetMatrix: o,
          offsetMatrixInv: a,
          radius: 1,
          centerOffset: new n.Pa4().copy(s).applyMatrix4(a)
        };
      return t.split(";").forEach(e => this.offsetCache[e] = l), e.userData._normalsCaptureOffsets = l, l;
    }
  }
  Gc.PluginType = "Diamond", Gc.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", zc([M(Gc.prototype.refreshEnvMaps), Ce()], Gc.prototype, "envMap", void 0), zc([M(Gc.prototype.refreshEnvMaps), Ce()], Gc.prototype, "forceSceneEnvMap", void 0);
  const Vc = e => ({
    writeMaterial: (t, r) => {
      t.isDiamondMaterial && (r.extensions = r.extensions || {}, r.extensions[Gc.DIAMOND_GLTF_EXTENSION] = t.toJSON(), e.extensionsUsed[Gc.DIAMOND_GLTF_EXTENSION] = !0);
    },
    writeMesh: (t, r) => {
      var n, i;
      if (!(null == t ? void 0 : t.material.isDiamondMaterial)) return;
      r.extensions = r.extensions || {};
      const s = {};
      null === (i = null === (n = t.userData) || void 0 === n ? void 0 : n.gltfExtensions) || void 0 === i || delete i[Gc.DIAMOND_GLTF_EXTENSION], t.userData._diamondNormalMapRes && (s.normalMapRes = t.userData._diamondNormalMapRes), t.userData._diamondCacheKey && (s.cacheKey = t.userData._diamondCacheKey), r.extensions[Gc.DIAMOND_GLTF_EXTENSION] = s, e.extensionsUsed[Gc.DIAMOND_GLTF_EXTENSION] = !0;
    }
  });
  var Qc,
    Hc = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Wc = Qc = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.animations = [], this.loopAnimations = !0, this.loopRepetitions = 1 / 0, this.timeScale = 0, this.animateOnScroll = !1, this.animationSpeed = 1, this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this.dependencies = [to], this._lastFrameTime = 0, this._fadeDisabled = !1, this._objectAdded = e => {
        const t = e.object;
        "model" === t.assetType && t.modelObject && this._viewer && t.modelObject.traverse(e => {
          const t = e.animations;
          if (t.length < 1) return;
          const r = Math.max(...t.map(e => e.duration));
          t.forEach(e => e.duration = r);
          const i = new n.Xcj(this._viewer.scene.modelRoot.modelObject),
            s = t.map(e => i.clipAction(e).setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions));
          this.animations.push({
            mixer: i,
            clips: t,
            actions: s,
            duration: r
          }), this.onPropertyChange();
        });
      }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.onPropertyChange = this.onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }
    get animationState() {
      return this._animationState;
    }
    get animationTime() {
      return this._animationTime;
    }
    get animationDuration() {
      return this._animationDuration;
    }
    _wheel({
      deltaY: e
    }) {
      this.enabled && Math.abs(e) > .001 && (this._scrollAnimationState = -1 * Math.sign(e));
    }
    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      const r = this._viewer,
        n = this.animateOnScroll;
      if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !n) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(Qc.PluginType), this._fadeDisabled = !1));
      const i = Dt() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = i - 1 / 30);
      let s = i - this._lastFrameTime;
      if (s *= this.animationSpeed, this._lastFrameTime = i, n && (s *= this._scrollAnimationState), Math.abs(s) < 1e-4) return;
      const o = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
      if (o && o > 0 && (s = o), 0 !== o && (this.animations.map(e => e.mixer.update(s)), this._animationTime += s, this._animationTime > this._animationDuration && (this._animationTime -= this._animationDuration), this._animationTime < 0 && (this._animationTime += this._animationDuration), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, r.scene.activeCamera.cameraObject.userData.__animatingCamera && r.scene.activeCamera.setDirty(), r.renderer.resetShadows(), r.setDirty(), !this._fadeDisabled)) {
        const e = this._viewer.getPluginByType("FrameFade");
        e && (e.disable(Qc.PluginType), this._fadeDisabled = !0);
      }
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new qc(e, this));
    }
    async onAdded(e) {
      var t, r, n, i, s, o;
      null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), e.scene.addEventListener("addSceneObject", this._objectAdded), null === (o = null === (s = null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.exporter) || void 0 === i ? void 0 : i.getExporter("gltf", "glb")) || void 0 === s ? void 0 : s.extensions) || void 0 === o || o.push(Xc), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel);
      let a = -1;
      return Object.defineProperty(e.scene.modelRoot, "currentTimelineMarker", {
        get: () => a,
        set: t => e.scene.modelRoot.dispatchEvent({
          type: "animationTimelineMarker",
          marker: this.timelineMarkers[a = t]
        })
      }), e.scene.modelRoot.addEventListener("animationTimelineMarker", ({
        marker: e
      }) => {
        var t;
        if (!this._viewer) return;
        if (!e) return this._viewer.scene.activeCamera = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.defaultCamera, void this._viewer.setDirty();
        const r = e.camera;
        r && (r.userData.__animatingCamera = !0, this._viewer.scene.activeCamera = this._viewer.createCamera(r));
      }), super.onAdded(e);
    }
    async onRemove(e) {
      var t, r;
      return e.scene.removeEventListener("addSceneObject", this._objectAdded), null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), super.onRemove(e);
    }
    onPropertyChange() {
      "playing" === this._animationState && this.playAnimation(), this._animationDuration = Math.max(...this.animations.map(({
        duration: e
      }) => e));
    }
    onStateChange() {
      var e, t;
      null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.children) || void 0 === t || t.map(e => e && A(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }
    playPauseAnimation() {
      "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation();
    }
    async playClip(e, t = !1) {
      return this.playClips([e], t);
    }
    async playClips(e, t = !1) {
      const r = [];
      return this.animations.forEach(({
        actions: t
      }) => {
        t.forEach(t => {
          e.includes(t.getClip().name) && r.push(t);
        });
      }), this.playAnimation(t, r);
    }
    async playAnimation(e = !1, t) {
      var r, i, s;
      if (!this.enabled) return;
      "playing" === this._animationState && this.stopAnimation(!1), _(null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("Picking")) || void 0 === i ? void 0 : i.transformControls, "enabled", !1);
      let o = 0;
      t || (t = [], this.animations.forEach(({
        mixer: e,
        actions: r,
        clips: n
      }) => {
        t.push(...r);
      }));
      const a = Xe();
      this._lastAnimId = a, "paused" !== this._animationState && this.resetAnimation();
      for (const e of t) this.timeScale > 0 && (e.timeScale = this.timeScale), e.setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions), e.play(), o = Math.max(o, e.getClip().duration / e.timeScale);
      if (this._animationState = "playing", null === (s = this._viewer) || void 0 === s || s.setDirty(), o *= this.loopAnimations ? this.loopRepetitions : 1, o /= this.animationSpeed, !isFinite(o)) return;
      const l = 1e3 * o - this._animationTime / this.animationSpeed + .01;
      l > 0 && (await Dc(l)), a === this._lastAnimId && this.stopAnimation(e);
    }
    pauseAnimation() {
      var e, t, r;
      this._animationState = "paused", _(null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.transformControls, "enabled", !0), null === (r = this._viewer) || void 0 === r || r.setDirty(), this._lastAnimId = "";
    }
    stopAnimation(e = !1) {
      var t, r, n;
      this._animationState = "stopped", _(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), "enabled", !0), e ? this.resetAnimation() : null === (r = this._viewer) || void 0 === r || r.setDirty(), this._lastAnimId = "", this._viewer && this._fadeDisabled && (null === (n = this._viewer.getPluginByType("FrameFade")) || void 0 === n || n.enable(Qc.PluginType), this._fadeDisabled = !1);
    }
    resetAnimation() {
      var e;
      "stopped" === this._animationState ? (this.animations.forEach(({
        mixer: e,
        actions: t,
        clips: r
      }) => {
        e.stopAllAction(), e.setTime(0);
      }), this._animationTime = 0, null === (e = this._viewer) || void 0 === e || e.setDirty()) : this.stopAnimation(!0);
    }
  };
  Wc.PluginType = "GLTFAnimation", Wc.AnimationMarkersExtension = "WEBGI_animation_markers", Hc([Ze()], Wc.prototype, "animationState", null), Hc([Ze()], Wc.prototype, "animationTime", null), Hc([Ze()], Wc.prototype, "animationDuration", null), Hc([M(Qc.prototype.onPropertyChange), Je("Loop", {
    limitedUi: !0
  })], Wc.prototype, "loopAnimations", void 0), Hc([M(Qc.prototype.onPropertyChange)], Wc.prototype, "loopRepetitions", void 0), Hc([M(Qc.prototype.onPropertyChange)], Wc.prototype, "timeScale", void 0), Hc([Je(), Ce()], Wc.prototype, "animateOnScroll", void 0), Hc([$e("Speed", [.1, 4], .1, {
    limitedUi: !0
  }), Ce()], Wc.prototype, "animationSpeed", void 0), Hc([M(Qc.prototype.onStateChange)], Wc.prototype, "_animationState", void 0), Hc([rt("Play/Pause", e => ({
    label: () => "playing" === e.animationState ? "Pause" : "Play",
    limitedUi: !0
  }))], Wc.prototype, "playPauseAnimation", null), Hc([rt("Stop", {
    limitedUi: !0
  })], Wc.prototype, "stopAnimation", null), Hc([rt("Reset", {
    limitedUi: !0
  })], Wc.prototype, "resetAnimation", null), Wc = Qc = Hc([lt("GLTF Animations")], Wc);
  class qc {
    constructor(e, t) {
      this.parser = e, this.name = Wc.AnimationMarkersExtension, this.plugin = t;
    }
    async afterRoot(e) {
      var t;
      let r = [];
      for (const e of this.parser.json.scenes) {
        if (!e.extensions) continue;
        const t = e.extensions[this.name];
        for (const e of (null == t ? void 0 : t.markers) || []) {
          const t = void 0 !== e.camera ? await this.parser.getDependency("camera", e.camera) : void 0;
          if (void 0 === e.time) {
            const t = 30;
            e.time = e.frame / t, console.error("Update timeline markers plugin for correct times.");
          }
          r.push({
            name: e.name,
            frame: e.frame,
            time: e.time,
            camera: t
          });
        }
      }
      if (r.length < 1) return;
      r = r.sort((e, t) => e.frame - t.frame);
      const i = null !== (t = e.scene) && void 0 !== t ? t : e.scenes[0];
      if (!i) return;
      i.userData.__markers = r;
      const s = this.plugin.timelineMarkers,
        o = r.map(e => e.time);
      let a = s.length;
      const l = r.map(e => a++),
        c = Math.max(...o) + .01;
      s.push(...r);
      const u = new n.dUE(".currentTimelineMarker", o, l, 2300),
        h = new n.m7l("animationTimelineMarker", c, [u]);
      h.__gltfExport = !1, e.animations.push(h);
    }
  }
  const Xc = e => ({
    afterParse(t) {
      const r = e.json.scenes[e.json.scene || 0];
      r.extensions = r.extensions || {};
      const n = {
          markers: []
        },
        i = [];
      if ((Array.isArray(t) ? t : [t]).forEach(e => e.traverse(e => {
        e.userData.__markers && i.push(...e.userData.__markers);
      })), i.sort((e, t) => e.frame - t.frame), !(i.length < 1)) {
        for (const t of i) {
          const r = t.camera;
          if (r) {
            const i = e.nodeMap.get(r);
            if (void 0 === i) {
              console.warn("Camera not found in gltf export", r, e.nodeMap);
              continue;
            }
            const s = e.json.nodes[i].camera;
            t.camera = s, n.markers.push(t);
          }
        }
        r.extensions[Wc.AnimationMarkersExtension] = n, e.extensionsUsed[Wc.AnimationMarkersExtension] = !0;
      }
    }
  });
  class Yc extends r {
    constructor() {
      super(...arguments), this.dirty = !1, this.counters = {}, this._generators = new Map(), this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender");
    }
    async onAdded(e) {
      this._viewer = e, e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender);
    }
    addTexture(e, t, r, s, o, a = "postRender", l = !1) {
      var c;
      this._generators.has(a) || this._generators.set(a, []), null === (c = this._generators.get(a)) || void 0 === c || c.push({
        key: e,
        fn: t,
        rect: r ? [...r] : void 0,
        frag: o || s || l ? new n.jyz({
          vertexShader: i.vertexShader,
          uniforms: {
            tDiffuse: {
              value: null
            },
            opacity: {
              value: 1
            }
          },
          fragmentShader: null != o ? o : `\n        #include <common>\n        #include <packing>\n        uniform float opacity;\n\t\tuniform ${l ? "samplerCube" : "sampler2D"} tDiffuse;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvec4 texel = ${l ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};\n\t\t\t${null != s ? s : ""}\n\t\t\tgl_FragColor = opacity * texel;\n\t\t}\n            `
        }) : void 0
      });
    }
    removeTexture(e, t = "postRender") {
      var r, n;
      this._generators.set(t, null !== (n = null === (r = this._generators.get(t)) || void 0 === r ? void 0 : r.filter(t => t.key !== e)) && void 0 !== n ? n : []);
    }
    async onDispose(e) {
      return Promise.resolve(void 0);
    }
    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0);
    }
    _showDebug(e) {
      var t;
      const r = this._viewer,
        n = null == r ? void 0 : r.renderer;
      n && r && (null === (t = this._generators.get(e)) || void 0 === t || t.forEach(({
        key: e,
        fn: t,
        rect: i,
        frag: s
      }) => {
        const o = t(r);
        if (o) {
          if (o.image && i) {
            const e = o.image.width / o.image.height;
            i[2] < 1 && i[3] < 1 && (i[2] = 200), i[2] < 1 && (i[2] = i[3] * e), i[3] < 1 && (i[3] = i[2] / e);
          }
          n.blit(o, void 0, {
            viewport: i,
            clear: !1,
            material: s
          });
        }
      }));
    }
  }
  Yc.PluginType = "debug";
  var Kc = function (e, t) {
    return Kc = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (e, t) {
      e.__proto__ = t;
    } || function (e, t) {
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    }, Kc(e, t);
  };
  function Jc(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    function r() {
      this.constructor = e;
    }
    Kc(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
  }
  var Zc,
    $c = function () {
      function e() {}
      return e._xfnv1a = function (e) {
        for (var t = 2166136261, r = 0; r < e.length; r++) t = Math.imul(t ^ e.charCodeAt(r), 16777619);
        return function () {
          return t += t << 13, t ^= t >>> 7, t += t << 3, t ^= t >>> 17, (t += t << 5) >>> 0;
        };
      }, e;
    }(),
    eu = function (e) {
      function t(r) {
        var n = e.call(this) || this;
        return n.a = t._xfnv1a(r)(), n;
      }
      return Jc(t, e), t.prototype.next = function () {
        var e = this.a += 1831565813;
        return e = Math.imul(e ^ e >>> 15, 1 | e), (((e ^= e + Math.imul(e ^ e >>> 7, 61 | e)) ^ e >>> 14) >>> 0) / 4294967296;
      }, t;
    }($c),
    tu = function (e) {
      function t(r) {
        var n = e.call(this) || this,
          i = t._xfnv1a(r);
        return n.a = i(), n.b = i(), n.c = i(), n.d = i(), n;
      }
      return Jc(t, e), t.prototype.next = function () {
        this.a >>>= 0, this.b >>>= 0, this.c >>>= 0, this.d >>>= 0;
        var e = this.a + this.b | 0;
        return this.a = this.b ^ this.b >>> 9, this.b = this.c + (this.c << 3) | 0, this.c = this.c << 21 | this.c >>> 11, this.d = this.d + 1 | 0, e = e + this.d | 0, this.c = this.c + e | 0, (e >>> 0) / 4294967296;
      }, t;
    }($c),
    ru = function (e) {
      function t(r) {
        var n = e.call(this) || this,
          i = t._xfnv1a(r);
        return n.a = i(), n.b = i(), n.c = i(), n.d = i(), n;
      }
      return Jc(t, e), t.prototype.next = function () {
        var e = this.b << 9,
          t = 5 * this.a;
        return t = t << 7 | 9 * (t >>> 25), this.c ^= this.a, this.d ^= this.b, this.b ^= this.c, this.a ^= this.d, this.c ^= e, this.d = this.d << 11 | this.d >>> 21, (t >>> 0) / 4294967296;
      }, t;
    }($c);
  !function (e) {
    e.sfc32 = "sfc32", e.mulberry32 = "mulberry32", e.xoshiro128ss = "xoshiro128ss";
  }(Zc || (Zc = {}));
  var nu = function () {
      function e(e, t) {
        void 0 === t && (t = Zc.sfc32), this.str = e, this.prng = t, this.generator = this._initializeGenerator();
      }
      return e.prototype.next = function () {
        return this.generator.next();
      }, e.prototype._initializeGenerator = function () {
        if (function (e) {
          return null === e;
        }(e = this.str) || function (e) {
          return void 0 === e;
        }(e)) return this.wrap();
        var e;
        switch (this.prng) {
          case "sfc32":
            return new tu(this.str);
          case "mulberry32":
            return new eu(this.str);
          case "xoshiro128ss":
            return new ru(this.str);
          default:
            return this.wrap();
        }
      }, e.prototype.wrap = function () {
        return {
          next: function () {
            return Math.random();
          }
        };
      }, e;
    }(),
    iu = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  class su extends Ws {
    constructor(e, t, r, i) {
      super(e, t), this._shadowParams = {
        enabled: !0,
        radius: 2,
        width: 1024,
        height: 1024,
        bias: -.001,
        normalBias: 0,
        near: 1.5,
        far: 4,
        frustumSize: 4
      }, this._randomParams = {
        focus: 1,
        spread: .01,
        distanceScale: 50,
        minDistanceScale: new n.Pa4(10, 10, 10),
        normalDirection: new n.Pa4(.01, .98, .01).normalize(),
        direction: new n.Pa4(-.9, .5, -1)
      }, this.isRandomizedDirectionalLight = !0, this.shadowParams = null != r ? r : {}, this.randomParams = null != i ? i : {}, this.updateShadowParams = this.updateShadowParams.bind(this);
    }
    get shadowParams() {
      return this._shadowParams;
    }
    set shadowParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), this._shadowParams = {
        ...this._shadowParams,
        ...e
      }, this.updateShadowParams();
    }
    get randomParams() {
      return this._randomParams;
    }
    set randomParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), Object.assign(this._randomParams, e);
    }
    updateShadowParams() {
      this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = !0;
    }
    randomizePosition(e, t = null, r = null) {
      const i = new nu(e.toString()),
        s = new n.FM8(i.next() * Math.PI * 2, Math.asin(2 * i.next() - 1));
      let o = new n.Pa4(Math.cos(s.x) * Math.cos(s.y), Math.sin(s.y), Math.sin(s.x) * Math.cos(s.y));
      const a = new n.FM8();
      for (let e = 0; e < 5; e++) {
        a.set(i.next(), i.next()), o = ou(a, this._randomParams.normalDirection, .4), i.next() < Math.sqrt(null != t ? t : this._randomParams.focus) && (a.set(i.next(), i.next()), o = ou(a, this._randomParams.direction, Math.pow((null != r ? r : this._randomParams.spread) / 2, 2)));
        const e = o.dot(this._randomParams.normalDirection);
        if (e > 0 && e < .4) break;
      }
      o.normalize(), o.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(o.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld();
    }
    refreshShadowCamNearFar() {
      const e = new n.Pa4().subVectors(this.target.position, this.shadow.camera.position).length();
      this.shadow.camera.near = e - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e + this._shadowParams.far * this._shadowParams.frustumSize / 2;
    }
    dispose() {}
    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
    }
    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.updateShadowParams(), this) : null;
    }
  }
  function ou(e, t, r) {
    t = t.clone().normalize();
    const i = new n.Pa4(0, -t.z, t.y).normalize(),
      s = new n.Pa4().crossVectors(t, i).normalize(),
      o = e;
    o.x = 2 * o.x * Math.PI, o.y = 1 - o.y * r;
    const a = Math.sqrt(1 - o.y * o.y);
    return i.multiplyScalar(Math.cos(o.x) * a).add(s.multiplyScalar(Math.sin(o.x) * a)).add(t.multiplyScalar(o.y));
  }
  iu([Ce("shadowParams")], su.prototype, "_shadowParams", void 0), iu([Ce("randomParams")], su.prototype, "_randomParams", void 0);
  class au extends n.Tn7 {
    constructor() {
      super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null;
    }
    get materialObject() {
      return this;
    }
    onBeforeCompile(e, t) {
      e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e.vertexShader = e.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e.fragmentShader = e.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e.fragmentShader = e.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", w`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e.uniforms, this._uniforms), super.onBeforeCompile(e, t);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey();
    }
    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e) {
      this.needsUpdate = !0, this.dispatchEvent({
        ...e,
        type: "materialUpdate"
      });
    }
  }
  !function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([G({
    propKey: "tLastThis"
  })], au.prototype, "lastFrameTexture", void 0);
  var lu = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class cu {
    constructor(e) {
      this.enabled = !0, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.groundMapMode = "aoMap", this.alphaVignette = !0, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = !0, this.materialExtension = {
        shaderExtender: (e, t, r) => {
          "aoMap" === this.groundMapMode ? e.fragmentShader = qt(e.fragmentShader, "#include <aomap_fragment>", qt(n.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( unpackRGBAToDepth(texture2D( aoMap, vUv2 ) ) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e.fragmentShader = qt(e.fragmentShader, "#include <map_fragment>", qt(n.WdD.map_fragment, "diffuseColor *= sampledDiffuseColor;", "float groundShadow = unpackRGBAToDepth(sampledDiffuseColor); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow);")) : "alphaMap" === this.groundMapMode && (e.fragmentShader = qt(e.fragmentShader, "#include <alphamap_fragment>", qt(n.WdD.alphamap_fragment, "texture2D( alphaMap, vUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vUv ) )", {
            replaceAll: !0
          }))), this.alphaVignette && r.capabilities.isWebGL2 && (e.fragmentShader = qt(e.fragmentShader, "#include <output_fragment>", w`#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vUv2.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `));
        },
        computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis,
        onObjectRender: (e, t) => {
          t.materialObject.userData.gMapMode !== this.groundMapMode && (t.materialObject.userData.gMapMode = this.groundMapMode, t.materialObject.needsUpdate = !0);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this._viewer = e;
      const t = new su(16777215, 10, {
        near: 1.5,
        far: 20,
        bias: 0,
        frustumSize: 4,
        width: 1024,
        height: 1024,
        enabled: !0,
        radius: 10,
        normalBias: 0
      }, {
        direction: new n.Pa4(.2, 1, .2).normalize(),
        spread: .9,
        focus: 1,
        distanceScale: 20,
        minDistanceScale: new n.Pa4(10, 10, 10),
        normalDirection: new n.Pa4(0, 1, 0)
      });
      t.shadow.camera.updateProjectionMatrix(), t.layers.disableAll(), t.layers.set(this._lightLayer), this._light = t, e.scene.addLight(this._light, {
        addToRoot: !0
      }), this._shadowMat = new au({
        color: "#ffffff",
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        premultipliedAlpha: !1,
        opacity: 1,
        transparent: !1,
        blending: n.jFi
      });
    }
    get attachedMesh() {
      return this._attachedMesh;
    }
    set attachedMesh(e) {
      this._attachedMesh !== e && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e, this._attachedMesh && this._updateMaterial());
    }
    get target() {
      return this._target;
    }
    get light() {
      return this._light;
    }
    dispose() {
      this._shadowMat.dispose(), this._target = void 0, this.reset();
    }
    cleanupMaterial() {
      this._updateMaterial(!0);
    }
    _groundMapModeChanged() {
      this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = !0 : this._attachedMesh.material.transparent = !1), this.reset();
    }
    _alphaVignetteChanged() {
      var e, t, r;
      null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (r = this._viewer) || void 0 === r || r.setDirty();
    }
    fromJSON(e, t) {
      return De(e, this, !0, t), this.reset(), this;
    }
    reset() {
      this._frameNumber = 0;
    }
    autoUpdateShadow() {
      this.shadowAutoUpdate && this.updateShadow();
    }
    updateShadow() {
      if (!this.enabled) return !1;
      const e = this._attachedMesh;
      if (++this._frameNumber > this.maxFrameNumber || !e) return !1;
      const t = 1024;
      this._target || (this._target = this._viewer.renderer.createTarget({
        type: n.ywz,
        depthBuffer: !1,
        size: new n.FM8(t, t),
        sizeMultiplier: void 0,
        encoding: n.rnI,
        format: n.wk1
      })), this._frameNumber < 3 ? this._light.randomizePosition(0, 1, 0) : this._light.randomizePosition(this._frameNumber), e.castShadow = !1;
      const r = this._viewer.renderer.rendererObject,
        i = r.shadowMap,
        s = i.type,
        o = i.needsUpdate,
        a = i.autoUpdate;
      i.type = n._MY, i.needsUpdate = !0, i.autoUpdate = !1;
      const l = this._viewer.scene,
        c = new n.S9g();
      c.disableAll(), l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.userData.__gp_layers = e.layers, e.layers = c);
      });
      const u = l.activeCamera.cameraObject;
      if (0 != (u.layers.mask & 1 << this._lightLayer)) throw "Camera can render pseudo directional light, check layers";
      u.layers.enable(this._lightLayer), e.layers.disable(this._lightLayer), W(r, {
        shadowMapRender: !0,
        backgroundRender: !1,
        sceneRender: !1
      }, () => this._viewer.renderer.renderScene(l)), u.layers.disable(this._lightLayer);
      const h = u.layers.mask;
      u.layers.set(this._lightLayer), e.layers.enable(this._lightLayer);
      const p = this._viewer.renderer.getTempTarget({
          type: n.ywz,
          depthBuffer: !1,
          size: new n.FM8(t, t),
          encoding: n.rnI,
          format: n.wk1
        }),
        d = p.texture.encoding;
      p.texture.encoding = n.rnI, this._viewer.renderer.blit(this._target.texture, p, {
        clear: !0
      });
      {
        const t = l.modelObject.environment,
          n = l.modelObject.background,
          i = e.material,
          s = e.frustumCulled,
          o = r.getRenderTarget(),
          a = r.getActiveCubeFace(),
          c = r.getActiveMipmapLevel();
        l.modelObject.background = null, l.modelObject.environment = null, e.material = this._shadowMat, e.frustumCulled = !1, r.setRenderTarget(this._target);
        const u = !1;
        this._shadowMat.opacity = u ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = p.texture, this._shadowMat.needsUpdate = !0, W(r, {
          shadowMapRender: !1,
          backgroundRender: !1,
          opaqueRender: !0,
          transparentRender: !1,
          transmissionRender: !1
        }, () => this._viewer.renderer.renderScene(l)), r.setRenderTarget(o, a, c), e.frustumCulled = s, e.material = i, l.modelObject.environment = t, l.modelObject.background = n;
      }
      return p.texture.encoding = d, this._viewer.renderer.releaseTempTarget(p), e.layers.disable(this._lightLayer), u.layers.mask = h, l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.layers = e.userData.__gp_layers, delete e.userData.__gp_layers);
      }), i.type = s, i.needsUpdate = o, i.autoUpdate = a, e.castShadow = !0, (this._frameNumber < 2 || this._frameNumber > Math.min(30, this.maxFrameNumber) && this._frameNumber % 150 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e.dispatchEvent({
        type: "materialUpdate"
      })), !0;
    }
    _updateMaterial(e = !1) {
      var t, r, n;
      this._attachedMesh && (e ? (this._attachedMesh.material.alphaMap === (null === (t = this._target) || void 0 === t ? void 0 : t.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (r = this._target) || void 0 === r ? void 0 : r.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (n = this._target) || void 0 === n ? void 0 : n.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e || "alphaMap" !== this.groundMapMode ? 0 : .001, this._attachedMesh.material.needsUpdate = !0));
    }
  }
  lu([Ce("randomizedLight")], cu.prototype, "_light", void 0), lu([M(cu.prototype.reset), Ce()], cu.prototype, "maxFrameNumber", void 0), lu([M(cu.prototype._groundMapModeChanged), Ce()], cu.prototype, "groundMapMode", void 0), lu([Ce(), M(cu.prototype._alphaVignetteChanged)], cu.prototype, "alphaVignette", void 0), lu([Ce(), M(cu.prototype._alphaVignetteChanged)], cu.prototype, "alphaVignetteAxis", void 0);
  var uu = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}",
    hu = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  class pu extends n.Kj0 {
    constructor(e, t, r = 0) {
      super(e), this.type = "Reflector", this.isReflector2 = !0, this.enabled = !0, this.reflectorModePhysical = !0, this.reflectionTargetNeedsUpdate = !0, this.transparentReflectionBackground = !0, this.materialExtension = {
        extraUniforms: {
          tRefDiffuse: {
            value: null
          },
          tRefDiffuseSize: {
            value: new n.FM8()
          },
          refTextureMatrix: {
            value: null
          },
          frameCount: {
            value: 0
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        updaters: [],
        shaderExtender: (e, t, r) => {
          if (this.enabled) {
            e.vertexShader = e.vertexShader.replace("void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
            const t = "#glMarker beforeModulation";
            e.fragmentShader = e.fragmentShader.replace(t, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        // d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t), e.vertexUvs = !0;
          }
        },
        parsVertexSnippet: () => this.enabled ? "\n\t\tuniform mat4 refTextureMatrix;\n\t\tvarying vec4 vRefUv;\n" : "",
        parsFragmentSnippet: () => this.enabled ? uu + "\n" + Po + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*interleavedGradientNoise(vUv.xy,frameCount);vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "",
        computeCacheKey: e => this.enabled + " " + e.materialObject.transparent + " " + this.reflectorModePhysical + " ",
        onObjectRender: (e, {
          materialObject: t
        }) => {
          t.userData.__lastTransparent !== t.transparent && (t.needsUpdate = !0, t.userData.__lastTransparent = t.transparent);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this.material = void 0, this._renderTarget = t;
      const i = new n.JOQ(),
        s = new n.Pa4(),
        o = new n.Pa4(),
        a = new n.Pa4(),
        l = new n.yGw(),
        c = new n.Pa4(0, 0, -1),
        u = new n.Ltg(),
        h = new n.Pa4(),
        p = new n.Pa4(),
        d = new n.Ltg(),
        f = new n.yGw(),
        m = new n.cPb();
      n.M8C.isPowerOfTwo(t.texture.image.width) && n.M8C.isPowerOfTwo(t.texture.image.height) || (this._renderTarget.texture.generateMipmaps = !1), this.onBeforeRender = (e, t, n) => {
        if (!this.enabled || !e.userData.mainRenderPass) return;
        if (!this.reflectionTargetNeedsUpdate) return;
        const _ = n.view ? Object.assign({}, n.view) : null;
        if (_ && n.clearViewOffset && n.clearViewOffset(), o.setFromMatrixPosition(this.matrixWorld), a.setFromMatrixPosition(n.matrixWorld), l.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(l), h.subVectors(o, a), h.dot(s) > 0) return;
        h.reflect(s).negate(), h.add(o), l.extractRotation(n.matrixWorld), c.set(0, 0, -1), c.applyMatrix4(l), c.add(a), p.subVectors(o, c), p.reflect(s).negate(), p.add(o), m.position.copy(h), m.up.set(0, 1, 0), m.up.applyMatrix4(l), m.up.reflect(s), m.lookAt(p), m.far = 2, m.near = 0, m.updateMatrixWorld(), m.projectionMatrix.copy(n.projectionMatrix), f.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), f.multiply(m.projectionMatrix), f.multiply(m.matrixWorldInverse), f.multiply(this.matrixWorld), i.setFromNormalAndCoplanarPoint(s, o), i.applyMatrix4(m.matrixWorldInverse), u.set(i.normal.x, i.normal.y, i.normal.z, i.constant);
        const g = m.projectionMatrix;
        d.x = (Math.sign(u.x) + g.elements[8]) / g.elements[0], d.y = (Math.sign(u.y) + g.elements[9]) / g.elements[5], d.z = -1, d.w = (1 + g.elements[10]) / g.elements[14], u.multiplyScalar(2 / u.dot(d)), g.elements[2] = u.x, g.elements[6] = u.y, g.elements[10] = u.z + 1 - r, g.elements[14] = u.w, this.visible = !1;
        const v = e.getRenderTarget(),
          A = e.xr.enabled,
          b = e.shadowMap.autoUpdate;
        e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(this._renderTarget), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear();
        const y = t.background;
        this.transparentReflectionBackground && (t.background = null);
        const x = !this.transparentReflectionBackground;
        y && x && (y.userData.flipX = !y.userData.flipX), W(e, {
          shadowMapRender: !1,
          backgroundRender: x,
          opaqueRender: !0,
          transparentRender: !0,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => e.render(t, m)), y && x && (y.userData.flipX = !y.userData.flipX || void 0), this.transparentReflectionBackground && (t.background = y), e.xr.enabled = A, e.shadowMap.autoUpdate = b, e.setRenderTarget(v), (null == _ ? void 0 : _.enabled) && n.setViewOffset && n.setViewOffset(_.fullWidth, _.fullHeight, _.offsetX, _.offsetY, _.width, _.height);
        const w = n.viewport;
        void 0 !== w && e.state.viewport(w), this.visible = !0, this.reflectionTargetNeedsUpdate = !1;
      }, this.textureMatrix = f, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new n.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.refTextureMatrix.value = f;
    }
    _updateExtension() {
      var e, t;
      this.transparentReflectionBackground = this.reflectorModePhysical, null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e);
    }
    getRenderTarget() {
      return this._renderTarget;
    }
  }
  hu([M(pu.prototype._updateExtension)], pu.prototype, "enabled", void 0), hu([M(pu.prototype._updateExtension)], pu.prototype, "reflectorModePhysical", void 0), pu.prototype.isReflector = !0;
  var du = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class fu extends ro {
    constructor(e = {}) {
      super(), this._transformNeedRefresh = !0, this.dependencies = [to], this.visible = !0, this.size = 8, this.yOffset = 0, this.renderToDepth = !0, this.tonemapGround = !0, this.limitCameraAboveGround = !1, this._cameraLimitsSet = !1, this._cameraLastMaxPolarAngle = Math.PI, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this._refreshCameraLimits = this._refreshCameraLimits.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new n._12(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0, this._options = {
        shape: "",
        up: [0, 100, 0],
        autoAdjustTransform: !0
      }, this.setOptions(e);
    }
    get enabled() {
      return this.visible;
    }
    set enabled(e) {
      this.visible = e;
    }
    get material() {
      return this._material;
    }
    get mesh() {
      return this._iMesh;
    }
    _createMesh() {
      return new n.Kj0(this._geometry);
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), e.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e.getPlugin(to);
      const n = this._createMesh();
      n.userData.physicsMass = 0, this._iMesh = await (null === (t = this._manager) || void 0 === t ? void 0 : t.addImportedSingle(n, {
        pseudoCenter: !1,
        autoScale: !1,
        addToRoot: !0
      })), this._mesh = null === (r = this._iMesh) || void 0 === r ? void 0 : r.modelObject, this._mesh && (this._mesh.userData.userSelectable = !1, this._mesh.castShadow = !0, this._mesh.receiveShadow = !0, this._mesh.name = "Ground Plane"), e.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e.scene.addEventListener("addSceneObject", this._onSceneUpdate), e.addEventListener("preRender", this._preRender), e.addEventListener("postFrame", this._postFrame), this.refreshOptions();
    }
    _postFrame() {
      this._transformNeedRefresh && this._refreshTransform(), this._viewer;
    }
    _preRender() {
      this._viewer;
    }
    async onDispose(e) {
      var t, r;
      return this._geometry.dispose(), null === (r = null === (t = this._iMesh) || void 0 === t ? void 0 : t.dispose) || void 0 === r || r.call(t), super.onDispose(e);
    }
    async onRemove(e) {
      return this._removeMaterial(), e.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e.removeEventListener("postFrame", this._postFrame), e.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e);
    }
    _removeMaterial() {
      var e, t;
      this._material && (null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t || t.unregisterMaterial(this._material), this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
    }
    _onSceneUpdate(e) {
      !1 !== e.geometryChanged && !1 !== e.updateGround && this.refreshTransform();
    }
    refreshTransform() {
      this._transformNeedRefresh = !0;
    }
    _refreshOptions2() {
      this.refreshOptions();
    }
    refreshOptions() {
      this._viewer && (this._refreshMaterial(), this.refreshTransform(), this._refreshCameraLimits());
    }
    _refreshCameraLimits() {
      var e;
      const t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera.controls;
      t && (void 0 !== t.maxPolarAngle ? this.limitCameraAboveGround ? (this._cameraLimitsSet || (this._cameraLastMaxPolarAngle = t.maxPolarAngle), t.maxPolarAngle = Math.PI / 2, this._cameraLimitsSet = !0) : this._cameraLimitsSet && (t.maxPolarAngle = this._cameraLastMaxPolarAngle, this._cameraLimitsSet = !1) : console.warn("refreshCameraLimits only available with orbit controls."));
    }
    _refreshTransform() {
      var e, t, r;
      if (!this._mesh) return;
      if (!this._viewer) return;
      let i = !1;
      if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, i = !0), this.enabled) {
        if (this._options.autoAdjustTransform) {
          this._mesh.userData.bboxVisible = !1;
          const e = this._viewer.scene.getBounds(!0);
          this._mesh.userData.bboxVisible = !0;
          const t = e.getCenter(new n.Pa4()).sub(new n.Pa4(0, e.getSize(new n.Pa4()).y / 2 + this.yOffset, 0));
          i = i || t.clone().sub(this._mesh.position).length() > 1e-4, i && this._mesh.position.copy(t);
        }
        i = i || Math.abs(this._mesh.scale.x - this.size) > 1e-4, i && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new n.USm(-Math.PI / 2, 0, 0)), this._mesh.matrixWorldNeedsUpdate = !0, null === (r = (t = this._mesh).setDirty) || void 0 === r || r.call(t)), this._transformNeedRefresh = !1;
      } else i && (null === (e = this._viewer) || void 0 === e || e.scene.setDirty());
    }
    _refreshMaterial() {
      var e, t, r, n, i, s, o, a;
      if (!this._viewer) return !1;
      if (!this.enabled) return !1;
      this._manager || console.error("GroundPlugin requires asset manager");
      const l = null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.findOrCreate(null !== (n = null === (r = this._material) || void 0 === r ? void 0 : r.uuid) && void 0 !== n ? n : "standard", {
        name: "BaseGroundMaterial",
        runtimeMaterial: !0,
        color: 16777215
      });
      let c = !1;
      if ((null == l ? void 0 : l.uuid) !== (null === (i = this._material) || void 0 === i ? void 0 : i.uuid)) {
        if (this._removeMaterial(), l && (this._material = l), (null === (s = this._material) || void 0 === s ? void 0 : s.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material) {
          this._material.roughness = .2, this._material.metalness = .5;
          (null !== (a = null === (o = this._mesh) || void 0 === o ? void 0 : o.setMaterial) && void 0 !== a ? a : e => {
            this._mesh && (this._mesh.material = e.materialObject);
          })(this._material);
        }
        c = !0;
      }
      return this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround), this._material.materialObject.userData.ssaoDisabled = !0, this._material.materialObject.userData.sscsDisabled = !0), this._viewer.setDirty(this), c;
    }
    setOptions(e) {
      Object.assign(this._options, e), this.refreshOptions();
    }
    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.refreshOptions(), this) : null;
    }
    _extraUiConfig() {
      return [() => {
        var e;
        return null === (e = this._material) || void 0 === e ? void 0 : e.uiConfig;
      }];
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ground",
        children: [{
          label: "Visible",
          type: "checkbox",
          property: [this, "visible"],
          limitedUi: !0
        }, {
          label: "Size",
          type: "input",
          property: [this, "size"],
          limitedUi: !0
        }, {
          label: "Render to Depth",
          type: "checkbox",
          property: [this, "renderToDepth"]
        }, {
          label: "Limit Camera",
          type: "checkbox",
          property: [this, "limitCameraAboveGround"]
        }, {
          label: "Tonemap",
          type: "checkbox",
          property: [this, "tonemapGround"]
        }, {
          label: "Height",
          type: "slider",
          bounds: [-2, 2],
          property: [this, "yOffset"]
        }, ...this._extraUiConfig()]
      };
    }
  }
  du([Ce("material")], fu.prototype, "_material", void 0), du([M(fu.prototype.refreshTransform), Ce()], fu.prototype, "visible", void 0), du([M(fu.prototype._onSceneUpdate), Ce()], fu.prototype, "size", void 0), du([M(fu.prototype._onSceneUpdate), Ce()], fu.prototype, "yOffset", void 0), du([M(fu.prototype._refreshOptions2), Ce()], fu.prototype, "renderToDepth", void 0), du([M(fu.prototype._refreshOptions2), Ce()], fu.prototype, "tonemapGround", void 0), du([M(fu.prototype._refreshCameraLimits), Ce()], fu.prototype, "limitCameraAboveGround", void 0);
  var mu = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class _u extends fu {
    constructor(e = {}, t = !1) {
      super(e), this.bakedShadows = !0, this.groundReflection = !1, this.physicalReflections = !1, this._showDebug = t, t && this.dependencies.push(Yc), this._onSceneUpdate = this._onSceneUpdate.bind(this);
    }
    get shadowBaker() {
      return this._shadowBaker;
    }
    _createMesh() {
      const e = new pu(this._geometry, this._viewer.renderer.createTarget({
          type: n.ywz,
          format: n.wk1,
          encoding: n.rnI,
          size: {
            width: 1024,
            height: 1024
          },
          generateMipmaps: !0,
          depthBuffer: !0,
          minFilter: n.D1R,
          magFilter: n.wem
        })),
        t = e.onBeforeRender;
      return e.onBeforeRender = (...e) => {
        var r, n, i, s, o;
        let a = null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("SSReflection")) || void 0 === n ? void 0 : n.passes.ssr.passObject;
        a && !a.enabled && (a = void 0), a && (a.enabled = !1);
        let l = null === (o = null === (s = null === (i = this._viewer) || void 0 === i ? void 0 : i.getPluginByType("SSBevelPlugin")) || void 0 === s ? void 0 : s.pass) || void 0 === o ? void 0 : o.passObject;
        l && !l.enabled && (l = void 0), l && (l.enabled = !1), t(...e), a && (a.enabled = !0), l && (l.enabled = !0);
      }, e;
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this._showDebug && (null === (t = e.getPlugin(Yc)) || void 0 === t || t.addTexture("bake_ground_1", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light.shadow.map) || void 0 === t ? void 0 : t.texture;
      }, [100, 100, 200, 200]), null === (r = e.getPlugin(Yc)) || void 0 === r || r.addTexture("bake_ground_2", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.target) || void 0 === t ? void 0 : t.texture;
      }, [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"));
    }
    _postFrame() {
      var e;
      super._postFrame(), this._viewer && this.enabled && this.bakedShadows && (null === (e = this._shadowBaker) || void 0 === e || e.autoUpdateShadow());
    }
    _preRender() {
      super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1);
    }
    async onDispose(e) {
      return super.onDispose(e);
    }
    async onRemove(e) {
      return super.onRemove(e);
    }
    _removeMaterial() {
      var e, t, r, n;
      if (this._material) {
        if (this._shadowBaker && this._material.groundMatExtension && (null === (t = (e = this._material).unregisterMaterialExtensions) || void 0 === t || t.call(e, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
          const e = this._mesh.materialExtension;
          e || console.warn("unable to find the extension to unregister"), null === (n = (r = this._material).unregisterMaterialExtensions) || void 0 === n || n.call(r, [e]), delete this._material.reflectorMatExtension;
        }
        super._removeMaterial();
      }
    }
    _onSceneUpdate(e) {
      var t;
      super._onSceneUpdate(e), !1 !== e.geometryChanged && (null === (t = this._shadowBaker) || void 0 === t || t.reset());
    }
    refreshOptions() {
      if (!this._viewer) return;
      this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new cu(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
      const e = this._mesh;
      e.isReflector2 && (e.enabled = this.groundReflection, e.reflectorModePhysical = this.physicalReflections), super.refreshOptions(), this._viewer.setDirty(this);
    }
    _refreshMaterial() {
      var e, t, r, n;
      if (!this._viewer) return !1;
      const i = super._refreshMaterial();
      if (!this._material) return i;
      if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
        const r = this._mesh.materialExtension;
        r.updaters = [this._viewer.scene, this._viewer.renderer], null === (t = (e = this._material).registerMaterialExtensions) || void 0 === t || t.call(e, [r]), this._material.reflectorMatExtension = !0;
      }
      return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (n = (r = this._material).registerMaterialExtensions) || void 0 === n || n.call(r, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = !0), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, this._viewer.setDirty(this), i;
    }
    _extraUiConfig() {
      var e, t, r, n, i, s, o, a, l, c, u, h, p, d, f, m, _, g, v, A, b, y, x, w, E, S, C, M, T, I;
      return [{
        label: "Baked Shadows",
        type: "checkbox",
        property: [this, "bakedShadows"]
      }, {
        label: "Shadow Frames",
        type: "input",
        hidden: () => !this._shadowBaker,
        stepSize: 1,
        bounds: [1, 1e3],
        property: [this._shadowBaker, "maxFrameNumber"]
      }, {
        label: "Alpha Vignette",
        type: "checkbox",
        hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent,
        property: [this._shadowBaker, "alphaVignette"],
        limitedUi: !0,
        onChange: () => {
          var e, t;
          return null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e, "postFrame", !0);
        }
      }, {
        label: "Alpha Vignette Axis",
        type: "dropdown",
        hidden: () => {
          var e;
          return !(null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent;
        },
        property: [this._shadowBaker, "alphaVignetteAxis"],
        children: ["x", "y", "xy"].map(e => ({
          label: e,
          value: e
        })),
        limitedUi: !0
      }, {
        label: "Planar Reflections",
        type: "checkbox",
        property: [this, "groundReflection"],
        limitedUi: !0
      }, {
        label: "Physical Reflections",
        type: "checkbox",
        property: [this, "physicalReflections"],
        limitedUi: !0
      }, {
        label: "Shadow type",
        type: "dropdown",
        hidden: () => !this._shadowBaker,
        property: [this._shadowBaker, "groundMapMode"],
        children: [{
          label: "aoMap"
        }, {
          label: "map"
        }, {
          label: "alphaMap"
        }],
        limitedUi: !0
      }, {
        type: "folder",
        label: "Randomized Light",
        hidden: () => !this._shadowBaker,
        limitedUi: !0,
        children: [{
          type: "color",
          label: "Color",
          property: [null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 100],
          property: [null === (t = this._shadowBaker) || void 0 === t ? void 0 : t.light, "intensity"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [null === (n = null === (r = this._shadowBaker) || void 0 === r ? void 0 : r.light) || void 0 === n ? void 0 : n.shadowParams, "enabled"],
          onChange: [null === (s = null === (i = this._shadowBaker) || void 0 === i ? void 0 : i.light) || void 0 === s ? void 0 : s.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (a = null === (o = this._shadowBaker) || void 0 === o ? void 0 : o.light) || void 0 === a ? void 0 : a.randomParams, "focus"],
          onChange: [this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (c = null === (l = this._shadowBaker) || void 0 === l ? void 0 : l.light) || void 0 === c ? void 0 : c.randomParams, "spread"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 60],
          property: [null === (h = null === (u = this._shadowBaker) || void 0 === u ? void 0 : u.light) || void 0 === h ? void 0 : h.randomParams, "distanceScale"],
          onChange: [null === (d = null === (p = this._shadowBaker) || void 0 === p ? void 0 : p.light) || void 0 === d ? void 0 : d.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (m = null === (f = this._shadowBaker) || void 0 === f ? void 0 : f.light) || void 0 === m ? void 0 : m.randomParams, "direction"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (g = null === (_ = this._shadowBaker) || void 0 === _ ? void 0 : _.light) || void 0 === g ? void 0 : g.randomParams, "normalDirection"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 10],
          property: [null === (A = null === (v = this._shadowBaker) || void 0 === v ? void 0 : v.light) || void 0 === A ? void 0 : A.shadowParams, "radius"],
          onChange: [null === (y = null === (b = this._shadowBaker) || void 0 === b ? void 0 : b.light) || void 0 === y ? void 0 : y.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "input",
          property: [null === (w = null === (x = this._shadowBaker) || void 0 === x ? void 0 : x.light) || void 0 === w ? void 0 : w.shadowParams, "frustumSize"],
          onChange: [null === (S = null === (E = this._shadowBaker) || void 0 === E ? void 0 : E.light) || void 0 === S ? void 0 : S.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [-.1, .1],
          property: [null === (M = null === (C = this._shadowBaker) || void 0 === C ? void 0 : C.light) || void 0 === M ? void 0 : M.shadowParams, "bias"],
          onChange: [null === (I = null === (T = this._shadowBaker) || void 0 === T ? void 0 : T.light) || void 0 === I ? void 0 : I.updateShadowParams, this._onSceneUpdate]
        }]
      }, ...super._extraUiConfig()];
    }
  }
  _u.PluginType = "Ground", mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "bakedShadows", void 0), mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "groundReflection", void 0), mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "physicalReflections", void 0), mu([Ce("shadowBaker")], _u.prototype, "_shadowBaker", void 0);
  var gu,
    vu = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Au = gu = class extends zt {
    constructor() {
      super({
        vertexShader: i.vertexShader,
        defines: {
          PASS_STEP: 1
        },
        uniforms: {
          tSource: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          opacity: {
            value: 1
          },
          tDiffuseSize: {
            value: new n.FM8()
          },
          weight: {
            value: 1
          },
          tNormalDepth: {
            value: null
          }
        },
        fragmentShader: Ht + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}void main(){\n#if PASS_STEP == 0 \ngl_FragColor=weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}"
      }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new n.Ltg(2, .5, 0, 0), this.threshold = 2, this.softThreshold = .5, this.intensity = .5, this.bloomIterations = 4, this.radius = .6, this.power = 1, this.bloomDebug = !1, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = !0, this.userData = {
        setDirty: () => {
          this.setDirty();
        }
      };
    }
    _thresholdsUpdated() {
      this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = .125 / (this.uniforms.prefilter.value.z + 1e-5);
    }
    render(e, t, r, i, s) {
      const o = e.baseRenderer;
      this.material.defines.PASS_STEP = 0, this.clear = !0;
      const a = r;
      let l = .5,
        c = a.width * l,
        u = a.height * l;
      const h = [];
      let p = o.getTempTarget({
        sizeMultiplier: .5,
        type: n.cLu
      });
      h.push(p);
      let d = a;
      this.material.needsUpdate = !0, this.material.uniforms.weight.value = this._weights[0], super.render(e, p, d, i, s), d = p;
      let f = 1;
      for (; f < this.bloomIterations && (c /= 2, u /= 2, l /= 2, !(u < 2 || c < 2)); f++) {
        p = o.getTempTarget({
          sizeMultiplier: l,
          type: n.cLu
        }), h.push(p), this.material.defines.PASS_STEP = 1;
        let t = this._weights[f];
        t = 0 !== this._weights[f - 1] ? this._weights[f] / this._weights[f - 1] : this._weights[f], this.material.uniforms.weight.value = t, this.material.needsUpdate = !0, super.render(e, p, d, i, s), d = p;
      }
      this.clear = !1;
      const m = e.autoClear;
      for (e.autoClear = !1, f -= 2; f >= 0; f--) p = h[f], h[f] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = !0, this.material.blending = n.WMw, this.material.needsUpdate = !0, e.autoClear = !1, super.render(e, p, d, i, s), this.material.blending = n.jFi, o.releaseTempTarget(d), d = p;
      this.clear = !0, e.autoClear = m, e.autoClear = !0, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = !0, super.render(e, t, d, i, s)) : (this.uniforms.tSource.value = a.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = !0, super.render(e, t, d, i, s), this.uniforms.tSource.value = null), o.releaseTempTarget(d);
    }
    _updateWeights() {
      if (!this._weights) return;
      const e = Math.max(Math.min(this.radius, 1), 0),
        t = 1 / (this.bloomIterations - 1);
      for (let r = 0; r < this.bloomIterations; r++) {
        let n = r * t + .1,
          i = 1.2 - n;
        n = Math.pow(n, this.power), i = Math.pow(i, this.power), this._weights[r] = i * (1 - e) + n * e;
      }
      this.setDirty();
    }
  };
  vu([G()], Au.prototype, "prefilter", void 0), vu([$e("Threshold", [0, 2]), M(gu.prototype._thresholdsUpdated), Ce()], Au.prototype, "threshold", void 0), vu([$e("Soft Threshold", [0, 1]), M(gu.prototype._thresholdsUpdated), Ce()], Au.prototype, "softThreshold", void 0), vu([$e("Intensity", [0, 3]), Ce(), G()], Au.prototype, "intensity", void 0), vu([$e("Iterations", [0, 7], 1), M(gu.prototype._updateWeights), Ce()], Au.prototype, "bloomIterations", void 0), vu([$e("Radius", [0, 1], .01), M(gu.prototype._updateWeights), Ce()], Au.prototype, "radius", void 0), vu([$e("Power", [.2, 10], .01), M(gu.prototype._updateWeights), Ce()], Au.prototype, "power", void 0), vu([Je("Debug")], Au.prototype, "bloomDebug", void 0), Au = gu = vu([lt("Bloom")], Au);
  class bu extends io {
    constructor() {
      super(...arguments), this.passId = "bloom", this._beforeFilters = ["combinedPost", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"];
    }
    passCtor(e) {
      return new Au();
    }
    _update(e) {
      var t, r;
      return null === (t = e.getPlugin(lo)) || void 0 === t || t.updateShaderProperties(null === (r = this.pass) || void 0 === r ? void 0 : r.passObject.material), super._update(e);
    }
    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }
  }
  bu.PluginType = "Bloom";
  var yu = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let xu = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this._defines = {
        ANISOTROPY_DEBUG: !1
      }, this._uniforms = {
        anisotropyFactor: {
          value: 1
        },
        anisotropyNoise: {
          value: 1
        },
        anisotropyDirection: {
          value: 1
        },
        anisotropyDirectionMap: {
          value: null
        },
        frameCount: {
          value: 0
        }
      }, this.materialExtension = {
        shaderExtender: (e, t, r) => {
          var i;
          if (!this.enabled || !t.materialObject.userData._isAnisotropic) return;
          const s = null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i._anisotropyDirectionMap,
            o = w`
                #include <bsdfs>
                //#if ANISOTROPY_ENABLED
                ${Po}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (s ? U("anisotropyDirectionMap", s, r.capabilities.isWebGL2) : "");
          e.fragmentShader = e.fragmentShader.replace("#include <bsdfs>", o), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tangent*rot2.x+bitangent*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));IncidentLight directLight;").replaceAll("RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )");
          const a = n.WdD.lights_physical_pars_fragment.replace("void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {").replace("BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_pars_fragment>", a);
          const l = w`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + n.WdD.lights_fragment_maps.replace("getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )").replace("getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_maps>", l), e.vertexUvs = !0, e.vertexTangents = !0;
        },
        onObjectRender: (e, t) => {
          var r;
          const n = t.materialObject.userData;
          if (!(null == n ? void 0 : n._isAnisotropic)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          if (!i.geometry.attributes.tangent) throw new Error("No tangents on the geometry");
          this._uniforms.anisotropyFactor.value = n._anisotropyFactor, this._uniforms.anisotropyNoise.value = n._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (r = n._anisotropyDirectionMap) || void 0 === r ? void 0 : r.isTexture) ? n._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = n._anisotropyDirection;
          let s = this.enabled ? 1 : 0;
          t.materialObject.defines.ANISOTROPY_ENABLED !== s && (t.materialObject.defines.ANISOTROPY_ENABLED = s, t.materialObject.needsUpdate = !0), s = +this._defines.ANISOTROPY_DEBUG, t.materialObject.defines.ANISOTROPY_DEBUG !== s && (t.materialObject.defines.ANISOTROPY_DEBUG = s, t.materialObject.needsUpdate = !0), s = n._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s = "CONSTANT"), s = "DIRECTION" === s ? 2 : "ROTATION" === s ? 1 : 0, t.materialObject.defines.ANISOTROPY_TEX_MODE !== s && (t.materialObject.defines.ANISOTROPY_TEX_MODE = s, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: {
          ...this._uniforms
        },
        computeCacheKey: e => {
          var t, r, n;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._isAnisotropic) ? "1" : "0") + (null === (n = null === (r = e.materialObject.userData) || void 0 === r ? void 0 : r._anisotropyDirectionMap) || void 0 === n ? void 0 : n.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer];
        },
        getUiConfig: e => {
          const t = this._viewer,
            r = this.makeAnisotropic,
            n = {
              type: "folder",
              label: "Anisotropy",
              children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                  return e.materialObject.userData._isAnisotropic || !1;
                },
                set value(i) {
                  var s;
                  i !== e.materialObject.userData._isAnisotropic && (i ? r(e) || t.alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._isAnisotropic = !1, e.materialObject.needsUpdate = !0), null === (s = n.uiRefresh) || void 0 === s || s.call(n, "postFrame", !0));
                },
                onChange: this.setDirty
              }, {
                type: "slider",
                label: "Factor",
                bounds: [-2, 2],
                hidden: () => !e.materialObject.userData._isAnisotropic,
                property: [e.materialObject.userData, "_anisotropyFactor"],
                onChange: this.setDirty
              }, {
                type: "slider",
                label: "Noise",
                bounds: [0, 2],
                hidden: () => !e.materialObject.userData._isAnisotropic,
                property: [e.materialObject.userData, "_anisotropyNoise"],
                onChange: this.setDirty
              }, {
                type: "image",
                label: "Texture",
                hidden: () => !e.materialObject.userData._isAnisotropic,
                property: [e.materialObject.userData, "_anisotropyDirectionMap"],
                onChange: () => {
                  e.materialObject.needsUpdate = !0, this.setDirty();
                }
              }, {
                type: "dropdown",
                label: "Mode",
                hidden: () => !e.materialObject.userData._isAnisotropic,
                property: [e.materialObject.userData, "_anisotropyDirectionMode"],
                children: ["CONSTANT", "ROTATION", "DIRECTION"].map(e => ({
                  label: e
                })),
                onChange: () => {
                  e.materialObject.needsUpdate = !0, this.setDirty();
                }
              }]
            };
          return n;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this.makeSelectedAnisotropic = () => {
        var e, t, r;
        const n = null === (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === r ? void 0 : r.material;
        return "material" === (null == n ? void 0 : n.assetType) && this.makeAnisotropic(n);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    makeAnisotropic(e) {
      var t;
      const r = null === (t = e.materialObject) || void 0 === t ? void 0 : t.userData;
      if (!r) return !1;
      if (void 0 === r._isAnisotropic) {
        const e = r.__appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: r
        } of e) !r || r.index && r.attributes.position && r.attributes.normal && r.attributes.uv || (t = !1), t && !r.attributes.tangent && r.computeTangents();
        if (!t) return !1;
      }
      return r._isAnisotropic = !0, void 0 === r._anisotropyFactor && (r._anisotropyFactor = 1), void 0 === r._anisotropyNoise && (r._anisotropyNoise = 0), void 0 === r._anisotropyDirectionMode && (r._anisotropyDirectionMode = "DIRECTION"), e.materialObject.needsUpdate = !0, !0;
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new wu(e));
    }
    async onAdded(e) {
      var t, r, n, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(to);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (r = null == o ? void 0 : o.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (n = null == o ? void 0 : o.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Eu);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }
  };
  xu.PluginType = "AnisotropyPlugin", xu.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", yu([Je("Enabled", e => ({
    onChange: e.setDirty
  })), Ce()], xu.prototype, "enabled", void 0), yu([rt("Make Anisotropy", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc));
    }
  }))], xu.prototype, "makeSelectedAnisotropic", void 0), xu = yu([lt("Anisotropy Materials")], xu);
  class wu {
    constructor(e) {
      this.parser = e, this.name = xu.ANISOTROPY_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      var r, i, s;
      const o = this.parser,
        a = o.json.materials[e];
      if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
      const l = [],
        c = a.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._isAnisotropic = !0, t.userData._anisotropyFactor = null !== (r = c.anisotropyFactor) && void 0 !== r ? r : 0, t.userData._anisotropyNoise = null !== (s = null !== (i = c.anisotropyNoiseFactor) && void 0 !== i ? i : c.anisotropyNoise) && void 0 !== s ? s : 0;
      let {
        anisotropyDirectionMode: u,
        anisotropyDirection: h
      } = c;
      return u || (u = c.anisotropyTextureMode), h || (h = c.anisotropyRotation), t.userData._anisotropyDirectionMode = u && "number" == typeof (null == h ? void 0 : h.index) ? u : "CONSTANT", "ROTATION" === u || "DIRECTION" === u ? l.push(o.assignTexture(t.userData, "_anisotropyDirectionMap", h).then(e => {
        e.encoding = n.knz;
      })) : t.userData._anisotropyDirection = null != h ? h : 0, Promise.all(l);
    }
    afterRoot(e) {
      return e.scene.traverse(e => {
        var t, r;
        if (!(null === (r = null === (t = e.material) || void 0 === t ? void 0 : t.userData) || void 0 === r ? void 0 : r._isAnisotropic)) return;
        const n = e.geometry;
        n.attributes.tangent || (n.computeTangents(), n.attributes.tangent.needsUpdate = !0);
      }), null;
    }
  }
  const Eu = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._isAnisotropic) return;
      if ((t.userData._anisotropyFactor || 0) < .001) return;
      r.extensions = r.extensions || {};
      const n = {};
      if (n.anisotropyFactor = t.userData._anisotropyFactor || 1, n.anisotropyNoiseFactor = t.userData._anisotropyNoise || 0, n.anisotropyDirectionMode = t.userData._anisotropyDirectionMode || "CONSTANT", t.userData._anisotropyDirectionMap && "CONSTANT" !== n.anisotropyDirectionMode) {
        const r = {
          index: e.processTexture(t.userData._anisotropyDirectionMap)
        };
        e.applyTextureTransform(r, t.userData._anisotropyDirectionMap), n.anisotropyDirection = r;
      } else n.anisotropyDirectionMode = "CONSTANT", n.anisotropyDirection = t.userData._anisotropyDirection || 0;
      r.extensions[xu.ANISOTROPY_GLTF_EXTENSION] = n, e.extensionsUsed[xu.ANISOTROPY_GLTF_EXTENSION] = !0;
    }
  });
  var Su = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let Cu = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this._defines = {}, this._uniforms = {
        thinBaseLayerFactors: {
          value: new n.Ltg()
        },
        thinNoiseLayerFactors: {
          value: new n.Ltg()
        },
        thinColorNoiseParams: {
          value: new n.Ltg()
        },
        thinFilmFactor: {
          value: .8
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var r;
          return this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm) ? Po + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER \nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS \nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : "";
        },
        shaderExtender: (e, t, r) => {
          var n;
          if (!this.enabled || !(null === (n = t.materialObject.userData._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var r;
          const n = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._thinFilmLayer;
          if (!(null == n ? void 0 : n.hasThinFilm)) return;
          this._uniforms.thinBaseLayerFactors.value.fromArray(n.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(n.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(n.colorNoiseParams), this._uniforms.thinFilmFactor.value = n.filmFactor;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i && (t.materialObject.defines.THIN_FILM_LAYER_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: {
          ...this._uniforms
        },
        computeCacheKey: e => {
          var t, r;
          return (this.enabled ? "1" : "0") + ((null === (r = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this._viewer,
            r = {
              type: "folder",
              label: "ThinFilmLayer",
              children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                  var t;
                  return (null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm) || !1;
                },
                set value(n) {
                  var i, s;
                  n !== (null === (i = e.materialObject.userData._thinFilmLayer) || void 0 === i ? void 0 : i.hasThinFilm) && (n ? Mu(e.materialObject) || t.alert("Cannot add thin film.") : (e.materialObject.userData._thinFilmLayer.hasThinFilm = !1, e.materialObject.needsUpdate = !0), null === (s = r.uiRefresh) || void 0 === s || s.call(r, "postFrame", !0));
                },
                onChange: this.setDirty
              }, () => ({
                type: "slider",
                bounds: [0, 1],
                label: "Intensity",
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
                },
                property: [e.materialObject.userData._thinFilmLayer, "filmFactor"],
                onChange: this.setDirty
              }), () => ({
                type: "vec4",
                label: "Base Layer",
                bounds: [0, 1],
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
                },
                property: [e.materialObject.userData._thinFilmLayer, "baseLayerFactors"],
                onChange: this.setDirty
              }), () => ({
                type: "vec4",
                label: "Noise Layer",
                bounds: [0, 1],
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
                },
                property: [e.materialObject.userData._thinFilmLayer, "noiseLayerFactors"],
                onChange: this.setDirty
              }), () => ({
                type: "vec4",
                label: "Noise Params",
                bounds: [0, 1],
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
                },
                property: [e.materialObject.userData._thinFilmLayer, "colorNoiseParams"],
                onChange: this.setDirty
              })]
            };
          return r;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addThinFilmLayer(e) {
      return Mu(e.materialObject);
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Tu(e));
    }
    async onAdded(e) {
      var t, r, n, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(to);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (r = null == o ? void 0 : o.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (n = null == o ? void 0 : o.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Iu);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }
  };
  function Mu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._thinFilmLayer || (t._thinFilmLayer = {});
    const r = t._thinFilmLayer;
    return r.hasThinFilm = !0, void 0 === r.baseLayerFactors && (r.baseLayerFactors = [.3, .6, 1, .9]), void 0 === r.noiseLayerFactors && (r.noiseLayerFactors = [.7, .5, .9, .7]), void 0 === r.colorNoiseParams && (r.colorNoiseParams = [.5, .5, .5, .7]), void 0 === r.filmFactor && (r.filmFactor = .3), e.isMaterial && (e.needsUpdate = !0), !0;
  }
  Cu.PluginType = "ThinFilmLayerPlugin", Cu.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", Su([Je("Enabled", e => ({
    onChange: e.setDirty
  })), Ce()], Cu.prototype, "enabled", void 0), Cu = Su([lt("ThinFilmLayer Materials")], Cu);
  class Tu {
    constructor(e) {
      this.parser = e, this.name = Cu.THIN_FILM_LAYER_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return t.userData || (t.userData = {}), Mu(t), t.userData._thinFilmLayer = De(n, t.userData._thinFilmLayer, !1, {}), Promise.resolve();
    }
  }
  const Iu = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._thinFilmLayer) return;
      if (!t.userData._thinFilmLayer.hasThinFilm) return;
      r.extensions = r.extensions || {};
      const n = ke(t.userData._thinFilmLayer, !1);
      r.extensions[Cu.THIN_FILM_LAYER_GLTF_EXTENSION] = n, e.extensionsUsed[Cu.THIN_FILM_LAYER_GLTF_EXTENSION] = !0;
    }
  });
  var ku = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let Du = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this._defines = {}, this._uniforms = {
        noiseBumpParams: {
          value: new n.FM8()
        },
        noiseBumpScale: {
          value: .05
        },
        noiseBumpFlakeScale: {
          value: 1e3
        },
        noiseFlakeClamp: {
          value: 1
        },
        noiseFlakeRadius: {
          value: .5
        },
        noiseFlakeRoughnessMod: {
          value: 1
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var r;
          return this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump) ? Po + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER \nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform float noiseFlakeRoughnessMod;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : "";
        },
        shaderExtender: (e, t, r) => {
          var n;
          if (!this.enabled || !(null === (n = t.materialObject.userData._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "\n            vec3 outColor; \n            float voronoiDist = clamp(voronoi_f1_2d( noiseBumpFlakeScale * noiseBumpParams.xy * vUv, 1., noiseFlakeClamp, noiseFlakeRadius, outColor ), 0.0, 1.0);\n            normal = perturbNormalArb_nb( - vViewPosition, normal, (2. * outColor.xy - 1.) * noiseBumpScale, faceDirection ); \n            float avg = (outColor.r + outColor.g)*0.5; \n            diffuseColor *= (clamp(avg+0.5, 0.3, 1.));\n            float roughnessModifier = mix(1. - avg, 1., noiseFlakeRoughnessMod);\n            roughnessFactor *= roughnessModifier;\n            \n" + i), e.vertexUvs = !0, e.extensionDerivatives = !0;
        },
        onObjectRender: (e, t) => {
          var r;
          const n = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._noiseBumpMat;
          if (!(null == n ? void 0 : n.hasBump)) return;
          this._uniforms.noiseBumpParams.value.fromArray(n.bumpNoiseParams), this._uniforms.noiseBumpScale.value = n.bumpScale, this._uniforms.noiseBumpFlakeScale.value = n.flakeScale, this._uniforms.noiseFlakeClamp.value = n.flakeClamp, this._uniforms.noiseFlakeRadius.value = n.flakeRadius, this._uniforms.noiseFlakeRoughnessMod.value = n.flakeRoughnessMod;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i && (t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: {
          ...this._uniforms
        },
        computeCacheKey: e => {
          var t, r;
          return (this.enabled ? "1" : "0") + ((null === (r = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this._viewer,
            r = {
              type: "folder",
              label: "NoiseBumpMaterial",
              children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                  var t;
                  return (null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump) || !1;
                },
                set value(n) {
                  var i, s;
                  n !== (null === (i = e.materialObject.userData._noiseBumpMat) || void 0 === i ? void 0 : i.hasBump) && (n ? Pu(e.materialObject) || t.alert("Cannot add noise bump.") : (e.materialObject.userData._noiseBumpMat.hasBump = !1, e.materialObject.needsUpdate = !0), null === (s = r.uiRefresh) || void 0 === s || s.call(r, "postFrame", !0));
                },
                onChange: this.setDirty
              }, () => ({
                type: "vec4",
                label: "Bump Noise Params",
                bounds: [0, 1],
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "bumpNoiseParams"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                label: "Bump Scale",
                bounds: [0, .01],
                stepSize: 1e-5,
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "bumpScale"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                label: "Flake Scale",
                bounds: [100, 1e4],
                stepSize: 1e-4,
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "flakeScale"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                label: "Flake Clamp",
                bounds: [0, 1],
                stepSize: 1,
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "flakeClamp"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                label: "Flake Radius",
                bounds: [.1, 1],
                stepSize: .01,
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "flakeRadius"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                label: "Flake Roughness Modifier",
                bounds: [0, 1],
                stepSize: 1,
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
                },
                property: [e.materialObject.userData._noiseBumpMat, "flakeRoughnessMod"],
                onChange: this.setDirty
              })]
            };
          return r;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addNoiseBumpMaterial(e) {
      return Pu(e.materialObject);
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Bu(e));
    }
    async onAdded(e) {
      var t, r, n, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(to);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (r = null == o ? void 0 : o.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (n = null == o ? void 0 : o.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Ru);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }
  };
  function Pu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._noiseBumpMat || (t._noiseBumpMat = {});
    const r = t._noiseBumpMat;
    return r.hasBump = !0, void 0 === r.bumpNoiseParams && (r.bumpNoiseParams = [.5, .5]), void 0 === r.bumpScale && (r.bumpScale = .05), void 0 === r.flakeScale && (r.flakeScale = .05), void 0 === r.flakeClamp && (r.flakeClamp = 1), void 0 === r.flakeRadius && (r.flakeRadius = .3), void 0 === r.flakeRoughnessMod && (r.flakeRoughnessMod = 1), e.isMaterial && (e.needsUpdate = !0), !0;
  }
  Du.PluginType = "NoiseBumpMaterialPlugin", Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", ku([Je("Enabled", e => ({
    onChange: e.setDirty
  })), Ce()], Du.prototype, "enabled", void 0), Du = ku([lt("NoiseBumpMaterial Materials")], Du);
  class Bu {
    constructor(e) {
      this.parser = e, this.name = Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return t.userData || (t.userData = {}), Pu(t), t.userData._noiseBumpMat = De(n, t.userData._noiseBumpMat, !1, {}), Promise.resolve();
    }
  }
  const Ru = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._noiseBumpMat) return;
      if (!t.userData._noiseBumpMat.hasBump) return;
      r.extensions = r.extensions || {};
      const n = ke(t.userData._noiseBumpMat, !1);
      r.extensions[Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = n, e.extensionsUsed[Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = !0;
    }
  });
  var Lu,
    Ou = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Fu = Lu = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this.bicubicFiltering = !0, this._defines = {
        CUSTOM_BUMP_MAP_DEBUG: !1,
        CUSTOM_BUMP_MAP_BICUBIC: !0
      }, this._uniforms = {
        customBumpUvTransform: {
          value: new n.Vkp()
        },
        customBumpScale: {
          value: .001
        },
        customBumpMap: {
          value: null
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => this.enabled && (null == t ? void 0 : t.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "",
        shaderExtender: (e, t, r) => {
          var n;
          this.enabled && t.materialObject.userData._hasCustomBump && (null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._customBumpMap) && (e.fragmentShader = qt(e.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = qt(e.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = qt(e.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", {
            prepend: !0
          }), e.vertexUvs = !0);
        },
        onObjectRender: (e, t) => {
          var r;
          const n = t.materialObject.userData;
          if (!(null == n ? void 0 : n._hasCustomBump)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          const s = (null === (r = n._customBumpMap) || void 0 === r ? void 0 : r.isTexture) ? n._customBumpMap : null;
          this._uniforms.customBumpMap.value = s, this._uniforms.customBumpScale.value = s ? n._customBumpScale : 0, s && (s.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s.matrix));
          let o = this.enabled && s ? 1 : 0;
          t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: {
          ...this._uniforms
        },
        computeCacheKey: e => {
          var t, r, n;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._hasCustomBump) ? "1" : "0") + (null === (n = null === (r = e.materialObject.userData) || void 0 === r ? void 0 : r._customBumpMap) || void 0 === n ? void 0 : n.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this._viewer,
            r = this.enableCustomBump,
            n = {
              type: "folder",
              label: "CustomBumpMap",
              children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                  return e.materialObject.userData._hasCustomBump || !1;
                },
                set value(i) {
                  var s;
                  i !== e.materialObject.userData._hasCustomBump && (i ? r(e) || t.alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._hasCustomBump = !1, e.materialObject.needsUpdate = !0), null === (s = n.uiRefresh) || void 0 === s || s.call(n, "postFrame", !0));
                },
                onChange: this.setDirty
              }, {
                type: "slider",
                label: "Bump Scale",
                hidden: () => !e.materialObject.userData._hasCustomBump,
                property: [e.materialObject.userData, "_customBumpScale"],
                onChange: this.setDirty
              }, {
                type: "image",
                label: "Bump Map",
                hidden: () => !e.materialObject.userData._hasCustomBump,
                property: [e.materialObject.userData, "_customBumpMap"],
                onChange: () => {
                  e.materialObject.needsUpdate = !0, this.setDirty();
                }
              }, be(e.materialObject.userData, "_customBumpMap")]
            };
          return n;
        }
      }, this.setDirty = () => {
        var e, t, r;
        null === (t = (e = this.materialExtension).setDirty) || void 0 === t || t.call(e), null === (r = this._viewer) || void 0 === r || r.setDirty();
      }, this.enableCustomBumpSelected = () => {
        var e, t, r;
        const n = null === (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === r ? void 0 : r.material;
        return "material" === (null == n ? void 0 : n.assetType) && this.enableCustomBump(n);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    enableCustomBump(e, t, r) {
      var n, i;
      const s = null === (n = e.materialObject) || void 0 === n ? void 0 : n.userData;
      if (!s) return !1;
      if (void 0 === s._hasCustomBump) {
        const e = s.__appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: r
        } of e) !r || r.attributes.position && r.attributes.normal && r.attributes.uv || (t = !1);
        if (!t) return !1;
      }
      return s._hasCustomBump = !0, s._customBumpScale = null !== (i = null != r ? r : s._customBumpScale) && void 0 !== i ? i : .001, s._customBumpMap = null != t ? t : s._customBumpMap, e.materialObject.needsUpdate = !0, !0;
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Uu(e));
    }
    async onAdded(e) {
      var t, r, n, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(to);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (r = null == o ? void 0 : o.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (n = null == o ? void 0 : o.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Nu);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }
  };
  Fu.PluginType = "CustomBumpMapPlugin", Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", Ou([Je("Enabled", e => ({
    onChange: e.setDirty
  })), Ce()], Fu.prototype, "enabled", void 0), Ou([Je("Bicubic", e => ({
    onChange: e.setDirty
  })), V("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, Lu.prototype.setDirty), Ce()], Fu.prototype, "bicubicFiltering", void 0), Ou([rt("Enable CustomBumpMap", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc));
    }
  }))], Fu.prototype, "enableCustomBumpSelected", void 0), Fu = Lu = Ou([lt("CustomBumpMap Materials")], Fu);
  class Uu {
    constructor(e) {
      this.parser = e, this.name = Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      var r;
      const i = this.parser,
        s = i.json.materials[e];
      if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
      const o = [],
        a = s.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._hasCustomBump = !0, t.userData._customBumpScale = null !== (r = a.customBumpScale) && void 0 !== r ? r : 0;
      const l = a.customBumpMap;
      return l && o.push(i.assignTexture(t.userData, "_customBumpMap", l).then(e => {
        e.encoding = n.knz;
      })), Promise.all(o);
    }
  }
  const Nu = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._hasCustomBump) return;
      if ((t.userData._customBumpScale || 0) < .001) return;
      r.extensions = r.extensions || {};
      const n = {};
      if (n.customBumpScale = t.userData._customBumpScale || 1, t.userData._customBumpMap) {
        const r = {
          index: e.processTexture(t.userData._customBumpMap)
        };
        e.applyTextureTransform(r, t.userData._customBumpMap), n.customBumpMap = r;
      }
      r.extensions[Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = n, e.extensionsUsed[Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = !0;
    }
  });
  var ju = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let zu = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this._defines = {}, this._uniforms = {
        ccTintColor: {
          value: new Ae()
        },
        ccThickness: {
          value: 0
        },
        ccIor: {
          value: 0
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var r;
          return this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && t.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : "";
        },
        shaderExtender: (e, t, r) => {
          var n;
          if (!(this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) && t.materialObject.clearcoat > 0)) return;
          const i = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
            s = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
          e.fragmentShader.includes(s) && e.fragmentShader.includes(i) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e.fragmentShader = e.fragmentShader.replace(s, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e.fragmentShader = e.fragmentShader.replace(i, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var r;
          const n = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._clearcoatTint;
          if (!(null == n ? void 0 : n.enableTint)) return;
          this._uniforms.ccTintColor.value.set(n.tintColor), this._uniforms.ccThickness.value = n.thickness, this._uniforms.ccIor.value = n.ior;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i && (t.materialObject.defines.CLEARCOAT_TINT_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: {
          ...this._uniforms
        },
        computeCacheKey: e => {
          var t, r;
          return (this.enabled ? "1" : "0") + ((null === (r = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) ? "1" : "0") + (e.materialObject.clearcoat > 0 ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this._viewer,
            r = {
              type: "folder",
              label: "ClearcoatTint",
              children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                  var t;
                  return (null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint) || !1;
                },
                set value(n) {
                  var i, s;
                  n !== (null === (i = e.materialObject.userData._clearcoatTint) || void 0 === i ? void 0 : i.enableTint) && (n ? Gu(e.materialObject) || t.alert("Cannot add clearcoat tint.") : (e.materialObject.userData._clearcoatTint.enableTint = !1, e.materialObject.needsUpdate = !0), null === (s = r.uiRefresh) || void 0 === s || s.call(r, "postFrame", !0));
                },
                onChange: this.setDirty
              }, () => ({
                type: "color",
                label: "Tint color",
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
                },
                property: [e.materialObject.userData._clearcoatTint, "tintColor"],
                onChange: this.setDirty
              }), () => ({
                type: "input",
                label: "Thickness",
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
                },
                property: [e.materialObject.userData._clearcoatTint, "thickness"],
                onChange: this.setDirty
              }), () => ({
                type: "slider",
                bounds: [.8, 2.5],
                label: "IOR",
                hidden: () => {
                  var t;
                  return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
                },
                property: [e.materialObject.userData._clearcoatTint, "ior"],
                onChange: this.setDirty
              })]
            };
          return r;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addClearcoatTint(e) {
      return Gu(e.materialObject);
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Vu(e));
    }
    async onAdded(e) {
      var t, r, n, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(to);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (r = null == o ? void 0 : o.importer) || void 0 === r || r.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (n = null == o ? void 0 : o.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Qu);
    }
    async onRemove(e) {
      var t, r, n, i;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), null === (i = null === (n = e.getPlugin(to)) || void 0 === n ? void 0 : n.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }
  };
  function Gu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._clearcoatTint || (t._clearcoatTint = {});
    const r = t._clearcoatTint;
    return r.enableTint = !0, void 0 === r.tintColor && (r.tintColor = 16777215), void 0 === r.thickness && (r.thickness = .1), void 0 === r.ior && (r.ior = 1.5), e.isMaterial && (e.needsUpdate = !0), !0;
  }
  zu.PluginType = "ClearcoatTintPlugin", zu.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", ju([Je("Enabled", e => ({
    onChange: e.setDirty
  })), Ce()], zu.prototype, "enabled", void 0), zu = ju([lt("ClearcoatTint Materials")], zu);
  class Vu {
    constructor(e) {
      this.parser = e, this.name = zu.CLEARCOAT_TINT_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return t.userData || (t.userData = {}), Gu(t), t.userData._clearcoatTint = De(n, t.userData._clearcoatTint, !1, {}), Promise.resolve();
    }
  }
  const Qu = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._clearcoatTint) return;
      if (!t.userData._clearcoatTint.enableTint) return;
      r.extensions = r.extensions || {};
      const n = ke(t.userData._clearcoatTint, !1);
      r.extensions[zu.CLEARCOAT_TINT_GLTF_EXTENSION] = n, e.extensionsUsed[zu.CLEARCOAT_TINT_GLTF_EXTENSION] = !0;
    }
  });
  var Hu = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let Wu = class extends Gt {
    constructor(e, t, r) {
      super(e, t, null != r ? r : new qu(), new Ae(0, 0, 0), 1), this.enabled = !0, this._firstCall = !0;
    }
    render(e, t, r, n, i) {
      if (!this.enabled) return;
      const s = this.overrideMaterial;
      s.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value), this._firstCall = !1), super.render(e, t, r, n, i), s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value);
    }
  };
  Hu([Je("Enabled")], Wu.prototype, "enabled", void 0), Wu = Hu([lt("Velocity Buffer (TAA)")], Wu);
  class qu extends n.jyz {
    constructor() {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
        fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}",
        uniforms: {
          cameraNearFar: {
            value: new n.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          currentProjectionViewMatrix: {
            value: new n.yGw()
          },
          lastProjectionViewMatrix: {
            value: new n.yGw()
          }
        }
      }), this.extraUniformsToUpload = {
        modelMatrixPrevious: {
          value: new n.yGw().identity()
        }
      }, this._previousWorldMatrices = {};
    }
    onBeforeRender(e, t, r, i, s) {
      var o, a;
      const l = this._previousWorldMatrices[s.uuid];
      this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l ? l : s.matrixWorld), l ? l.copy(s.matrixWorld) : this._previousWorldMatrices[s.uuid] = s.matrixWorld.clone();
      let c = s.material;
      Array.isArray(c) && (c = c[0]), this.uniforms.alphaMap.value = null !== (o = null == c ? void 0 : c.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !c || !c.alphaTest || c.alphaTest < 1e-7 ? .001 : c.alphaTest;
      let u = this.uniforms.alphaMap.value ? 1 : void 0;
      u !== this.defines.USE_ALPHAMAP && (void 0 === u ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = u, this.needsUpdate = !0), u = c.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === u ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = u, this.needsUpdate = !0), this.side = null !== (a = c.side) && void 0 !== a ? a : n.ehD;
    }
  }
  class Xu extends io {
    constructor(e = !0) {
      super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e;
    }
    passCtor(e) {
      const t = e.renderer.createTarget({
        depthBuffer: !0,
        type: n.ywz
      });
      t.texture.name = "velocityBuffer", this._velocityBuffers.push(t), e.getPluginByType("debug");
      const r = new Set(),
        i = new Set();
      return new class extends Wu {
        render(n, s, o, a, l) {
          if (e.renderer.frameCount > 0) return;
          const c = n.getRenderTarget(),
            u = n.getActiveCubeFace(),
            h = n.getActiveMipmapLevel();
          this.scene.traverse(({
            material: e
          }) => {
            e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (r.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (i.add([e, e.transmission]), e.transmission = 0));
          }), W(n, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1,
            mainRenderPass: !1
          }, () => super.render(n, s, t, a, l)), r.forEach(e => e.transparent = !e.transparent), r.clear(), i.forEach(([e, t]) => e.transmission = t), i.clear(), n.setRenderTarget(c, u, h);
        }
      }();
    }
    _update(e) {
      if (!super._update(e)) return !1;
      if (e.renderer.frameCount > 0) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }
    getVelocityBuffer() {
      return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0;
    }
    async onDispose(e) {}
    async onRemove(e) {
      return this._velocityBuffers.forEach(t => {
        var r;
        return e.renderer.disposeTarget(null === (r = null == t ? void 0 : t.dispose) || void 0 === r ? void 0 : r.call(t));
      }), super.onRemove(e);
    }
    updateShaderProperties(e) {
      var t, r;
      return e.uniforms.tVelocity ? e.uniforms.tVelocity.value = this.enabled && null !== (r = null === (t = this.getVelocityBuffer()) || void 0 === t ? void 0 : t.texture) && void 0 !== r ? r : null : console.warn("BaseRenderer: no uniform: tVelocity"), this;
    }
    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }
  }
  Xu.PluginType = "VelocityBuffer";
  class Yu extends zt {
    constructor(e, t) {
      super({
        vertexShader: i.vertexShader,
        fragmentShader: t + "\n" + ko + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zx*texelSize));vec3 dtl=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.yz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.xz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);\n#if HAS_VELOCITY_BUFFER == 0\nvec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=(texture2D(tVelocity,vUv).xy*2.-1.);screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}",
        uniforms: {
          currentRT: {
            value: null
          },
          previousRT: {
            value: null
          },
          previousRTSize: {
            value: new n.FM8()
          },
          cameraNearFar: {
            value: new n.FM8()
          },
          lastProjectionViewMatrix: {
            value: new n.yGw()
          },
          currentProjectionViewMatrix: {
            value: new n.yGw()
          },
          projection: {
            value: new n.yGw()
          },
          inverseViewMatrix: {
            value: new n.yGw()
          },
          jitterSample: {
            value: new n.FM8()
          },
          firstFrame: {
            value: !0
          },
          tNormalDepth: {
            value: null
          },
          tVelocity: {
            value: null
          }
        },
        defines: {
          HAS_VELOCITY_BUFFER: 0,
          QUALITY: 1,
          UNJITTER: 0
        }
      }, "currentRT", "previousRT"), this.taaEnabled = !0, this.feedBack = new n.FM8(.88, .97), this.uiConfig = {
        type: "folder",
        label: "Temporal AA",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: () => this.onSizeUpdate()
        }, {
          type: "input",
          label: "Feedback",
          property: [this, "feedBack"],
          onChange: this.setDirty
        }]
      }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e, this.clear = !1, this.needsSwap = !0;
    }
    render(e, t, r, n, i) {
      if (!this.taaEnabled || !this.enabled) return void (this.needsSwap = !1);
      this.needsSwap = !0;
      const s = this.uniforms.tVelocity.value ? 1 : 0;
      s !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s, this.material.needsUpdate = !0), this.uniforms.previousRT.value = this.target.texture, super.render(e, t, r, n, i), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = !1;
    }
    updateCameraProperties(e) {
      e && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e.matrixWorld));
    }
    onSizeUpdate() {
      this.uniforms.firstFrame.value = !0, this.setDirty();
    }
    setSize(e, t) {
      super.setSize(e, t), this.onSizeUpdate();
    }
  }
  !function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Ce(), G()], Yu.prototype, "feedBack", void 0);
  class Ku extends io {
    constructor() {
      super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [lo];
    }
    passCtor(e) {
      if (!e.getPlugin(To)) throw "Add ProgressivePlugin before TAA";
      const t = new Yu(e.getPlugin(To).lastFrame, e.getPlugin(lo).getUnpackSnippet());
      return e.renderer.addEventListener("resize", t.onSizeUpdate), t;
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    async onDispose(e) {
      return this.pass && e.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e);
    }
    _update(e) {
      if (!super._update(e)) return !1;
      const t = e.renderer.frameCount,
        r = this._pass.passObject;
      if (r.taaEnabled = t < 1, !r.taaEnabled) return !1;
      const n = e.scene.activeCamera;
      return r.updateShaderProperties([e.getPlugin(lo), n, e.getPluginByType("VelocityBuffer")]), r.target = e.getPlugin(To).lastFrame, r.updateCameraProperties(null == n ? void 0 : n.cameraObject), !0;
    }
    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }
  }
  Ku.PluginType = "TAA";
  class Ju {
    static async GetDataUrl(e, {
      mimeType: t = "image/png",
      rect: r = {
        x: 0,
        y: 0,
        width: e.width,
        height: e.height,
        assumeClientRect: !1
      },
      displayPixelRatio: n = 1,
      scale: i = 1
    }) {
      var s, o, a;
      const l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      l.width = r.width * i * n, l.height = r.height * i * n, r.assumeClientRect && (r.x *= e.width / (n * e.clientWidth), r.y *= e.height / (n * e.clientHeight), r.width *= e.width / (n * e.clientWidth), r.height *= e.height / (n * e.clientHeight));
      const c = l.getContext("2d");
      if (!c) return console.error("snapshot: cannot create context"), "";
      const u = e.style.background || (null === (s = e.parentElement) || void 0 === s ? void 0 : s.style.background) || "";
      if (u.includes("url")) {
        const t = null === (o = /url\("(.*)"\)/gi.exec(u)) || void 0 === o ? void 0 : o[1];
        if (t) {
          const i = new Image();
          i.src = t, await new Promise((e, t) => {
            i.onload = () => e(), i.onerror = () => t(), i.complete && e();
          }), c.drawImage(i, i.width * r.x * n / e.width, i.height * r.y * n / e.height, i.width * r.width * n / e.width, i.height * r.height * n / e.height, 0, 0, l.width, l.height);
        }
      } else c.fillStyle = e.style.background || (null === (a = e.parentElement) || void 0 === a ? void 0 : a.style.backgroundColor) || "#00000000", c.fillRect(0, 0, l.width, l.height);
      null == c || c.drawImage(e, r.x * n, r.y * n, r.width * n, r.height * n, 0, 0, l.width, l.height);
      const h = c.canvas.toDataURL(t);
      return l.remove(), h;
    }
    static async GetImage(e, t = {}) {
      const r = await this.GetDataUrl(e, t);
      return new Promise((e, t) => {
        const n = new Image();
        n.onload = () => {
          e(n);
        }, n.src = r;
      });
    }
    static async GetBlob(e, t = {}) {
      return await (await fetch(await this.GetDataUrl(e, t))).blob();
    }
    static async GetFile(e, t = "image.png", r = {}) {
      var n;
      return r.getDataUrl ? await this.GetDataUrl(e, r) : new File([await this.GetBlob(e, r)], t, {
        type: null !== (n = r.mimeType) && void 0 !== n ? n : "image/png",
        lastModified: Dt()
      });
    }
  }
  var Zu = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let $u = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.downloadSnapshot = this.downloadSnapshot.bind(this);
    }
    async getFile(e, t = {}) {
      return t.getDataUrl = !1, await this._getFile(e, t);
    }
    async getDataUrl(e = {}) {
      var t;
      return e.getDataUrl = !0, null !== (t = await this._getFile("", e)) && void 0 !== t ? t : "";
    }
    async _getFile(e, t = {}) {
      var r, n, i;
      const s = null === (r = this._viewer) || void 0 === r ? void 0 : r.canvas;
      if (s) {
        const r = this._viewer.renderer.displayCanvasScaling;
        void 0 !== t.displayPixelRatio && t.displayPixelRatio !== r && (this._viewer.renderer.displayCanvasScaling = t.displayPixelRatio);
        const o = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPlugin(To);
        if (t.waitForProgressive && o && void 0 === t.timeout) for (; !o.isConverged(!0);) await Dc(64);else await Dc(null !== (i = t.timeout) && void 0 !== i ? i : 200);
        t.displayPixelRatio = 1;
        const a = await Ju.GetFile(s, e, t);
        return t.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = r, a;
      }
    }
    async downloadSnapshot(e = "snapshot.png", t = {}) {
      const r = await this.getFile(e, t);
      r && wt(r);
    }
  };
  $u.PluginType = "CanvasSnipper", Zu([rt("Download .png", {
    limitedUi: !0
  })], $u.prototype, "downloadSnapshot", null), $u = Zu([lt("Image Export")], $u);
  var eh = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let th = 1,
    rh = class {
      constructor(e, t, r, i, s) {
        this.position = new n.Pa4(), this.target = new n.Pa4(), this.quaternion = new n._fP(), this.up = new n.Pa4(), this.name = "Camera View", this.snap = "", this.focusView = () => {}, this.deleteView = () => {}, this.uiConfig = at(this.name, this), e && (this.position = e), t && (this.target = t), r && (this.up = r), i && (this.quaternion = i), s && (this.snap = s), this.name = "Camera View" + th++;
      }
      _nameChanged() {
        var e, t;
        this.uiConfig && (this.uiConfig.label = this.name, null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
      }
    };
  eh([Ce(), et()], rh.prototype, "position", void 0), eh([Ce(), et()], rh.prototype, "target", void 0), eh([Ce(), et()], rh.prototype, "quaternion", void 0), eh([Ce(), et()], rh.prototype, "up", void 0), eh([Ce(), nt()], rh.prototype, "name", void 0), eh([st()], rh.prototype, "snap", void 0), eh([rt()], rh.prototype, "focusView", void 0), eh([rt()], rh.prototype, "deleteView", void 0), rh = eh([Be("CameraView")], rh);
  class nh extends ro {
    constructor() {
      super(), this.enabled = !0, this._cameraViews = [], this.viewLooping = !1, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = .25, this.interpolateMode = "spherical", this.animateOnScroll = !1, this.seekOnScroll = !1, this._animating = !1, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = !1, this._viewQueue = [], this._animationLooping = !1, this._infiniteLooping = !0, this._driver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.focusNext = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2) return;
        let t = this._cameraViews.findIndex(e => e === this._currentView);
        t < 0 && (t = -1), t += 1, e ? t %= this._cameraViews.length : t = Math.min(t, this._cameraViews.length - 1), this.focusView(this._cameraViews[t]);
      }, this.focusPrevious = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2 || !this._currentView) return;
        let t = this._cameraViews.findIndex(e => e === this._currentView);
        t < 0 && (t = 0), t -= 1, t = e ? (t + this._cameraViews.length) % this._cameraViews.length : Math.max(t, 0), this.focusView(this._cameraViews[t]);
      }, this._popAnimations = [], this.uiConfig = {
        type: "folder",
        label: "Camera Views",
        children: [() => [...this._cameraViews.map(e => e.uiConfig)], ...ot(this)]
      }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this);
    }
    get animationLooping() {
      return this._animationLooping;
    }
    get animating() {
      return this._animating;
    }
    get camViews() {
      return this._cameraViews;
    }
    _wheel(e) {
      this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e.deltaY) > .001 && (this._scrollAnimationState = -1 * Math.sign(e.deltaY)));
    }
    _pointerMove(e) {
      var t;
      if (this.enabled && !this._animating && this.seekOnScroll) {
        const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera;
        if (!r) return;
        const i = new n.$V(),
          s = r.position,
          o = r.target,
          a = new n._fP().setFromUnitVectors(r.cameraObject.up, new n.Pa4(0, 1, 0)),
          l = a.clone().invert(),
          c = s.clone().sub(o);
        c.applyQuaternion(a), i.setFromVector3(c), i.theta += this.rotationOffset * e.movementX / this._viewer.canvas.clientWidth, i.phi += this.rotationOffset * e.movementY / this._viewer.canvas.clientHeight, i.makeSafe(), c.setFromSpherical(i), c.applyQuaternion(l), s.copy(o).add(c), r.positionUpdated(!1), r.targetUpdated();
      }
    }
    async onAdded(e) {
      await super.onAdded(e);
      let t = !1;
      e.addEventListener("preFrame", e => {
        this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.interactionsEnabled && (this._viewer.scene.activeCamera.interactionsEnabled = !1, t = !0) : t && (this._viewer.scene.activeCamera.interactionsEnabled = !0, t = !1);
      }), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove);
    }
    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      if (!this.enabled || !this._animating) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(nh.PluginType), this._fadeDisabled = !1));
      const r = Dt() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = r - 1 / 60);
      let n = r - this._lastFrameTime;
      this._lastFrameTime = r, n *= this.animateOnScroll ? this._scrollAnimationState : 1;
      const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
      if (i && i > 0 && (n = i), 0 !== i && (n *= 1e3, !(n <= 0 || (this._updaters.forEach(e => {
        let t = n;
        e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
      }), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
        const e = this._viewer.getPluginByType("FrameFade");
        e && (e.disable(nh.PluginType), this._fadeDisabled = !0);
      }
    }
    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e);
    }
    async _animationLoop() {
      if (!this._animationLooping) {
        for (this._animationLooping = !0; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1);) {
          if (0 === this._viewQueue.length) {
            if (!this._infiniteLooping) break;
            this._viewQueue.push(...this._cameraViews);
          }
          await this.animateToView(this._viewQueue.shift()), await Dc(2 + this.viewPauseTime);
        }
        this._animationLooping = !1;
      }
    }
    async animateAllViews() {
      if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
        for (; this._viewQueue.length > 0;) this._viewQueue.pop();
        this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = !1, await this._animationLoop(), this._infiniteLooping = !0;
      }
    }
    async resetToFirstView(e = 100) {
      this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e), await Dc(2));
    }
    async recordAllViews(e) {
      var t;
      if (!this.enabled) return;
      const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("CanvasRecorder");
      return r && r.enabled && (await this.resetToFirstView(), r.startRecording()) ? new Promise((t, n) => {
        const i = () => {
            r.removeEventListener("start", s), r.removeEventListener("stop", i), r.removeEventListener("error", o);
          },
          s = async () => {
            i(), null == e || e(), await this.animateAllViews();
            const n = await r.stopRecording();
            n && yt(n, "recording.mp4"), t();
          },
          o = async () => {
            i(), n();
          };
        r.addEventListener("start", s), r.addEventListener("stop", i), r.addEventListener("error", o);
      }) : void 0;
    }
    async addCurrentView() {
      var e, t, r, n, i;
      if (!this.enabled) return;
      const s = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera;
      if (!s) return;
      const o = this.getCurrentCameraView(s);
      o.snap = (await (null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin($u)) || void 0 === r ? void 0 : r.getDataUrl({
        displayPixelRatio: .25,
        mimeType: "image/jpg"
      }))) || "", this._cameraViews.push(o), null === (i = (n = this.uiConfig).uiRefresh) || void 0 === i || i.call(n);
    }
    getCurrentCameraView(e) {
      var t;
      if (e || (e = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera), !e) return new rh();
      const r = new n.Pa4(),
        i = e.cameraObject.matrixWorld;
      r.x = i.elements[4], r.y = i.elements[5], r.z = i.elements[6];
      const s = new rh(e.position.clone(), e.target.clone(), r.normalize(), e.cameraObject.quaternion.clone(), "");
      return s.focusView = async () => this.focusView(s), s.deleteView = () => this.deleteView(s), s;
    }
    async focusView(e) {
      return this.animateToView(e);
    }
    deleteView(e) {
      var t, r;
      const n = this._cameraViews.indexOf(e);
      n >= 0 && this._cameraViews.splice(n, 1), null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t);
    }
    async stopAllAnimations() {
      for (this.viewLooping = !1, this._popAnimations.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e);
      }), this._popAnimations = []; this._animating || this._animationLooping;) await Dc(100);
    }
    async animateToView(e, t, r) {
      var i;
      const s = null === (i = this._viewer) || void 0 === i ? void 0 : i.scene.activeCamera;
      if (!s) return;
      if (this._animating && (this._popAnimations.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e);
      }), await Dc(100), this._animating)) return void console.warn("todo: still animating?");
      this._currentView = e, this._animating = !0, this.dispatchEvent({
        type: "startViewChange",
        view: e
      }), void 0 === t && (t = this.animDuration);
      const o = "function" == typeof r ? r : kc[r || this.animEase],
        a = this._driver,
        l = [];
      this._popAnimations = [];
      const c = this._popAnimations;
      if ("spherical" === this.interpolateMode) l.push(async function (e, t, r, i, s, o) {
        const a = e.target.clone(),
          l = new n.Pa4(),
          c = new n.Pa4(),
          u = sh(e.cameraObject, a),
          h = sh(t, t.target),
          p = new n.$V();
        return ih({
          from: 0,
          to: 1,
          duration: r,
          ease: i,
          driver: s,
          onUpdate: r => {
            p.phi = oh(u.phi, h.phi, r), p.theta = oh(u.theta, h.theta, r), p.radius = te(u.radius, h.radius, r), l.copy(a).lerp(t.target, r), c.setFromSpherical(p), c.add(l), e.position = c, e.target = l, e.positionUpdated(!1), e.targetUpdated();
          },
          onComplete: () => {
            e.position = t.position, e.target = t.target, e.positionUpdated(!1), e.targetUpdated();
          }
        }, o);
      }(s, e, t, o, a, c));else if ("linear" === this.interpolateMode) {
        l.push(ih({
          from: s.position.clone(),
          to: e.position.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => s.position = e,
          onComplete: () => s.position = e.position
        }, c)), l.push(ih({
          from: s.target.clone(),
          to: e.target.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => {
            s.target = e, s.targetUpdated();
          },
          onComplete: () => {
            s.target = e.target, s.targetUpdated();
          }
        }, c));
        const r = s.cameraObject.quaternion.clone(),
          i = new n._fP();
        l.push(ih({
          from: 0,
          to: 1,
          duration: t,
          ease: o,
          driver: a,
          onUpdate: t => {
            i.copy(r).slerp(e.quaternion, t), s.cameraObject.quaternion.copy(i), s.cameraObject.updateProjectionMatrix();
          },
          onComplete: () => {
            s.cameraObject.quaternion.copy(e.quaternion), s.cameraObject.updateProjectionMatrix();
          }
        }, c));
      }
      await Promise.all(l), this._animating = !1, this.dispatchEvent({
        type: "viewChange",
        view: e
      }), await Dc(10);
    }
    fromJSON(e, t) {
      var r, n;
      return this._cameraViews.forEach(e => this.deleteView(e)), super.fromJSON(e, t) ? (this._cameraViews.forEach(e => e.focusView = async () => this.focusView(e)), this._cameraViews.forEach(e => e.deleteView = () => this.deleteView(e)), null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r), this) : null;
    }
    async animateToObject(e, t = 4, r, i, s = {
      min: .5,
      max: 5
    }) {
      if (!this._viewer) return;
      const o = new k().expandByObject(e || this._viewer.scene.modelRoot.modelObject, !1, !0),
        a = o.getCenter(new n.Pa4()),
        l = o.getSize(new n.Pa4()).length() / 2;
      await this.animateToTarget(Math.min(s.max, Math.max(s.min, l * t)), a, r, i);
    }
    async animateToTarget(e, t, r, i) {
      const s = this.getCurrentCameraView();
      s.target.copy(t);
      const o = new n.Pa4().subVectors(s.target, s.position).normalize();
      s.position.copy(o.multiplyScalar(-e).add(s.target)), await this.animateToView(s, r, i);
    }
  }
  async function ih(e, t) {
    const r = e.onComplete,
      n = e.onStop;
    return e = {
      ...e
    }, new Promise((i, s) => {
      e.onComplete = () => {
        null == r || r(), i();
      }, e.onStop = () => {
        null == n || n(), i();
      };
      const o = Ic(e);
      t.push(o);
    });
  }
  function sh(e, t) {
    const r = e.position.clone();
    r.sub(t);
    const i = new n.$V().setFromVector3(r);
    return i.makeSafe(), i;
  }
  function oh(e, t, r) {
    const n = t - e;
    return n >= Math.PI ? e + (n - 2 * Math.PI) * r : n <= -Math.PI ? e + (n + 2 * Math.PI) * r : e + n * r;
  }
  function ah(e, t, r) {
    const n = (1 - r) * Math.cos(e) + r * Math.cos(t),
      i = (1 - r) * Math.sin(e) + r * Math.sin(t);
    return Math.atan2(i, n);
  }
  nh.PluginType = "CameraViews", eh([Ce("cameraViews")], nh.prototype, "_cameraViews", void 0), eh([M(nh.prototype._animationLoop), Ce(), Je("Loop All Views", {
    limitedUi: !0
  })], nh.prototype, "viewLooping", void 0), eh([Ce(), nt("View Pause Time")], nh.prototype, "viewPauseTime", void 0), eh([Ce(), tt("Ease", Object.keys(kc).map(e => ({
    label: e
  })))], nh.prototype, "animEase", void 0), eh([Ce(), $e("Duration", [10, 1e4], 10, {
    limitedUi: !0
  })], nh.prototype, "animDuration", void 0), eh([Ce(), $e("RotationOffset", [.2, .75], .01)], nh.prototype, "rotationOffset", void 0), eh([Ce(), tt("Interpolation", ["spherical", "linear"].map(e => ({
    label: e
  })))], nh.prototype, "interpolateMode", void 0), eh([Je(), Ce()], nh.prototype, "seekOnScroll", void 0), eh([rt("Animate All Views", {
    limitedUi: !0
  })], nh.prototype, "animateAllViews", null), eh([rt("Record All Views")], nh.prototype, "recordAllViews", null), eh([rt("Add Current View")], nh.prototype, "addCurrentView", null), eh([rt("Focus Next")], nh.prototype, "focusNext", void 0), eh([rt("Focus Previous")], nh.prototype, "focusPrevious", void 0);
  const lh = new n.Pa4();
  function ch(e, t, r) {
    let n = e.dot(t);
    n = Math.min(Math.max(n, -1), 1);
    const i = Math.acos(n) * r;
    return lh.copy(e).multiplyScalar(n).sub(t).negate().normalize(), e.multiplyScalar(Math.cos(i)).add(lh.multiplyScalar(Math.sin(i)));
  }
  var uh = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class hh extends ro {
    constructor(e = !0) {
      super(), this.enabled = !0, this.light = new su("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
        var e, t, r;
        if (!this.enabled) return void (this.light.layers.mask = 0);
        const n = null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) && void 0 !== t ? t : 0;
        (n < 1 || n > 5) && this.light.randomizePosition(n < 5 ? 0 : n), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (r = this._cameraHelper) || void 0 === r || r.update();
      }, this._setDirty = this._setDirty.bind(this), this.enabled = e;
    }
    get cameraHelper() {
      return this._cameraHelper;
    }
    async onAdded(e) {
      await super.onAdded(e), this._cameraHelper = new n.Rki(this.light.shadow.camera), this._cameraHelper.visible = !1, this._cameraHelper.userData.bboxVisible = !1, e.scene.add(this._cameraHelper), e.scene.addLight(this.light, {
        addToRoot: !0
      }), e.addEventListener("preRender", this._preRender);
    }
    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e);
    }
    _setDirty(e = !1) {
      var t, r;
      e ? null === (t = this._viewer) || void 0 === t || t.scene.setDirty() : null === (r = this._viewer) || void 0 === r || r.setDirty();
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Progressive Shadow",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: this._setDirty
        }, {
          type: "folder",
          label: "Directional Light",
          children: [{
            type: "checkbox",
            label: "Visible",
            property: [this.light, "visible"],
            onChange: this._setDirty
          }, {
            type: "slider",
            label: "Intensity",
            bounds: [0, 10],
            property: [this.light, "intensity"],
            onChange: this._setDirty
          }, {
            type: "color",
            label: "Color",
            property: [this.light, "color"],
            onChange: this._setDirty
          }, {
            type: "checkbox",
            label: "Shadow Enabled",
            property: [this.light.shadowParams, "enabled"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "focus"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "spread"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 60],
            property: [this.light.randomParams, "distanceScale"],
            onChange: this._setDirty
          }, {
            type: "vec3",
            bounds: [-5, 5],
            property: [this.light.randomParams, "direction"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 10],
            property: [this.light.shadowParams, "radius"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [.01, 30],
            property: [this.light.shadowParams, "frustumSize"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [-.01, .01],
            property: [this.light.shadowParams, "bias"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }]
        }]
      };
    }
  }
  hh.PluginType = "RandomizedDirectionalLight", uh([Ce()], hh.prototype, "enabled", void 0), uh([Ce("rdLight")], hh.prototype, "light", void 0), uh([Ce()], hh.prototype, "lightLayers", void 0);
  var ph,
    dh = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let fh = ph = class extends ro {
    constructor(e = !1) {
      super(), this.enabled = !1, this.worldRadius = 100, this.tripodHeight = 10, this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e;
    }
    _paramsChanged() {
      var e, t, r, i, s, o, a, l, c, u, h;
      const p = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0);
      if (this.enabled && p && p !== vo) if (p.isDataTexture) p.mapping = n.dSO;else if (confirm("Background must be same as environment, do you want to change it?")) {
        const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SimpleBackgroundEnvUiPlugin1");
        e ? (e.envmapBg = !0, null === (i = (r = e.uiConfig).uiRefresh) || void 0 === i || i.call(r, "postFrame", !0)) : null === (s = this._viewer) || void 0 === s || s.setBackground(vo);
      } else this.enabled = !1;
      const d = null === (c = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.renderer) || void 0 === a ? void 0 : a.rendererObject) || void 0 === l ? void 0 : l.background.getBoxMesh2()) || void 0 === c ? void 0 : c.material,
        f = null !== (u = null == d ? void 0 : d.uniforms) && void 0 !== u ? u : n.Vj0.cube.uniforms;
      f.tripodHeight || (f.tripodHeight = {
        value: 1
      }), f.worldRadius || (f.worldRadius = {
        value: 1
      }), f.tripodHeight.value = this.tripodHeight, f.worldRadius.value = this.worldRadius, d && (!this.enabled && d.defines.HDRi_GROUND_PROJ ? delete d.defines.HDRi_GROUND_PROJ : this.enabled && (d.defines.HDRi_GROUND_PROJ = "1"), d.needsUpdate = !0), null === (h = this._viewer) || void 0 === h || h.setDirty();
    }
    async onAdded(e) {
      var t, r, i;
      await super.onAdded(e), (null === (i = null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer) || void 0 === r ? void 0 : r.rendererObject) || void 0 === i ? void 0 : i.background.getBoxMesh()) && console.error("HDRi Ground Plugin must be added before setting any cube or env map"), n.Vj0.cube.fragmentShader = n.Vj0.cube.fragmentShader.replace("void main() {", "\n#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF  1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,vec3(0.,0.,0.),worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n\nvoid main() {"), n.Vj0.cube.fragmentShader = n.Vj0.cube.fragmentShader.replace("vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n"), e.scene.addEventListener("environmentChanged", this._paramsChanged);
    }
  };
  fh.PluginType = "HDRiGroundPlugin", dh([Ce(), M(ph.prototype._paramsChanged), Je("Enabled")], fh.prototype, "enabled", void 0), dh([Ce(), M(ph.prototype._paramsChanged), $e("World Radius", [1, 1e3])], fh.prototype, "worldRadius", void 0), dh([Ce(), M(ph.prototype._paramsChanged), $e("Tripod height", [0, 50])], fh.prototype, "tripodHeight", void 0), fh = ph = dh([lt("HDRi Ground")], fh);
  var mh = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const _h = {
      uniforms: {
        colorTexture: {
          value: null
        },
        tNormalDepth: {
          value: null
        },
        blurTexture: {
          value: null
        },
        cocTexture: {
          value: null
        },
        cocTextureSize: {
          value: new n.FM8()
        },
        cameraNearFar: {
          value: new n.FM8()
        }
      },
      vertexShader: Io,
      fragmentShader: Ht + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}"
    },
    gh = (jt({
      uniforms: {
        cocTexture: {
          value: null
        },
        colorTexture: {
          value: null
        },
        colorTextureSize: {
          value: new n.FM8()
        },
        direction: {
          value: new n.FM8()
        }
      },
      vertexShader: Io,
      fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}"
    }, "colorTexture", "cocTexture"), jt({
      uniforms: {
        colorTexture: {
          value: null
        },
        colorTextureSize: {
          value: new n.FM8()
        },
        direction: {
          value: new n.FM8()
        },
        frameCount: {
          value: 0
        },
        blurRadius: {
          value: 16
        }
      },
      vertexShader: Io,
      fragmentShader: Po + "\n" + uu + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(saturate(colorSum),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}",
      defines: {
        DOF_MODE: 1
      }
    }, "colorTexture"));
  class vh extends zt {
    constructor() {
      super(_h, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = gh, this.nearFarBlurScale = new n.FM8(.25, .25), this.focalDepthRange = new n.FM8(.5, 1.5), this.crossCenter = new n.FM8(.5, .5), this.crossRadius = .04, this.crossAlpha = 1, this.crossColor = new Ae(16750848), this.uiConfig = {
        type: "folder",
        label: "Depth of Field",
        children: [{
          type: "checkbox",
          label: "Enabled",
          limitedUi: !0,
          property: [this, "enabled"]
        }, {
          type: "slider",
          label: "Depth Range",
          bounds: [.5, 3],
          property: [this.focalDepthRange, "y"]
        }, {
          type: "slider",
          label: "Near Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "x"]
        }, {
          type: "slider",
          label: "Far Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "y"]
        }]
      }, this.material.extensions.derivatives = !0, this.computeCocMaterial = jt({
        uniforms: {
          colorTexture: {
            value: null
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          cameraNearFar: this.uniforms.cameraNearFar,
          nearFarBlurScale: this.uniforms.nearFarBlurScale,
          focalDepthRange: this.uniforms.focalDepthRange
        },
        vertexShader: Io,
        fragmentShader: Ht + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture"), this.expandCocMaterial = jt({
        uniforms: {
          colorTexture: {
            value: null
          },
          colorTextureSize: {
            value: new n.FM8()
          },
          direction: {
            value: new n.FM8()
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          nearFarBlurScale: this.uniforms.nearFarBlurScale
        },
        vertexShader: Io,
        fragmentShader: Ht + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture");
    }
    render(e, t, r, i, s) {
      if (!this.enabled) return;
      const o = e.baseRenderer,
        a = {
          minFilter: n.TyD,
          magFilter: n.TyD,
          type: n.cLu,
          encoding: n.rnI,
          sizeMultiplier: .5,
          isAntialiased: !1,
          format: n.wk1,
          depthBuffer: !1,
          generateMipmaps: !1
        },
        l = o.getTempTarget(a),
        c = o.getTempTarget(a);
      if (this.computeCocMaterial.uniforms.colorTexture.value = r.texture, o.blit(void 0, l, {
        material: this.computeCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = l.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, c, {
        material: this.expandCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = c.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, l, {
        material: this.expandCocMaterial
      }), this.dofBlurMaterial.uniforms.frameCount) this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, o.blit(void 0, c, {
        material: this.dofBlurMaterial
      });else {
        const e = o.getTempTarget(a);
        this.dofBlurMaterial.uniforms.cocTexture.value = l.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, e, {
          material: this.dofBlurMaterial
        }), this.dofBlurMaterial.uniforms.colorTexture.value = e.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, c, {
          material: this.dofBlurMaterial
        }), o.releaseTempTarget(e);
      }
      this.material.uniforms.blurTexture.value = c.texture, this.material.uniforms.cocTexture.value = l.texture, super.render(e, t, r, i, s), o.releaseTempTarget(l), o.releaseTempTarget(c);
    }
  }
  mh([Ce(), G()], vh.prototype, "nearFarBlurScale", void 0), mh([Ce(), G()], vh.prototype, "focalDepthRange", void 0), mh([G()], vh.prototype, "crossCenter", void 0), mh([G()], vh.prototype, "crossRadius", void 0), mh([G()], vh.prototype, "crossAlpha", void 0), mh([G()], vh.prototype, "crossColor", void 0);
  var Ah = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class bh extends io {
    constructor(e = !0, t = !1) {
      super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [lo], this.enableEdit = !1, this._focalPointHit = new n.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new n.Pa4(), this.enabled = e, this.enableEdit = t, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this);
    }
    passCtor(e) {
      return new vh();
    }
    setFocalPoint(e, t = !0, r = !1) {
      var n, i;
      this._focalPointHit.copy(e), t && (null === (i = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPlugin(Oc)) || void 0 === i || i.startTransition(this._frameFadeTime)), r && (this._focalPointHitTime = Dt()), this.setDirty();
    }
    getFocalPoint() {
      return this._focalPointHit;
    }
    get depthRange() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.focalDepthRange.y) && void 0 !== t ? t : 0;
    }
    set depthRange(e) {
      this.pass && (this.pass.passObject.focalDepthRange.y = e), this.setDirty();
    }
    get nearBlurScale() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.nearFarBlurScale.x) && void 0 !== t ? t : 0;
    }
    set nearBlurScale(e) {
      this.pass && (this.pass.passObject.nearFarBlurScale.x = e), this.setDirty();
    }
    get farBlurScale() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.nearFarBlurScale.y) && void 0 !== t ? t : 0;
    }
    set farBlurScale(e) {
      this.pass && (this.pass.passObject.nearFarBlurScale.y = e), this.setDirty();
    }
    get _frameFadeTime() {
      return 2.5 * this.crossFadeTime;
    }
    _onObjectHit(e) {
      var t, r;
      this._pass && e.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e.intersects.intersect.point), this._focalPointHitTime = e.time, e.intersects.selectedObject = null, null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Oc)) || void 0 === r || r.startTransition(this._frameFadeTime), this.setDirty());
    }
    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("hitObject", this._onObjectHit);
    }
    async onRemove(e) {
      var t;
      return null === (t = e.getPluginByType("Picking")) || void 0 === t || t.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e);
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    _update(e) {
      var t, r;
      if (!super._update(e)) return !1;
      const i = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      if (!i) return !1;
      const s = e.getPlugin(lo);
      null == s || s.updateShaderProperties(i.material), i.dofBlurMaterial.uniforms.frameCount && (null === (r = e.renderer) || void 0 === r || r.updateShaderProperties(i.dofBlurMaterial));
      const o = e.scene.activeCamera;
      if (!o) return !1;
      o.cameraObject.updateMatrixWorld(!0), o.updateShaderProperties(i.material), this._tempVec.subVectors(this._focalPointHit, o.cameraObject.position), i.focalDepthRange.x = this._tempVec.length(), i.focalDepthRange.x *= o.cameraObject.getWorldDirection(new n.Pa4()).dot(this._tempVec.normalize());
      let a = (Dt() - this._focalPointHitTime) / this.crossFadeTime;
      if (a = 1 - Math.min(1, Math.max(0, a)), Math.abs(a - i.crossAlpha) > .01 && (i.crossAlpha = a, this.setDirty()), a > 0) {
        const e = this._tempVec.copy(this._focalPointHit).project(o.cameraObject).addScalar(1).divideScalar(2);
        i.crossCenter.set(e.x, e.y), i.computeCocMaterial.uniformsNeedUpdate = !0, i.expandCocMaterial.uniformsNeedUpdate = !0;
      }
      return !0;
    }
    get uiConfig() {
      var e, t, r, n, i;
      if (this._uiConfig) return this._uiConfig;
      const s = null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
      return s ? (null === (n = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => A(e))) || void 0 === n || n.flat(2).forEach(e => e && (e.onChange = this.setDirty)), null === (i = s.children) || void 0 === i || i.push({
        type: "checkbox",
        label: "Enable Edit",
        limitedUi: !0,
        property: [this, "enableEdit"]
      }), this._uiConfig = s, s) : {};
    }
  }
  bh.PluginType = "DepthOfField", Ah([Ce()], bh.prototype, "enableEdit", void 0), Ah([Ce("focalPoint")], bh.prototype, "_focalPointHit", void 0), Ah([Ce()], bh.prototype, "crossFadeTime", void 0);
  var yh,
    xh = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let wh = yh = class extends ro {
    constructor(e = !0) {
      super(), this.enabled = !0, this.radius = .015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = !1, this.stepCount = 2, this.dependencies = [lo, to], this.materialExtension = {
        shaderExtender: (e, t, r) => {
          if (!e.defines.SSCS_ENABLED) return;
          const i = w`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `,
            s = `\n#if SSCS_ENABLED\n\n    uniform float sscsIntensity;\n    uniform float sscsRadius;\n    uniform float sscsTolerance;\n\n    ${Do}\n    \n    #define THREE_PACKING_INCLUDED\n    ${ko}\n    \n    ${Ht}\n    ${Po}\n    \n    ${Ro}\n\n#endif\n            \n            ` + n.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${i}\n`).replace("return shadow;", "return min(shadow, state.z);");
          e.fragmentShader = e.fragmentShader.replace("#include <shadowmap_pars_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;").replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ], directLight.direction ) : 1.0;");
        },
        onObjectRender: (e, t, r) => {
          var n;
          const i = t.materialObject;
          let s = this.enabled && !1 !== r.userData.screenSpaceRendering && !(null === (n = i.userData) || void 0 === n ? void 0 : n.sscsDisabled) ? 1 : 0;
          i.defines.SSCS_ENABLED !== s && (i.defines.SSCS_ENABLED = s, i.needsUpdate = !0), s = this._defines.SSCS_STEP_COUNT, i.defines.SSCS_STEP_COUNT !== s && (i.defines.SSCS_STEP_COUNT = s, i.needsUpdate = !0), s = +this._defines.SSCS_DEBUG, i.defines.SSCS_DEBUG !== s && (i.defines.SSCS_DEBUG = s, i.needsUpdate = !0);
        },
        parsFragmentSnippet: () => "\n",
        extraUniforms: {
          ...yh._uniforms
        },
        computeCacheKey: e => this.enabled ? "1" : "0",
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e, t, r, n, i;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(lo), null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(To), null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.activeCamera, null === (n = this._viewer) || void 0 === n ? void 0 : n.renderer, null === (i = this._viewer) || void 0 === i ? void 0 : i.scene];
        }
      }, this.enabled = e, this.userData = {
        setDirty: () => {
          var e;
          null === (e = this._viewer) || void 0 === e || e.setDirty();
        }
      };
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.registerMaterialExtension(this.materialExtension);
    }
    async onRemove(e) {
      var t, r;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this.materialExtension), super.onRemove(e);
    }
  };
  wh.PluginType = "SSContactShadows", wh._uniforms = {
    tNormalDepth: {
      value: null
    },
    frameCount: {
      value: 0
    },
    projection: {
      value: new n.yGw()
    },
    cameraPositionWorld: {
      value: new n.Pa4()
    },
    cameraNearFar: {
      value: new n.FM8(.1, 1e3)
    },
    sceneBoundingRadius: {
      value: 0
    }
  }, xh([Je("Enabled"), Ce()], wh.prototype, "enabled", void 0), xh([G({
    uniforms: yh._uniforms,
    propKey: "sscsRadius"
  }), $e("Radius", [1e-4, .1], 1e-4), Ce()], wh.prototype, "radius", void 0), xh([G({
    uniforms: yh._uniforms,
    propKey: "sscsIntensity"
  }), $e("Intensity", [1e-4, 1], 1e-4), Ce()], wh.prototype, "intensity", void 0), xh([G({
    uniforms: yh._uniforms,
    propKey: "sscsTolerance"
  }), $e("Tolerance", [.1, 5]), Ce()], wh.prototype, "tolerance", void 0), xh([V("SSCS_DEBUG", void 0, !0), Je("Debug only SSCS"), Ce()], wh.prototype, "onlySSCSDebug", void 0), xh([V("SSCS_STEP_COUNT", void 0, !0), $e("Step count", [1, 8], 1), Ce()], wh.prototype, "stepCount", void 0), wh = yh = xh([lt("Screen Space Contact Shadows")], wh);
  class Eh {
    constructor(e = 4) {
      this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }
    _initWorker(e) {
      if (!this.workers[e]) {
        const t = this.workerCreator();
        t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
      }
    }
    _getIdleWorker() {
      for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;
      return -1;
    }
    _onMessage(e, t) {
      const r = this.workersResolve[e];
      if (r && r(t), this.queue.length) {
        const {
          resolve: t,
          msg: r,
          transfer: n
        } = this.queue.shift();
        this.workersResolve[e] = t, this.workers[e].postMessage(r, n);
      } else this.workerStatus ^= 1 << e;
    }
    setWorkerCreator(e) {
      this.workerCreator = e;
    }
    setWorkerLimit(e) {
      this.pool = e;
    }
    postMessage(e, t) {
      return new Promise(r => {
        const n = this._getIdleWorker();
        -1 !== n ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = r, this.workers[n].postMessage(e, t)) : this.queue.push({
          resolve: r,
          msg: e,
          transfer: t
        });
      });
    }
    dispose() {
      this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }
  }
  class Sh {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }
  }
  class Ch {
    constructor(e, t, r, n) {
      this._dataView = new DataView(e.buffer, e.byteOffset + t, r), this._littleEndian = n, this._offset = 0;
    }
    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);
      return this._offset += 1, e;
    }
    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e;
    }
    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e;
    }
    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e;
    }
    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e;
    }
    _skip(e) {
      return this._offset += e, this;
    }
    _scan(e, t = 0) {
      const r = this._offset;
      let n = 0;
      for (; this._dataView.getUint8(this._offset) !== t && n < e;) n++, this._offset++;
      return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r, n);
    }
  }
  new Uint8Array([0]);
  const Mh = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function Th(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }
  let Ih, kh, Dh;
  const Ph = {
    env: {
      emscripten_notify_memory_growth: function (e) {
        Dh = new Uint8Array(kh.exports.memory.buffer);
      }
    }
  };
  class Bh {
    init() {
      return Ih || (Ih = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + Rh).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, Ph)).then(this._init) : WebAssembly.instantiate(Buffer.from(Rh, "base64"), Ph).then(this._init), Ih);
    }
    _init(e) {
      kh = e.instance, Ph.env.emscripten_notify_memory_growth(0);
    }
    decode(e, t = 0) {
      if (!kh) throw new Error("ZSTDDecoder: Await .init() before decoding.");
      const r = e.byteLength,
        n = kh.exports.malloc(r);
      Dh.set(e, n), t = t || Number(kh.exports.ZSTD_findDecompressedSize(n, r));
      const i = kh.exports.malloc(t),
        s = kh.exports.ZSTD_decompress(i, t, n, r),
        o = Dh.slice(i, i + s);
      return kh.exports.free(n), kh.exports.free(i), o;
    }
  }
  const Rh = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",
    Lh = new WeakMap();
  let Oh,
    Fh = 0;
  class Uh extends n.aNw {
    constructor(e) {
      super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Eh(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
    setTranscoderPath(e) {
      return this.transcoderPath = e, this;
    }
    setWorkerLimit(e) {
      return this.workerPool.setWorkerLimit(e), this;
    }
    detectSupport(e) {
      return this.workerConfig = {
        astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this;
    }
    init() {
      if (!this.transcoderPending) {
        const e = new n.hH6(this.manager);
        e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
        const t = e.loadAsync("basis_transcoder.js"),
          r = new n.hH6(this.manager);
        r.setPath(this.transcoderPath), r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials);
        const i = r.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([t, i]).then(([e, t]) => {
          const r = Uh.BasisWorker.toString(),
            n = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Uh.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Uh.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Uh.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([n])), this.transcoderBinary = t, this.workerPool.setWorkerCreator(() => {
            const e = new Worker(this.workerSourceURL),
              t = this.transcoderBinary.slice(0);
            return e.postMessage({
              type: "init",
              config: this.workerConfig,
              transcoderBinary: t
            }, [t]), e;
          });
        }), Fh > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Fh++;
      }
      return this.transcoderPending;
    }
    load(e, t, r, i) {
      if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const s = new n.hH6(this.manager);
      s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials), s.load(e, e => {
        if (Lh.has(e)) return Lh.get(e).promise.then(t).catch(i);
        this.createTexture(e).then(e => t ? t(e) : null).catch(i);
      }, r, i);
    }
    _createTextureFrom(e) {
      const {
        mipmaps: t,
        width: r,
        height: i,
        format: s,
        type: o,
        error: a,
        dfdTransferFn: l,
        dfdFlags: c
      } = e;
      if ("error" === o) return Promise.reject(a);
      const u = new n.EB7(t, r, i, s, n.ywz);
      return u.minFilter = 1 === t.length ? n.wem : n.D1R, u.magFilter = n.wem, u.generateMipmaps = !1, u.needsUpdate = !0, u.encoding = 2 === l ? n.knz : n.rnI, u.premultiplyAlpha = !!(1 & c), u;
    }
    createTexture(e, t = {}) {
      const r = function (e) {
        const t = new Uint8Array(e.buffer, e.byteOffset, Mh.length);
        if (t[0] !== Mh[0] || t[1] !== Mh[1] || t[2] !== Mh[2] || t[3] !== Mh[3] || t[4] !== Mh[4] || t[5] !== Mh[5] || t[6] !== Mh[6] || t[7] !== Mh[7] || t[8] !== Mh[8] || t[9] !== Mh[9] || t[10] !== Mh[10] || t[11] !== Mh[11]) throw new Error("Missing KTX 2.0 identifier.");
        const r = new Sh(),
          n = 17 * Uint32Array.BYTES_PER_ELEMENT,
          i = new Ch(e, Mh.length, n, !0);
        r.vkFormat = i._nextUint32(), r.typeSize = i._nextUint32(), r.pixelWidth = i._nextUint32(), r.pixelHeight = i._nextUint32(), r.pixelDepth = i._nextUint32(), r.layerCount = i._nextUint32(), r.faceCount = i._nextUint32();
        const s = i._nextUint32();
        r.supercompressionScheme = i._nextUint32();
        const o = i._nextUint32(),
          a = i._nextUint32(),
          l = i._nextUint32(),
          c = i._nextUint32(),
          u = i._nextUint64(),
          h = i._nextUint64(),
          p = new Ch(e, Mh.length + n, 3 * s * 8, !0);
        for (let t = 0; t < s; t++) r.levels.push({
          levelData: new Uint8Array(e.buffer, e.byteOffset + p._nextUint64(), p._nextUint64()),
          uncompressedByteLength: p._nextUint64()
        });
        const d = new Ch(e, o, a, !0),
          f = {
            vendorId: d._skip(4)._nextUint16(),
            descriptorType: d._nextUint16(),
            versionNumber: d._nextUint16(),
            descriptorBlockSize: d._nextUint16(),
            colorModel: d._nextUint8(),
            colorPrimaries: d._nextUint8(),
            transferFunction: d._nextUint8(),
            flags: d._nextUint8(),
            texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
            bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
            samples: []
          },
          m = (f.descriptorBlockSize / 4 - 6) / 4;
        for (let e = 0; e < m; e++) {
          const t = {
            bitOffset: d._nextUint16(),
            bitLength: d._nextUint8(),
            channelType: d._nextUint8(),
            samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
          };
          64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
        }
        r.dataFormatDescriptor.length = 0, r.dataFormatDescriptor.push(f);
        const _ = new Ch(e, l, c, !0);
        for (; _._offset < c;) {
          const e = _._nextUint32(),
            t = _._scan(e),
            n = Th(t),
            i = _._scan(e - t.byteLength);
          r.keyValue[n] = n.match(/^ktx/i) ? Th(i) : i, _._offset % 4 && _._skip(4 - _._offset % 4);
        }
        if (h <= 0) return r;
        const g = new Ch(e, u, h, !0),
          v = g._nextUint16(),
          A = g._nextUint16(),
          b = g._nextUint32(),
          y = g._nextUint32(),
          x = g._nextUint32(),
          w = g._nextUint32(),
          E = [];
        for (let e = 0; e < s; e++) E.push({
          imageFlags: g._nextUint32(),
          rgbSliceByteOffset: g._nextUint32(),
          rgbSliceByteLength: g._nextUint32(),
          alphaSliceByteOffset: g._nextUint32(),
          alphaSliceByteLength: g._nextUint32()
        });
        const S = u + g._offset,
          C = S + b,
          M = C + y,
          T = M + x,
          I = new Uint8Array(e.buffer, e.byteOffset + S, b),
          k = new Uint8Array(e.buffer, e.byteOffset + C, y),
          D = new Uint8Array(e.buffer, e.byteOffset + M, x),
          P = new Uint8Array(e.buffer, e.byteOffset + T, w);
        return r.globalData = {
          endpointCount: v,
          selectorCount: A,
          imageDescs: E,
          endpointsData: I,
          selectorsData: k,
          tablesData: D,
          extendedData: P
        }, r;
      }(new Uint8Array(e));
      if (0 !== r.vkFormat) return async function (e) {
        const {
          vkFormat: t,
          pixelWidth: r,
          pixelHeight: i,
          pixelDepth: s
        } = e;
        if (void 0 === Nh[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        const o = e.levels[0];
        let a, l;
        if (0 === e.supercompressionScheme) a = o.levelData;else {
          if (2 !== e.supercompressionScheme) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
          Oh || (Oh = new Promise(async e => {
            const t = new Bh();
            await t.init(), e(t);
          })), a = (await Oh).decode(o.levelData, o.uncompressedByteLength);
        }
        l = jh[t] === n.VzW ? new Float32Array(a.buffer, a.byteOffset, a.byteLength / Float32Array.BYTES_PER_ELEMENT) : jh[t] === n.cLu ? new Uint16Array(a.buffer, a.byteOffset, a.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a;
        const c = 0 === s ? new n.IEO(l, r, i) : new n.JUT(l, r, i, s);
        return c.type = jh[t], c.format = Nh[t], c.encoding = zh[t] || n.rnI, c.needsUpdate = !0, Promise.resolve(c);
      }(r);
      const i = t,
        s = this.init().then(() => this.workerPool.postMessage({
          type: "transcode",
          buffer: e,
          taskConfig: i
        }, [e])).then(e => this._createTextureFrom(e.data));
      return Lh.set(e, {
        promise: s
      }), s;
    }
    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Fh--, this;
    }
  }
  Uh.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
  }, Uh.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
  }, Uh.EngineFormat = {
    RGBAFormat: n.wk1,
    RGBA_ASTC_4x4_Format: n.ptH,
    RGBA_BPTC_Format: n.bsb,
    RGBA_ETC2_EAC_Format: n.ekQ,
    RGBA_PVRTC_4BPPV1_Format: n.eaV,
    RGBA_S3TC_DXT5_Format: n.ILR,
    RGB_ETC1_Format: n.fto,
    RGB_ETC2_Format: n.l0P,
    RGB_PVRTC_4BPPV1_Format: n._AM,
    RGB_S3TC_DXT1_Format: n.wuA
  }, Uh.BasisWorker = function () {
    let e, t, r;
    const n = _EngineFormat,
      i = _TranscoderFormat,
      s = _BasisFormat;
    self.addEventListener("message", function (o) {
      const u = o.data;
      switch (u.type) {
        case "init":
          e = u.config, h = u.transcoderBinary, t = new Promise(e => {
            r = {
              wasmBinary: h,
              onRuntimeInitialized: e
            }, BASIS(r);
          }).then(() => {
            r.initializeBasis(), void 0 === r.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
          break;
        case "transcode":
          t.then(() => {
            try {
              const {
                  width: t,
                  height: o,
                  hasAlpha: h,
                  mipmaps: p,
                  format: d,
                  dfdTransferFn: f,
                  dfdFlags: m
                } = function (t) {
                  const o = new r.KTX2File(new Uint8Array(t));
                  function u() {
                    o.close(), o.delete();
                  }
                  if (!o.isValid()) throw u(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                  const h = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                    p = o.getWidth(),
                    d = o.getHeight(),
                    f = o.getLevels(),
                    m = o.getHasAlpha(),
                    _ = o.getDFDTransferFunc(),
                    g = o.getDFDFlags(),
                    {
                      transcoderFormat: v,
                      engineFormat: A
                    } = function (t, r, o, u) {
                      let h, p;
                      const d = t === s.ETC1S ? a : l;
                      for (let n = 0; n < d.length; n++) {
                        const i = d[n];
                        if (e[i.if] && i.basisFormat.includes(t) && !(u && i.transcoderFormat.length < 2) && (!i.needsPowerOfTwo || c(r) && c(o))) return h = i.transcoderFormat[u ? 1 : 0], p = i.engineFormat[u ? 1 : 0], {
                          transcoderFormat: h,
                          engineFormat: p
                        };
                      }
                      return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), h = i.RGBA32, p = n.RGBAFormat, {
                        transcoderFormat: h,
                        engineFormat: p
                      };
                    }(h, p, d, m);
                  if (!p || !d || !f) throw u(), new Error("THREE.KTX2Loader:\tInvalid texture");
                  if (!o.startTranscoding()) throw u(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                  const b = [];
                  for (let e = 0; e < f; e++) {
                    const t = o.getImageLevelInfo(e, 0, 0),
                      r = t.origWidth,
                      n = t.origHeight,
                      i = new Uint8Array(o.getImageTranscodedSizeInBytes(e, 0, 0, v));
                    if (!o.transcodeImage(i, e, 0, 0, v, 0, -1, -1)) throw u(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                    b.push({
                      data: i,
                      width: r,
                      height: n
                    });
                  }
                  return u(), {
                    width: p,
                    height: d,
                    hasAlpha: m,
                    mipmaps: b,
                    format: A,
                    dfdTransferFn: _,
                    dfdFlags: g
                  };
                }(u.buffer),
                _ = [];
              for (let e = 0; e < p.length; ++e) _.push(p[e].data.buffer);
              self.postMessage({
                type: "transcode",
                id: u.id,
                width: t,
                height: o,
                hasAlpha: h,
                mipmaps: p,
                format: d,
                dfdTransferFn: f,
                dfdFlags: m
              }, _);
            } catch (e) {
              console.error(e), self.postMessage({
                type: "error",
                id: u.id,
                error: e.message
              });
            }
          });
      }
      var h;
    });
    const o = [{
        if: "astcSupported",
        basisFormat: [s.UASTC_4x4],
        transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
        engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
        priorityETC1S: 1 / 0,
        priorityUASTC: 1,
        needsPowerOfTwo: !1
      }, {
        if: "bptcSupported",
        basisFormat: [s.ETC1S, s.UASTC_4x4],
        transcoderFormat: [i.BC7_M5, i.BC7_M5],
        engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
        priorityETC1S: 3,
        priorityUASTC: 2,
        needsPowerOfTwo: !1
      }, {
        if: "dxtSupported",
        basisFormat: [s.ETC1S, s.UASTC_4x4],
        transcoderFormat: [i.BC1, i.BC3],
        engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
        priorityETC1S: 4,
        priorityUASTC: 5,
        needsPowerOfTwo: !1
      }, {
        if: "etc2Supported",
        basisFormat: [s.ETC1S, s.UASTC_4x4],
        transcoderFormat: [i.ETC1, i.ETC2],
        engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
        priorityETC1S: 1,
        priorityUASTC: 3,
        needsPowerOfTwo: !1
      }, {
        if: "etc1Supported",
        basisFormat: [s.ETC1S, s.UASTC_4x4],
        transcoderFormat: [i.ETC1],
        engineFormat: [n.RGB_ETC1_Format],
        priorityETC1S: 2,
        priorityUASTC: 4,
        needsPowerOfTwo: !1
      }, {
        if: "pvrtcSupported",
        basisFormat: [s.ETC1S, s.UASTC_4x4],
        transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
        engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
        priorityETC1S: 5,
        priorityUASTC: 6,
        needsPowerOfTwo: !0
      }],
      a = o.sort(function (e, t) {
        return e.priorityETC1S - t.priorityETC1S;
      }),
      l = o.sort(function (e, t) {
        return e.priorityUASTC - t.priorityUASTC;
      });
    function c(e) {
      return e <= 2 || 0 == (e & e - 1) && 0 !== e;
    }
  };
  const Nh = {
      109: n.wk1,
      97: n.wk1,
      37: n.wk1,
      43: n.wk1,
      103: n.av9,
      83: n.av9,
      16: n.av9,
      22: n.av9,
      100: n.hEm,
      76: n.hEm,
      15: n.hEm,
      9: n.hEm
    },
    jh = {
      109: n.VzW,
      97: n.cLu,
      37: n.ywz,
      43: n.ywz,
      103: n.VzW,
      83: n.cLu,
      16: n.ywz,
      22: n.ywz,
      100: n.VzW,
      76: n.cLu,
      15: n.ywz,
      9: n.ywz
    },
    zh = {
      43: n.knz,
      22: n.knz,
      15: n.knz
    },
    Gh = "KHR_texture_basisu";
  class Vh extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e) {
      var t, r, n, i;
      this._importer || (this._importer = new ir(class extends Uh {
        constructor(t) {
          super(t), this.setTranscoderPath("https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/").detectSupport(e.renderer.rendererObject);
        }
        async createTexture(e, t) {
          const r = e.map(e => new Uint8Array(e.slice(0))),
            n = await super.createTexture(e, t);
          return n.source._sourceImgBuffer = r, n.userData.mimeType = "image/ktx2", n;
        }
      }, ["ktx2"], !1)), Js.Importers.push(this._importer), null === (i = null === (n = null === (r = null === (t = e.getManager()) || void 0 === t ? void 0 : t.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === n ? void 0 : n.extensions) || void 0 === i || i.push(Qh);
    }
    async onDispose(e) {
      this._importer = void 0;
    }
    async onRemove(e) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  Vh.PluginType = "KTX2LoadPlugin";
  const Qh = e => ({
    writeTexture: (t, r) => {
      if ("image/ktx2" !== t.userData.mimeType) return;
      if (void 0 !== r.source) return void console.warn("ktx2 export: source already set");
      const n = t.source._sourceImgBuffer;
      if (!n || !n.length) return void console.warn("ktx2 export: no source buffer for ktx2");
      r.extensions = r.extensions || {};
      const i = {},
        s = new Blob(Array.isArray(n) ? n : [n], {
          type: "image/ktx2"
        });
      i.source = e.processImageBlob(s, t), r.extensions[Gh] = i, e.extensionsUsed[Gh] = !0;
    }
  });
  class Hh {
    constructor(e) {
      this.presets = [], this.name = "", this.selected = void 0, e && (this.name = e);
    }
    async apply(e, t, r) {
      var n, i;
      if (!t) return void (this.selected = void 0);
      let s = this.presets.find(e => e.path === t.path);
      return s || (this.presets.push(t), s = t), this.selected = s, null === (i = null === (n = e.getManager()) || void 0 === n ? void 0 : n.importer) || void 0 === i ? void 0 : i.importAsset(s, r);
    }
  }
  class Wh extends Hh {
    constructor() {
      super(...arguments), this.name = "Background";
    }
    async apply(e, t) {
      const r = await super.apply(e, t),
        i = null == r ? void 0 : r[0];
      return i && (i.encoding = n.knz, await e.setBackground(i)), i;
    }
  }
  class qh extends Hh {
    constructor() {
      super(...arguments), this.name = "Environment";
    }
    async apply(e, t) {
      const r = await super.apply(e, t),
        n = null == r ? void 0 : r[0];
      return n && (await e.scene.setEnvironment(n)), n;
    }
  }
  class Xh extends Hh {
    constructor() {
      super(...arguments), this.name = "GemEnvironment";
    }
    async apply(e, t) {
      const r = await super.apply(e, t),
        n = null == r ? void 0 : r[0];
      return _(e.getPluginByType("Diamond"), "envMap", n), n;
    }
  }
  class Yh extends Hh {
    async apply(e, t) {
      var r, n;
      const i = await super.apply(e, t, {
        processImported: !1
      });
      return i ? null === (n = null === (r = e.getManager()) || void 0 === r ? void 0 : r.importer) || void 0 === n ? void 0 : n.processImported(i) : void 0;
    }
  }
  class Kh extends Yh {
    constructor() {
      super(...arguments), this.name = "MaterialLibraries";
    }
    async apply(e, t) {
      const r = await super.apply(e, t);
      return r && (await e.alert("Material Library successfully imported.")), r;
    }
  }
  class Jh extends ro {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = !0, this.presetGroups = [], this.uiConfig = {
        type: "folder",
        label: "Presets",
        expanded: !0,
        limitedUi: !0,
        children: [() => this.presetGroups.map(e => ({
          type: "dropdown",
          label: e.name,
          limitedUi: !0,
          children: [{
            value: "",
            label: "none"
          }, ...e.presets.map(e => ({
            label: e.path.split("/").pop(),
            value: e.path
          }))],
          getValue: () => {
            var t;
            return (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || "";
          },
          setValue: t => {
            e.apply(this._viewer, e.presets.find(e => e.path === t));
          }
        })), {
          type: "button",
          label: "Download Selection",
          limitedUi: !0,
          value: () => {
            const e = this.exportPresets();
            wt(new File([JSON.stringify(e, null, 2)], "preset.template.json", {
              type: "application/json"
            }));
          }
        }, {
          type: "button",
          label: "Export Preset Groups",
          hidden: !0,
          limitedUi: !1,
          value: () => {
            const e = this.exportPresetGroups();
            wt(new File([JSON.stringify(e, null, 2)], "presetGroups.json", {
              type: "application/json"
            }));
          }
        }]
      };
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this.presetGroups.push(new Wh()), this.presetGroups.push(new qh()), this.presetGroups.push(new Xh()), this.presetGroups.push(new Yh("Ground")), this.presetGroups.push(new Yh("CameraViews")), this.presetGroups.push(new Yh("MaterialConfiguration")), this.presetGroups.push(new Kh()), null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t, "postFrame", !0);
    }
    exportPresets() {
      const e = Object.fromEntries(this.presetGroups.map(e => {
        var t;
        return [e.name, (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || void 0];
      }).filter(([, e]) => e));
      return e.type = Jh.PluginType, e;
    }
    async fromJSON(e, t) {
      var r, n;
      if (!super.fromJSON(e, t)) return null;
      const i = {
        ...e
      };
      delete i.type;
      const s = [];
      for (const [e, t] of Object.entries(i)) {
        const r = this.presetGroups.find(t => t.name === e),
          n = null == r ? void 0 : r.presets;
        if (!r || !n) continue;
        const i = "string" == typeof t ? {
          path: t
        } : t;
        s.push(r.apply(this._viewer, i));
      }
      return await Promise.all(s), null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0), this;
    }
    loadPresetGroups(e) {
      var t;
      for (const [r, n] of Object.entries(e)) {
        const e = null === (t = this.presetGroups.find(e => e.name === r)) || void 0 === t ? void 0 : t.presets;
        null == e || e.push(...n);
      }
    }
    exportPresetGroups() {
      return Object.fromEntries(this.presetGroups.map(e => [e.name, e.presets.map(e => e.path)]).filter(([, e]) => e.length > 0));
    }
  }
  Jh.PluginType = "PresetLibraryPlugin";
  var Zh = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  let $h = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this.scenes = [], this.assets = {}, this.toJSON = void 0, this._isPlaying = !1, this._isPlayingLoop = !1, this._options = {}, this.minSceneTime = 2e3, this.loadScenes = this.loadScenes.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.downloadScenes = this.downloadScenes.bind(this), this.promptLoadScenes = this.promptLoadScenes.bind(this);
    }
    get loadedScenes() {
      return this.scenes.length;
    }
    async promptLoadScenes() {
      const e = await Et(!0, !1, "model/gltf");
      await this.loadScenes(e);
    }
    async loadScenes(e) {
      var t, r;
      const n = await Promise.all(e.map(async e => await e.arrayBuffer()));
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        this.scenes.push({
          [r.name]: new Uint8Array(n[t])
        }), this.assets[r.name] = {
          path: r.name,
          file: r
        };
      }
      null === (r = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === r || r.call(t);
    }
    async play() {
      var e;
      if (!this._viewer) return;
      if (this._isPlaying || this._isPlayingLoop) return;
      this._isPlaying = !0, this._isPlayingLoop = !0;
      const t = this._viewer.getPluginByType("AssetManagerBasicPopupPlugin");
      null == t || t.enabled, t && (t.enabled = !1);
      const r = this._viewer.getPluginByType("FrameFade"),
        n = this._viewer.getPluginByType("GLTFAnimation"),
        i = this._viewer.getPluginByType("CameraViews");
      for (; this._isPlaying;) for (const s of this.scenes) {
        if (!this._isPlaying) break;
        const o = Object.keys(s);
        null == n || n.stopAnimation(!1), await (null == i ? void 0 : i.stopAllAnimations()), this._viewer.scene.removeSceneModels(), this._viewer.renderEnabled = !1;
        for (const t of o) {
          let r = this.assets[t];
          r || (r = {
            path: t,
            file: new File([s[t]], t)
          }, this.assets[t] = r), await (null === (e = this._viewer.getManager()) || void 0 === e ? void 0 : e.addAssetSingle(r, this._options));
        }
        if (!this._isPlaying) break;
        this._viewer.renderEnabled = !0, t && (t.enabled = !1), r && (r.enabled = !0, await r.startTransition(1e3));
        const a = [Dc(this.minSceneTime)];
        n && a.push(n.playAnimation()), i && a.push(i.animateAllViews()), await Promise.all(a);
      }
      this._isPlayingLoop = !1;
    }
    stop() {
      this._isPlaying = !1;
    }
    async downloadScenes() {
      const e = {};
      for (const t of this.scenes) for (const r of Object.keys(t)) {
        const n = e[r] ? r + "_" : r;
        e[n] = t[n];
      }
      const t = Fs(e);
      yt(new Blob([t], {
        type: "application/zip"
      }), "scenes.glbloop");
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = this;
      Js.Importers.push(new ir(class extends Qs {
        load(e, r, n, i) {
          super.load(e, e => {
            t.loadScenes([...e.values()]), null == r || r(null), Dc(100).then(t.play);
          }, n, i);
        }
      }, ["glbloop"], !0));
    }
  };
  $h.PluginType = "SceneLoopPlugin", Zh([Ze("Loaded scenes")], $h.prototype, "loadedScenes", null), Zh([rt("Load Scenes")], $h.prototype, "promptLoadScenes", null), Zh([Ze("Playing")], $h.prototype, "_isPlaying", void 0), Zh([nt("Min Scene Time")], $h.prototype, "minSceneTime", void 0), Zh([rt("Play")], $h.prototype, "play", null), Zh([rt("Stop")], $h.prototype, "stop", null), Zh([rt("Download Scenes")], $h.prototype, "downloadScenes", null), $h = Zh([lt("Scene Loop")], $h);
  var ep = __webpackgi_require__(701),
    tp = __webpackgi_require__.n(ep),
    rp = __webpackgi_require__(236),
    np = __webpackgi_require__.n(rp),
    ip = __webpackgi_require__(850),
    sp = __webpackgi_require__.n(ip),
    op = __webpackgi_require__(182),
    ap = __webpackgi_require__.n(op),
    lp = __webpackgi_require__(213),
    cp = __webpackgi_require__.n(lp),
    up = __webpackgi_require__(798),
    hp = {};
  up.Z && up.Z.locals && (hp.locals = up.Z.locals);
  var pp,
    dp = 0,
    fp = {};
  fp.styleTagTransform = cp(), fp.setAttributes = sp(), fp.insert = function (e, t) {
    (t.target || document.head).appendChild(e);
  }, fp.domAPI = np(), fp.insertStyleElement = ap(), hp.use = function (e) {
    return fp.options = e || {}, dp++ || (pp = tp()(up.Z, fp)), hp;
  }, hp.unuse = function () {
    dp > 0 && ! --dp && (pp(), pp = null);
  };
  var mp,
    _p = hp,
    gp = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let vp = mp = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [to], this._popupDiv = St({
        id: "assetManagerPopup",
        addToBody: !1,
        innerHTML: ""
      });
      const e = St({
        id: "assetManagerPopupClose",
        addToBody: !1,
        innerHTML: "&#10005"
      });
      e.addEventListener("click", () => {
        this._popupDiv.style.display = "none";
      }), this._popupContent = St({
        id: "assetManagerPopupContent",
        addToBody: !1,
        innerHTML: ""
      }), this.enabled || (this._popupDiv.style.display = "none"), this._popupDiv.appendChild(e), this._popupDiv.appendChild(this._popupContent);
    }
    _onEnabledChange() {
      this.enabled || (this._popupDiv.style.display = "none");
    }
    _updatePopupDiv(e) {
      if (!this._popupContent) return;
      if (!this.enabled) return void (this._popupDiv.style.display = "none");
      let t = "";
      e.forEach((e, r) => {
        t += `<span class="processState">${e.state}</span>: ${r.split("/").pop()} ${e.progress ? " - " + e.progress : ""}<br>`;
      }), this._popupContent.innerHTML = t, 0 === e.size ? this._popupDiv.style.display = "none" : this._popupDiv.style.display = "block";
    }
    async onAdded(e) {
      var t, r, n, i;
      await super.onAdded(e), _p.use({
        target: e.container
      }), e.container.appendChild(this._popupDiv);
      const s = new Map();
      null === (r = null === (t = e.getManager()) || void 0 === t ? void 0 : t.importer) || void 0 === r || r.addEventListener("importFile", e => {
        "done" !== e.state ? s.set(e.path, {
          state: e.state,
          progress: e.progress ? (100 * e.progress).toFixed(0) + "%" : void 0
        }) : s.delete(e.path), this._updatePopupDiv(s);
      }), null === (i = null === (n = e.getManager()) || void 0 === n ? void 0 : n.exporter) || void 0 === i || i.addEventListener("exportFile", e => {
        "done" !== e.state ? s.set(e.obj.name, {
          state: e.state,
          progress: e.progress ? (100 * e.progress).toFixed(0) + "%" : void 0
        }) : s.delete(e.obj.name), this._updatePopupDiv(s);
      });
    }
  };
  vp.PluginType = "AssetManagerBasicPopupPlugin", gp([Je("Enabled"), M(mp.prototype._onEnabledChange), Ce()], vp.prototype, "enabled", void 0), vp = mp = gp([lt("Asset manager popup")], vp);
  class Ap extends zt {
    constructor(e) {
      super({
        vertexShader: i.vertexShader,
        uniforms: {
          tDiffuse: {
            value: null
          }
        },
        defines: {},
        fragmentShader: `\n                varying vec2 vUv;\n                ${e[0]}\n                void main() {\n                    gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));\n                    #glMarker\n                    ${e[1]}\n                }\n                `
      }, "tDiffuse"), this.uiConfig = void 0, this.customMaterial = new Ut();
    }
    render(e, t, r, n, i) {
      super.render(e, t, r, n, i), this.needsSwap = !0;
    }
  }
  class bp extends io {
    constructor(e = !0, t = !0) {
      super(), this.depthTonemap = e, this.passId = "combinedPost", this.dependencies = [lo], this.toJSON = void 0, this._beforeFilters = [], this._afterFilters = ["render"], this._requiredFilters = ["render"], this._renderToScreen = !0, this._setDirty = this._setDirty.bind(this), this._renderToScreen = t;
    }
    get renderToScreen() {
      return this._renderToScreen;
    }
    async onAdded(e) {
      var t, r;
      return (null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.screenShader) || void 0 === r ? void 0 : r.isShaderPass2) && (this._renderToScreen = !1), this._renderToScreen && _(e.renderer.passes.find(e => "screen" === e.passId), "enabled", !1, !0, !0), super.onAdded(e);
    }
    passCtor(e) {
      var t, r, n, i;
      const s = e.screenShader,
        o = ["", ""];
      this._renderToScreen && !s.isShaderPass2 && (o[0] = Array.isArray(s) ? s[0] : (null === (t = s) || void 0 === t ? void 0 : t.pars) || "", o[1] = Array.isArray(s) ? s[1] : "string" == typeof s ? s : (null === (r = s) || void 0 === r ? void 0 : r.main) || "");
      const a = new Ap(o);
      return _(null === (i = null === (n = a.uiConfig) || void 0 === n ? void 0 : n.children) || void 0 === i ? void 0 : i.find(e => {
        var t;
        return "Enabled" === (null === (t = e) || void 0 === t ? void 0 : t.label);
      }), "hidden", !0, !0), a;
    }
    _update(e) {
      var t;
      return !!super._update(e) && (this._pass.passObject.updateShaderProperties(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(lo)), !0);
    }
    _setDirty() {
      this.pass && (this.pass.dirty = !0);
    }
    get uiConfig() {
      var e, t, r;
      return null !== (r = null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== r ? r : {};
    }
    addExtension(e) {
      this.pass.passObject.material.registerMaterialExtensions([e]);
    }
  }
  bp.PluginType = "CombinedPostPlugin";
  var yp = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class xp extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.dependencies = [bp];
    }
    get uiConfig() {
      var e;
      return null === (e = this._extension) || void 0 === e ? void 0 : e.uiConfig;
    }
    get config() {
      return this._extension;
    }
    disposeExtension() {}
    async onAdded(e) {
      var t;
      await super.onAdded(e), this._extension = this.generateExtension(e), null === (t = e.getPlugin(bp)) || void 0 === t || t.addExtension(this._extension);
    }
    async onRemove(e) {
      this.disposeExtension(), this._extension = void 0, await super.onRemove(e);
    }
  }
  yp([Ce("extension")], xp.prototype, "_extension", void 0), yp([Ce()], xp.prototype, "enabled", void 0);
  class wp {
    constructor() {
      this.uiConfig = void 0, this.enabled = !0;
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            gl_FragColor = LinearTosRGB(gl_FragColor);\n            #glMarker\n        "));
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
  }
  class Ep extends xp {
    generateExtension(e) {
      return new wp();
    }
  }
  Ep.PluginType = "GammaCorrection";
  var Sp,
    Cp = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  const Mp = n.dZ3;
  let Tp = Sp = class {
    constructor(e, t = !0, r = !0) {
      this.depthTonemap = t, this.toneMapping = n.LY2, this.tonemapBackground = !0, this.clipBackground = !1, this.exposure = 1, this._renderToScreen = !0, this.enabled = !0, this._rendererState = {}, this.extraUniforms = {
        tNormalDepth: {
          value: null
        },
        tGBufferFlags: {
          value: null
        },
        opacity: {
          value: 1
        }
      }, this.parsFragmentSnippet = (e, t) => this.enabled ? w`
            ${this.depthTonemap ? Ht : ""}
            #define USE_DEPTH_TONEMAP ${this.depthTonemap ? "1" : "0"}
            uniform float opacity;
            ${"vec4 ToneMapping(in vec4 color){vec4 outColor=opacity*color;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getGBufferFlags(vUv).x>0.5;float depth=getDepth(vUv);\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nbool isBackground=depth>0.9999;if(isBackground)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#if defined( TONE_MAPPING )\noutColor.rgb=toneMapping(outColor.rgb);\n#endif\n#if USE_DEPTH_TONEMAP > 0\n}else{\n#if TRANSPARENT_BACKGROUND > 0\nif(isBackground)outColor.a=0.;\n#endif\n}if(depth<0.00001)outColor.a=0.;\n#endif\nreturn outColor;}"}
        ` : "", this._combinedPostPlugin = e.getPlugin(bp), this._setDirty = this._setDirty.bind(this), this._renderToScreen = r, this.depthTonemap = t;
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            gl_FragColor = ToneMapping(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e, t, r) {
      if (!this.enabled) return;
      const {
        toneMapping: i,
        toneMappingExposure: s,
        outputEncoding: o
      } = r;
      this._rendererState.toneMapping = i, this._rendererState.toneMappingExposure = s, this._rendererState.outputEncoding = o;
      let a = this.tonemapBackground ? "1" : "0";
      t.materialObject.defines.TONEMAP_BACKGROUND !== a && (t.materialObject.defines.TONEMAP_BACKGROUND = a, t.materialObject.needsUpdate = !0), a = this.clipBackground ? "1" : "0", t.materialObject.defines.TRANSPARENT_BACKGROUND !== a && (t.materialObject.defines.TRANSPARENT_BACKGROUND = a, t.materialObject.needsUpdate = !0), r.toneMapping = this.toneMapping, r.toneMappingExposure = this.exposure, r.outputEncoding = n.knz, t.materialObject.toneMapped = !0, t.materialObject.needsUpdate = !0;
    }
    onAfterRender(e, t, r) {
      r.toneMapping = this._rendererState.toneMapping, r.toneMappingExposure = this._rendererState.toneMappingExposure, r.outputEncoding = this._rendererState.outputEncoding;
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Tp.PluginType = "Tonemap", Cp([tt("Mode", [["Linear", n.EoG], ["Reinhard", n.CdI], ["Cineon", n.YGz], ["ACESFilmic", n.LY2], ["Uncharted2", Mp]].map(e => ({
    label: e[0],
    value: e[1]
  })), {
    limitedUi: !0
  }), M(Sp.prototype._setDirty), Ce()], Tp.prototype, "toneMapping", void 0), Cp([Je("Tonemap Background", {
    limitedUi: !0
  }), Ce()], Tp.prototype, "tonemapBackground", void 0), Cp([M(Sp.prototype._setDirty), Je("Clip Background"), Ce()], Tp.prototype, "clipBackground", void 0), Cp([M(Sp.prototype._setDirty), $e("Exposure", [0, 2 * Math.PI], .01, {
    limitedUi: !0
  }), Ce()], Tp.prototype, "exposure", void 0), Tp = Sp = Cp([lt("Tonemapping")], Tp);
  class Ip extends xp {
    constructor(e = !0) {
      super(), this.depthTonemap = e, this.depthTonemap = e;
    }
    fromJSON(e, t) {
      return e.pass && ((e = {
        ...e
      }).extension = {
        ...e.pass
      }, delete e.extension.enabled, delete e.pass), super.fromJSON(e, t);
    }
    generateExtension(e) {
      return new Tp(e, this.depthTonemap);
    }
    get exposure() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.exposure) && void 0 !== t ? t : 1;
    }
    set exposure(e) {
      this._extension && (this._extension.exposure = e, this._extension.setDirty());
    }
    get toneMapping() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.toneMapping) && void 0 !== t ? t : n.EoG;
    }
    set toneMapping(e) {
      this._extension && (this._extension.toneMapping = e, this._extension.setDirty());
    }
  }
  Ip.PluginType = "Tonemap", n.WdD.tonemapping_pars_fragment = n.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");
  var kp,
    Dp = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Pp = kp = class {
    constructor(e) {
      this.enabled = !1, this.intensity = 1, this.lutMap = void 0, this.extraUniforms = {
        intensity: {
          value: 1
        },
        lutSize: {
          value: 1
        }
      }, this.parsFragmentSnippet = (e, t) => this.enabled ? "#if USE_LUT == 1\nuniform float lutSize;uniform float intensity;\n#if USE_3DTEXTURE == 1\nprecision highp sampler3D;uniform sampler3D lut3d;\n#else\nuniform sampler2D lut;vec3 lutLookup(sampler2D tex,float size,vec3 rgb){float sliceHeight=1./size;float yPixelHeight=1./(size*size);float slice=rgb.b*size;float interp=fract(slice);float slice0=slice-interp;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);float greenOffset=clamp(rgb.g*sliceHeight,yPixelHeight*0.5,sliceHeight-yPixelHeight*0.5);vec2 uv0=vec2(rgb.r,slice0*sliceHeight+greenOffset);vec2 uv1=vec2(rgb.r,slice1*sliceHeight+greenOffset);vec3 sample0=texture2D(tex,uv0).rgb;vec3 sample1=texture2D(tex,uv1).rgb;return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvec4 colorLookUp(in vec4 color){vec4 outColor;float pixelWidth=1./lutSize;float halfPixelWidth=0.5/lutSize;vec3 uvw=vec3(halfPixelWidth)+color.rgb*(1.-pixelWidth);float lutFac=step(0.0001,getGBufferFlags(vUv).a);\n#if USE_3DTEXTURE == 1\noutColor=vec4(texture(lut3d,uvw).rgb,color.a);\n#else\noutColor=vec4(lutLookup(lut,lutSize,uvw),color.a);\n#endif\noutColor=mix(color,outColor,lutFac);return vec4(mix(color,outColor,intensity));}\n#endif\n" : "", this._combinedPostPlugin = e.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            #if USE_LUT == 1\n                gl_FragColor = colorLookUp(gl_FragColor);\n            #endif\n            #glMarker\n        "));
    }
    onObjectRender(e, t, r) {
      if (this.enabled) if (this.lutMap) {
        const e = this.lutMap.texture3D ? 1 : 0;
        t.materialObject.defines.USE_3DTEXTURE !== e && (t.materialObject.defines.USE_3DTEXTURE = e, t.materialObject.needsUpdate = !0);
        let r = 1;
        this.lutMap.texture3D ? (t.materialObject.uniforms.lut3d = {
          value: this.lutMap.texture3D
        }, t.materialObject.uniforms.lut3d.value.needsUpdate = !0, r = this.lutMap.texture3D.image.width) : this.lutMap.texture && (t.materialObject.uniforms.lut = {
          value: this.lutMap.texture
        }, t.materialObject.uniforms.lut.value.needsUpdate = !0, r = this.lutMap.texture.image.width), t.materialObject.uniforms.lutSize.value = r, t.materialObject.uniforms.intensity.value = this.intensity, t.materialObject.defines.USE_LUT = 1;
      } else t.materialObject.defines.USE_3DTEXTURE = 0, t.materialObject.defines.USE_LUT = 0, t.materialObject.needsUpdate = !0;
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0);
    }
  };
  Dp([Ce(), M(kp.prototype._setDirty), Je("Enable")], Pp.prototype, "enabled", void 0), Dp([Ce(), M(kp.prototype._setDirty), $e("Intensity")], Pp.prototype, "intensity", void 0), Dp([M(kp.prototype._setDirty), st("LUT"), Ce()], Pp.prototype, "lutMap", void 0), Pp = kp = Dp([lt("LUT")], Pp);
  class Bp extends xp {
    generateExtension(e) {
      return new Pp(e);
    }
  }
  Bp.PluginType = "LUT";
  var Rp,
    Lp = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Op = Rp = class {
    constructor(e) {
      this.enabled = !1, this.power = .5, this.bgcolor = new n.Ilk(0), this.extraUniforms = {
        power: {
          value: 1
        },
        bgcolor: {
          value: new n.Ilk()
        }
      }, this.parsFragmentSnippet = (e, t) => this.enabled ? w`
            uniform float power;
            uniform vec3 bgcolor;
            ${"vec4 Vignette(in vec4 color){vec2 uv=vUv*(1.-vUv);float vig=uv.x*uv.y*16.;vig=pow(vig,power);return vec4(mix(color.rgb,vec3(bgcolor),1.-vig),color.a);}"}
        ` : "", this._combinedPostPlugin = e.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            gl_FragColor = Vignette(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e, t, r) {
      this.enabled && (t.materialObject.uniforms.power.value = this.power, t.materialObject.uniforms.bgcolor.value.copy(this.bgcolor));
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Op.PluginType = "Vignette", Lp([M(Rp.prototype._setDirty), Je("Enable"), Ce()], Op.prototype, "enabled", void 0), Lp([M(Rp.prototype._setDirty), $e("Power", [.1, 4], .01, {
    limitedUi: !0
  }), Ce()], Op.prototype, "power", void 0), Lp([M(Rp.prototype._setDirty), it("Color"), Ce()], Op.prototype, "bgcolor", void 0), Op = Rp = Lp([lt("Vignette")], Op);
  class Fp extends xp {
    constructor() {
      super();
    }
    generateExtension(e) {
      return new Op(e);
    }
    get power() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.power) && void 0 !== t ? t : 1;
    }
    set power(e) {
      this._extension && (this._extension.power = e, this._extension.setDirty());
    }
    get color() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.bgcolor) && void 0 !== t ? t : new n.Ilk();
    }
    set color(e) {
      this._extension && (this._extension.bgcolor.copy(e), this._extension.setDirty());
    }
  }
  Fp.PluginType = "Vignette";
  var Up,
    Np = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let jp = Up = class {
    constructor(e) {
      this.enabled = !1, this.aberrationIntensity = .01, this.extraUniforms = {
        aberrationIntensity: {
          value: 1
        }
      }, this.parsFragmentSnippet = (e, t) => this.enabled ? w`
            uniform float aberrationIntensity;
            ${"vec4 chromaticAberration(){vec2 distFromCenter=vUv-0.5;vec2 aberrated=aberrationIntensity*pow(distFromCenter,vec2(2.));vec4 color=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 outColor=vec4(tDiffuseTexelToLinear(texture2D(tDiffuse,vUv+aberrated)).r,color.g,tDiffuseTexelToLinear(texture2D(tDiffuse,vUv-aberrated)).b,color.a);return outColor;}"}
        ` : "", this._combinedPostPlugin = e.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            gl_FragColor = chromaticAberration();\n            #glMarker\n        "));
    }
    onObjectRender(e, t, r) {
      this.enabled && (t.materialObject.uniforms.aberrationIntensity.value = this.aberrationIntensity);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0);
    }
    setDirty() {
      this._setDirty();
    }
  };
  jp.PluginType = "ChromaticAberration", Np([M(Up.prototype._setDirty), Je("Enable"), Ce()], jp.prototype, "enabled", void 0), Np([M(Up.prototype._setDirty), $e("Intensity", [0, .1], .001, {
    limitedUi: !0
  }), Ce()], jp.prototype, "aberrationIntensity", void 0), jp = Up = Np([lt("ChromaticAberration")], jp);
  class zp extends xp {
    constructor() {
      super();
    }
    generateExtension(e) {
      return new jp(e);
    }
    get intensity() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.aberrationIntensity) && void 0 !== t ? t : 1;
    }
    set intensity(e) {
      this._extension && (this._extension.aberrationIntensity = e, this._extension.setDirty());
    }
  }
  zp.PluginType = "ChromaticAberration";
  var Gp,
    Vp = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let Qp = Gp = class {
    constructor(e) {
      this.enabled = !1, this.grainMultiply = !1, this.grainIntensity = 10, this.extraUniforms = {
        grainIntensity: {
          value: 1
        },
        grainMultiply: {
          value: 1
        }
      }, this.parsFragmentSnippet = (e, t) => this.enabled ? w`
            uniform float grainIntensity;
            uniform bool grainMultiply;
            ${"vec4 grain(in vec4 color){float x=(vUv.x+4.)*(vUv.y+4.)*(10.);vec4 grain=vec4(mod((mod(x,13.)+1.)*(mod(x,123.)+1.),0.01)-0.005)*grainIntensity;vec4 outColor=color;if(grainMultiply){grain=1.-grain;outColor.rgb=color.rgb*vec3(grain);}else{outColor.rgb=color.rgb+vec3(grain);}return outColor;}"}
        ` : "", this._combinedPostPlugin = e.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e, t, r) {
      this.enabled && (e.fragmentShader = qt(e.fragmentShader, "#glMarker", " \n            gl_FragColor = grain(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e, t, r) {
      this.enabled && (t.materialObject.uniforms.grainIntensity.value = this.grainIntensity, t.materialObject.uniforms.grainMultiply.value = this.grainMultiply);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e) {
      return !0;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Vp([M(Gp.prototype._setDirty), Je("Enable"), Ce()], Qp.prototype, "enabled", void 0), Vp([M(Gp.prototype._setDirty), Je("Multiply"), Ce()], Qp.prototype, "grainMultiply", void 0), Vp([M(Gp.prototype._setDirty), $e("Intensity", [0, 20], .01, {
    limitedUi: !0
  }), Ce()], Qp.prototype, "grainIntensity", void 0), Qp = Gp = Vp([lt("FilmicGrain")], Qp);
  class Hp extends xp {
    constructor() {
      super();
    }
    generateExtension(e) {
      return new Qp(e);
    }
    get intensity() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.grainIntensity) && void 0 !== t ? t : 1;
    }
    set intensity(e) {
      this._extension && (this._extension.grainIntensity = e, this._extension.setDirty());
    }
    get multiply() {
      var e, t;
      return null !== (t = null === (e = this._extension) || void 0 === e ? void 0 : e.grainMultiply) && void 0 !== t && t;
    }
    set multiply(e) {
      this._extension && (this._extension.grainMultiply = e, this._extension.setDirty());
    }
  }
  async function Wp(e, {
    ground: t = !0,
    bloom: r = !0,
    depthTonemap: n = !0,
    enableDrop: i = !1
  } = {}) {
    await e.addPlugin(lo), await e.addPlugin(yo), i && (await e.addPlugin(wo)), await e.addPlugin(new To(32)), await e.addPlugin(new bp()), await e.addPlugin(new zp()), await e.addPlugin(new Ip(n || !e.useRgbm)), await e.addPlugin(new Bp()), await e.addPlugin(new Fp()), await e.addPlugin(new Hp()), await e.addPlugin(new Ep()), await e.addPlugin(No), await e.addPlugin(Qo), await e.addPlugin(Gc), await e.addPlugin(Oc), await e.addPlugin(Wc), t && (await e.addPlugin(_u)), r && (await e.addPlugin(bu)), await e.addPlugin(xu), await e.addPlugin(Cu), await e.addPlugin(Du), await e.addPlugin(Fu), await e.addPlugin(zu), await e.addPlugin(Xu, !1), await e.addPlugin(Ku), await e.addPlugin(nh), await e.addPlugin(hh, !1), await e.addPlugin(fh, !1), await e.addPlugin(bh, !1), await e.addPlugin(wh, !1), await e.addPlugin(Vh), await e.addPlugin(Jh), await e.addPlugin($h);
  }
  async function qp(e, {
    debug: t = !1,
    ground: r = !0,
    bloom: n = !0,
    depthTonemap: i = !1,
    importPopup: s = !0,
    enableDrop: o = !1
  } = {}) {
    var a;
    const l = new go(e);
    t && (await l.addPlugin(Yc));
    const c = await l.addPlugin(to, void 0, void 0, {
      storage: caches ? await caches.open("webgi-cache-storage") : void 0
    });
    return s && (await l.addPlugin(vp)), await Wp(l, {
      ground: r,
      bloom: n,
      depthTonemap: i,
      enableDrop: o
    }), l.renderer.refreshPipeline(), null === (a = c.importer) || void 0 === a || a.processors.add("model", {
      forAssetType: "model",
      process: (e, t) => e
    }), l;
  }
  Hp.PluginType = "FilmicGrain";
  let Xp = 0;
  class Yp extends HTMLElement {
    constructor() {
      super(), this._initialized = !1, this._state = {
        src: "",
        environment: ""
      }, this._models = {}, this._refreshingModels = !1, this._refreshingEnvironment = !1, this.viewerIndex = Xp++, this.canvasId = "webgi-viewer-" + this.viewerIndex, this.attachShadow({
        mode: "open"
      }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block", this.canvas = At(), this.canvas.setAttribute("id", this.canvasId);
      const e = document.createElement("style");
      e.textContent = E`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
        `, this.wrapper.append(this.canvas), this.shadowRoot.append(e, this.wrapper), this._initialize().then(async () => this.refreshAll());
    }
    async refreshAll() {
      await Promise.all([this.refreshModelSource(), this.refreshEnvironment()]);
    }
    async _initialize() {
      this._initialized || (this.viewer = await qp({
        canvas: this.canvas,
        useRgbm: "true" === this._getAttr("rgbm", "true"),
        useGBufferDepth: "true" === this._getAttr("depth-prepass", "true")
      }, {
        debug: "true" === this._getAttr("debug", "false"),
        ground: "baked" === this._getAttr("ground", "baked"),
        bloom: "true" === this._getAttr("bloom", "true"),
        depthTonemap: !0
      }), this._initialized = !0, this.dispatchEvent(new Event("initialized")));
    }
    connectedCallback() {
      console.log("WebGiViewerElement added to page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }
    disconnectedCallback() {
      console.log("WebGiViewerElement removed from page."), this.viewer && (this.viewer.enabled = !1);
    }
    adoptedCallback() {
      console.log("WebGiViewerElement moved to new page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }
    static get observedAttributes() {
      return ["src", "environment"];
    }
    attributeChangedCallback(e, t, r) {
      console.log("WebGiViewerElement attributes changed.", e, t, r), this.refreshAll();
    }
    clearModels() {}
    async refreshModelSource() {
      if (!this.viewer) return;
      const e = this._getAttr("src", "");
      if (e === this._state.src) return;
      if (this._refreshingModels) return;
      this._refreshingModels = !0;
      const t = [e],
        r = [],
        n = [];
      for (const e of t) !this._models[e] && e && (this._models[e] = this.viewer.getManager().importer.importPath(e, {
        autoScale: "true" === this._getAttr("auto-scale", "true"),
        autoCenter: "true" === this._getAttr("auto-center", "true"),
        processImported: !1
      }));
      for (const [e, i] of Object.entries(this._models)) t.includes(e) ? r.push(i) : n.push(i);
      await Promise.all([Promise.all(r).then(async e => Promise.all(e.map(async e => this.viewer.getManager().importer.processImported(e)))).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && this.viewer.scene.addSceneObject(e);
      }), Promise.all(n).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && e.modelObject.removeFromParent();
      })]), this._state.src = e, this._refreshingModels = !1;
    }
    async refreshEnvironment() {
      if (!this.viewer) return;
      if (!this.hasAttribute("environment")) return void (this._state.environment = null);
      const e = this._getAttr("environment", "");
      if (e === this._state.src) return;
      if (this._refreshingEnvironment) return;
      this._refreshingEnvironment = !0;
      const t = this.viewer.scene.getEnvironment(),
        r = e ? await this.viewer.getManager().importer.importSinglePath(e) : void 0;
      r && "texture" !== r.assetType || (await this.viewer.scene.setEnvironment(r)), null == t || t.dispose(), this._state.environment = e, this._refreshingEnvironment = !1;
    }
    _getAttr(e, t) {
      return this.hasAttribute(e) ? this.getAttribute(e) : t;
    }
  }
  window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", Yp);
  class Kp {
    constructor(e) {
      var t, r, n;
      this._basePath = null !== (t = null == e ? void 0 : e.basePath) && void 0 !== t ? t : "", this._assets = null !== (n = null === (r = null == e ? void 0 : e.assets) || void 0 === r ? void 0 : r.map(e => this._resolveAsset(e))) && void 0 !== n ? n : [];
    }
    get basePath() {
      return this._basePath;
    }
    get assets() {
      return this._assets;
    }
    find(e) {
      const t = this._assets.find(e);
      return null != t ? t : void 0;
    }
    _resolveAsset(e) {
      return {
        ...e,
        path: bt([this._basePath, e.path])
      };
    }
  }
  class Jp extends r {
    constructor(...e) {
      super(), this._assets = e;
    }
    addAssetList(e) {
      this._assets.push(e);
    }
    removeAssetList(e) {
      const t = this._assets.indexOf(e);
      t >= 0 && this._assets.splice(t, 1);
    }
    async findAssetRegex(e) {
      for (const t of this._assets) {
        const r = t.find(t => {
          var r, n;
          return t && (e.test(t.path) || e.test(null !== (n = null === (r = t.file) || void 0 === r ? void 0 : r.name) && void 0 !== n ? n : ""));
        });
        if (r) return r;
      }
      console.warn("Asset not found:", e);
    }
    async findAsset(e) {
      return this.findAssetRegex(e.query);
    }
    async findAssetSimple(e, t = !1) {
      return this.findAssetRegex(new RegExp(e, t ? "i" : ""));
    }
  }
  var Zp = {},
    $p = function (e) {
      return URL.createObjectURL(new Blob([e], {
        type: "text/javascript"
      }));
    },
    ed = function (e) {
      return new Worker(e);
    };
  try {
    URL.revokeObjectURL($p(""));
  } catch (ru) {
    $p = function (e) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(e);
    }, ed = function (e) {
      return new Worker(e, {
        type: "module"
      });
    };
  }
  var td = Uint8Array,
    rd = Uint16Array,
    nd = Uint32Array,
    id = new td([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    sd = new td([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
    od = new td([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    ad = function (e, t) {
      for (var r = new rd(31), n = 0; n < 31; ++n) r[n] = t += 1 << e[n - 1];
      var i = new nd(r[30]);
      for (n = 1; n < 30; ++n) for (var s = r[n]; s < r[n + 1]; ++s) i[s] = s - r[n] << 5 | n;
      return [r, i];
    },
    ld = ad(id, 2),
    cd = ld[0],
    ud = ld[1];
  cd[28] = 258, ud[258] = 28;
  for (var hd = ad(sd, 0), pd = hd[0], dd = hd[1], fd = new rd(32768), md = 0; md < 32768; ++md) {
    var _d = (43690 & md) >>> 1 | (21845 & md) << 1;
    _d = (61680 & (_d = (52428 & _d) >>> 2 | (13107 & _d) << 2)) >>> 4 | (3855 & _d) << 4, fd[md] = ((65280 & _d) >>> 8 | (255 & _d) << 8) >>> 1;
  }
  var gd = function (e, t, r) {
      for (var n = e.length, i = 0, s = new rd(t); i < n; ++i) ++s[e[i] - 1];
      var o,
        a = new rd(t);
      for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;
      if (r) {
        o = new rd(1 << t);
        var l = 15 - t;
        for (i = 0; i < n; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], h = a[e[i] - 1]++ << u, p = h | (1 << u) - 1; h <= p; ++h) o[fd[h] >>> l] = c;
      } else for (o = new rd(n), i = 0; i < n; ++i) e[i] && (o[i] = fd[a[e[i] - 1]++] >>> 15 - e[i]);
      return o;
    },
    vd = new td(288);
  for (md = 0; md < 144; ++md) vd[md] = 8;
  for (md = 144; md < 256; ++md) vd[md] = 9;
  for (md = 256; md < 280; ++md) vd[md] = 7;
  for (md = 280; md < 288; ++md) vd[md] = 8;
  var Ad = new td(32);
  for (md = 0; md < 32; ++md) Ad[md] = 5;
  var bd = gd(vd, 9, 0),
    yd = gd(vd, 9, 1),
    xd = gd(Ad, 5, 0),
    wd = gd(Ad, 5, 1),
    Ed = function (e) {
      for (var t = e[0], r = 1; r < e.length; ++r) e[r] > t && (t = e[r]);
      return t;
    },
    Sd = function (e, t, r) {
      var n = t / 8 | 0;
      return (e[n] | e[n + 1] << 8) >> (7 & t) & r;
    },
    Cd = function (e, t) {
      var r = t / 8 | 0;
      return (e[r] | e[r + 1] << 8 | e[r + 2] << 16) >> (7 & t);
    },
    Md = function (e) {
      return (e / 8 | 0) + (7 & e && 1);
    },
    Td = function (e, t, r) {
      (null == t || t < 0) && (t = 0), (null == r || r > e.length) && (r = e.length);
      var n = new (e instanceof rd ? rd : e instanceof nd ? nd : td)(r - t);
      return n.set(e.subarray(t, r)), n;
    },
    Id = function (e, t, r) {
      var n = e.length;
      if (!n || r && !r.l && n < 5) return t || new td(0);
      var i = !t || r,
        s = !r || r.i;
      r || (r = {}), t || (t = new td(3 * n));
      var o = function (e) {
          var r = t.length;
          if (e > r) {
            var n = new td(Math.max(2 * r, e));
            n.set(t), t = n;
          }
        },
        a = r.f || 0,
        l = r.p || 0,
        c = r.b || 0,
        u = r.l,
        h = r.d,
        p = r.m,
        d = r.n,
        f = 8 * n;
      do {
        if (!u) {
          r.f = a = Sd(e, l, 1);
          var m = Sd(e, l + 1, 3);
          if (l += 3, !m) {
            var _ = e[(M = Md(l) + 4) - 4] | e[M - 3] << 8,
              g = M + _;
            if (g > n) {
              if (s) throw "unexpected EOF";
              break;
            }
            i && o(c + _), t.set(e.subarray(M, g), c), r.b = c += _, r.p = l = 8 * g;
            continue;
          }
          if (1 == m) u = yd, h = wd, p = 9, d = 5;else {
            if (2 != m) throw "invalid block type";
            var v = Sd(e, l, 31) + 257,
              A = Sd(e, l + 10, 15) + 4,
              b = v + Sd(e, l + 5, 31) + 1;
            l += 14;
            for (var y = new td(b), x = new td(19), w = 0; w < A; ++w) x[od[w]] = Sd(e, l + 3 * w, 7);
            l += 3 * A;
            var E = Ed(x),
              S = (1 << E) - 1,
              C = gd(x, E, 1);
            for (w = 0; w < b;) {
              var M,
                T = C[Sd(e, l, S)];
              if (l += 15 & T, (M = T >>> 4) < 16) y[w++] = M;else {
                var I = 0,
                  k = 0;
                for (16 == M ? (k = 3 + Sd(e, l, 3), l += 2, I = y[w - 1]) : 17 == M ? (k = 3 + Sd(e, l, 7), l += 3) : 18 == M && (k = 11 + Sd(e, l, 127), l += 7); k--;) y[w++] = I;
              }
            }
            var D = y.subarray(0, v),
              P = y.subarray(v);
            p = Ed(D), d = Ed(P), u = gd(D, p, 1), h = gd(P, d, 1);
          }
          if (l > f) {
            if (s) throw "unexpected EOF";
            break;
          }
        }
        i && o(c + 131072);
        for (var B = (1 << p) - 1, R = (1 << d) - 1, L = l;; L = l) {
          var O = (I = u[Cd(e, l) & B]) >>> 4;
          if ((l += 15 & I) > f) {
            if (s) throw "unexpected EOF";
            break;
          }
          if (!I) throw "invalid length/literal";
          if (O < 256) t[c++] = O;else {
            if (256 == O) {
              L = l, u = null;
              break;
            }
            var F = O - 254;
            if (O > 264) {
              var U = id[w = O - 257];
              F = Sd(e, l, (1 << U) - 1) + cd[w], l += U;
            }
            var N = h[Cd(e, l) & R],
              j = N >>> 4;
            if (!N) throw "invalid distance";
            if (l += 15 & N, P = pd[j], j > 3 && (U = sd[j], P += Cd(e, l) & (1 << U) - 1, l += U), l > f) {
              if (s) throw "unexpected EOF";
              break;
            }
            i && o(c + 131072);
            for (var z = c + F; c < z; c += 4) t[c] = t[c - P], t[c + 1] = t[c + 1 - P], t[c + 2] = t[c + 2 - P], t[c + 3] = t[c + 3 - P];
            c = z;
          }
        }
        r.l = u, r.p = L, r.b = c, u && (a = 1, r.m = p, r.d = h, r.n = d);
      } while (!a);
      return c == t.length ? t : Td(t, 0, c);
    },
    kd = function (e, t, r) {
      r <<= 7 & t;
      var n = t / 8 | 0;
      e[n] |= r, e[n + 1] |= r >>> 8;
    },
    Dd = function (e, t, r) {
      r <<= 7 & t;
      var n = t / 8 | 0;
      e[n] |= r, e[n + 1] |= r >>> 8, e[n + 2] |= r >>> 16;
    },
    Pd = function (e, t) {
      for (var r = [], n = 0; n < e.length; ++n) e[n] && r.push({
        s: n,
        f: e[n]
      });
      var i = r.length,
        s = r.slice();
      if (!i) return [Nd, 0];
      if (1 == i) {
        var o = new td(r[0].s + 1);
        return o[r[0].s] = 1, [o, 1];
      }
      r.sort(function (e, t) {
        return e.f - t.f;
      }), r.push({
        s: -1,
        f: 25001
      });
      var a = r[0],
        l = r[1],
        c = 0,
        u = 1,
        h = 2;
      for (r[0] = {
        s: -1,
        f: a.f + l.f,
        l: a,
        r: l
      }; u != i - 1;) a = r[r[c].f < r[h].f ? c++ : h++], l = r[c != u && r[c].f < r[h].f ? c++ : h++], r[u++] = {
        s: -1,
        f: a.f + l.f,
        l: a,
        r: l
      };
      var p = s[0].s;
      for (n = 1; n < i; ++n) s[n].s > p && (p = s[n].s);
      var d = new rd(p + 1),
        f = Bd(r[u - 1], d, 0);
      if (f > t) {
        n = 0;
        var m = 0,
          _ = f - t,
          g = 1 << _;
        for (s.sort(function (e, t) {
          return d[t.s] - d[e.s] || e.f - t.f;
        }); n < i; ++n) {
          var v = s[n].s;
          if (!(d[v] > t)) break;
          m += g - (1 << f - d[v]), d[v] = t;
        }
        for (m >>>= _; m > 0;) {
          var A = s[n].s;
          d[A] < t ? m -= 1 << t - d[A]++ - 1 : ++n;
        }
        for (; n >= 0 && m; --n) {
          var b = s[n].s;
          d[b] == t && (--d[b], ++m);
        }
        f = t;
      }
      return [new td(d), f];
    },
    Bd = function (e, t, r) {
      return -1 == e.s ? Math.max(Bd(e.l, t, r + 1), Bd(e.r, t, r + 1)) : t[e.s] = r;
    },
    Rd = function (e) {
      for (var t = e.length; t && !e[--t];);
      for (var r = new rd(++t), n = 0, i = e[0], s = 1, o = function (e) {
          r[n++] = e;
        }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
        if (!i && s > 2) {
          for (; s > 138; s -= 138) o(32754);
          s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
        } else if (s > 3) {
          for (o(i), --s; s > 6; s -= 6) o(8304);
          s > 2 && (o(s - 3 << 5 | 8208), s = 0);
        }
        for (; s--;) o(i);
        s = 1, i = e[a];
      }
      return [r.subarray(0, n), t];
    },
    Ld = function (e, t) {
      for (var r = 0, n = 0; n < t.length; ++n) r += e[n] * t[n];
      return r;
    },
    Od = function (e, t, r) {
      var n = r.length,
        i = Md(t + 2);
      e[i] = 255 & n, e[i + 1] = n >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
      for (var s = 0; s < n; ++s) e[i + s + 4] = r[s];
      return 8 * (i + 4 + n);
    },
    Fd = function (e, t, r, n, i, s, o, a, l, c, u) {
      kd(t, u++, r), ++i[256];
      for (var h = Pd(i, 15), p = h[0], d = h[1], f = Pd(s, 15), m = f[0], _ = f[1], g = Rd(p), v = g[0], A = g[1], b = Rd(m), y = b[0], x = b[1], w = new rd(19), E = 0; E < v.length; ++E) w[31 & v[E]]++;
      for (E = 0; E < y.length; ++E) w[31 & y[E]]++;
      for (var S = Pd(w, 7), C = S[0], M = S[1], T = 19; T > 4 && !C[od[T - 1]]; --T);
      var I,
        k,
        D,
        P,
        B = c + 5 << 3,
        R = Ld(i, vd) + Ld(s, Ad) + o,
        L = Ld(i, p) + Ld(s, m) + o + 14 + 3 * T + Ld(w, C) + (2 * w[16] + 3 * w[17] + 7 * w[18]);
      if (B <= R && B <= L) return Od(t, u, e.subarray(l, l + c));
      if (kd(t, u, 1 + (L < R)), u += 2, L < R) {
        I = gd(p, d, 0), k = p, D = gd(m, _, 0), P = m;
        var O = gd(C, M, 0);
        for (kd(t, u, A - 257), kd(t, u + 5, x - 1), kd(t, u + 10, T - 4), u += 14, E = 0; E < T; ++E) kd(t, u + 3 * E, C[od[E]]);
        u += 3 * T;
        for (var F = [v, y], U = 0; U < 2; ++U) {
          var N = F[U];
          for (E = 0; E < N.length; ++E) {
            var j = 31 & N[E];
            kd(t, u, O[j]), u += C[j], j > 15 && (kd(t, u, N[E] >>> 5 & 127), u += N[E] >>> 12);
          }
        }
      } else I = bd, k = vd, D = xd, P = Ad;
      for (E = 0; E < a; ++E) if (n[E] > 255) {
        j = n[E] >>> 18 & 31, Dd(t, u, I[j + 257]), u += k[j + 257], j > 7 && (kd(t, u, n[E] >>> 23 & 31), u += id[j]);
        var z = 31 & n[E];
        Dd(t, u, D[z]), u += P[z], z > 3 && (Dd(t, u, n[E] >>> 5 & 8191), u += sd[z]);
      } else Dd(t, u, I[n[E]]), u += k[n[E]];
      return Dd(t, u, I[256]), u + k[256];
    },
    Ud = new nd([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
    Nd = new td(0),
    jd = function (e, t, r, n, i, s) {
      var o = e.length,
        a = new td(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(n, a.length - i),
        c = 0;
      if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
        var h = u + 65535;
        h < o ? c = Od(l, c, e.subarray(u, h)) : (l[u] = s, c = Od(l, c, e.subarray(u, o)));
      } else {
        for (var p = Ud[t - 1], d = p >>> 13, f = 8191 & p, m = (1 << r) - 1, _ = new rd(32768), g = new rd(m + 1), v = Math.ceil(r / 3), A = 2 * v, b = function (t) {
            return (e[t] ^ e[t + 1] << v ^ e[t + 2] << A) & m;
          }, y = new nd(25e3), x = new rd(288), w = new rd(32), E = 0, S = 0, C = (u = 0, 0), M = 0, T = 0; u < o; ++u) {
          var I = b(u),
            k = 32767 & u,
            D = g[I];
          if (_[k] = D, g[I] = k, M <= u) {
            var P = o - u;
            if ((E > 7e3 || C > 24576) && P > 423) {
              c = Fd(e, l, 0, y, x, w, S, C, T, u - T, c), C = E = S = 0, T = u;
              for (var B = 0; B < 286; ++B) x[B] = 0;
              for (B = 0; B < 30; ++B) w[B] = 0;
            }
            var R = 2,
              L = 0,
              O = f,
              F = k - D & 32767;
            if (P > 2 && I == b(u - F)) for (var U = Math.min(d, P) - 1, N = Math.min(32767, u), j = Math.min(258, P); F <= N && --O && k != D;) {
              if (e[u + R] == e[u + R - F]) {
                for (var z = 0; z < j && e[u + z] == e[u + z - F]; ++z);
                if (z > R) {
                  if (R = z, L = F, z > U) break;
                  var G = Math.min(F, z - 2),
                    V = 0;
                  for (B = 0; B < G; ++B) {
                    var Q = u - F + B + 32768 & 32767,
                      H = Q - _[Q] + 32768 & 32767;
                    H > V && (V = H, D = Q);
                  }
                }
              }
              F += (k = D) - (D = _[k]) + 32768 & 32767;
            }
            if (L) {
              y[C++] = 268435456 | ud[R] << 18 | dd[L];
              var W = 31 & ud[R],
                q = 31 & dd[L];
              S += id[W] + sd[q], ++x[257 + W], ++w[q], M = u + R, ++E;
            } else y[C++] = e[u], ++x[e[u]];
          }
        }
        c = Fd(e, l, s, y, x, w, S, C, T, u - T, c), !s && 7 & c && (c = Od(l, c + 1, Nd));
      }
      return Td(a, 0, n + Md(c) + i);
    },
    zd = function () {
      for (var e = new nd(256), t = 0; t < 256; ++t) {
        for (var r = t, n = 9; --n;) r = (1 & r && 3988292384) ^ r >>> 1;
        e[t] = r;
      }
      return e;
    }(),
    Gd = function () {
      var e = -1;
      return {
        p: function (t) {
          for (var r = e, n = 0; n < t.length; ++n) r = zd[255 & r ^ t[n]] ^ r >>> 8;
          e = r;
        },
        d: function () {
          return ~e;
        }
      };
    },
    Vd = function () {
      var e = 1,
        t = 0;
      return {
        p: function (r) {
          for (var n = e, i = t, s = r.length, o = 0; o != s;) {
            for (var a = Math.min(o + 2655, s); o < a; ++o) i += n += r[o];
            n = (65535 & n) + 15 * (n >> 16), i = (65535 & i) + 15 * (i >> 16);
          }
          e = n, t = i;
        },
        d: function () {
          return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
        }
      };
    },
    Qd = function (e, t, r, n, i) {
      return jd(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, r, n, !i);
    },
    Hd = function (e, t) {
      var r = {};
      for (var n in e) r[n] = e[n];
      for (var n in t) r[n] = t[n];
      return r;
    },
    Wd = function (e, t, r) {
      for (var n = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < n.length; ++o) {
        var a = n[o],
          l = s[o];
        if ("function" == typeof a) {
          t += ";" + l + "=";
          var c = a.toString();
          if (a.prototype) {
            if (-1 != c.indexOf("[native code]")) {
              var u = c.indexOf(" ", 8) + 1;
              t += c.slice(u, c.indexOf("(", u));
            } else for (var h in t += c, a.prototype) t += ";" + l + ".prototype." + h + "=" + a.prototype[h].toString();
          } else t += c;
        } else r[l] = a;
      }
      return [t, r];
    },
    qd = [],
    Xd = function (e, t, r, n) {
      var i;
      if (!qd[r]) {
        for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = Wd(e[l], s, o))[0], o = i[1];
        qd[r] = Wd(e[a], s, o);
      }
      var c = Hd({}, qd[r][1]);
      return function (e, t, r, n, i) {
        var s = ed(Zp[t] || (Zp[t] = $p(e)));
        return s.onerror = function (e) {
          return i(e.error, null);
        }, s.onmessage = function (e) {
          return i(null, e.data);
        }, s.postMessage(r, n), s;
      }(qd[r][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", r, c, function (e) {
        var t = [];
        for (var r in e) (e[r] instanceof td || e[r] instanceof rd || e[r] instanceof nd) && t.push((e[r] = new e[r].constructor(e[r])).buffer);
        return t;
      }(c), n);
    },
    Yd = function () {
      return [td, rd, nd, id, sd, od, cd, pd, yd, wd, fd, gd, Ed, Sd, Cd, Md, Td, Id, Sf, tf, rf];
    },
    Kd = function () {
      return [td, rd, nd, id, sd, od, ud, dd, bd, vd, xd, Ad, fd, Ud, Nd, gd, kd, Dd, Pd, Bd, Rd, Ld, Od, Fd, Md, Td, jd, Qd, yf, tf];
    },
    Jd = function () {
      return [hf, ff, uf, Gd, zd];
    },
    Zd = function () {
      return [pf, df];
    },
    $d = function () {
      return [mf, uf, Vd];
    },
    ef = function () {
      return [_f];
    },
    tf = function (e) {
      return postMessage(e, [e.buffer]);
    },
    rf = function (e) {
      return e && e.size && new td(e.size);
    },
    nf = function (e, t, r, n, i, s) {
      var o = Xd(r, n, i, function (e, t) {
        o.terminate(), s(e, t);
      });
      return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
        o.terminate();
      };
    },
    sf = function (e) {
      return e.ondata = function (e, t) {
        return postMessage([e, t], [e.buffer]);
      }, function (t) {
        return e.push(t.data[0], t.data[1]);
      };
    },
    of = function (e, t, r, n, i) {
      var s,
        o = Xd(e, n, i, function (e, r) {
          e ? (o.terminate(), t.ondata.call(t, e)) : (r[1] && o.terminate(), t.ondata.call(t, e, r[0], r[1]));
        });
      o.postMessage(r), t.push = function (e, r) {
        if (s) throw "stream finished";
        if (!t.ondata) throw "no stream handler";
        o.postMessage([e, s = r], [e.buffer]);
      }, t.terminate = function () {
        o.terminate();
      };
    },
    af = function (e, t) {
      return e[t] | e[t + 1] << 8;
    },
    lf = function (e, t) {
      return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
    },
    cf = function (e, t) {
      return lf(e, t) + 4294967296 * lf(e, t + 4);
    },
    uf = function (e, t, r) {
      for (; r; ++t) e[t] = r, r >>>= 8;
    },
    hf = function (e, t) {
      var r = t.filename;
      if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && uf(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), r) {
        e[3] = 8;
        for (var n = 0; n <= r.length; ++n) e[n + 10] = r.charCodeAt(n);
      }
    },
    pf = function (e) {
      if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
      var t = e[3],
        r = 10;
      4 & t && (r += e[10] | 2 + (e[11] << 8));
      for (var n = (t >> 3 & 1) + (t >> 4 & 1); n > 0; n -= !e[r++]);
      return r + (2 & t);
    },
    df = function (e) {
      var t = e.length;
      return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
    },
    ff = function (e) {
      return 10 + (e.filename && e.filename.length + 1 || 0);
    },
    mf = function (e, t) {
      var r = t.level,
        n = 0 == r ? 0 : r < 6 ? 1 : 9 == r ? 3 : 2;
      e[0] = 120, e[1] = n << 6 | (n ? 32 - 2 * n : 1);
    },
    _f = function (e) {
      if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
      if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
    };
  function gf(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }
  var vf = function () {
      function e(e, t) {
        t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
      }
      return e.prototype.p = function (e, t) {
        this.ondata(Qd(e, this.o, 0, 0, !t), t);
      }, e.prototype.push = function (e, t) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        this.d = t, this.p(e, t || !1);
      }, e;
    }(),
    Af = function () {
      return function (e, t) {
        of([Kd, function () {
          return [sf, vf];
        }], this, gf.call(this, e, t), function (e) {
          var t = new vf(e.data);
          onmessage = sf(t);
        }, 6);
      };
    }();
  function bf(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Kd], function (e) {
      return tf(yf(e.data[0], e.data[1]));
    }, 0, r);
  }
  function yf(e, t) {
    return Qd(e, t || {}, 0, 0);
  }
  var xf = function () {
      function e(e) {
        this.s = {}, this.p = new td(0), this.ondata = e;
      }
      return e.prototype.e = function (e) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        var t = this.p.length,
          r = new td(t + e.length);
        r.set(this.p), r.set(e, t), this.p = r;
      }, e.prototype.c = function (e) {
        this.d = this.s.i = e || !1;
        var t = this.s.b,
          r = Id(this.p, this.o, this.s);
        this.ondata(Td(r, t, this.s.b), this.d), this.o = Td(r, this.s.b - 32768), this.s.b = this.o.length, this.p = Td(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      }, e.prototype.push = function (e, t) {
        this.e(e), this.c(t);
      }, e;
    }(),
    wf = function () {
      return function (e) {
        this.ondata = e, of([Yd, function () {
          return [sf, xf];
        }], this, 0, function () {
          var e = new xf();
          onmessage = sf(e);
        }, 7);
      };
    }();
  function Ef(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Yd], function (e) {
      return tf(Sf(e.data[0], rf(e.data[1])));
    }, 1, r);
  }
  function Sf(e, t) {
    return Id(e, t);
  }
  var Cf = function () {
      function e(e, t) {
        this.c = Gd(), this.l = 0, this.v = 1, vf.call(this, e, t);
      }
      return e.prototype.push = function (e, t) {
        vf.prototype.push.call(this, e, t);
      }, e.prototype.p = function (e, t) {
        this.c.p(e), this.l += e.length;
        var r = Qd(e, this.o, this.v && ff(this.o), t && 8, !t);
        this.v && (hf(r, this.o), this.v = 0), t && (uf(r, r.length - 8, this.c.d()), uf(r, r.length - 4, this.l)), this.ondata(r, t);
      }, e;
    }(),
    Mf = function () {
      return function (e, t) {
        of([Kd, Jd, function () {
          return [sf, vf, Cf];
        }], this, gf.call(this, e, t), function (e) {
          var t = new Cf(e.data);
          onmessage = sf(t);
        }, 8);
      };
    }();
  function Tf(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Kd, Jd, function () {
      return [If];
    }], function (e) {
      return tf(If(e.data[0], e.data[1]));
    }, 2, r);
  }
  function If(e, t) {
    t || (t = {});
    var r = Gd(),
      n = e.length;
    r.p(e);
    var i = Qd(e, t, ff(t), 8),
      s = i.length;
    return hf(i, t), uf(i, s - 8, r.d()), uf(i, s - 4, n), i;
  }
  var kf = function () {
      function e(e) {
        this.v = 1, xf.call(this, e);
      }
      return e.prototype.push = function (e, t) {
        if (xf.prototype.e.call(this, e), this.v) {
          var r = this.p.length > 3 ? pf(this.p) : 4;
          if (r >= this.p.length && !t) return;
          this.p = this.p.subarray(r), this.v = 0;
        }
        if (t) {
          if (this.p.length < 8) throw "invalid gzip stream";
          this.p = this.p.subarray(0, -8);
        }
        xf.prototype.c.call(this, t);
      }, e;
    }(),
    Df = function () {
      return function (e) {
        this.ondata = e, of([Yd, Zd, function () {
          return [sf, xf, kf];
        }], this, 0, function () {
          var e = new kf();
          onmessage = sf(e);
        }, 9);
      };
    }();
  function Pf(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Yd, Zd, function () {
      return [Bf];
    }], function (e) {
      return tf(Bf(e.data[0]));
    }, 3, r);
  }
  function Bf(e, t) {
    return Id(e.subarray(pf(e), -8), t || new td(df(e)));
  }
  var Rf = function () {
      function e(e, t) {
        this.c = Vd(), this.v = 1, vf.call(this, e, t);
      }
      return e.prototype.push = function (e, t) {
        vf.prototype.push.call(this, e, t);
      }, e.prototype.p = function (e, t) {
        this.c.p(e);
        var r = Qd(e, this.o, this.v && 2, t && 4, !t);
        this.v && (mf(r, this.o), this.v = 0), t && uf(r, r.length - 4, this.c.d()), this.ondata(r, t);
      }, e;
    }(),
    Lf = function () {
      return function (e, t) {
        of([Kd, $d, function () {
          return [sf, vf, Rf];
        }], this, gf.call(this, e, t), function (e) {
          var t = new Rf(e.data);
          onmessage = sf(t);
        }, 10);
      };
    }();
  function Of(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Kd, $d, function () {
      return [Ff];
    }], function (e) {
      return tf(Ff(e.data[0], e.data[1]));
    }, 4, r);
  }
  function Ff(e, t) {
    t || (t = {});
    var r = Vd();
    r.p(e);
    var n = Qd(e, t, 2, 4);
    return mf(n, t), uf(n, n.length - 4, r.d()), n;
  }
  var Uf = function () {
      function e(e) {
        this.v = 1, xf.call(this, e);
      }
      return e.prototype.push = function (e, t) {
        if (xf.prototype.e.call(this, e), this.v) {
          if (this.p.length < 2 && !t) return;
          this.p = this.p.subarray(2), this.v = 0;
        }
        if (t) {
          if (this.p.length < 4) throw "invalid zlib stream";
          this.p = this.p.subarray(0, -4);
        }
        xf.prototype.c.call(this, t);
      }, e;
    }(),
    Nf = function () {
      return function (e) {
        this.ondata = e, of([Yd, ef, function () {
          return [sf, xf, Uf];
        }], this, 0, function () {
          var e = new Uf();
          onmessage = sf(e);
        }, 11);
      };
    }();
  function jf(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return nf(e, t, [Yd, ef, function () {
      return [zf];
    }], function (e) {
      return tf(zf(e.data[0], rf(e.data[1])));
    }, 5, r);
  }
  function zf(e, t) {
    return Id((_f(e), e.subarray(2, -4)), t);
  }
  var Gf = function () {
      function e(e) {
        this.G = kf, this.I = xf, this.Z = Uf, this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no stream handler";
        if (this.s) this.s.push(e, t);else {
          if (this.p && this.p.length) {
            var r = new td(this.p.length + e.length);
            r.set(this.p), r.set(e, this.p.length);
          } else this.p = e;
          if (this.p.length > 2) {
            var n = this,
              i = function () {
                n.ondata.apply(n, arguments);
              };
            this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
          }
        }
      }, e;
    }(),
    Vf = function () {
      function e(e) {
        this.G = Df, this.I = wf, this.Z = Nf, this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        Gf.prototype.push.call(this, e, t);
      }, e;
    }();
  function Qf(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Pf(e, t, r) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ef(e, t, r) : jf(e, t, r);
  }
  function Hf(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Bf(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Sf(e, t) : zf(e, t);
  }
  var Wf = function (e, t, r, n) {
      for (var i in e) {
        var s = e[i],
          o = t + i;
        s instanceof td ? r[o] = [s, n] : Array.isArray(s) ? r[o] = [s[0], Hd(n, s[1])] : Wf(s, o + "/", r, n);
      }
    },
    qf = "undefined" != typeof TextEncoder && new TextEncoder(),
    Xf = "undefined" != typeof TextDecoder && new TextDecoder(),
    Yf = 0;
  try {
    Xf.decode(Nd, {
      stream: !0
    }), Yf = 1;
  } catch (ru) {}
  var Kf = function (e) {
      for (var t = "", r = 0;;) {
        var n = e[r++],
          i = (n > 127) + (n > 223) + (n > 239);
        if (r + i > e.length) return [t, Td(e, r - 1)];
        i ? 3 == i ? (n = ((15 & n) << 18 | (63 & e[r++]) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) - 65536, t += String.fromCharCode(55296 | n >> 10, 56320 | 1023 & n)) : t += 1 & i ? String.fromCharCode((31 & n) << 6 | 63 & e[r++]) : String.fromCharCode((15 & n) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) : t += String.fromCharCode(n);
      }
    },
    Jf = function () {
      function e(e) {
        this.ondata = e, Yf ? this.t = new TextDecoder() : this.p = Nd;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (t = !!t, this.t) {
          if (this.ondata(this.t.decode(e, {
            stream: !0
          }), t), t) {
            if (this.t.decode().length) throw "invalid utf-8 data";
            this.t = null;
          }
        } else {
          if (!this.p) throw "stream finished";
          var r = new td(this.p.length + e.length);
          r.set(this.p), r.set(e, this.p.length);
          var n = Kf(r),
            i = n[0],
            s = n[1];
          if (t) {
            if (s.length) throw "invalid utf-8 data";
            this.p = null;
          } else this.p = s;
          this.ondata(i, t);
        }
      }, e;
    }(),
    Zf = function () {
      function e(e) {
        this.ondata = e;
      }
      return e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (this.d) throw "stream finished";
        this.ondata($f(e), this.d = t || !1);
      }, e;
    }();
  function $f(e, t) {
    if (t) {
      for (var r = new td(e.length), n = 0; n < e.length; ++n) r[n] = e.charCodeAt(n);
      return r;
    }
    if (qf) return qf.encode(e);
    var i = e.length,
      s = new td(e.length + (e.length >> 1)),
      o = 0,
      a = function (e) {
        s[o++] = e;
      };
    for (n = 0; n < i; ++n) {
      if (o + 5 > s.length) {
        var l = new td(o + 8 + (i - n << 1));
        l.set(s), s = l;
      }
      var c = e.charCodeAt(n);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++n)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }
    return Td(s, 0, o);
  }
  function em(e, t) {
    if (t) {
      for (var r = "", n = 0; n < e.length; n += 16384) r += String.fromCharCode.apply(null, e.subarray(n, n + 16384));
      return r;
    }
    if (Xf) return Xf.decode(e);
    var i = Kf(e),
      s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }
  var tm = function (e) {
      return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
    },
    rm = function (e, t) {
      return t + 30 + af(e, t + 26) + af(e, t + 28);
    },
    nm = function (e, t, r) {
      var n = af(e, t + 28),
        i = em(e.subarray(t + 46, t + 46 + n), !(2048 & af(e, t + 8))),
        s = t + 46 + n,
        o = lf(e, t + 20),
        a = r && 4294967295 == o ? im(e, s) : [o, lf(e, t + 24), lf(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
      return [af(e, t + 10), l, c, i, s + af(e, t + 30) + af(e, t + 32), u];
    },
    im = function (e, t) {
      for (; 1 != af(e, t); t += 4 + af(e, t + 2));
      return [cf(e, t + 12), cf(e, t + 4), cf(e, t + 20)];
    },
    sm = function (e) {
      var t = 0;
      if (e) for (var r in e) {
        var n = e[r].length;
        if (n > 65535) throw "extra field too long";
        t += n + 4;
      }
      return t;
    },
    om = function (e, t, r, n, i, s, o, a) {
      var l = n.length,
        c = r.extra,
        u = a && a.length,
        h = sm(c);
      uf(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = r.os), e[t] = 20, t += 2, e[t++] = r.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & r.compression, e[t++] = r.compression >> 8;
      var p = new Date(null == r.mtime ? Date.now() : r.mtime),
        d = p.getFullYear() - 1980;
      if (d < 0 || d > 119) throw "date not in range 1980-2099";
      if (uf(e, t, d << 25 | p.getMonth() + 1 << 21 | p.getDate() << 16 | p.getHours() << 11 | p.getMinutes() << 5 | p.getSeconds() >>> 1), t += 4, null != s && (uf(e, t, r.crc), uf(e, t + 4, s), uf(e, t + 8, r.size)), uf(e, t + 12, l), uf(e, t + 14, h), t += 16, null != o && (uf(e, t, u), uf(e, t + 6, r.attrs), uf(e, t + 10, o), t += 14), e.set(n, t), t += l, h) for (var f in c) {
        var m = c[f],
          _ = m.length;
        uf(e, t, +f), uf(e, t + 2, _), e.set(m, t + 4), t += 4 + _;
      }
      return u && (e.set(a, t), t += u), t;
    },
    am = function (e, t, r, n, i) {
      uf(e, t, 101010256), uf(e, t + 8, r), uf(e, t + 10, r), uf(e, t + 12, n), uf(e, t + 16, i);
    },
    lm = function () {
      function e(e) {
        this.filename = e, this.c = Gd(), this.size = 0, this.compression = 0;
      }
      return e.prototype.process = function (e, t) {
        this.ondata(null, e, t);
      }, e.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
        this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
      }, e;
    }(),
    cm = function () {
      function e(e, t) {
        var r = this;
        t || (t = {}), lm.call(this, e), this.d = new vf(t, function (e, t) {
          r.ondata(null, e, t);
        }), this.compression = 8, this.flag = tm(t.level);
      }
      return e.prototype.process = function (e, t) {
        try {
          this.d.push(e, t);
        } catch (e) {
          this.ondata(e, null, t);
        }
      }, e.prototype.push = function (e, t) {
        lm.prototype.push.call(this, e, t);
      }, e;
    }(),
    um = function () {
      function e(e, t) {
        var r = this;
        t || (t = {}), lm.call(this, e), this.d = new Af(t, function (e, t, n) {
          r.ondata(e, t, n);
        }), this.compression = 8, this.flag = tm(t.level), this.terminate = this.d.terminate;
      }
      return e.prototype.process = function (e, t) {
        this.d.push(e, t);
      }, e.prototype.push = function (e, t) {
        lm.prototype.push.call(this, e, t);
      }, e;
    }(),
    hm = function () {
      function e(e) {
        this.ondata = e, this.u = [], this.d = 1;
      }
      return e.prototype.add = function (e) {
        var t = this;
        if (2 & this.d) throw "stream finished";
        var r = $f(e.filename),
          n = r.length,
          i = e.comment,
          s = i && $f(i),
          o = n != e.filename.length || s && i.length != s.length,
          a = n + sm(e.extra) + 30;
        if (n > 65535) throw "filename too long";
        var l = new td(a);
        om(l, 0, e, r, o);
        var c = [l],
          u = function () {
            for (var e = 0, r = c; e < r.length; e++) {
              var n = r[e];
              t.ondata(null, n, !1);
            }
            c = [];
          },
          h = this.d;
        this.d = 0;
        var p = this.u.length,
          d = Hd(e, {
            f: r,
            u: o,
            o: s,
            t: function () {
              e.terminate && e.terminate();
            },
            r: function () {
              if (u(), h) {
                var e = t.u[p + 1];
                e ? e.r() : t.d = 1;
              }
              h = 1;
            }
          }),
          f = 0;
        e.ondata = function (r, n, i) {
          if (r) t.ondata(r, n, i), t.terminate();else if (f += n.length, c.push(n), i) {
            var s = new td(16);
            uf(s, 0, 134695760), uf(s, 4, e.crc), uf(s, 8, f), uf(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, h && d.r(), h = 1;
          } else h && u();
        }, this.u.push(d);
      }, e.prototype.end = function () {
        var e = this;
        if (2 & this.d) {
          if (1 & this.d) throw "stream finishing";
          throw "stream finished";
        }
        this.d ? this.e() : this.u.push({
          r: function () {
            1 & e.d && (e.u.splice(-1, 1), e.e());
          },
          t: function () {}
        }), this.d = 3;
      }, e.prototype.e = function () {
        for (var e = 0, t = 0, r = 0, n = 0, i = this.u; n < i.length; n++) r += 46 + (l = i[n]).f.length + sm(l.extra) + (l.o ? l.o.length : 0);
        for (var s = new td(r + 22), o = 0, a = this.u; o < a.length; o++) {
          var l = a[o];
          om(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + sm(l.extra) + (l.o ? l.o.length : 0), t += l.b;
        }
        am(s, e, this.u.length, r, t), this.ondata(null, s, !0), this.d = 2;
      }, e.prototype.terminate = function () {
        for (var e = 0, t = this.u; e < t.length; e++) t[e].t();
        this.d = 2;
      }, e;
    }();
  function pm(e, t, r) {
    if (r || (r = t, t = {}), "function" != typeof r) throw "no callback";
    var n = {};
    Wf(e, "", n, t);
    var i = Object.keys(n),
      s = i.length,
      o = 0,
      a = 0,
      l = s,
      c = new Array(s),
      u = [],
      h = function () {
        for (var e = 0; e < u.length; ++e) u[e]();
      },
      p = function () {
        var e = new td(a + 22),
          t = o,
          n = a - o;
        a = 0;
        for (var i = 0; i < l; ++i) {
          var s = c[i];
          try {
            var u = s.c.length;
            om(e, a, s, s.f, s.u, u);
            var h = 30 + s.f.length + sm(s.extra),
              p = a + h;
            e.set(s.c, p), om(e, o, s, s.f, s.u, u, a, s.m), o += 16 + h + (s.m ? s.m.length : 0), a = p + u;
          } catch (e) {
            return r(e, null);
          }
        }
        am(e, o, c.length, n, t), r(null, e);
      };
    s || p();
    for (var d = function (e) {
        var t = i[e],
          l = n[t],
          d = l[0],
          f = l[1],
          m = Gd(),
          _ = d.length;
        m.p(d);
        var g = $f(t),
          v = g.length,
          A = f.comment,
          b = A && $f(A),
          y = b && b.length,
          x = sm(f.extra),
          w = 0 == f.level ? 0 : 8,
          E = function (n, i) {
            if (n) h(), r(n, null);else {
              var l = i.length;
              c[e] = Hd(f, {
                size: _,
                crc: m.d(),
                c: i,
                f: g,
                m: b,
                u: v != t.length || b && A.length != y,
                compression: w
              }), o += 30 + v + x + l, a += 76 + 2 * (v + x) + (y || 0) + l, --s || p();
            }
          };
        if (v > 65535 && E("filename too long", null), w) {
          if (_ < 16e4) try {
            E(null, yf(d, f));
          } catch (e) {
            E(e, null);
          } else u.push(bf(d, f, E));
        } else E(null, d);
      }, f = 0; f < l; ++f) d(f);
    return h;
  }
  function dm(e, t) {
    t || (t = {});
    var r = {},
      n = [];
    Wf(e, "", r, t);
    var i = 0,
      s = 0;
    for (var o in r) {
      var a = r[o],
        l = a[0],
        c = a[1],
        u = 0 == c.level ? 0 : 8,
        h = (w = $f(o)).length,
        p = c.comment,
        d = p && $f(p),
        f = d && d.length,
        m = sm(c.extra);
      if (h > 65535) throw "filename too long";
      var _ = u ? yf(l, c) : l,
        g = _.length,
        v = Gd();
      v.p(l), n.push(Hd(c, {
        size: l.length,
        crc: v.d(),
        c: _,
        f: w,
        m: d,
        u: h != o.length || d && p.length != f,
        o: i,
        compression: u
      })), i += 30 + h + m + g, s += 76 + 2 * (h + m) + (f || 0) + g;
    }
    for (var A = new td(s + 22), b = i, y = s - i, x = 0; x < n.length; ++x) {
      var w = n[x];
      om(A, w.o, w, w.f, w.u, w.c.length);
      var E = 30 + w.f.length + sm(w.extra);
      A.set(w.c, w.o + E), om(A, i, w, w.f, w.u, w.c.length, w.o, w.m), i += 16 + E + (w.m ? w.m.length : 0);
    }
    return am(A, i, n.length, y, b), A;
  }
  var fm = function () {
      function e() {}
      return e.prototype.push = function (e, t) {
        this.ondata(null, e, t);
      }, e.compression = 0, e;
    }(),
    mm = function () {
      function e() {
        var e = this;
        this.i = new xf(function (t, r) {
          e.ondata(null, t, r);
        });
      }
      return e.prototype.push = function (e, t) {
        try {
          this.i.push(e, t);
        } catch (r) {
          this.ondata(r, e, t);
        }
      }, e.compression = 8, e;
    }(),
    _m = function () {
      function e(e, t) {
        var r = this;
        t < 32e4 ? this.i = new xf(function (e, t) {
          r.ondata(null, e, t);
        }) : (this.i = new wf(function (e, t, n) {
          r.ondata(e, t, n);
        }), this.terminate = this.i.terminate);
      }
      return e.prototype.push = function (e, t) {
        this.i.terminate && (e = Td(e, 0)), this.i.push(e, t);
      }, e.compression = 8, e;
    }(),
    gm = function () {
      function e(e) {
        this.onfile = e, this.k = [], this.o = {
          0: fm
        }, this.p = Nd;
      }
      return e.prototype.push = function (e, t) {
        var r = this;
        if (!this.onfile) throw "no callback";
        if (!this.p) throw "stream finished";
        if (this.c > 0) {
          var n = Math.min(this.c, e.length),
            i = e.subarray(0, n);
          if (this.c -= n, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(n)).length) return this.push(e, t);
        } else {
          var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
          this.p.length ? e.length ? ((l = new td(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
          for (var c = l.length, u = this.c, h = u && this.d, p = function () {
              var e,
                t = lf(l, o);
              if (67324752 == t) {
                s = 1, a = o, d.d = null, d.c = 0;
                var n = af(l, o + 6),
                  i = af(l, o + 8),
                  h = 2048 & n,
                  p = 8 & n,
                  f = af(l, o + 26),
                  m = af(l, o + 28);
                if (c > o + 30 + f + m) {
                  var _ = [];
                  d.k.unshift(_), s = 2;
                  var g,
                    v = lf(l, o + 18),
                    A = lf(l, o + 22),
                    b = em(l.subarray(o + 30, o += 30 + f), !h);
                  4294967295 == v ? (e = p ? [-2] : im(l, o), v = e[0], A = e[1]) : p && (v = -1), o += m, d.c = v;
                  var y = {
                    name: b,
                    compression: i,
                    start: function () {
                      if (!y.ondata) throw "no callback";
                      if (v) {
                        var e = r.o[i];
                        if (!e) throw "unknown compression type " + i;
                        (g = v < 0 ? new e(b) : new e(b, v, A)).ondata = function (e, t, r) {
                          y.ondata(e, t, r);
                        };
                        for (var t = 0, n = _; t < n.length; t++) {
                          var s = n[t];
                          g.push(s, !1);
                        }
                        r.k[0] == _ && r.c ? r.d = g : g.push(Nd, !0);
                      } else y.ondata(null, Nd, !0);
                    },
                    terminate: function () {
                      g && g.terminate && g.terminate();
                    }
                  };
                  v >= 0 && (y.size = v, y.originalSize = A), d.onfile(y);
                }
                return "break";
              }
              if (u) {
                if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
                if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
              }
            }, d = this; o < c - 4 && "break" !== p(); ++o);
          if (this.p = Nd, u < 0) {
            var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == lf(l, a - 16) && 4)) : l.subarray(0, o);
            h ? h.push(f, !!s) : this.k[+(2 == s)].push(f);
          }
          if (2 & s) return this.push(l.subarray(o), t);
          this.p = l.subarray(o);
        }
        if (t) {
          if (this.c) throw "invalid zip file";
          this.p = null;
        }
      }, e.prototype.register = function (e) {
        this.o[e.compression] = e;
      }, e;
    }();
  function vm(e, t) {
    if ("function" != typeof t) throw "no callback";
    for (var r = [], n = function () {
        for (var e = 0; e < r.length; ++e) r[e]();
      }, i = {}, s = e.length - 22; 101010256 != lf(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);
    var o = af(e, s + 8);
    o || t(null, {});
    var a = o,
      l = lf(e, s + 16),
      c = 4294967295 == l;
    if (c) {
      if (s = lf(e, s - 12), 101075792 != lf(e, s)) return void t("invalid zip file", null);
      a = o = lf(e, s + 32), l = lf(e, s + 48);
    }
    for (var u = function (s) {
        var a = nm(e, l, c),
          u = a[0],
          h = a[1],
          p = a[2],
          d = a[3],
          f = a[4],
          m = a[5],
          _ = rm(e, m);
        l = f;
        var g = function (e, r) {
          e ? (n(), t(e, null)) : (i[d] = r, --o || t(null, i));
        };
        if (u) {
          if (8 == u) {
            var v = e.subarray(_, _ + h);
            if (h < 32e4) try {
              g(null, Sf(v, new td(p)));
            } catch (e) {
              g(e, null);
            } else r.push(Ef(v, {
              size: p
            }, g));
          } else g("unknown compression type " + u, null);
        } else g(null, Td(e, _, _ + h));
      }, h = 0; h < a; ++h) u();
    return n;
  }
  function Am(e) {
    for (var t = {}, r = e.length - 22; 101010256 != lf(e, r); --r) if (!r || e.length - r > 65558) throw "invalid zip file";
    var n = af(e, r + 8);
    if (!n) return {};
    var i = lf(e, r + 16),
      s = 4294967295 == i;
    if (s) {
      if (r = lf(e, r - 12), 101075792 != lf(e, r)) throw "invalid zip file";
      n = lf(e, r + 32), i = lf(e, r + 48);
    }
    for (var o = 0; o < n; ++o) {
      var a = nm(e, i, s),
        l = a[0],
        c = a[1],
        u = a[2],
        h = a[3],
        p = a[4],
        d = a[5],
        f = rm(e, d);
      if (i = p, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[h] = Sf(e.subarray(f, f + c), new td(u));
      } else t[h] = Td(e, f, f + c);
    }
    return t;
  }
  class bm extends n.yxD {
    constructor(e) {
      super(e), this.type = n.cLu;
    }
    parse(e) {
      const r = 65536,
        i = 14,
        s = 65537,
        o = Math.pow(2.7182818, 2.2),
        a = {
          l: 0,
          c: 0,
          lc: 0
        };
      function l(e, t, r, n, i) {
        for (; r < e;) t = t << 8 | N(n, i), r += 8;
        r -= e, a.l = t >> r & (1 << e) - 1, a.c = t, a.lc = r;
      }
      const c = new Array(59);
      function u(e) {
        return 63 & e;
      }
      function h(e) {
        return e >> 6;
      }
      const p = {
        c: 0,
        lc: 0
      };
      function d(e, t, r, n) {
        e = e << 8 | N(r, n), t += 8, p.c = e, p.lc = t;
      }
      const f = {
        c: 0,
        lc: 0
      };
      function m(e, t, r, n, i, s, o, a, l) {
        if (e == t) {
          n < 8 && (d(r, n, i, s), r = p.c, n = p.lc);
          let e = r >> (n -= 8);
          if (e = new Uint8Array([e])[0], a.value + e > l) return !1;
          const t = o[a.value - 1];
          for (; e-- > 0;) o[a.value++] = t;
        } else {
          if (!(a.value < l)) return !1;
          o[a.value++] = e;
        }
        f.c = r, f.lc = n;
      }
      function _(e) {
        return 65535 & e;
      }
      function g(e) {
        const t = _(e);
        return t > 32767 ? t - 65536 : t;
      }
      const v = {
        a: 0,
        b: 0
      };
      function A(e, t) {
        const r = g(e),
          n = g(t),
          i = r + (1 & n) + (n >> 1),
          s = i,
          o = i - n;
        v.a = s, v.b = o;
      }
      function b(e, t) {
        const r = _(e),
          n = _(t),
          i = r - (n >> 1) & 65535,
          s = n + i - 32768 & 65535;
        v.a = s, v.b = i;
      }
      function y(e, t, r, n, i, s, o) {
        const a = o < 16384,
          l = r > i ? i : r;
        let c,
          u,
          h = 1;
        for (; h <= l;) h <<= 1;
        for (h >>= 1, c = h, h >>= 1; h >= 1;) {
          u = 0;
          const o = u + s * (i - c),
            l = s * h,
            p = s * c,
            d = n * h,
            f = n * c;
          let m, _, g, y;
          for (; u <= o; u += p) {
            let i = u;
            const s = u + n * (r - c);
            for (; i <= s; i += f) {
              const r = i + d,
                n = i + l,
                s = n + d;
              a ? (A(e[i + t], e[n + t]), m = v.a, g = v.b, A(e[r + t], e[s + t]), _ = v.a, y = v.b, A(m, _), e[i + t] = v.a, e[r + t] = v.b, A(g, y), e[n + t] = v.a, e[s + t] = v.b) : (b(e[i + t], e[n + t]), m = v.a, g = v.b, b(e[r + t], e[s + t]), _ = v.a, y = v.b, b(m, _), e[i + t] = v.a, e[r + t] = v.b, b(g, y), e[n + t] = v.a, e[s + t] = v.b);
            }
            if (r & h) {
              const r = i + l;
              a ? A(e[i + t], e[r + t]) : b(e[i + t], e[r + t]), m = v.a, e[r + t] = v.b, e[i + t] = m;
            }
          }
          if (i & h) {
            let i = u;
            const s = u + n * (r - c);
            for (; i <= s; i += f) {
              const r = i + d;
              a ? A(e[i + t], e[r + t]) : b(e[i + t], e[r + t]), m = v.a, e[r + t] = v.b, e[i + t] = m;
            }
          }
          c = h, h >>= 1;
        }
        return u;
      }
      function x(e, t, r, n, o, _) {
        const g = r.value,
          v = U(t, r),
          A = U(t, r);
        r.value += 4;
        const b = U(t, r);
        if (r.value += 4, v < 0 || v >= s || A < 0 || A >= s) throw new Error("Something wrong with HUF_ENCSIZE");
        const y = new Array(s),
          x = new Array(16384);
        if (function (e) {
          for (let t = 0; t < 16384; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null;
        }(x), function (e, t, r, n, i, o) {
          const u = t;
          let h = 0,
            p = 0;
          for (; n <= i; n++) {
            if (u.value - t.value > r) return !1;
            l(6, h, p, e, u);
            const s = a.l;
            if (h = a.c, p = a.lc, o[n] = s, 63 == s) {
              if (u.value - t.value > r) throw new Error("Something wrong with hufUnpackEncTable");
              l(8, h, p, e, u);
              let s = a.l + 6;
              if (h = a.c, p = a.lc, n + s > i + 1) throw new Error("Something wrong with hufUnpackEncTable");
              for (; s--;) o[n++] = 0;
              n--;
            } else if (s >= 59) {
              let e = s - 59 + 2;
              if (n + e > i + 1) throw new Error("Something wrong with hufUnpackEncTable");
              for (; e--;) o[n++] = 0;
              n--;
            }
          }
          !function (e) {
            for (let e = 0; e <= 58; ++e) c[e] = 0;
            for (let t = 0; t < s; ++t) c[e[t]] += 1;
            let t = 0;
            for (let e = 58; e > 0; --e) {
              const r = t + c[e] >> 1;
              c[e] = t, t = r;
            }
            for (let t = 0; t < s; ++t) {
              const r = e[t];
              r > 0 && (e[t] = r | c[r]++ << 6);
            }
          }(o);
        }(e, r, n - (r.value - g), v, A, y), b > 8 * (n - (r.value - g))) throw new Error("Something wrong with hufUncompress");
        !function (e, t, r, n) {
          for (; t <= r; t++) {
            const r = h(e[t]),
              s = u(e[t]);
            if (r >> s) throw new Error("Invalid table entry");
            if (s > i) {
              const e = n[r >> s - i];
              if (e.len) throw new Error("Invalid table entry");
              if (e.lit++, e.p) {
                const t = e.p;
                e.p = new Array(e.lit);
                for (let r = 0; r < e.lit - 1; ++r) e.p[r] = t[r];
              } else e.p = new Array(1);
              e.p[e.lit - 1] = t;
            } else if (s) {
              let e = 0;
              for (let o = 1 << i - s; o > 0; o--) {
                const o = n[(r << i - s) + e];
                if (o.len || o.p) throw new Error("Invalid table entry");
                o.len = s, o.lit = t, e++;
              }
            }
          }
        }(y, v, A, x), function (e, t, r, n, s, o, a, l, c) {
          let _ = 0,
            g = 0;
          const v = a,
            A = Math.trunc(n.value + (s + 7) / 8);
          for (; n.value < A;) for (d(_, g, r, n), _ = p.c, g = p.lc; g >= i;) {
            const s = t[_ >> g - i & 16383];
            if (s.len) g -= s.len, m(s.lit, o, _, g, r, n, l, c, v), _ = f.c, g = f.lc;else {
              if (!s.p) throw new Error("hufDecode issues");
              let t;
              for (t = 0; t < s.lit; t++) {
                const i = u(e[s.p[t]]);
                for (; g < i && n.value < A;) d(_, g, r, n), _ = p.c, g = p.lc;
                if (g >= i && h(e[s.p[t]]) == (_ >> g - i & (1 << i) - 1)) {
                  g -= i, m(s.p[t], o, _, g, r, n, l, c, v), _ = f.c, g = f.lc;
                  break;
                }
              }
              if (t == s.lit) throw new Error("hufDecode issues");
            }
          }
          const b = 8 - s & 7;
          for (_ >>= b, g -= b; g > 0;) {
            const e = t[_ << i - g & 16383];
            if (!e.len) throw new Error("hufDecode issues");
            g -= e.len, m(e.lit, o, _, g, r, n, l, c, v), _ = f.c, g = f.lc;
          }
        }(y, x, e, r, b, A, _, o, {
          value: 0
        });
      }
      function w(e) {
        for (let t = 1; t < e.length; t++) {
          const r = e[t - 1] + e[t] - 128;
          e[t] = r;
        }
      }
      function E(e, t) {
        let r = 0,
          n = Math.floor((e.length + 1) / 2),
          i = 0;
        const s = e.length - 1;
        for (; !(i > s || (t[i++] = e[r++], i > s));) t[i++] = e[n++];
      }
      function S(e) {
        let t = e.byteLength;
        const r = new Array();
        let n = 0;
        const i = new DataView(e);
        for (; t > 0;) {
          const e = i.getInt8(n++);
          if (e < 0) {
            const s = -e;
            t -= s + 1;
            for (let e = 0; e < s; e++) r.push(i.getUint8(n++));
          } else {
            const s = e;
            t -= 2;
            const o = i.getUint8(n++);
            for (let e = 0; e < s + 1; e++) r.push(o);
          }
        }
        return r;
      }
      function C(e, t, r) {
        let n,
          i = 1;
        for (; i < 64;) n = t[e.value], 65280 == n ? i = 64 : n >> 8 == 255 ? i += 255 & n : (r[i] = n, i++), e.value++;
      }
      function M(e) {
        const t = .5 * Math.cos(.7853975),
          r = .5 * Math.cos(3.14159 / 16),
          n = .5 * Math.cos(3.14159 / 8),
          i = .5 * Math.cos(3 * 3.14159 / 16),
          s = .5 * Math.cos(.981746875),
          o = .5 * Math.cos(3 * 3.14159 / 8),
          a = .5 * Math.cos(1.374445625),
          l = new Array(4),
          c = new Array(4),
          u = new Array(4),
          h = new Array(4);
        for (let p = 0; p < 8; ++p) {
          const d = 8 * p;
          l[0] = n * e[d + 2], l[1] = o * e[d + 2], l[2] = n * e[d + 6], l[3] = o * e[d + 6], c[0] = r * e[d + 1] + i * e[d + 3] + s * e[d + 5] + a * e[d + 7], c[1] = i * e[d + 1] - a * e[d + 3] - r * e[d + 5] - s * e[d + 7], c[2] = s * e[d + 1] - r * e[d + 3] + a * e[d + 5] + i * e[d + 7], c[3] = a * e[d + 1] - s * e[d + 3] + i * e[d + 5] - r * e[d + 7], u[0] = t * (e[d + 0] + e[d + 4]), u[3] = t * (e[d + 0] - e[d + 4]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], h[0] = u[0] + u[1], h[1] = u[3] + u[2], h[2] = u[3] - u[2], h[3] = u[0] - u[1], e[d + 0] = h[0] + c[0], e[d + 1] = h[1] + c[1], e[d + 2] = h[2] + c[2], e[d + 3] = h[3] + c[3], e[d + 4] = h[3] - c[3], e[d + 5] = h[2] - c[2], e[d + 6] = h[1] - c[1], e[d + 7] = h[0] - c[0];
        }
        for (let p = 0; p < 8; ++p) l[0] = n * e[16 + p], l[1] = o * e[16 + p], l[2] = n * e[48 + p], l[3] = o * e[48 + p], c[0] = r * e[8 + p] + i * e[24 + p] + s * e[40 + p] + a * e[56 + p], c[1] = i * e[8 + p] - a * e[24 + p] - r * e[40 + p] - s * e[56 + p], c[2] = s * e[8 + p] - r * e[24 + p] + a * e[40 + p] + i * e[56 + p], c[3] = a * e[8 + p] - s * e[24 + p] + i * e[40 + p] - r * e[56 + p], u[0] = t * (e[p] + e[32 + p]), u[3] = t * (e[p] - e[32 + p]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], h[0] = u[0] + u[1], h[1] = u[3] + u[2], h[2] = u[3] - u[2], h[3] = u[0] - u[1], e[0 + p] = h[0] + c[0], e[8 + p] = h[1] + c[1], e[16 + p] = h[2] + c[2], e[24 + p] = h[3] + c[3], e[32 + p] = h[3] - c[3], e[40 + p] = h[2] - c[2], e[48 + p] = h[1] - c[1], e[56 + p] = h[0] - c[0];
      }
      function T(e) {
        for (let t = 0; t < 64; ++t) {
          const r = e[0][t],
            n = e[1][t],
            i = e[2][t];
          e[0][t] = r + 1.5747 * i, e[1][t] = r - .1873 * n - .4682 * i, e[2][t] = r + 1.8556 * n;
        }
      }
      function I(e, t, r) {
        for (let s = 0; s < 64; ++s) t[r + s] = n.A5E.toHalfFloat((i = e[s]) <= 1 ? Math.sign(i) * Math.pow(Math.abs(i), 2.2) : Math.sign(i) * Math.pow(o, Math.abs(i) - 1));
        var i;
      }
      function k(e) {
        return new DataView(e.array.buffer, e.offset.value, e.size);
      }
      function D(e) {
        const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
          r = new Uint8Array(S(t)),
          n = new Uint8Array(r.length);
        return w(r), E(r, n), new DataView(n.buffer);
      }
      function P(e) {
        const r = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === t && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const n = zf(r),
          i = new Uint8Array(n.length);
        return w(n), E(n, i), new DataView(i.buffer);
      }
      function B(e) {
        const t = e.viewer,
          n = {
            value: e.offset.value
          },
          i = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)),
          s = new Uint8Array(8192);
        let o = 0;
        const a = new Array(e.channels);
        for (let t = 0; t < e.channels; t++) a[t] = {}, a[t].start = o, a[t].end = a[t].start, a[t].nx = e.width, a[t].ny = e.lines, a[t].size = e.type, o += a[t].nx * a[t].ny * a[t].size;
        const l = H(t, n),
          c = H(t, n);
        if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
        if (l <= c) for (let e = 0; e < c - l + 1; e++) s[e + l] = j(t, n);
        const u = new Uint16Array(r),
          h = function (e, t) {
            let n = 0;
            for (let i = 0; i < r; ++i) (0 == i || e[i >> 3] & 1 << (7 & i)) && (t[n++] = i);
            const i = n - 1;
            for (; n < r;) t[n++] = 0;
            return i;
          }(s, u),
          p = U(t, n);
        x(e.array, t, n, p, i, o);
        for (let t = 0; t < e.channels; ++t) {
          const e = a[t];
          for (let r = 0; r < a[t].size; ++r) y(i, e.start + r, e.nx, e.size, e.ny, e.nx * e.size, h);
        }
        !function (e, t, r) {
          for (let n = 0; n < r; ++n) t[n] = e[t[n]];
        }(u, i, o);
        let d = 0;
        const f = new Uint8Array(i.buffer.byteLength);
        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          const e = a[t],
            r = e.nx * e.size,
            n = new Uint8Array(i.buffer, 2 * e.end, 2 * r);
          f.set(n, d), d += 2 * r, e.end += r;
        }
        return new DataView(f.buffer);
      }
      function R(e) {
        const r = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === t && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const n = zf(r),
          i = e.lines * e.channels * e.width,
          s = 1 == e.type ? new Uint16Array(i) : new Uint32Array(i);
        let o = 0,
          a = 0;
        const l = new Array(4);
        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          let t = 0;
          switch (e.type) {
            case 1:
              l[0] = o, l[1] = l[0] + e.width, o = l[1] + e.width;
              for (let r = 0; r < e.width; ++r) t += n[l[0]++] << 8 | n[l[1]++], s[a] = t, a++;
              break;
            case 2:
              l[0] = o, l[1] = l[0] + e.width, l[2] = l[1] + e.width, o = l[2] + e.width;
              for (let r = 0; r < e.width; ++r) t += n[l[0]++] << 24 | n[l[1]++] << 16 | n[l[2]++] << 8, s[a] = t, a++;
          }
        }
        return new DataView(s.buffer);
      }
      function L(e) {
        const t = e.viewer,
          r = {
            value: e.offset.value
          },
          n = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
          i = {
            version: z(t, r),
            unknownUncompressedSize: z(t, r),
            unknownCompressedSize: z(t, r),
            acCompressedSize: z(t, r),
            dcCompressedSize: z(t, r),
            rleCompressedSize: z(t, r),
            rleUncompressedSize: z(t, r),
            rleRawSize: z(t, r),
            totalAcUncompressedCount: z(t, r),
            totalDcUncompressedCount: z(t, r),
            acCompression: z(t, r)
          };
        if (i.version < 2) throw new Error("EXRLoader.parse: " + J.compression + " version " + i.version + " is unsupported");
        const s = new Array();
        let o = H(t, r) - 2;
        for (; o > 0;) {
          const e = O(t.buffer, r),
            n = j(t, r),
            i = n >> 2 & 3,
            a = new Int8Array([(n >> 4) - 1])[0],
            l = j(t, r);
          s.push({
            name: e,
            index: a,
            type: l,
            compression: i
          }), o -= e.length + 3;
        }
        const a = J.channels,
          l = new Array(e.channels);
        for (let t = 0; t < e.channels; ++t) {
          const r = l[t] = {},
            n = a[t];
          r.name = n.name, r.compression = 0, r.decoded = !1, r.type = n.pixelType, r.pLinear = n.pLinear, r.width = e.width, r.height = e.lines;
        }
        const c = {
          idx: new Array(3)
        };
        for (let t = 0; t < e.channels; ++t) {
          const e = l[t];
          for (let r = 0; r < s.length; ++r) {
            const n = s[r];
            e.name == n.name && (e.compression = n.compression, n.index >= 0 && (c.idx[n.index] = t), e.offset = t);
          }
        }
        let u, h, p;
        if (i.acCompressedSize > 0) switch (i.acCompression) {
          case 0:
            u = new Uint16Array(i.totalAcUncompressedCount), x(e.array, t, r, i.acCompressedSize, u, i.totalAcUncompressedCount);
            break;
          case 1:
            const n = zf(e.array.slice(r.value, r.value + i.totalAcUncompressedCount));
            u = new Uint16Array(n.buffer), r.value += i.totalAcUncompressedCount;
        }
        if (i.dcCompressedSize > 0) {
          const t = {
            array: e.array,
            offset: r,
            size: i.dcCompressedSize
          };
          h = new Uint16Array(P(t).buffer), r.value += i.dcCompressedSize;
        }
        i.rleRawSize > 0 && (p = S(zf(e.array.slice(r.value, r.value + i.rleCompressedSize)).buffer), r.value += i.rleCompressedSize);
        let d = 0;
        const f = new Array(l.length);
        for (let e = 0; e < f.length; ++e) f[e] = new Array();
        for (let t = 0; t < e.lines; ++t) for (let t = 0; t < l.length; ++t) f[t].push(d), d += l[t].width * e.type * 2;
        !function (e, t, r, n, i, s) {
          let o = new DataView(s.buffer);
          const a = r[e.idx[0]].width,
            l = r[e.idx[0]].height,
            c = Math.floor(a / 8),
            u = Math.ceil(a / 8),
            h = Math.ceil(l / 8),
            p = a - 8 * (u - 1),
            d = l - 8 * (h - 1),
            f = {
              value: 0
            },
            m = new Array(3),
            _ = new Array(3),
            g = new Array(3),
            v = new Array(3),
            A = new Array(3);
          for (let r = 0; r < 3; ++r) A[r] = t[e.idx[r]], m[r] = r < 1 ? 0 : m[r - 1] + u * h, _[r] = new Float32Array(64), g[r] = new Uint16Array(64), v[r] = new Uint16Array(64 * u);
          for (let t = 0; t < h; ++t) {
            let s = 8;
            t == h - 1 && (s = d);
            let a = 8;
            for (let e = 0; e < u; ++e) {
              e == u - 1 && (a = p);
              for (let e = 0; e < 3; ++e) g[e].fill(0), g[e][0] = i[m[e]++], C(f, n, g[e]), b = g[e], (y = _[e])[0] = Q(b[0]), y[1] = Q(b[1]), y[2] = Q(b[5]), y[3] = Q(b[6]), y[4] = Q(b[14]), y[5] = Q(b[15]), y[6] = Q(b[27]), y[7] = Q(b[28]), y[8] = Q(b[2]), y[9] = Q(b[4]), y[10] = Q(b[7]), y[11] = Q(b[13]), y[12] = Q(b[16]), y[13] = Q(b[26]), y[14] = Q(b[29]), y[15] = Q(b[42]), y[16] = Q(b[3]), y[17] = Q(b[8]), y[18] = Q(b[12]), y[19] = Q(b[17]), y[20] = Q(b[25]), y[21] = Q(b[30]), y[22] = Q(b[41]), y[23] = Q(b[43]), y[24] = Q(b[9]), y[25] = Q(b[11]), y[26] = Q(b[18]), y[27] = Q(b[24]), y[28] = Q(b[31]), y[29] = Q(b[40]), y[30] = Q(b[44]), y[31] = Q(b[53]), y[32] = Q(b[10]), y[33] = Q(b[19]), y[34] = Q(b[23]), y[35] = Q(b[32]), y[36] = Q(b[39]), y[37] = Q(b[45]), y[38] = Q(b[52]), y[39] = Q(b[54]), y[40] = Q(b[20]), y[41] = Q(b[22]), y[42] = Q(b[33]), y[43] = Q(b[38]), y[44] = Q(b[46]), y[45] = Q(b[51]), y[46] = Q(b[55]), y[47] = Q(b[60]), y[48] = Q(b[21]), y[49] = Q(b[34]), y[50] = Q(b[37]), y[51] = Q(b[47]), y[52] = Q(b[50]), y[53] = Q(b[56]), y[54] = Q(b[59]), y[55] = Q(b[61]), y[56] = Q(b[35]), y[57] = Q(b[36]), y[58] = Q(b[48]), y[59] = Q(b[49]), y[60] = Q(b[57]), y[61] = Q(b[58]), y[62] = Q(b[62]), y[63] = Q(b[63]), M(_[e]);
              T(_);
              for (let t = 0; t < 3; ++t) I(_[t], v[t], 64 * e);
            }
            let l = 0;
            for (let n = 0; n < 3; ++n) {
              const i = r[e.idx[n]].type;
              for (let e = 8 * t; e < 8 * t + s; ++e) {
                l = A[n][e];
                for (let t = 0; t < c; ++t) {
                  const r = 64 * t + 8 * (7 & e);
                  o.setUint16(l + 0 * i, v[n][r + 0], !0), o.setUint16(l + 2 * i, v[n][r + 1], !0), o.setUint16(l + 4 * i, v[n][r + 2], !0), o.setUint16(l + 6 * i, v[n][r + 3], !0), o.setUint16(l + 8 * i, v[n][r + 4], !0), o.setUint16(l + 10 * i, v[n][r + 5], !0), o.setUint16(l + 12 * i, v[n][r + 6], !0), o.setUint16(l + 14 * i, v[n][r + 7], !0), l += 16 * i;
                }
              }
              if (c != u) for (let e = 8 * t; e < 8 * t + s; ++e) {
                const t = A[n][e] + 8 * c * 2 * i,
                  r = 64 * c + 8 * (7 & e);
                for (let e = 0; e < a; ++e) o.setUint16(t + 2 * e * i, v[n][r + e], !0);
              }
            }
          }
          var b, y;
          const x = new Uint16Array(a);
          o = new DataView(s.buffer);
          for (let t = 0; t < 3; ++t) {
            r[e.idx[t]].decoded = !0;
            const n = r[e.idx[t]].type;
            if (2 == r[t].type) for (let e = 0; e < l; ++e) {
              const r = A[t][e];
              for (let e = 0; e < a; ++e) x[e] = o.getUint16(r + 2 * e * n, !0);
              for (let e = 0; e < a; ++e) o.setFloat32(r + 2 * e * n, Q(x[e]), !0);
            }
          }
        }(c, f, l, u, h, n);
        for (let t = 0; t < l.length; ++t) {
          const r = l[t];
          if (!r.decoded) {
            if (2 !== r.compression) throw new Error("EXRLoader.parse: unsupported channel compression");
            {
              let i = 0,
                s = 0;
              for (let o = 0; o < e.lines; ++o) {
                let e = f[t][i];
                for (let t = 0; t < r.width; ++t) {
                  for (let t = 0; t < 2 * r.type; ++t) n[e++] = p[s + t * r.width * r.height];
                  s++;
                }
                i++;
              }
            }
          }
        }
        return new DataView(n.buffer);
      }
      function O(e, t) {
        const r = new Uint8Array(e);
        let n = 0;
        for (; 0 != r[t.value + n];) n += 1;
        const i = new TextDecoder().decode(r.slice(t.value, t.value + n));
        return t.value = t.value + n + 1, i;
      }
      function F(e, t) {
        const r = e.getInt32(t.value, !0);
        return t.value = t.value + 4, r;
      }
      function U(e, t) {
        const r = e.getUint32(t.value, !0);
        return t.value = t.value + 4, r;
      }
      function N(e, t) {
        const r = e[t.value];
        return t.value = t.value + 1, r;
      }
      function j(e, t) {
        const r = e.getUint8(t.value);
        return t.value = t.value + 1, r;
      }
      const z = function (e, t) {
        const r = Number(e.getBigInt64(t.value, !0));
        return t.value += 8, r;
      };
      function G(e, t) {
        const r = e.getFloat32(t.value, !0);
        return t.value += 4, r;
      }
      function V(e, t) {
        return n.A5E.toHalfFloat(G(e, t));
      }
      function Q(e) {
        const t = (31744 & e) >> 10,
          r = 1023 & e;
        return (e >> 15 ? -1 : 1) * (t ? 31 === t ? r ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + r / 1024) : r / 1024 * 6103515625e-14);
      }
      function H(e, t) {
        const r = e.getUint16(t.value, !0);
        return t.value += 2, r;
      }
      function W(e, t) {
        return Q(H(e, t));
      }
      function q(e, t, r, n, i) {
        return "string" === n || "stringvector" === n || "iccProfile" === n ? function (e, t, r) {
          const n = new TextDecoder().decode(new Uint8Array(e).slice(t.value, t.value + r));
          return t.value = t.value + r, n;
        }(t, r, i) : "chlist" === n ? function (e, t, r, n) {
          const i = r.value,
            s = [];
          for (; r.value < i + n - 1;) {
            const n = O(t, r),
              i = F(e, r),
              o = j(e, r);
            r.value += 3;
            const a = F(e, r),
              l = F(e, r);
            s.push({
              name: n,
              pixelType: i,
              pLinear: o,
              xSampling: a,
              ySampling: l
            });
          }
          return r.value += 1, s;
        }(e, t, r, i) : "chromaticities" === n ? function (e, t) {
          return {
            redX: G(e, t),
            redY: G(e, t),
            greenX: G(e, t),
            greenY: G(e, t),
            blueX: G(e, t),
            blueY: G(e, t),
            whiteX: G(e, t),
            whiteY: G(e, t)
          };
        }(e, r) : "compression" === n ? function (e, t) {
          return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j(e, t)];
        }(e, r) : "box2i" === n ? function (e, t) {
          return {
            xMin: U(e, t),
            yMin: U(e, t),
            xMax: U(e, t),
            yMax: U(e, t)
          };
        }(e, r) : "lineOrder" === n ? function (e, t) {
          return ["INCREASING_Y"][j(e, t)];
        }(e, r) : "float" === n ? G(e, r) : "v2f" === n ? function (e, t) {
          return [G(e, t), G(e, t)];
        }(e, r) : "v3f" === n ? function (e, t) {
          return [G(e, t), G(e, t), G(e, t)];
        }(e, r) : "int" === n ? F(e, r) : "rational" === n ? function (e, t) {
          return [F(e, t), U(e, t)];
        }(e, r) : "timecode" === n ? function (e, t) {
          return [U(e, t), U(e, t)];
        }(e, r) : "preview" === n ? (r.value += i, "skipped") : void (r.value += i);
      }
      const X = new DataView(e),
        Y = new Uint8Array(e),
        K = {
          value: 0
        },
        J = function (e, t, r) {
          const n = {};
          if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
          n.version = e.getUint8(4);
          const i = e.getUint8(5);
          n.spec = {
            singleTile: !!(2 & i),
            longName: !!(4 & i),
            deepFormat: !!(8 & i),
            multiPart: !!(16 & i)
          }, r.value = 8;
          let s = !0;
          for (; s;) {
            const i = O(t, r);
            if (0 == i) s = !1;else {
              const s = O(t, r),
                o = q(e, t, r, s, U(e, r));
              void 0 === o ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`) : n[i] = o;
            }
          }
          if (0 != (-5 & i)) throw console.error("EXRHeader:", n), new Error("THREE.EXRLoader: provided file is currently unsupported.");
          return n;
        }(X, e, K),
        Z = function (e, t, r, i, s) {
          const o = {
            size: 0,
            viewer: t,
            array: r,
            offset: i,
            width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
            height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
            channels: e.channels.length,
            bytesPerLine: null,
            lines: null,
            inputSize: null,
            type: e.channels[0].pixelType,
            uncompress: null,
            getter: null,
            format: null,
            encoding: null
          };
          switch (e.compression) {
            case "NO_COMPRESSION":
              o.lines = 1, o.uncompress = k;
              break;
            case "RLE_COMPRESSION":
              o.lines = 1, o.uncompress = D;
              break;
            case "ZIPS_COMPRESSION":
              o.lines = 1, o.uncompress = P;
              break;
            case "ZIP_COMPRESSION":
              o.lines = 16, o.uncompress = P;
              break;
            case "PIZ_COMPRESSION":
              o.lines = 32, o.uncompress = B;
              break;
            case "PXR24_COMPRESSION":
              o.lines = 16, o.uncompress = R;
              break;
            case "DWAA_COMPRESSION":
              o.lines = 32, o.uncompress = L;
              break;
            case "DWAB_COMPRESSION":
              o.lines = 256, o.uncompress = L;
              break;
            default:
              throw new Error("EXRLoader.parse: " + e.compression + " is unsupported");
          }
          if (o.scanlineBlockSize = o.lines, 1 == o.type) switch (s) {
            case n.VzW:
              o.getter = W, o.inputSize = 2;
              break;
            case n.cLu:
              o.getter = H, o.inputSize = 2;
          } else {
            if (2 != o.type) throw new Error("EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".");
            switch (s) {
              case n.VzW:
                o.getter = G, o.inputSize = 4;
                break;
              case n.cLu:
                o.getter = V, o.inputSize = 4;
            }
          }
          o.blockCount = (e.dataWindow.yMax + 1) / o.scanlineBlockSize;
          for (let e = 0; e < o.blockCount; e++) z(t, i);
          o.outputChannels = 3 == o.channels ? 4 : o.channels;
          const a = o.width * o.height * o.outputChannels;
          switch (s) {
            case n.VzW:
              o.byteArray = new Float32Array(a), o.channels < o.outputChannels && o.byteArray.fill(1, 0, a);
              break;
            case n.cLu:
              o.byteArray = new Uint16Array(a), o.channels < o.outputChannels && o.byteArray.fill(15360, 0, a);
              break;
            default:
              console.error("THREE.EXRLoader: unsupported type: ", s);
          }
          return o.bytesPerLine = o.width * o.inputSize * o.channels, 4 == o.outputChannels ? (o.format = n.wk1, o.encoding = n.rnI) : (o.format = n.hEm, o.encoding = n.rnI), o;
        }(J, X, Y, K, this.type),
        $ = {
          value: 0
        },
        ee = {
          R: 0,
          G: 1,
          B: 2,
          A: 3,
          Y: 0
        };
      for (let e = 0; e < Z.height / Z.scanlineBlockSize; e++) {
        const t = U(X, K);
        Z.size = U(X, K), Z.lines = t + Z.scanlineBlockSize > Z.height ? Z.height - t : Z.scanlineBlockSize;
        const r = Z.size < Z.lines * Z.bytesPerLine ? Z.uncompress(Z) : k(Z);
        K.value += Z.size;
        for (let t = 0; t < Z.scanlineBlockSize; t++) {
          const n = t + e * Z.scanlineBlockSize;
          if (n >= Z.height) break;
          for (let e = 0; e < Z.channels; e++) {
            const i = ee[J.channels[e].name];
            for (let s = 0; s < Z.width; s++) {
              $.value = (t * (Z.channels * Z.width) + e * Z.width + s) * Z.inputSize;
              const o = (Z.height - 1 - n) * (Z.width * Z.outputChannels) + s * Z.outputChannels + i;
              Z.byteArray[o] = Z.getter(r, $);
            }
          }
        }
      }
      return {
        header: J,
        width: Z.width,
        height: Z.height,
        data: Z.byteArray,
        format: Z.format,
        encoding: Z.encoding,
        type: this.type
      };
    }
    setDataType(e) {
      return this.type = e, this;
    }
    load(e, t, r, i) {
      return super.load(e, function (e, r) {
        e.encoding = r.encoding, e.minFilter = n.wem, e.magFilter = n.wem, e.generateMipmaps = !1, e.flipY = !1, t && t(e, r);
      }, r, i);
    }
  }
  class ym extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e) {
      this._importer || (this._importer = new ir(class extends bm {
        constructor(t) {
          super(t), this.setDataType(Zs(e.renderer.rendererObject));
        }
      }, ["exr"], !1)), Js.Importers.push(this._importer);
    }
    async onDispose(e) {
      this._importer = void 0;
    }
    async onRemove(e) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  function xm(e, t, r) {
    const n = r.length - e - 1;
    if (t >= r[n]) return n - 1;
    if (t <= r[e]) return e;
    let i = e,
      s = n,
      o = Math.floor((i + s) / 2);
    for (; t < r[o] || t >= r[o + 1];) t < r[o] ? s = o : i = o, o = Math.floor((i + s) / 2);
    return o;
  }
  function wm(e, t) {
    let r = 1;
    for (let t = 2; t <= e; ++t) r *= t;
    let n = 1;
    for (let e = 2; e <= t; ++e) n *= e;
    for (let r = 2; r <= e - t; ++r) n *= r;
    return r / n;
  }
  ym.PluginType = "EXRLoadPlugin";
  class Em extends n.Hyl {
    constructor(e, t, r, i, s) {
      super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = s || this.knots.length - 1;
      for (let e = 0; e < r.length; ++e) {
        const t = r[e];
        this.controlPoints[e] = new n.Ltg(t.x, t.y, t.z, t.w);
      }
    }
    getPoint(e, t = new n.Pa4()) {
      const r = t,
        i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
        s = function (e, t, r, i) {
          const s = xm(e, i, t),
            o = function (e, t, r, n) {
              const i = [],
                s = [],
                o = [];
              i[0] = 1;
              for (let a = 1; a <= r; ++a) {
                s[a] = t - n[e + 1 - a], o[a] = n[e + a] - t;
                let r = 0;
                for (let e = 0; e < a; ++e) {
                  const t = o[e + 1],
                    n = s[a - e],
                    l = i[e] / (t + n);
                  i[e] = r + t * l, r = n * l;
                }
                i[a] = r;
              }
              return i;
            }(s, i, e, t),
            a = new n.Ltg(0, 0, 0, 0);
          for (let t = 0; t <= e; ++t) {
            const n = r[s - e + t],
              i = o[t],
              l = n.w * i;
            a.x += n.x * l, a.y += n.y * l, a.z += n.z * l, a.w += n.w * i;
          }
          return a;
        }(this.degree, this.knots, this.controlPoints, i);
      return 1 !== s.w && s.divideScalar(s.w), r.set(s.x, s.y, s.z);
    }
    getTangent(e, t = new n.Pa4()) {
      const r = t,
        i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
        s = function (e, t, r, i, s) {
          const o = function (e, t, r, i, s) {
            const o = s < e ? s : e,
              a = [],
              l = xm(e, i, t),
              c = function (e, t, r, n, i) {
                const s = [];
                for (let e = 0; e <= r; ++e) s[e] = 0;
                const o = [];
                for (let e = 0; e <= n; ++e) o[e] = s.slice(0);
                const a = [];
                for (let e = 0; e <= r; ++e) a[e] = s.slice(0);
                a[0][0] = 1;
                const l = s.slice(0),
                  c = s.slice(0);
                for (let n = 1; n <= r; ++n) {
                  l[n] = t - i[e + 1 - n], c[n] = i[e + n] - t;
                  let r = 0;
                  for (let e = 0; e < n; ++e) {
                    const t = c[e + 1],
                      i = l[n - e];
                    a[n][e] = t + i;
                    const s = a[e][n - 1] / a[n][e];
                    a[e][n] = r + t * s, r = i * s;
                  }
                  a[n][n] = r;
                }
                for (let e = 0; e <= r; ++e) o[0][e] = a[e][r];
                for (let e = 0; e <= r; ++e) {
                  let t = 0,
                    i = 1;
                  const l = [];
                  for (let e = 0; e <= r; ++e) l[e] = s.slice(0);
                  l[0][0] = 1;
                  for (let s = 1; s <= n; ++s) {
                    let n = 0;
                    const c = e - s,
                      u = r - s;
                    e >= s && (l[i][0] = l[t][0] / a[u + 1][c], n = l[i][0] * a[c][u]);
                    const h = e - 1 <= u ? s - 1 : r - e;
                    for (let e = c >= -1 ? 1 : -c; e <= h; ++e) l[i][e] = (l[t][e] - l[t][e - 1]) / a[u + 1][c + e], n += l[i][e] * a[c + e][u];
                    e <= u && (l[i][s] = -l[t][s - 1] / a[u + 1][e], n += l[i][s] * a[e][u]), o[s][e] = n;
                    const p = t;
                    t = i, i = p;
                  }
                }
                let u = r;
                for (let e = 1; e <= n; ++e) {
                  for (let t = 0; t <= r; ++t) o[e][t] *= u;
                  u *= r - e;
                }
                return o;
              }(l, i, e, o, t),
              u = [];
            for (let e = 0; e < r.length; ++e) {
              const t = r[e].clone(),
                n = t.w;
              t.x *= n, t.y *= n, t.z *= n, u[e] = t;
            }
            for (let t = 0; t <= o; ++t) {
              const r = u[l - e].clone().multiplyScalar(c[t][0]);
              for (let n = 1; n <= e; ++n) r.add(u[l - e + n].clone().multiplyScalar(c[t][n]));
              a[t] = r;
            }
            for (let e = o + 1; e <= s + 1; ++e) a[e] = new n.Ltg(0, 0, 0);
            return a;
          }(e, t, r, i, s);
          return function (e) {
            const t = e.length,
              r = [],
              i = [];
            for (let s = 0; s < t; ++s) {
              const t = e[s];
              r[s] = new n.Pa4(t.x, t.y, t.z), i[s] = t.w;
            }
            const s = [];
            for (let e = 0; e < t; ++e) {
              const t = r[e].clone();
              for (let r = 1; r <= e; ++r) t.sub(s[e - r].clone().multiplyScalar(wm(e, r) * i[r]));
              s[e] = t.divideScalar(i[0]);
            }
            return s;
          }(o);
        }(this.degree, this.knots, this.controlPoints, i, 1);
      return r.copy(s[1]).normalize(), r;
    }
  }
  let Sm, Cm, Mm;
  class Tm extends n.aNw {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      const s = this,
        o = "" === s.path ? n.Zp0.extractUrlBase(e) : s.path,
        a = new n.hH6(this.manager);
      a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function (r) {
        try {
          t(s.parse(r, o));
        } catch (t) {
          i ? i(t) : console.error(t), s.manager.itemError(e);
        }
      }, r, i);
    }
    parse(e, t) {
      if (function (e) {
        const t = "Kaydara FBX Binary  \0";
        return e.byteLength >= t.length && t === Hm(e, 0, t.length);
      }(e)) Sm = new Bm().parse(e);else {
        const t = Hm(e);
        if (!function (e) {
          const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
          let r = 0;
          function n(t) {
            const n = e[t - 1];
            return e = e.slice(r + t), r++, n;
          }
          for (let e = 0; e < t.length; ++e) if (n(1) === t[e]) return !1;
          return !0;
        }(t)) throw new Error("THREE.FBXLoader: Unknown format.");
        if (Om(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Om(t));
        Sm = new Pm().parse(t);
      }
      const r = new n.dpR(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
      return new Im(r, this.manager).parse(Sm);
    }
  }
  class Im {
    constructor(e, t) {
      this.textureLoader = e, this.manager = t;
    }
    parse() {
      Cm = this.parseConnections();
      const e = this.parseImages(),
        t = this.parseTextures(e),
        r = this.parseMaterials(t),
        n = this.parseDeformers(),
        i = new km().parse(n);
      return this.parseScene(n, i, r), Mm;
    }
    parseConnections() {
      const e = new Map();
      return "Connections" in Sm && Sm.Connections.connections.forEach(function (t) {
        const r = t[0],
          n = t[1],
          i = t[2];
        e.has(r) || e.set(r, {
          parents: [],
          children: []
        });
        const s = {
          ID: n,
          relationship: i
        };
        e.get(r).parents.push(s), e.has(n) || e.set(n, {
          parents: [],
          children: []
        });
        const o = {
          ID: r,
          relationship: i
        };
        e.get(n).children.push(o);
      }), e;
    }
    parseImages() {
      const e = {},
        t = {};
      if ("Video" in Sm.Objects) {
        const r = Sm.Objects.Video;
        for (const n in r) {
          const i = r[n];
          if (e[parseInt(n)] = i.RelativeFilename || i.Filename, "Content" in i) {
            const e = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0,
              s = "string" == typeof i.Content && "" !== i.Content;
            if (e || s) {
              const e = this.parseImage(r[n]);
              t[i.RelativeFilename || i.Filename] = e;
            }
          }
        }
      }
      for (const r in e) {
        const n = e[r];
        void 0 !== t[n] ? e[r] = t[n] : e[r] = e[r].split("\\").pop();
      }
      return e;
    }
    parseImage(e) {
      const t = e.Content,
        r = e.RelativeFilename || e.Filename,
        n = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
      let i;
      switch (n) {
        case "bmp":
          i = "image/bmp";
          break;
        case "jpg":
        case "jpeg":
          i = "image/jpeg";
          break;
        case "png":
          i = "image/png";
          break;
        case "tif":
          i = "image/tiff";
          break;
        case "tga":
          null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", r), i = "image/tga";
          break;
        default:
          return void console.warn('FBXLoader: Image type "' + n + '" is not supported.');
      }
      if ("string" == typeof t) return "data:" + i + ";base64," + t;
      {
        const e = new Uint8Array(t);
        return window.URL.createObjectURL(new Blob([e], {
          type: i
        }));
      }
    }
    parseTextures(e) {
      const t = new Map();
      if ("Texture" in Sm.Objects) {
        const r = Sm.Objects.Texture;
        for (const n in r) {
          const i = this.parseTexture(r[n], e);
          t.set(parseInt(n), i);
        }
      }
      return t;
    }
    parseTexture(e, t) {
      const r = this.loadTexture(e, t);
      r.ID = e.id, r.name = e.attrName;
      const i = e.WrapModeU,
        s = e.WrapModeV,
        o = void 0 !== i ? i.value : 0,
        a = void 0 !== s ? s.value : 0;
      if (r.wrapS = 0 === o ? n.rpg : n.uWy, r.wrapT = 0 === a ? n.rpg : n.uWy, "Scaling" in e) {
        const t = e.Scaling.value;
        r.repeat.x = t[0], r.repeat.y = t[1];
      }
      if ("Translation" in e) {
        const t = e.Translation.value;
        r.offset.x = t[0], r.offset.y = t[1];
      }
      return r;
    }
    loadTexture(e, t) {
      let r;
      const i = this.textureLoader.path,
        s = Cm.get(e.id).children;
      let o;
      void 0 !== s && s.length > 0 && void 0 !== t[s[0].ID] && (r = t[s[0].ID], 0 !== r.indexOf("blob:") && 0 !== r.indexOf("data:") || this.textureLoader.setPath(void 0));
      const a = e.FileName.slice(-3).toLowerCase();
      if ("tga" === a) {
        const t = this.manager.getHandler(".tga");
        null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new n.xEZ()) : (t.setPath(this.textureLoader.path), o = t.load(r));
      } else "psd" === a ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new n.xEZ()) : o = this.textureLoader.load(r);
      return this.textureLoader.setPath(i), o;
    }
    parseMaterials(e) {
      const t = new Map();
      if ("Material" in Sm.Objects) {
        const r = Sm.Objects.Material;
        for (const n in r) {
          const i = this.parseMaterial(r[n], e);
          null !== i && t.set(parseInt(n), i);
        }
      }
      return t;
    }
    parseMaterial(e, t) {
      const r = e.id,
        i = e.attrName;
      let s = e.ShadingModel;
      if ("object" == typeof s && (s = s.value), !Cm.has(r)) return null;
      const o = this.parseParameters(e, t, r);
      let a;
      switch (s.toLowerCase()) {
        case "phong":
          a = new n.xoR();
          break;
        case "lambert":
          a = new n.YBo();
          break;
        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new n.xoR();
      }
      return a.setValues(o), a.name = i, a;
    }
    parseParameters(e, t, r) {
      const i = {};
      e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = new n.Ilk().fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (i.color = new n.Ilk().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = new n.Ilk().fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (i.emissive = new n.Ilk().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = new n.Ilk().fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (i.specular = new n.Ilk().fromArray(e.SpecularColor.value));
      const s = this;
      return Cm.get(r).children.forEach(function (e) {
        const r = e.relationship;
        switch (r) {
          case "Bump":
            i.bumpMap = s.getTexture(t, e.ID);
            break;
          case "Maya|TEX_ao_map":
            i.aoMap = s.getTexture(t, e.ID);
            break;
          case "DiffuseColor":
          case "Maya|TEX_color_map":
            i.map = s.getTexture(t, e.ID), void 0 !== i.map && (i.map.encoding = n.knz);
            break;
          case "DisplacementColor":
            i.displacementMap = s.getTexture(t, e.ID);
            break;
          case "EmissiveColor":
            i.emissiveMap = s.getTexture(t, e.ID), void 0 !== i.emissiveMap && (i.emissiveMap.encoding = n.knz);
            break;
          case "NormalMap":
          case "Maya|TEX_normal_map":
            i.normalMap = s.getTexture(t, e.ID);
            break;
          case "ReflectionColor":
            i.envMap = s.getTexture(t, e.ID), void 0 !== i.envMap && (i.envMap.mapping = n.dSO, i.envMap.encoding = n.knz);
            break;
          case "SpecularColor":
            i.specularMap = s.getTexture(t, e.ID), void 0 !== i.specularMap && (i.specularMap.encoding = n.knz);
            break;
          case "TransparentColor":
          case "TransparencyFactor":
            i.alphaMap = s.getTexture(t, e.ID), i.transparent = !0;
            break;
          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r);
        }
      }), i;
    }
    getTexture(e, t) {
      return "LayeredTexture" in Sm.Objects && t in Sm.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Cm.get(t).children[0].ID), e.get(t);
    }
    parseDeformers() {
      const e = {},
        t = {};
      if ("Deformer" in Sm.Objects) {
        const r = Sm.Objects.Deformer;
        for (const n in r) {
          const i = r[n],
            s = Cm.get(parseInt(n));
          if ("Skin" === i.attrType) {
            const t = this.parseSkeleton(s, r);
            t.ID = n, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = s.parents[0].ID, e[n] = t;
          } else if ("BlendShape" === i.attrType) {
            const e = {
              id: n
            };
            e.rawTargets = this.parseMorphTargets(s, r), e.id = n, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = e;
          }
        }
      }
      return {
        skeletons: e,
        morphTargets: t
      };
    }
    parseSkeleton(e, t) {
      const r = [];
      return e.children.forEach(function (e) {
        const i = t[e.ID];
        if ("Cluster" !== i.attrType) return;
        const s = {
          ID: e.ID,
          indices: [],
          weights: [],
          transformLink: new n.yGw().fromArray(i.TransformLink.a)
        };
        "Indexes" in i && (s.indices = i.Indexes.a, s.weights = i.Weights.a), r.push(s);
      }), {
        rawBones: r,
        bones: []
      };
    }
    parseMorphTargets(e, t) {
      const r = [];
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n],
          s = t[i.ID],
          o = {
            name: s.attrName,
            initialWeight: s.DeformPercent,
            id: s.id,
            fullWeights: s.FullWeights.a
          };
        if ("BlendShapeChannel" !== s.attrType) return;
        o.geoID = Cm.get(parseInt(i.ID)).children.filter(function (e) {
          return void 0 === e.relationship;
        })[0].ID, r.push(o);
      }
      return r;
    }
    parseScene(e, t, r) {
      Mm = new n.ZAu();
      const i = this.parseModels(e.skeletons, t, r),
        s = Sm.Objects.Model,
        o = this;
      i.forEach(function (e) {
        const t = s[e.ID];
        o.setLookAtProperties(e, t), Cm.get(e.ID).parents.forEach(function (t) {
          const r = i.get(t.ID);
          void 0 !== r && r.add(e);
        }), null === e.parent && Mm.add(e);
      }), this.bindSkeleton(e.skeletons, t, i), this.createAmbientLight(), Mm.traverse(function (e) {
        if (e.userData.transformData) {
          e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
          const t = Gm(e.userData.transformData);
          e.applyMatrix4(t), e.updateWorldMatrix();
        }
      });
      const a = new Dm().parse();
      1 === Mm.children.length && Mm.children[0].isGroup && (Mm.children[0].animations = a, Mm = Mm.children[0]), Mm.animations = a;
    }
    parseModels(e, t, r) {
      const i = new Map(),
        s = Sm.Objects.Model;
      for (const o in s) {
        const a = parseInt(o),
          l = s[o],
          c = Cm.get(a);
        let u = this.buildSkeleton(c, e, a, l.attrName);
        if (!u) {
          switch (l.attrType) {
            case "Camera":
              u = this.createCamera(c);
              break;
            case "Light":
              u = this.createLight(c);
              break;
            case "Mesh":
              u = this.createMesh(c, t, r);
              break;
            case "NurbsCurve":
              u = this.createCurve(c, t);
              break;
            case "LimbNode":
            case "Root":
              u = new n.N$j();
              break;
            default:
              u = new n.ZAu();
          }
          u.name = l.attrName ? n.iUV.sanitizeNodeName(l.attrName) : "", u.ID = a;
        }
        this.getTransformData(u, l), i.set(a, u);
      }
      return i;
    }
    buildSkeleton(e, t, r, i) {
      let s = null;
      return e.parents.forEach(function (e) {
        for (const o in t) {
          const a = t[o];
          a.rawBones.forEach(function (t, o) {
            if (t.ID === e.ID) {
              const e = s;
              s = new n.N$j(), s.matrixWorld.copy(t.transformLink), s.name = i ? n.iUV.sanitizeNodeName(i) : "", s.ID = r, a.bones[o] = s, null !== e && s.add(e);
            }
          });
        }
      }), s;
    }
    createCamera(e) {
      let t, r;
      if (e.children.forEach(function (e) {
        const t = Sm.Objects.NodeAttribute[e.ID];
        void 0 !== t && (r = t);
      }), void 0 === r) t = new n.Tme();else {
        let e = 0;
        void 0 !== r.CameraProjectionType && 1 === r.CameraProjectionType.value && (e = 1);
        let i = 1;
        void 0 !== r.NearPlane && (i = r.NearPlane.value / 1e3);
        let s = 1e3;
        void 0 !== r.FarPlane && (s = r.FarPlane.value / 1e3);
        let o = window.innerWidth,
          a = window.innerHeight;
        void 0 !== r.AspectWidth && void 0 !== r.AspectHeight && (o = r.AspectWidth.value, a = r.AspectHeight.value);
        const l = o / a;
        let c = 45;
        void 0 !== r.FieldOfView && (c = r.FieldOfView.value);
        const u = r.FocalLength ? r.FocalLength.value : null;
        switch (e) {
          case 0:
            t = new n.cPb(c, l, i, s), null !== u && t.setFocalLength(u);
            break;
          case 1:
            t = new n.iKG(-o / 2, o / 2, a / 2, -a / 2, i, s);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new n.Tme();
        }
      }
      return t;
    }
    createLight(e) {
      let t, r;
      if (e.children.forEach(function (e) {
        const t = Sm.Objects.NodeAttribute[e.ID];
        void 0 !== t && (r = t);
      }), void 0 === r) t = new n.Tme();else {
        let e;
        e = void 0 === r.LightType ? 0 : r.LightType.value;
        let i = 16777215;
        void 0 !== r.Color && (i = new n.Ilk().fromArray(r.Color.value));
        let s = void 0 === r.Intensity ? 1 : r.Intensity.value / 100;
        void 0 !== r.CastLightOnObject && 0 === r.CastLightOnObject.value && (s = 0);
        let o = 0;
        void 0 !== r.FarAttenuationEnd && (o = void 0 !== r.EnableFarAttenuation && 0 === r.EnableFarAttenuation.value ? 0 : r.FarAttenuationEnd.value);
        const a = 1;
        switch (e) {
          case 0:
            t = new n.cek(i, s, o, a);
            break;
          case 1:
            t = new n.Ox3(i, s);
            break;
          case 2:
            let e = Math.PI / 3;
            void 0 !== r.InnerAngle && (e = n.M8C.degToRad(r.InnerAngle.value));
            let l = 0;
            void 0 !== r.OuterAngle && (l = n.M8C.degToRad(r.OuterAngle.value), l = Math.max(l, 1)), t = new n.PMe(i, s, o, e, l, a);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), t = new n.cek(i, s);
        }
        void 0 !== r.CastShadows && 1 === r.CastShadows.value && (t.castShadow = !0);
      }
      return t;
    }
    createMesh(e, t, r) {
      let i,
        s = null,
        o = null;
      const a = [];
      return e.children.forEach(function (e) {
        t.has(e.ID) && (s = t.get(e.ID)), r.has(e.ID) && a.push(r.get(e.ID));
      }), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new n.xoR({
        color: 13421772
      }), a.push(o)), "color" in s.attributes && a.forEach(function (e) {
        e.vertexColors = !0;
      }), s.FBX_Deformer ? (i = new n.TUv(s, o), i.normalizeSkinWeights()) : i = new n.Kj0(s, o), i;
    }
    createCurve(e, t) {
      const r = e.children.reduce(function (e, r) {
          return t.has(r.ID) && (e = t.get(r.ID)), e;
        }, null),
        i = new n.nls({
          color: 3342591,
          linewidth: 1
        });
      return new n.x12(r, i);
    }
    getTransformData(e, t) {
      const r = {};
      "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), r.eulerOrder = "RotationOrder" in t ? Vm(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r;
    }
    setLookAtProperties(e, t) {
      "LookAtProperty" in t && Cm.get(e.ID).children.forEach(function (t) {
        if ("LookAtProperty" === t.relationship) {
          const r = Sm.Objects.Model[t.ID];
          if ("Lcl_Translation" in r) {
            const t = r.Lcl_Translation.value;
            void 0 !== e.target ? (e.target.position.fromArray(t), Mm.add(e.target)) : e.lookAt(new n.Pa4().fromArray(t));
          }
        }
      });
    }
    bindSkeleton(e, t, r) {
      const i = this.parsePoseNodes();
      for (const s in e) {
        const o = e[s];
        Cm.get(parseInt(o.ID)).parents.forEach(function (e) {
          if (t.has(e.ID)) {
            const t = e.ID;
            Cm.get(t).parents.forEach(function (e) {
              r.has(e.ID) && r.get(e.ID).bind(new n.OdW(o.bones), i[e.ID]);
            });
          }
        });
      }
    }
    parsePoseNodes() {
      const e = {};
      if ("Pose" in Sm.Objects) {
        const t = Sm.Objects.Pose;
        for (const r in t) if ("BindPose" === t[r].attrType && t[r].NbPoseNodes > 0) {
          const i = t[r].PoseNode;
          Array.isArray(i) ? i.forEach(function (t) {
            e[t.Node] = new n.yGw().fromArray(t.Matrix.a);
          }) : e[i.Node] = new n.yGw().fromArray(i.Matrix.a);
        }
      }
      return e;
    }
    createAmbientLight() {
      if ("GlobalSettings" in Sm && "AmbientColor" in Sm.GlobalSettings) {
        const e = Sm.GlobalSettings.AmbientColor.value,
          t = e[0],
          r = e[1],
          i = e[2];
        if (0 !== t || 0 !== r || 0 !== i) {
          const e = new n.Ilk(t, r, i);
          Mm.add(new n.Mig(e, 1));
        }
      }
    }
  }
  class km {
    parse(e) {
      const t = new Map();
      if ("Geometry" in Sm.Objects) {
        const r = Sm.Objects.Geometry;
        for (const n in r) {
          const i = Cm.get(parseInt(n)),
            s = this.parseGeometry(i, r[n], e);
          t.set(parseInt(n), s);
        }
      }
      return t;
    }
    parseGeometry(e, t, r) {
      switch (t.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(e, t, r);
        case "NurbsCurve":
          return this.parseNurbsGeometry(t);
      }
    }
    parseMeshGeometry(e, t, r) {
      const n = r.skeletons,
        i = [],
        s = e.parents.map(function (e) {
          return Sm.Objects.Model[e.ID];
        });
      if (0 === s.length) return;
      const o = e.children.reduce(function (e, t) {
        return void 0 !== n[t.ID] && (e = n[t.ID]), e;
      }, null);
      e.children.forEach(function (e) {
        void 0 !== r.morphTargets[e.ID] && i.push(r.morphTargets[e.ID]);
      });
      const a = s[0],
        l = {};
      "RotationOrder" in a && (l.eulerOrder = Vm(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
      const c = Gm(l);
      return this.genGeometry(t, o, i, c);
    }
    genGeometry(e, t, r, i) {
      const s = new n.u9r();
      e.attrName && (s.name = e.attrName);
      const o = this.parseGeoNode(e, t),
        a = this.genBuffers(o),
        l = new n.a$l(a.vertex, 3);
      if (l.applyMatrix4(i), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new n.a$l(a.colors, 3)), t && (s.setAttribute("skinIndex", new n.qlB(a.weightsIndices, 4)), s.setAttribute("skinWeight", new n.a$l(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
        const e = new n.Vkp().getNormalMatrix(i),
          t = new n.a$l(a.normal, 3);
        t.applyNormalMatrix(e), s.setAttribute("normal", t);
      }
      if (a.uvs.forEach(function (e, t) {
        let r = "uv" + (t + 1).toString();
        0 === t && (r = "uv"), s.setAttribute(r, new n.a$l(a.uvs[t], 2));
      }), o.material && "AllSame" !== o.material.mappingType) {
        let e = a.materialIndex[0],
          t = 0;
        if (a.materialIndex.forEach(function (r, n) {
          r !== e && (s.addGroup(t, n - t, e), e = r, t = n);
        }), s.groups.length > 0) {
          const t = s.groups[s.groups.length - 1],
            r = t.start + t.count;
          r !== a.materialIndex.length && s.addGroup(r, a.materialIndex.length - r, e);
        }
        0 === s.groups.length && s.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
      }
      return this.addMorphTargets(s, e, r, i), s;
    }
    parseGeoNode(e, t) {
      const r = {};
      if (r.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], r.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
        r.uv = [];
        let t = 0;
        for (; e.LayerElementUV[t];) e.LayerElementUV[t].UV && r.uv.push(this.parseUVs(e.LayerElementUV[t])), t++;
      }
      return r.weightTable = {}, null !== t && (r.skeleton = t, t.rawBones.forEach(function (e, t) {
        e.indices.forEach(function (n, i) {
          void 0 === r.weightTable[n] && (r.weightTable[n] = []), r.weightTable[n].push({
            id: t,
            weight: e.weights[i]
          });
        });
      })), r;
    }
    genBuffers(e) {
      const t = {
        vertex: [],
        normal: [],
        colors: [],
        uvs: [],
        materialIndex: [],
        vertexWeights: [],
        weightsIndices: []
      };
      let r = 0,
        n = 0,
        i = !1,
        s = [],
        o = [],
        a = [],
        l = [],
        c = [],
        u = [];
      const h = this;
      return e.vertexIndices.forEach(function (p, d) {
        let f,
          m = !1;
        p < 0 && (p ^= -1, m = !0);
        let _ = [],
          g = [];
        if (s.push(3 * p, 3 * p + 1, 3 * p + 2), e.color) {
          const t = Nm(d, r, p, e.color);
          a.push(t[0], t[1], t[2]);
        }
        if (e.skeleton) {
          if (void 0 !== e.weightTable[p] && e.weightTable[p].forEach(function (e) {
            g.push(e.weight), _.push(e.id);
          }), g.length > 4) {
            i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
            const e = [0, 0, 0, 0],
              t = [0, 0, 0, 0];
            g.forEach(function (r, n) {
              let i = r,
                s = _[n];
              t.forEach(function (t, r, n) {
                if (i > t) {
                  n[r] = i, i = t;
                  const o = e[r];
                  e[r] = s, s = o;
                }
              });
            }), _ = e, g = t;
          }
          for (; g.length < 4;) g.push(0), _.push(0);
          for (let e = 0; e < 4; ++e) c.push(g[e]), u.push(_[e]);
        }
        if (e.normal) {
          const t = Nm(d, r, p, e.normal);
          o.push(t[0], t[1], t[2]);
        }
        e.material && "AllSame" !== e.material.mappingType && (f = Nm(d, r, p, e.material)[0], f < 0 && (console.warn("THREE.FBXLoader: Invalid material index:", f), f = 0)), e.uv && e.uv.forEach(function (e, t) {
          const n = Nm(d, r, p, e);
          void 0 === l[t] && (l[t] = []), l[t].push(n[0]), l[t].push(n[1]);
        }), n++, m && (h.genFace(t, e, s, f, o, a, l, c, u, n), r++, n = 0, s = [], o = [], a = [], l = [], c = [], u = []);
      }), t;
    }
    genFace(e, t, r, n, i, s, o, a, l, c) {
      for (let u = 2; u < c; u++) e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[3 * (u - 1)]]), e.vertex.push(t.vertexPositions[r[3 * (u - 1) + 1]]), e.vertex.push(t.vertexPositions[r[3 * (u - 1) + 2]]), e.vertex.push(t.vertexPositions[r[3 * u]]), e.vertex.push(t.vertexPositions[r[3 * u + 1]]), e.vertex.push(t.vertexPositions[r[3 * u + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[4 * (u - 1)]), e.vertexWeights.push(a[4 * (u - 1) + 1]), e.vertexWeights.push(a[4 * (u - 1) + 2]), e.vertexWeights.push(a[4 * (u - 1) + 3]), e.vertexWeights.push(a[4 * u]), e.vertexWeights.push(a[4 * u + 1]), e.vertexWeights.push(a[4 * u + 2]), e.vertexWeights.push(a[4 * u + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (u - 1)]), e.weightsIndices.push(l[4 * (u - 1) + 1]), e.weightsIndices.push(l[4 * (u - 1) + 2]), e.weightsIndices.push(l[4 * (u - 1) + 3]), e.weightsIndices.push(l[4 * u]), e.weightsIndices.push(l[4 * u + 1]), e.weightsIndices.push(l[4 * u + 2]), e.weightsIndices.push(l[4 * u + 3])), t.color && (e.colors.push(s[0]), e.colors.push(s[1]), e.colors.push(s[2]), e.colors.push(s[3 * (u - 1)]), e.colors.push(s[3 * (u - 1) + 1]), e.colors.push(s[3 * (u - 1) + 2]), e.colors.push(s[3 * u]), e.colors.push(s[3 * u + 1]), e.colors.push(s[3 * u + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[3 * (u - 1)]), e.normal.push(i[3 * (u - 1) + 1]), e.normal.push(i[3 * (u - 1) + 2]), e.normal.push(i[3 * u]), e.normal.push(i[3 * u + 1]), e.normal.push(i[3 * u + 2])), t.uv && t.uv.forEach(function (t, r) {
        void 0 === e.uvs[r] && (e.uvs[r] = []), e.uvs[r].push(o[r][0]), e.uvs[r].push(o[r][1]), e.uvs[r].push(o[r][2 * (u - 1)]), e.uvs[r].push(o[r][2 * (u - 1) + 1]), e.uvs[r].push(o[r][2 * u]), e.uvs[r].push(o[r][2 * u + 1]);
      });
    }
    addMorphTargets(e, t, r, n) {
      if (0 === r.length) return;
      e.morphTargetsRelative = !0, e.morphAttributes.position = [];
      const i = this;
      r.forEach(function (r) {
        r.rawTargets.forEach(function (r) {
          const s = Sm.Objects.Geometry[r.geoID];
          void 0 !== s && i.genMorphGeometry(e, t, s, n, r.name);
        });
      });
    }
    genMorphGeometry(e, t, r, i, s) {
      const o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
        a = void 0 !== r.Vertices ? r.Vertices.a : [],
        l = void 0 !== r.Indexes ? r.Indexes.a : [],
        c = 3 * e.attributes.position.count,
        u = new Float32Array(c);
      for (let e = 0; e < l.length; e++) {
        const t = 3 * l[e];
        u[t] = a[3 * e], u[t + 1] = a[3 * e + 1], u[t + 2] = a[3 * e + 2];
      }
      const h = {
          vertexIndices: o,
          vertexPositions: u
        },
        p = this.genBuffers(h),
        d = new n.a$l(p.vertex, 3);
      d.name = s || r.attrName, d.applyMatrix4(i), e.morphAttributes.position.push(d);
    }
    parseNormals(e) {
      const t = e.MappingInformationType,
        r = e.ReferenceInformationType,
        n = e.Normals.a;
      let i = [];
      return "IndexToDirect" === r && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
        dataSize: 3,
        buffer: n,
        indices: i,
        mappingType: t,
        referenceType: r
      };
    }
    parseUVs(e) {
      const t = e.MappingInformationType,
        r = e.ReferenceInformationType,
        n = e.UV.a;
      let i = [];
      return "IndexToDirect" === r && (i = e.UVIndex.a), {
        dataSize: 2,
        buffer: n,
        indices: i,
        mappingType: t,
        referenceType: r
      };
    }
    parseVertexColors(e) {
      const t = e.MappingInformationType,
        r = e.ReferenceInformationType,
        n = e.Colors.a;
      let i = [];
      return "IndexToDirect" === r && (i = e.ColorIndex.a), {
        dataSize: 4,
        buffer: n,
        indices: i,
        mappingType: t,
        referenceType: r
      };
    }
    parseMaterialIndices(e) {
      const t = e.MappingInformationType,
        r = e.ReferenceInformationType;
      if ("NoMappingInformation" === t) return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: r
      };
      const n = e.Materials.a,
        i = [];
      for (let e = 0; e < n.length; ++e) i.push(e);
      return {
        dataSize: 1,
        buffer: n,
        indices: i,
        mappingType: t,
        referenceType: r
      };
    }
    parseNurbsGeometry(e) {
      if (void 0 === Em) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new n.u9r();
      const t = parseInt(e.Order);
      if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new n.u9r();
      const r = t - 1,
        i = e.KnotVector.a,
        s = [],
        o = e.Points.a;
      for (let e = 0, t = o.length; e < t; e += 4) s.push(new n.Ltg().fromArray(o, e));
      let a, l;
      if ("Closed" === e.Form) s.push(s[0]);else if ("Periodic" === e.Form) {
        a = r, l = i.length - 1 - a;
        for (let e = 0; e < r; ++e) s.push(s[e]);
      }
      const c = new Em(r, i, s, a, l).getPoints(12 * s.length);
      return new n.u9r().setFromPoints(c);
    }
  }
  class Dm {
    parse() {
      const e = [],
        t = this.parseClips();
      if (void 0 !== t) for (const r in t) {
        const n = t[r],
          i = this.addClip(n);
        e.push(i);
      }
      return e;
    }
    parseClips() {
      if (void 0 === Sm.Objects.AnimationCurve) return;
      const e = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(e);
      const t = this.parseAnimationLayers(e);
      return this.parseAnimStacks(t);
    }
    parseAnimationCurveNodes() {
      const e = Sm.Objects.AnimationCurveNode,
        t = new Map();
      for (const r in e) {
        const n = e[r];
        if (null !== n.attrName.match(/S|R|T|DeformPercent/)) {
          const e = {
            id: n.id,
            attr: n.attrName,
            curves: {}
          };
          t.set(e.id, e);
        }
      }
      return t;
    }
    parseAnimationCurves(e) {
      const t = Sm.Objects.AnimationCurve;
      for (const r in t) {
        const n = {
            id: t[r].id,
            times: t[r].KeyTime.a.map(Fm),
            values: t[r].KeyValueFloat.a
          },
          i = Cm.get(n.id);
        if (void 0 !== i) {
          const t = i.parents[0].ID,
            r = i.parents[0].relationship;
          r.match(/X/) ? e.get(t).curves.x = n : r.match(/Y/) ? e.get(t).curves.y = n : r.match(/Z/) ? e.get(t).curves.z = n : r.match(/d|DeformPercent/) && e.has(t) && (e.get(t).curves.morph = n);
        }
      }
    }
    parseAnimationLayers(e) {
      const t = Sm.Objects.AnimationLayer,
        r = new Map();
      for (const i in t) {
        const t = [],
          s = Cm.get(parseInt(i));
        void 0 !== s && (s.children.forEach(function (r, i) {
          if (e.has(r.ID)) {
            const s = e.get(r.ID);
            if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
              if (void 0 === t[i]) {
                const e = Cm.get(r.ID).parents.filter(function (e) {
                  return void 0 !== e.relationship;
                })[0].ID;
                if (void 0 !== e) {
                  const s = Sm.Objects.Model[e.toString()];
                  if (void 0 === s) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", r);
                  const o = {
                    modelName: s.attrName ? n.iUV.sanitizeNodeName(s.attrName) : "",
                    ID: s.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  Mm.traverse(function (e) {
                    e.ID === s.id && (o.transform = e.matrix, e.userData.transformData && (o.eulerOrder = e.userData.transformData.eulerOrder));
                  }), o.transform || (o.transform = new n.yGw()), "PreRotation" in s && (o.preRotation = s.PreRotation.value), "PostRotation" in s && (o.postRotation = s.PostRotation.value), t[i] = o;
                }
              }
              t[i] && (t[i][s.attr] = s);
            } else if (void 0 !== s.curves.morph) {
              if (void 0 === t[i]) {
                const e = Cm.get(r.ID).parents.filter(function (e) {
                    return void 0 !== e.relationship;
                  })[0].ID,
                  s = Cm.get(e).parents[0].ID,
                  o = Cm.get(s).parents[0].ID,
                  a = Cm.get(o).parents[0].ID,
                  l = Sm.Objects.Model[a],
                  c = {
                    modelName: l.attrName ? n.iUV.sanitizeNodeName(l.attrName) : "",
                    morphName: Sm.Objects.Deformer[e].attrName
                  };
                t[i] = c;
              }
              t[i][s.attr] = s;
            }
          }
        }), r.set(parseInt(i), t));
      }
      return r;
    }
    parseAnimStacks(e) {
      const t = Sm.Objects.AnimationStack,
        r = {};
      for (const n in t) {
        const i = Cm.get(parseInt(n)).children;
        i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        const s = e.get(i[0].ID);
        r[n] = {
          name: t[n].attrName,
          layer: s
        };
      }
      return r;
    }
    addClip(e) {
      let t = [];
      const r = this;
      return e.layer.forEach(function (e) {
        t = t.concat(r.generateTracks(e));
      }), new n.m7l(e.name, -1, t);
    }
    generateTracks(e) {
      const t = [];
      let r = new n.Pa4(),
        i = new n._fP(),
        s = new n.Pa4();
      if (e.transform && e.transform.decompose(r, i, s), r = r.toArray(), i = new n.USm().setFromQuaternion(i, e.eulerOrder).toArray(), s = s.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
        const n = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
        void 0 !== n && t.push(n);
      }
      if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
        const r = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotation, e.postRotation, e.eulerOrder);
        void 0 !== r && t.push(r);
      }
      if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
        const r = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
        void 0 !== r && t.push(r);
      }
      if (void 0 !== e.DeformPercent) {
        const r = this.generateMorphTrack(e);
        void 0 !== r && t.push(r);
      }
      return t;
    }
    generateVectorTrack(e, t, r, i) {
      const s = this.getTimesForAllAxes(t),
        o = this.getKeyframeTrackValues(s, t, r);
      return new n.yC1(e + "." + i, s, o);
    }
    generateRotationTrack(e, t, r, i, s, o) {
      void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(n.M8C.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(n.M8C.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(n.M8C.degToRad));
      const a = this.getTimesForAllAxes(t),
        l = this.getKeyframeTrackValues(a, t, r);
      void 0 !== i && ((i = i.map(n.M8C.degToRad)).push(o), i = new n.USm().fromArray(i), i = new n._fP().setFromEuler(i)), void 0 !== s && ((s = s.map(n.M8C.degToRad)).push(o), s = new n.USm().fromArray(s), s = new n._fP().setFromEuler(s).invert());
      const c = new n._fP(),
        u = new n.USm(),
        h = [];
      for (let e = 0; e < l.length; e += 3) u.set(l[e], l[e + 1], l[e + 2], o), c.setFromEuler(u), void 0 !== i && c.premultiply(i), void 0 !== s && c.multiply(s), c.toArray(h, e / 3 * 4);
      return new n.iLg(e + ".quaternion", a, h);
    }
    generateMorphTrack(e) {
      const t = e.DeformPercent.curves.morph,
        r = t.values.map(function (e) {
          return e / 100;
        }),
        i = Mm.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
      return new n.dUE(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, r);
    }
    getTimesForAllAxes(e) {
      let t = [];
      if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort(function (e, t) {
        return e - t;
      }), t.length > 1) {
        let e = 1,
          r = t[0];
        for (let n = 1; n < t.length; n++) {
          const i = t[n];
          i !== r && (t[e] = i, r = i, e++);
        }
        t = t.slice(0, e);
      }
      return t;
    }
    getKeyframeTrackValues(e, t, r) {
      const n = r,
        i = [];
      let s = -1,
        o = -1,
        a = -1;
      return e.forEach(function (e) {
        if (t.x && (s = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (a = t.z.times.indexOf(e)), -1 !== s) {
          const e = t.x.values[s];
          i.push(e), n[0] = e;
        } else i.push(n[0]);
        if (-1 !== o) {
          const e = t.y.values[o];
          i.push(e), n[1] = e;
        } else i.push(n[1]);
        if (-1 !== a) {
          const e = t.z.values[a];
          i.push(e), n[2] = e;
        } else i.push(n[2]);
      }), i;
    }
    interpolateRotations(e) {
      for (let t = 1; t < e.values.length; t++) {
        const r = e.values[t - 1],
          n = e.values[t] - r,
          i = Math.abs(n);
        if (i >= 180) {
          const s = i / 180,
            o = n / s;
          let a = r + o;
          const l = e.times[t - 1],
            c = (e.times[t] - l) / s;
          let u = l + c;
          const h = [],
            p = [];
          for (; u < e.times[t];) h.push(u), u += c, p.push(a), a += o;
          e.times = Wm(e.times, t, h), e.values = Wm(e.values, t, p);
        }
      }
    }
  }
  class Pm {
    getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }
    getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }
    getCurrentProp() {
      return this.currentProp;
    }
    pushStack(e) {
      this.nodeStack.push(e), this.currentIndent += 1;
    }
    popStack() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }
    setCurrentProp(e, t) {
      this.currentProp = e, this.currentPropName = t;
    }
    parse(e) {
      this.currentIndent = 0, this.allNodes = new Lm(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      const t = this,
        r = e.split(/[\r\n]+/);
      return r.forEach(function (e, n) {
        const i = e.match(/^[\s\t]*;/),
          s = e.match(/^[\s\t]*$/);
        if (i || s) return;
        const o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
          a = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
          l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
        o ? t.parseNodeBegin(e, o) : a ? t.parseNodeProperty(e, a, r[++n]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
      }), this.allNodes;
    }
    parseNodeBegin(e, t) {
      const r = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
        n = t[2].split(",").map(function (e) {
          return e.trim().replace(/^"/, "").replace(/"$/, "");
        }),
        i = {
          name: r
        },
        s = this.parseNodeAttr(n),
        o = this.getCurrentNode();
      0 === this.currentIndent ? this.allNodes.add(r, i) : r in o ? ("PoseNode" === r ? o.PoseNode.push(i) : void 0 !== o[r].id && (o[r] = {}, o[r][o[r].id] = o[r]), "" !== s.id && (o[r][s.id] = i)) : "number" == typeof s.id ? (o[r] = {}, o[r][s.id] = i) : "Properties70" !== r && (o[r] = "PoseNode" === r ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i);
    }
    parseNodeAttr(e) {
      let t = e[0];
      "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
      let r = "",
        n = "";
      return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), n = e[2]), {
        id: t,
        name: r,
        type: n
      };
    }
    parseNodeProperty(e, t, r) {
      let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
        i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
      "Content" === n && "," === i && (i = r.replace(/"/g, "").replace(/,$/, "").trim());
      const s = this.getCurrentNode();
      if ("Properties70" !== s.name) {
        if ("C" === n) {
          const e = i.split(",").slice(1),
            t = parseInt(e[0]),
            r = parseInt(e[1]);
          let o = i.split(",").slice(3);
          o = o.map(function (e) {
            return e.trim().replace(/^"/, "");
          }), n = "connections", i = [t, r], function (e, t) {
            for (let r = 0, n = e.length, i = t.length; r < i; r++, n++) e[n] = t[r];
          }(i, o), void 0 === s[n] && (s[n] = []);
        }
        "Node" === n && (s.id = i), n in s && Array.isArray(s[n]) ? s[n].push(i) : "a" !== n ? s[n] = i : s.a = i, this.setCurrentProp(s, n), "a" === n && "," !== i.slice(-1) && (s.a = Qm(i));
      } else this.parseNodeSpecialProperty(e, n, i);
    }
    parseNodePropertyContinued(e) {
      const t = this.getCurrentNode();
      t.a += e, "," !== e.slice(-1) && (t.a = Qm(t.a));
    }
    parseNodeSpecialProperty(e, t, r) {
      const n = r.split('",').map(function (e) {
          return e.trim().replace(/^\"/, "").replace(/\s/, "_");
        }),
        i = n[0],
        s = n[1],
        o = n[2],
        a = n[3];
      let l = n[4];
      switch (s) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          l = parseFloat(l);
          break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          l = Qm(l);
      }
      this.getPrevNode()[i] = {
        type: s,
        type2: o,
        flag: a,
        value: l
      }, this.setCurrentProp(this.getPrevNode(), i);
    }
  }
  class Bm {
    parse(e) {
      const t = new Rm(e);
      t.skip(23);
      const r = t.getUint32();
      if (r < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
      const n = new Lm();
      for (; !this.endOfContent(t);) {
        const e = this.parseNode(t, r);
        null !== e && n.add(e.name, e);
      }
      return n;
    }
    endOfContent(e) {
      return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
    }
    parseNode(e, t) {
      const r = {},
        n = t >= 7500 ? e.getUint64() : e.getUint32(),
        i = t >= 7500 ? e.getUint64() : e.getUint32();
      t >= 7500 ? e.getUint64() : e.getUint32();
      const s = e.getUint8(),
        o = e.getString(s);
      if (0 === n) return null;
      const a = [];
      for (let t = 0; t < i; t++) a.push(this.parseProperty(e));
      const l = a.length > 0 ? a[0] : "",
        c = a.length > 1 ? a[1] : "",
        u = a.length > 2 ? a[2] : "";
      for (r.singleProperty = 1 === i && e.getOffset() === n; n > e.getOffset();) {
        const n = this.parseNode(e, t);
        null !== n && this.parseSubNode(o, r, n);
      }
      return r.propertyList = a, "number" == typeof l && (r.id = l), "" !== c && (r.attrName = c), "" !== u && (r.attrType = u), "" !== o && (r.name = o), r;
    }
    parseSubNode(e, t, r) {
      if (!0 === r.singleProperty) {
        const e = r.propertyList[0];
        Array.isArray(e) ? (t[r.name] = r, r.a = e) : t[r.name] = e;
      } else if ("Connections" === e && "C" === r.name) {
        const e = [];
        r.propertyList.forEach(function (t, r) {
          0 !== r && e.push(t);
        }), void 0 === t.connections && (t.connections = []), t.connections.push(e);
      } else if ("Properties70" === r.name) Object.keys(r).forEach(function (e) {
        t[e] = r[e];
      });else if ("Properties70" === e && "P" === r.name) {
        let e = r.propertyList[0],
          n = r.propertyList[1];
        const i = r.propertyList[2],
          s = r.propertyList[3];
        let o;
        0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === n.indexOf("Lcl ") && (n = n.replace("Lcl ", "Lcl_")), o = "Color" === n || "ColorRGB" === n || "Vector" === n || "Vector3D" === n || 0 === n.indexOf("Lcl_") ? [r.propertyList[4], r.propertyList[5], r.propertyList[6]] : r.propertyList[4], t[e] = {
          type: n,
          type2: i,
          flag: s,
          value: o
        };
      } else void 0 === t[r.name] ? "number" == typeof r.id ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : "PoseNode" === r.name ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : void 0 === t[r.name][r.id] && (t[r.name][r.id] = r);
    }
    parseProperty(e) {
      const r = e.getString(1);
      let n;
      switch (r) {
        case "C":
          return e.getBoolean();
        case "D":
          return e.getFloat64();
        case "F":
          return e.getFloat32();
        case "I":
          return e.getInt32();
        case "L":
          return e.getInt64();
        case "R":
          return n = e.getUint32(), e.getArrayBuffer(n);
        case "S":
          return n = e.getUint32(), e.getString(n);
        case "Y":
          return e.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          const i = e.getUint32(),
            s = e.getUint32(),
            o = e.getUint32();
          if (0 === s) switch (r) {
            case "b":
            case "c":
              return e.getBooleanArray(i);
            case "d":
              return e.getFloat64Array(i);
            case "f":
              return e.getFloat32Array(i);
            case "i":
              return e.getInt32Array(i);
            case "l":
              return e.getInt64Array(i);
          }
          void 0 === t && console.error("THREE.FBXLoader: External library fflate.min.js required.");
          const a = zf(new Uint8Array(e.getArrayBuffer(o))),
            l = new Rm(a.buffer);
          switch (r) {
            case "b":
            case "c":
              return l.getBooleanArray(i);
            case "d":
              return l.getFloat64Array(i);
            case "f":
              return l.getFloat32Array(i);
            case "i":
              return l.getInt32Array(i);
            case "l":
              return l.getInt64Array(i);
          }
          break;
        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + r);
      }
    }
  }
  class Rm {
    constructor(e, t) {
      this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t;
    }
    getOffset() {
      return this.offset;
    }
    size() {
      return this.dv.buffer.byteLength;
    }
    skip(e) {
      this.offset += e;
    }
    getBoolean() {
      return 1 == (1 & this.getUint8());
    }
    getBooleanArray(e) {
      const t = [];
      for (let r = 0; r < e; r++) t.push(this.getBoolean());
      return t;
    }
    getUint8() {
      const e = this.dv.getUint8(this.offset);
      return this.offset += 1, e;
    }
    getInt16() {
      const e = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, e;
    }
    getInt32() {
      const e = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }
    getInt32Array(e) {
      const t = [];
      for (let r = 0; r < e; r++) t.push(this.getInt32());
      return t;
    }
    getUint32() {
      const e = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }
    getInt64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, 4294967295 === e && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e;
    }
    getInt64Array(e) {
      const t = [];
      for (let r = 0; r < e; r++) t.push(this.getInt64());
      return t;
    }
    getUint64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e;
    }
    getFloat32() {
      const e = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }
    getFloat32Array(e) {
      const t = [];
      for (let r = 0; r < e; r++) t.push(this.getFloat32());
      return t;
    }
    getFloat64() {
      const e = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, e;
    }
    getFloat64Array(e) {
      const t = [];
      for (let r = 0; r < e; r++) t.push(this.getFloat64());
      return t;
    }
    getArrayBuffer(e) {
      const t = this.dv.buffer.slice(this.offset, this.offset + e);
      return this.offset += e, t;
    }
    getString(e) {
      let t = [];
      for (let r = 0; r < e; r++) t[r] = this.getUint8();
      const r = t.indexOf(0);
      return r >= 0 && (t = t.slice(0, r)), n.Zp0.decodeText(new Uint8Array(t));
    }
  }
  class Lm {
    add(e, t) {
      this[e] = t;
    }
  }
  function Om(e) {
    const t = e.match(/FBXVersion: (\d+)/);
    if (t) return parseInt(t[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }
  function Fm(e) {
    return e / 46186158e3;
  }
  const Um = [];
  function Nm(e, t, r, n) {
    let i;
    switch (n.mappingType) {
      case "ByPolygonVertex":
        i = e;
        break;
      case "ByPolygon":
        i = t;
        break;
      case "ByVertice":
        i = r;
        break;
      case "AllSame":
        i = n.indices[0];
        break;
      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
    }
    "IndexToDirect" === n.referenceType && (i = n.indices[i]);
    const s = i * n.dataSize,
      o = s + n.dataSize;
    return function (e, t, r, n) {
      for (let i = r, s = 0; i < n; i++, s++) e[s] = t[i];
      return e;
    }(Um, n.buffer, s, o);
  }
  const jm = new n.USm(),
    zm = new n.Pa4();
  function Gm(e) {
    const t = new n.yGw(),
      r = new n.yGw(),
      i = new n.yGw(),
      s = new n.yGw(),
      o = new n.yGw(),
      a = new n.yGw(),
      l = new n.yGw(),
      c = new n.yGw(),
      u = new n.yGw(),
      h = new n.yGw(),
      p = new n.yGw(),
      d = new n.yGw(),
      f = e.inheritType ? e.inheritType : 0;
    if (e.translation && t.setPosition(zm.fromArray(e.translation)), e.preRotation) {
      const t = e.preRotation.map(n.M8C.degToRad);
      t.push(e.eulerOrder || n.USm.DefaultOrder), r.makeRotationFromEuler(jm.fromArray(t));
    }
    if (e.rotation) {
      const t = e.rotation.map(n.M8C.degToRad);
      t.push(e.eulerOrder || n.USm.DefaultOrder), i.makeRotationFromEuler(jm.fromArray(t));
    }
    if (e.postRotation) {
      const t = e.postRotation.map(n.M8C.degToRad);
      t.push(e.eulerOrder || n.USm.DefaultOrder), s.makeRotationFromEuler(jm.fromArray(t)), s.invert();
    }
    e.scale && o.scale(zm.fromArray(e.scale)), e.scalingOffset && l.setPosition(zm.fromArray(e.scalingOffset)), e.scalingPivot && a.setPosition(zm.fromArray(e.scalingPivot)), e.rotationOffset && c.setPosition(zm.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(zm.fromArray(e.rotationPivot)), e.parentMatrixWorld && (p.copy(e.parentMatrix), h.copy(e.parentMatrixWorld));
    const m = r.clone().multiply(i).multiply(s),
      _ = new n.yGw();
    _.extractRotation(h);
    const g = new n.yGw();
    g.copyPosition(h);
    const v = g.clone().invert().multiply(h),
      A = _.clone().invert().multiply(v),
      b = o,
      y = new n.yGw();
    if (0 === f) y.copy(_).multiply(m).multiply(A).multiply(b);else if (1 === f) y.copy(_).multiply(A).multiply(m).multiply(b);else {
      const e = new n.yGw().scale(new n.Pa4().setFromMatrixScale(p)).clone().invert(),
        t = A.clone().multiply(e);
      y.copy(_).multiply(m).multiply(t).multiply(b);
    }
    const x = u.clone().invert(),
      w = a.clone().invert();
    let E = t.clone().multiply(c).multiply(u).multiply(r).multiply(i).multiply(s).multiply(x).multiply(l).multiply(a).multiply(o).multiply(w);
    const S = new n.yGw().copyPosition(E),
      C = h.clone().multiply(S);
    return d.copyPosition(C), E = d.clone().multiply(y), E.premultiply(h.invert()), E;
  }
  function Vm(e) {
    const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e];
  }
  function Qm(e) {
    return e.split(",").map(function (e) {
      return parseFloat(e);
    });
  }
  function Hm(e, t, r) {
    return void 0 === t && (t = 0), void 0 === r && (r = e.byteLength), n.Zp0.decodeText(new Uint8Array(e, t, r));
  }
  function Wm(e, t, r) {
    return e.slice(0, t).concat(r).concat(e.slice(t));
  }
  class qm extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer = new ir(Tm, ["fbx"], !0);
    }
    async onAdded(e) {
      Js.Importers.push(this._importer);
    }
    async onDispose(e) {}
    async onRemove(e) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer), 1);
    }
  }
  qm.PluginType = "FBXLoadPlugin";
  const Xm = new WeakMap();
  class Ym extends n.aNw {
    constructor(e) {
      super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
    }
    setLibraryPath(e) {
      return this.libraryPath = e, this;
    }
    setWorkerLimit(e) {
      return this.workerLimit = e, this;
    }
    load(e, t, r, i) {
      const s = new n.hH6(this.manager);
      s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), this.url = e, s.load(e, r => {
        if (Xm.has(r)) return Xm.get(r).promise.then(t).catch(i);
        this.decodeObjects(r, e).then(e => {
          e.userData.warnings = this.warnings, t(e);
        }).catch(e => i(e));
      }, r, i);
    }
    debug() {
      console.log("Task load: ", this.workerPool.map(e => e._taskLoad));
    }
    decodeObjects(e, t) {
      let r, n;
      const i = e.byteLength,
        s = this._getWorker(i).then(t => (r = t, n = this.workerNextTaskID++, new Promise((t, i) => {
          r._callbacks[n] = {
            resolve: t,
            reject: i
          }, r.postMessage({
            type: "decode",
            id: n,
            buffer: e
          }, [e]);
        }))).then(e => this._createGeometry(e.data)).catch(e => {
          throw e;
        });
      return s.catch(() => !0).then(() => {
        r && n && this._releaseTask(r, n);
      }), Xm.set(e, {
        url: t,
        promise: s
      }), s;
    }
    parse(e, t, r) {
      this.decodeObjects(e, "").then(e => {
        e.userData.warnings = this.warnings, t(e);
      }).catch(e => r(e));
    }
    _compareMaterials(e) {
      const t = {};
      t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type;
      for (let e = 0; e < this.materials.length; e++) {
        const r = this.materials[e],
          n = {};
        if (n.name = r.name, n.color = {}, n.color.r = r.color.r, n.color.g = r.color.g, n.color.b = r.color.b, n.type = r.type, JSON.stringify(t) === JSON.stringify(n)) return r;
      }
      return this.materials.push(e), e;
    }
    _createMaterial(e) {
      if (void 0 === e) return new n.Wid({
        color: new n.Ilk(1, 1, 1),
        metalness: .8,
        name: "default",
        side: 2
      });
      const t = e.diffuseColor,
        r = new n.Ilk(t.r / 255, t.g / 255, t.b / 255);
      0 === t.r && 0 === t.g && 0 === t.b && (r.r = 1, r.g = 1, r.b = 1);
      const i = new n.Wid({
          color: r,
          name: e.name,
          side: 2,
          transparent: e.transparency > 0,
          opacity: 1 - e.transparency
        }),
        s = new n.dpR();
      for (let t = 0; t < e.textures.length; t++) {
        const r = e.textures[t];
        if (null !== r.image) {
          const e = s.load(r.image);
          switch (r.type) {
            case "Diffuse":
              i.map = e;
              break;
            case "Bump":
              i.bumpMap = e;
              break;
            case "Transparency":
              i.alphaMap = e, i.transparent = !0;
              break;
            case "Emap":
              i.envMap = e;
          }
          e.wrapS = 0 === r.wrapU ? n.rpg : n.uWy, e.wrapT = 0 === r.wrapV ? n.rpg : n.uWy, e.repeat.set(r.repeat[0], r.repeat[1]);
        }
      }
      return i;
    }
    _createGeometry(e) {
      const t = new n.Tme(),
        r = [],
        i = [],
        s = [];
      t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url;
      let o = e.objects;
      const a = e.materials;
      for (let n = 0; n < o.length; n++) {
        const l = o[n],
          c = l.attributes;
        switch (l.objectType) {
          case "InstanceDefinition":
            i.push(l);
            break;
          case "InstanceReference":
            s.push(l);
            break;
          default:
            let n;
            if (c.materialIndex >= 0) {
              const e = a[c.materialIndex];
              let t = this._createMaterial(e);
              t = this._compareMaterials(t), n = this._createObject(l, t);
            } else {
              const e = this._createMaterial();
              n = this._createObject(l, e);
            }
            if (void 0 === n) continue;
            const o = e.layers[c.layerIndex];
            n.visible = !o || e.layers[c.layerIndex].visible, c.isInstanceDefinitionObject ? r.push(n) : t.add(n);
        }
      }
      for (let e = 0; e < i.length; e++) {
        const a = i[e];
        o = [];
        for (let e = 0; e < a.attributes.objectIds.length; e++) {
          const t = a.attributes.objectIds[e];
          for (let e = 0; e < r.length; e++) t === r[e].userData.attributes.id && o.push(r[e]);
        }
        for (let e = 0; e < s.length; e++) {
          const r = s[e];
          if (r.geometry.parentIdefId === a.attributes.id) {
            const e = new n.Tme(),
              i = r.geometry.xform.array,
              s = new n.yGw();
            s.set(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]), e.applyMatrix4(s);
            for (let t = 0; t < o.length; t++) e.add(o[t].clone(!0));
            t.add(e);
          }
        }
      }
      return t.userData.materials = this.materials, t;
    }
    _createObject(e, t) {
      const r = new n.s4_(),
        i = e.attributes;
      let s, o, a, l;
      switch (e.objectType) {
        case "Point":
        case "PointSet":
          s = r.parse(e.geometry), s.attributes.hasOwnProperty("color") ? o = new n.UY4({
            vertexColors: !0,
            sizeAttenuation: !1,
            size: 2
          }) : (a = i.drawColor, l = new n.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new n.UY4({
            color: l,
            sizeAttenuation: !1,
            size: 2
          })), o = this._compareMaterials(o);
          const c = new n.woe(s, o);
          return c.userData.attributes = i, c.userData.objectType = e.objectType, i.name && (c.name = i.name), c;
        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
          if (null === e.geometry) return;
          s = r.parse(e.geometry), s.attributes.hasOwnProperty("color") && (t.vertexColors = !0), null === t && (t = this._createMaterial(), t = this._compareMaterials(t));
          const u = new n.Kj0(s, t);
          return u.castShadow = i.castsShadows, u.receiveShadow = i.receivesShadows, u.userData.attributes = i, u.userData.objectType = e.objectType, i.name && (u.name = i.name), u;
        case "Curve":
          s = r.parse(e.geometry), a = i.drawColor, l = new n.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new n.nls({
            color: l
          }), o = this._compareMaterials(o);
          const h = new n.x12(s, o);
          return h.userData.attributes = i, h.userData.objectType = e.objectType, i.name && (h.name = i.name), h;
        case "TextDot":
          s = e.geometry;
          const p = document.createElement("canvas").getContext("2d"),
            d = `${s.fontHeight}px ${s.fontFace}`;
          p.font = d;
          const f = p.measureText(s.text).width + 10,
            m = s.fontHeight + 10,
            _ = window.devicePixelRatio;
          p.canvas.width = f * _, p.canvas.height = m * _, p.canvas.style.width = f + "px", p.canvas.style.height = m + "px", p.setTransform(_, 0, 0, _, 0, 0), p.font = d, p.textBaseline = "middle", p.textAlign = "center", l = i.drawColor, p.fillStyle = `rgba(${l.r},${l.g},${l.b},${l.a})`, p.fillRect(0, 0, f, m), p.fillStyle = "white", p.fillText(s.text, f / 2, m / 2);
          const g = new n.ROQ(p.canvas);
          g.minFilter = n.wem, g.wrapS = n.uWy, g.wrapT = n.uWy, o = new n.xeV({
            map: g,
            depthTest: !1
          });
          const v = new n.jyi(o);
          return v.position.set(s.point[0], s.point[1], s.point[2]), v.scale.set(f / 10, m / 10, 1), v.userData.attributes = i, v.userData.objectType = e.objectType, i.name && (v.name = i.name), v;
        case "Light":
          let A;
          switch (s = e.geometry, s.lightStyle.name) {
            case "LightStyle_WorldPoint":
              A = new n.cek(), A.castShadow = i.castsShadows, A.position.set(s.location[0], s.location[1], s.location[2]), A.shadow.normalBias = .1;
              break;
            case "LightStyle_WorldSpot":
              A = new n.PMe(), A.castShadow = i.castsShadows, A.position.set(s.location[0], s.location[1], s.location[2]), A.target.position.set(s.direction[0], s.direction[1], s.direction[2]), A.angle = s.spotAngleRadians, A.shadow.normalBias = .1;
              break;
            case "LightStyle_WorldRectangular":
              A = new n.T_f();
              const e = Math.abs(s.width[2]),
                t = Math.abs(s.length[0]);
              A.position.set(s.location[0] - t / 2, s.location[1], s.location[2] - e / 2), A.height = t, A.width = e, A.lookAt(new n.Pa4(s.direction[0], s.direction[1], s.direction[2]));
              break;
            case "LightStyle_WorldDirectional":
              A = new n.Ox3(), A.castShadow = i.castsShadows, A.position.set(s.location[0], s.location[1], s.location[2]), A.target.position.set(s.direction[0], s.direction[1], s.direction[2]), A.shadow.normalBias = .1;
          }
          return A && (A.intensity = s.intensity, a = s.diffuse, l = new n.Ilk(a.r / 255, a.g / 255, a.b / 255), A.color = l, A.userData.attributes = i, A.userData.objectType = e.objectType), A;
      }
    }
    _initLibrary() {
      if (!this.libraryPending) {
        const e = new n.hH6(this.manager);
        e.setPath(this.libraryPath);
        const t = new Promise((t, r) => {
            e.load("rhino3dm.js", t, void 0, r);
          }),
          r = new n.hH6(this.manager);
        r.setPath(this.libraryPath), r.setResponseType("arraybuffer");
        const i = new Promise((e, t) => {
          r.load("rhino3dm.wasm", e, void 0, t);
        });
        this.libraryPending = Promise.all([t, i]).then(([e, t]) => {
          this.libraryConfig.wasmBinary = t;
          const r = Km.toString(),
            n = ["/* rhino3dm.js */", e, "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([n]));
        });
      }
      return this.libraryPending;
    }
    _getWorker(e) {
      return this._initLibrary().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e = new Worker(this.workerSourceURL);
          e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
            type: "init",
            libraryConfig: this.libraryConfig
          }), e.onmessage = t => {
            const r = t.data;
            switch (r.type) {
              case "warning":
                this.warnings.push(r.data), console.warn(r.data);
                break;
              case "decode":
                e._callbacks[r.id].resolve(r);
                break;
              case "error":
                e._callbacks[r.id].reject(r);
                break;
              default:
                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + r.type + '"');
            }
          }, this.workerPool.push(e);
        } else this.workerPool.sort(function (e, t) {
          return e._taskLoad > t._taskLoad ? -1 : 1;
        });
        const t = this.workerPool[this.workerPool.length - 1];
        return t._taskLoad += e, t;
      });
    }
    _releaseTask(e, t) {
      e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
    }
    dispose() {
      for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
      return this.workerPool.length = 0, this;
    }
  }
  function Km() {
    let e, t, r, n;
    function i(e, t) {
      const i = e.geometry(),
        a = e.attributes();
      let l,
        c,
        u,
        h,
        p,
        d = i.objectType;
      switch (d) {
        case r.ObjectType.Curve:
          const e = o(i, 100);
          u = {}, c = {}, h = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [];
          for (let t = 0; t < e.length; t++) u.array.push(e[t][0]), u.array.push(e[t][1]), u.array.push(e[t][2]);
          c.position = u, h.attributes = c, l = {
            data: h
          };
          break;
        case r.ObjectType.Point:
          const f = i.location;
          u = {};
          const m = {};
          c = {}, h = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [f[0], f[1], f[2]];
          const _ = a.drawColor(t);
          m.itemSize = 3, m.type = "Float32Array", m.array = [_.r / 255, _.g / 255, _.b / 255], c.position = u, c.color = m, h.attributes = c, l = {
            data: h
          };
          break;
        case r.ObjectType.PointSet:
        case r.ObjectType.Mesh:
          l = i.toThreejsJSON();
          break;
        case r.ObjectType.Brep:
          const g = i.faces();
          p = new r.Mesh();
          for (let e = 0; e < g.count; e++) {
            const t = g.get(e),
              n = t.getMesh(r.MeshType.Any);
            n && (p.append(n), n.delete()), t.delete();
          }
          p.faces().count > 0 && (p.compact(), l = p.toThreejsJSON(), g.delete()), p.delete();
          break;
        case r.ObjectType.Extrusion:
          p = i.getMesh(r.MeshType.Any), p && (l = p.toThreejsJSON(), p.delete());
          break;
        case r.ObjectType.TextDot:
          l = s(i);
          break;
        case r.ObjectType.Light:
          l = s(i), "LightStyle_WorldLinear" === l.lightStyle.name && self.postMessage({
            type: "warning",
            id: n,
            data: {
              message: `THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${l.lightStyle.name}`,
              type: "no conversion",
              guid: a.id
            }
          });
          break;
        case r.ObjectType.InstanceReference:
          l = s(i), l.xform = s(i.xform), l.xform.array = i.xform.toFloatArray(!0);
          break;
        case r.ObjectType.SubD:
          i.subdivide(3), p = r.Mesh.createFromSubDControlNet(i), p && (l = p.toThreejsJSON(), p.delete());
          break;
        default:
          self.postMessage({
            type: "warning",
            id: n,
            data: {
              message: `THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`,
              type: "not implemented",
              guid: a.id
            }
          });
      }
      if (l) return c = s(a), c.geometry = s(i), a.groupCount > 0 && (c.groupIds = a.getGroupList()), a.userStringCount > 0 && (c.userStrings = a.getUserStrings()), i.userStringCount > 0 && (c.geometry.userStrings = i.getUserStrings()), c.drawColor = a.drawColor(t), d = d.constructor.name, d = d.substring(11, d.length), {
        geometry: l,
        attributes: c,
        objectType: d
      };
      self.postMessage({
        type: "warning",
        id: n,
        data: {
          message: `THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`,
          type: "missing mesh",
          guid: a.id
        }
      });
    }
    function s(e) {
      const t = {};
      for (const r in e) {
        const n = e[r];
        "function" != typeof n && ("object" == typeof n && null !== n && n.hasOwnProperty("constructor") ? t[r] = {
          name: n.constructor.name,
          value: n.value
        } : t[r] = n);
      }
      return t;
    }
    function o(e, t) {
      let n = t,
        i = [];
      const s = [];
      if (e instanceof r.LineCurve) return [e.pointAtStart, e.pointAtEnd];
      if (e instanceof r.PolylineCurve) {
        n = e.pointCount;
        for (let t = 0; t < n; t++) i.push(e.point(t));
        return i;
      }
      if (e instanceof r.PolyCurve) {
        const t = e.segmentCount;
        for (let r = 0; r < t; r++) {
          const t = e.segmentCurve(r),
            s = o(t, n);
          i = i.concat(s), t.delete();
        }
        return i;
      }
      if (e instanceof r.ArcCurve && (n = Math.floor(e.angleDegrees / 5), n = n < 2 ? 2 : n), e instanceof r.NurbsCurve && 1 === e.degree) {
        const t = e.tryGetPolyline();
        for (let e = 0; e < t.count; e++) i.push(t.get(e));
        return t.delete(), i;
      }
      const a = e.domain,
        l = n - 1;
      for (let t = 0; t < n; t++) {
        const r = a[0] + t / l * (a[1] - a[0]);
        if (r === a[0] || r === a[1]) {
          s.push(r);
          continue;
        }
        const n = e.tangentAt(r),
          i = e.tangentAt(s.slice(-1)[0]),
          o = n[0] * n[0] + n[1] * n[1] + n[2] * n[2],
          c = i[0] * i[0] + i[1] * i[1] + i[2] * i[2],
          u = Math.sqrt(o * c);
        let h;
        if (0 === u) h = Math.PI / 2;else {
          const e = (n.x * i.x + n.y * i.y + n.z * i.z) / u;
          h = Math.acos(Math.max(-1, Math.min(1, e)));
        }
        h < .1 || s.push(r);
      }
      return i = s.map(t => e.pointAt(t)), i;
    }
    onmessage = function (o) {
      const a = o.data;
      switch (a.type) {
        case "init":
          t = a.libraryConfig;
          const o = t.wasmBinary;
          let l;
          e = new Promise(function (e) {
            l = {
              wasmBinary: o,
              onRuntimeInitialized: e
            }, rhino3dm(l);
          }).then(() => {
            r = l;
          });
          break;
        case "decode":
          n = a.id;
          const c = a.buffer;
          e.then(() => {
            try {
              const e = function (e, t) {
                const r = new Uint8Array(t),
                  o = e.File3dm.fromByteArray(r),
                  a = [],
                  l = [],
                  c = [],
                  u = [],
                  h = [],
                  p = [],
                  d = [],
                  f = o.objects(),
                  m = f.count;
                for (let e = 0; e < m; e++) {
                  const t = f.get(e),
                    r = i(t, o);
                  t.delete(), r && a.push(r);
                }
                for (let e = 0; e < o.instanceDefinitions().count(); e++) {
                  const t = o.instanceDefinitions().get(e),
                    r = s(t);
                  r.objectIds = t.getObjectIds(), a.push({
                    geometry: null,
                    attributes: r,
                    objectType: "InstanceDefinition"
                  });
                }
                const _ = [e.TextureType.Diffuse, e.TextureType.Bump, e.TextureType.Transparency, e.TextureType.Opacity, e.TextureType.Emap],
                  g = [e.TextureType.PBR_BaseColor, e.TextureType.PBR_Subsurface, e.TextureType.PBR_SubsurfaceScattering, e.TextureType.PBR_SubsurfaceScatteringRadius, e.TextureType.PBR_Metallic, e.TextureType.PBR_Specular, e.TextureType.PBR_SpecularTint, e.TextureType.PBR_Roughness, e.TextureType.PBR_Anisotropic, e.TextureType.PBR_Anisotropic_Rotation, e.TextureType.PBR_Sheen, e.TextureType.PBR_SheenTint, e.TextureType.PBR_Clearcoat, e.TextureType.PBR_ClearcoatBump, e.TextureType.PBR_ClearcoatRoughness, e.TextureType.PBR_OpacityIor, e.TextureType.PBR_OpacityRoughness, e.TextureType.PBR_Emission, e.TextureType.PBR_AmbientOcclusion, e.TextureType.PBR_Displacement];
                for (let e = 0; e < o.materials().count(); e++) {
                  const t = o.materials().get(e),
                    r = t.physicallyBased();
                  let i = s(t);
                  const a = [];
                  for (let e = 0; e < _.length; e++) {
                    const r = t.getTexture(_[e]);
                    if (r) {
                      let t = _[e].constructor.name;
                      t = t.substring(12, t.length);
                      const i = {
                          type: t
                        },
                        s = o.getEmbeddedFileAsBase64(r.fileName);
                      i.wrapU = r.wrapU, i.wrapV = r.wrapV, i.wrapW = r.wrapW;
                      const l = r.uvwTransform.toFloatArray(!0);
                      i.repeat = [l[0], l[5]], s ? i.image = "data:image/png;base64," + s : (self.postMessage({
                        type: "warning",
                        id: n,
                        data: {
                          message: `THREE.3DMLoader: Image for ${t} texture not embedded in file.`,
                          type: "missing resource"
                        }
                      }), i.image = null), a.push(i), r.delete();
                    }
                  }
                  if (i.textures = a, r.supported) {
                    for (let e = 0; e < g.length; e++) {
                      const r = t.getTexture(g[e]);
                      if (r) {
                        const t = o.getEmbeddedFileAsBase64(r.fileName);
                        let n = g[e].constructor.name;
                        n = n.substring(12, n.length);
                        const i = {
                          type: n,
                          image: "data:image/png;base64," + t
                        };
                        a.push(i), r.delete();
                      }
                    }
                    const e = s(t.physicallyBased());
                    i = Object.assign(e, i);
                  }
                  l.push(i), t.delete(), r.delete();
                }
                for (let e = 0; e < o.layers().count(); e++) {
                  const t = o.layers().get(e),
                    r = s(t);
                  c.push(r), t.delete();
                }
                for (let e = 0; e < o.views().count(); e++) {
                  const t = o.views().get(e),
                    r = s(t);
                  u.push(r), t.delete();
                }
                for (let e = 0; e < o.namedViews().count(); e++) {
                  const t = o.namedViews().get(e),
                    r = s(t);
                  h.push(r), t.delete();
                }
                for (let e = 0; e < o.groups().count(); e++) {
                  const t = o.groups().get(e),
                    r = s(t);
                  p.push(r), t.delete();
                }
                const v = s(o.settings()),
                  A = o.strings().count();
                for (let e = 0; e < A; e++) d.push(o.strings().get(e));
                return o.delete(), {
                  objects: a,
                  materials: l,
                  layers: c,
                  views: u,
                  namedViews: h,
                  groups: p,
                  strings: d,
                  settings: v
                };
              }(r, c);
              self.postMessage({
                type: "decode",
                id: a.id,
                data: e
              });
            } catch (e) {
              self.postMessage({
                type: "error",
                id: a.id,
                error: e
              });
            }
          });
      }
    };
  }
  class Jm extends Ym {
    constructor(e) {
      super(e), this.setLibraryPath("https://cdn.jsdelivr.net/npm/rhino3dm@7.11.1/");
    }
    async loadAsync(e, t) {
      return await super.loadAsync(e, t);
    }
  }
  class Zm extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer = new ir(Jm, ["3dm"], !0);
    }
    async onAdded(e) {
      Js.Importers.push(this._importer);
    }
    async onDispose(e) {}
    async onRemove(e) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer), 1);
    }
  }
  Zm.PluginType = "Rhino3dmLoadPlugin";
  class $m extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e) {
      const t = document.createElement("script");
      t.type = "module", t.innerHTML = "\nimport { MeshoptDecoder } from 'https://cdn.jsdelivr.net/gh/zeux/meshoptimizer@master/js/meshopt_decoder.module.js'\nwindow.MeshoptDecoder = MeshoptDecoder\n", document.head.appendChild(t), this._script = t;
    }
    async onDispose(e) {}
    async onRemove(e) {
      this._script && (document.head.removeChild(this._script), this._script = void 0);
    }
  }
  $m.PluginType = "GLTFMeshOptPlugin";
  class e_ extends n.aNw {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      const s = this,
        o = new n.hH6(this.manager);
      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (r) {
        try {
          t(s.parse(r));
        } catch (t) {
          i ? i(t) : console.error(t), s.manager.itemError(e);
        }
      }, r, i);
    }
    parse(e) {
      function t(e, t, r) {
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t.getUint8(r + n)) return !1;
        return !0;
      }
      const r = function (e) {
        if ("string" == typeof e) {
          const t = new Uint8Array(e.length);
          for (let r = 0; r < e.length; r++) t[r] = 255 & e.charCodeAt(r);
          return t.buffer || t;
        }
        return e;
      }(e);
      return function (e) {
        const r = new DataView(e);
        if (84 + 50 * r.getUint32(80, !0) === r.byteLength) return !0;
        const n = [115, 111, 108, 105, 100];
        for (let e = 0; e < 5; e++) if (t(n, r, e)) return !1;
        return !0;
      }(r) ? function (e) {
        const t = new DataView(e),
          r = t.getUint32(80, !0);
        let i,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          p = !1;
        for (let e = 0; e < 70; e++) 1129270351 == t.getUint32(e, !1) && 82 == t.getUint8(e + 4) && 61 == t.getUint8(e + 5) && (p = !0, a = new Float32Array(3 * r * 3), l = t.getUint8(e + 6) / 255, c = t.getUint8(e + 7) / 255, u = t.getUint8(e + 8) / 255, h = t.getUint8(e + 9) / 255);
        const d = new n.u9r(),
          f = new Float32Array(3 * r * 3),
          m = new Float32Array(3 * r * 3);
        for (let e = 0; e < r; e++) {
          const r = 84 + 50 * e,
            n = t.getFloat32(r, !0),
            h = t.getFloat32(r + 4, !0),
            d = t.getFloat32(r + 8, !0);
          if (p) {
            const e = t.getUint16(r + 48, !0);
            0 == (32768 & e) ? (i = (31 & e) / 31, s = (e >> 5 & 31) / 31, o = (e >> 10 & 31) / 31) : (i = l, s = c, o = u);
          }
          for (let l = 1; l <= 3; l++) {
            const c = r + 12 * l,
              u = 3 * e * 3 + 3 * (l - 1);
            f[u] = t.getFloat32(c, !0), f[u + 1] = t.getFloat32(c + 4, !0), f[u + 2] = t.getFloat32(c + 8, !0), m[u] = n, m[u + 1] = h, m[u + 2] = d, p && (a[u] = i, a[u + 1] = s, a[u + 2] = o);
          }
        }
        return d.setAttribute("position", new n.TlE(f, 3)), d.setAttribute("normal", new n.TlE(m, 3)), p && (d.setAttribute("color", new n.TlE(a, 3)), d.hasColors = !0, d.alpha = h), d;
      }(r) : function (e) {
        const t = new n.u9r(),
          r = /solid([\s\S]*?)endsolid/g,
          i = /facet([\s\S]*?)endfacet/g;
        let s = 0;
        const o = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
          a = new RegExp("vertex" + o + o + o, "g"),
          l = new RegExp("normal" + o + o + o, "g"),
          c = [],
          u = [],
          h = new n.Pa4();
        let p,
          d = 0,
          f = 0,
          m = 0;
        for (; null !== (p = r.exec(e));) {
          f = m;
          const e = p[0];
          for (; null !== (p = i.exec(e));) {
            let e = 0,
              t = 0;
            const r = p[0];
            for (; null !== (p = l.exec(r));) h.x = parseFloat(p[1]), h.y = parseFloat(p[2]), h.z = parseFloat(p[3]), t++;
            for (; null !== (p = a.exec(r));) c.push(parseFloat(p[1]), parseFloat(p[2]), parseFloat(p[3])), u.push(h.x, h.y, h.z), e++, m++;
            1 !== t && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s), 3 !== e && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s), s++;
          }
          const r = f,
            n = m - f;
          t.addGroup(r, n, d), d++;
        }
        return t.setAttribute("position", new n.a$l(c, 3)), t.setAttribute("normal", new n.a$l(u, 3)), t;
      }("string" != typeof (i = e) ? n.Zp0.decodeText(new Uint8Array(i)) : i);
      var i;
    }
  }
  class t_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e) {
      this._importer || (this._importer = new ir(e_, ["stl"], !0)), Js.Importers.push(this._importer);
    }
    async onDispose(e) {
      this._importer = void 0;
    }
    async onRemove(e) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  t_.PluginType = "STLLoadPlugin";
  class r_ extends n.aNw {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      const s = this,
        o = "" === this.path ? n.Zp0.extractUrlBase(e) : this.path,
        a = new n.hH6(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (r) {
        try {
          t(s.parse(r, o));
        } catch (t) {
          i ? i(t) : console.error(t), s.manager.itemError(e);
        }
      }, r, i);
    }
    setMaterialOptions(e) {
      return this.materialOptions = e, this;
    }
    parse(e, t) {
      const r = e.split("\n");
      let n = {};
      const i = /\s+/,
        s = {};
      for (let e = 0; e < r.length; e++) {
        let t = r[e];
        if (t = t.trim(), 0 === t.length || "#" === t.charAt(0)) continue;
        const o = t.indexOf(" ");
        let a = o >= 0 ? t.substring(0, o) : t;
        a = a.toLowerCase();
        let l = o >= 0 ? t.substring(o + 1) : "";
        if (l = l.trim(), "newmtl" === a) n = {
          name: l
        }, s[l] = n;else if ("ka" === a || "kd" === a || "ks" === a || "ke" === a) {
          const e = l.split(i, 3);
          n[a] = [parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2])];
        } else n[a] = l;
      }
      const o = new n_(this.resourcePath || t, this.materialOptions);
      return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(s), o;
    }
  }
  class n_ {
    constructor(e = "", t = {}) {
      this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : n.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : n.rpg;
    }
    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }
    setManager(e) {
      this.manager = e;
    }
    setMaterials(e) {
      this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
    }
    convert(e) {
      if (!this.options) return e;
      const t = {};
      for (const r in e) {
        const n = e[r],
          i = {};
        t[r] = i;
        for (const e in n) {
          let t = !0,
            r = n[e];
          const s = e.toLowerCase();
          switch (s) {
            case "kd":
            case "ka":
            case "ks":
              this.options && this.options.normalizeRGB && (r = [r[0] / 255, r[1] / 255, r[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === r[0] && 0 === r[1] && 0 === r[2] && (t = !1);
          }
          t && (i[s] = r);
        }
      }
      return t;
    }
    async preload() {
      for (const e in this.materialsInfo) await this.create(e);
    }
    getIndex(e) {
      return this.nameLookup[e];
    }
    async getAsArray() {
      let e = 0;
      for (const t in this.materialsInfo) this.materialsArray[e] = await this.create(t), this.nameLookup[t] = e, e++;
      return this.materialsArray;
    }
    async create(e) {
      return void 0 === this.materials[e] && (await this.createMaterial_(e)), this.materials[e];
    }
    async createMaterial_(e) {
      const t = this,
        r = this.materialsInfo[e],
        i = {
          name: e,
          side: this.side
        };
      async function s(e, r) {
        if (i[e]) return;
        const n = t.getTextureParams(r, i);
        return new Promise((r, s) => {
          let o = !1,
            a = () => !o && (o = !0) && r();
          const l = t.loadTexture((c = t.baseUrl, "string" != typeof (u = n.url) || "" === u ? "" : /^https?:\/\//i.test(u) ? u : c + u), void 0, t => {
            i[e] = t, a();
          }, void 0, a);
          var c, u;
          setTimeout(a, 50), l.repeat.copy(n.scale), l.offset.copy(n.offset), l.wrapS = t.wrap, l.wrapT = t.wrap;
        });
      }
      const o = Array.from(Object.keys(r || {}));
      let a = o.includes("d") || o.includes("D");
      for (const e of o) {
        const t = r[e];
        let o;
        if ("" !== t) switch (e.toLowerCase()) {
          case "kd":
            i.color = new n.Ilk().fromArray(t);
            break;
          case "ks":
            i.specular = new n.Ilk().fromArray(t);
            break;
          case "ke":
            i.emissive = new n.Ilk().fromArray(t);
            break;
          case "map_kd":
            await s("map", t);
            break;
          case "map_ks":
            await s("specularMap", t);
            break;
          case "map_ke":
            await s("emissiveMap", t);
            break;
          case "norm":
            await s("normalMap", t);
            break;
          case "map_bump":
          case "bump":
            await s("bumpMap", t);
            break;
          case "map_d":
            await s("alphaMap", t), i.transparent = !0;
            break;
          case "ns":
            i.shininess = parseFloat(t);
            break;
          case "d":
            o = parseFloat(t), o < 1 && (i.opacity = o, i.transparent = !0);
            break;
          case "tr":
            if (a) break;
            o = parseFloat(t), this.options && this.options.invertTrProperty && (o = 1 - o), o > 0 && (i.opacity = 1 - o, i.transparent = !0);
        }
      }
      return this.materials[e] = new n.xoR(i), this.materials[e];
    }
    getTextureParams(e, t) {
      const r = {
          scale: new n.FM8(1, 1),
          offset: new n.FM8(0, 0)
        },
        i = e.split(/\s+/);
      let s;
      return s = i.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(i[s + 1]), i.splice(s, 2)), s = i.indexOf("-s"), s >= 0 && (r.scale.set(parseFloat(i[s + 1]), parseFloat(i[s + 2])), i.splice(s, 4)), s = i.indexOf("-o"), s >= 0 && (r.offset.set(parseFloat(i[s + 1]), parseFloat(i[s + 2])), i.splice(s, 4)), r.url = i.join(" ").trim(), r;
    }
    loadTexture(e, t, r, i, s) {
      const o = void 0 !== this.manager ? this.manager : n.tEQ;
      let a = o.getHandler(e);
      null === a && (a = new n.dpR(o)), a.setCrossOrigin && a.setCrossOrigin(this.crossOrigin);
      const l = a.load(e, r, i, s);
      return void 0 !== t && (l.mapping = t), l;
    }
  }
  const i_ = /^[og]\s*(.+)?/,
    s_ = /^mtllib /,
    o_ = /^usemtl /,
    a_ = /^usemap /,
    l_ = new n.Pa4(),
    c_ = new n.Pa4(),
    u_ = new n.Pa4(),
    h_ = new n.Pa4(),
    p_ = new n.Pa4();
  function d_() {
    const e = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      colors: [],
      uvs: [],
      materials: {},
      materialLibraries: [],
      startObject: function (e, t) {
        if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void (this.object.fromDeclaration = !1 !== t);
        const r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
        if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
          name: e || "",
          fromDeclaration: !1 !== t,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: !1
          },
          materials: [],
          smooth: !0,
          startMaterial: function (e, t) {
            const r = this._finalize(!1);
            r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1);
            const n = {
              index: this.materials.length,
              name: e || "",
              mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
              smooth: void 0 !== r ? r.smooth : this.smooth,
              groupStart: void 0 !== r ? r.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: !1,
              clone: function (e) {
                const t = {
                  index: "number" == typeof e ? e : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1
                };
                return t.clone = this.clone.bind(t), t;
              }
            };
            return this.materials.push(n), n;
          },
          currentMaterial: function () {
            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
          },
          _finalize: function (e) {
            const t = this.currentMaterial();
            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1) for (let e = this.materials.length - 1; e >= 0; e--) this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
            return e && 0 === this.materials.length && this.materials.push({
              name: "",
              smooth: this.smooth
            }), t;
          }
        }, r && r.name && "function" == typeof r.clone) {
          const e = r.clone(0);
          e.inherited = !0, this.object.materials.push(e);
        }
        this.objects.push(this.object);
      },
      finalize: function () {
        this.object && "function" == typeof this.object._finalize && this.object._finalize(!0);
      },
      parseVertexIndex: function (e, t) {
        const r = parseInt(e, 10);
        return 3 * (r >= 0 ? r - 1 : r + t / 3);
      },
      parseNormalIndex: function (e, t) {
        const r = parseInt(e, 10);
        return 3 * (r >= 0 ? r - 1 : r + t / 3);
      },
      parseUVIndex: function (e, t) {
        const r = parseInt(e, 10);
        return 2 * (r >= 0 ? r - 1 : r + t / 2);
      },
      addVertex: function (e, t, r) {
        const n = this.vertices,
          i = this.object.geometry.vertices;
        i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[r + 0], n[r + 1], n[r + 2]);
      },
      addVertexPoint: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addVertexLine: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addNormal: function (e, t, r) {
        const n = this.normals,
          i = this.object.geometry.normals;
        i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[r + 0], n[r + 1], n[r + 2]);
      },
      addFaceNormal: function (e, t, r) {
        const n = this.vertices,
          i = this.object.geometry.normals;
        l_.fromArray(n, e), c_.fromArray(n, t), u_.fromArray(n, r), p_.subVectors(u_, c_), h_.subVectors(l_, c_), p_.cross(h_), p_.normalize(), i.push(p_.x, p_.y, p_.z), i.push(p_.x, p_.y, p_.z), i.push(p_.x, p_.y, p_.z);
      },
      addColor: function (e, t, r) {
        const n = this.colors,
          i = this.object.geometry.colors;
        void 0 !== n[e] && i.push(n[e + 0], n[e + 1], n[e + 2]), void 0 !== n[t] && i.push(n[t + 0], n[t + 1], n[t + 2]), void 0 !== n[r] && i.push(n[r + 0], n[r + 1], n[r + 2]);
      },
      addUV: function (e, t, r) {
        const n = this.uvs,
          i = this.object.geometry.uvs;
        i.push(n[e + 0], n[e + 1]), i.push(n[t + 0], n[t + 1]), i.push(n[r + 0], n[r + 1]);
      },
      addDefaultUV: function () {
        const e = this.object.geometry.uvs;
        e.push(0, 0), e.push(0, 0), e.push(0, 0);
      },
      addUVLine: function (e) {
        const t = this.uvs;
        this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
      },
      addFace: function (e, t, r, n, i, s, o, a, l) {
        const c = this.vertices.length;
        let u = this.parseVertexIndex(e, c),
          h = this.parseVertexIndex(t, c),
          p = this.parseVertexIndex(r, c);
        if (this.addVertex(u, h, p), this.addColor(u, h, p), void 0 !== o && "" !== o) {
          const e = this.normals.length;
          u = this.parseNormalIndex(o, e), h = this.parseNormalIndex(a, e), p = this.parseNormalIndex(l, e), this.addNormal(u, h, p);
        } else this.addFaceNormal(u, h, p);
        if (void 0 !== n && "" !== n) {
          const e = this.uvs.length;
          u = this.parseUVIndex(n, e), h = this.parseUVIndex(i, e), p = this.parseUVIndex(s, e), this.addUV(u, h, p), this.object.geometry.hasUVIndices = !0;
        } else this.addDefaultUV();
      },
      addPointGeometry: function (e) {
        this.object.geometry.type = "Points";
        const t = this.vertices.length;
        for (let r = 0, n = e.length; r < n; r++) {
          const n = this.parseVertexIndex(e[r], t);
          this.addVertexPoint(n), this.addColor(n);
        }
      },
      addLineGeometry: function (e, t) {
        this.object.geometry.type = "Line";
        const r = this.vertices.length,
          n = this.uvs.length;
        for (let t = 0, n = e.length; t < n; t++) this.addVertexLine(this.parseVertexIndex(e[t], r));
        for (let e = 0, r = t.length; e < r; e++) this.addUVLine(this.parseUVIndex(t[e], n));
      }
    };
    return e.startObject("", !1), e;
  }
  class f_ extends n.aNw {
    constructor(e) {
      super(e), this.materials = null;
    }
    load(e, t, r, i) {
      const s = this,
        o = new n.hH6(this.manager);
      o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, async function (r) {
        try {
          t(await s.parse(r));
        } catch (t) {
          i ? i(t) : console.error(t), s.manager.itemError(e);
        }
      }, r, i);
    }
    setMaterials(e) {
      return this.materials = e, this;
    }
    async parse(e) {
      const t = new d_();
      -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
      const r = e.split("\n");
      let i = "",
        s = "",
        o = 0,
        a = [];
      const l = "function" == typeof "".trimLeft;
      for (let e = 0, n = r.length; e < n; e++) if (i = r[e], i = l ? i.trimLeft() : i.trim(), o = i.length, 0 !== o && (s = i.charAt(0), "#" !== s)) if ("v" === s) {
        const e = i.split(/\s+/);
        switch (e[0]) {
          case "v":
            t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])), e.length >= 7 ? t.colors.push(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6])) : t.colors.push(void 0, void 0, void 0);
            break;
          case "vn":
            t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
            break;
          case "vt":
            t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
        }
      } else if ("f" === s) {
        const e = i.substr(1).trim().split(/\s+/),
          r = [];
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t];
          if (n.length > 0) {
            const e = n.split("/");
            r.push(e);
          }
        }
        const n = r[0];
        for (let e = 1, i = r.length - 1; e < i; e++) {
          const i = r[e],
            s = r[e + 1];
          t.addFace(n[0], i[0], s[0], n[1], i[1], s[1], n[2], i[2], s[2]);
        }
      } else if ("l" === s) {
        const e = i.substring(1).trim().split(" ");
        let r = [];
        const n = [];
        if (-1 === i.indexOf("/")) r = e;else for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t].split("/");
          "" !== i[0] && r.push(i[0]), "" !== i[1] && n.push(i[1]);
        }
        t.addLineGeometry(r, n);
      } else if ("p" === s) {
        const e = i.substr(1).trim().split(" ");
        t.addPointGeometry(e);
      } else if (null !== (a = i_.exec(i))) {
        const e = (" " + a[0].substr(1).trim()).substr(1);
        t.startObject(e);
      } else if (o_.test(i)) t.object.startMaterial(i.substring(7).trim(), t.materialLibraries);else if (s_.test(i)) {
        t.materialLibraries.push(i.substring(7).trim());
        const e = i.substring(7).trim(),
          r = this.manager.getHandler(e);
        if (r) {
          const t = await r.loadAsync(e).catch(e => {
            console.warn(e);
          });
          t && this.setMaterials(t);
        } else console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.");
      } else if (a_.test(i)) console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if ("s" === s) {
        if (a = i.split(" "), a.length > 1) {
          const e = a[1].trim().toLowerCase();
          t.object.smooth = "0" !== e && "off" !== e;
        } else t.object.smooth = !0;
        const e = t.object.currentMaterial();
        e && (e.smooth = t.object.smooth);
      } else {
        if ("\0" === i) continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + i + '"');
      }
      t.finalize();
      const c = new n.ZAu();
      if (c.materialLibraries = [].concat(t.materialLibraries), !0 == !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length)) for (let e = 0, r = t.objects.length; e < r; e++) {
        const r = t.objects[e],
          i = r.geometry,
          s = r.materials,
          o = "Line" === i.type,
          a = "Points" === i.type;
        let l = !1;
        if (0 === i.vertices.length) continue;
        const u = new n.u9r();
        u.setAttribute("position", new n.a$l(i.vertices, 3)), i.normals.length > 0 && u.setAttribute("normal", new n.a$l(i.normals, 3)), i.colors.length > 0 && (l = !0, u.setAttribute("color", new n.a$l(i.colors, 3))), !0 === i.hasUVIndices && u.setAttribute("uv", new n.a$l(i.uvs, 2));
        const h = [];
        for (let e = 0, r = s.length; e < r; e++) {
          const r = s[e],
            i = r.name + "_" + r.smooth + "_" + l;
          let c = t.materials[i];
          if (null !== this.materials) if (c = await this.materials.create(r.name), !o || !c || c instanceof n.nls) {
            if (a && c && !(c instanceof n.UY4)) {
              const e = new n.UY4({
                size: 10,
                sizeAttenuation: !1
              });
              n.F5T.prototype.copy.call(e, c), e.color.copy(c.color), e.map = c.map, c = e;
            }
          } else {
            const e = new n.nls();
            n.F5T.prototype.copy.call(e, c), e.color.copy(c.color), c = e;
          }
          void 0 === c && (c = o ? new n.nls() : a ? new n.UY4({
            size: 1,
            sizeAttenuation: !1
          }) : new n.xoR(), c.name = r.name, c.flatShading = !r.smooth, c.vertexColors = l, t.materials[i] = c), h.push(c);
        }
        let p;
        if (h.length > 1) {
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            u.addGroup(t.groupStart, t.groupCount, e);
          }
          p = o ? new n.ejS(u, h) : a ? new n.woe(u, h) : new n.Kj0(u, h);
        } else p = o ? new n.ejS(u, h[0]) : a ? new n.woe(u, h[0]) : new n.Kj0(u, h[0]);
        p.name = r.name, c.add(p);
      } else if (t.vertices.length > 0) {
        const e = new n.UY4({
            size: 1,
            sizeAttenuation: !1
          }),
          r = new n.u9r();
        r.setAttribute("position", new n.a$l(t.vertices, 3)), t.colors.length > 0 && void 0 !== t.colors[0] && (r.setAttribute("color", new n.a$l(t.colors, 3)), e.vertexColors = !0);
        const i = new n.woe(r, e);
        c.add(i);
      }
      return c;
    }
  }
  class m_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer1 = new ir(f_, ["obj"], !0), this._importer2 = new ir(r_, ["mtl"], !1);
    }
    async onAdded(e) {
      Js.Importers.push(this._importer1), Js.Importers.push(this._importer2);
    }
    async onDispose(e) {}
    async onRemove(e) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer1), 1), Js.Importers.splice(Js.Importers.indexOf(this._importer2), 1);
    }
  }
  m_.PluginType = "ObjMtlLoadPlugin";
  class __ extends n.DqL {
    constructor(e) {
      super(e);
    }
    parse(e, t) {
      const r = new g_(e, 1);
      return {
        mipmaps: r.mipmaps(t),
        width: r.pixelWidth,
        height: r.pixelHeight,
        format: r.glInternalFormat,
        isCubemap: 6 === r.numberOfFaces,
        mipmapCount: r.numberOfMipmapLevels
      };
    }
  }
  class g_ {
    constructor(e, t) {
      this.arrayBuffer = e;
      const r = new Uint8Array(this.arrayBuffer, 0, 12);
      if (171 !== r[0] || 75 !== r[1] || 84 !== r[2] || 88 !== r[3] || 32 !== r[4] || 49 !== r[5] || 49 !== r[6] || 187 !== r[7] || 13 !== r[8] || 10 !== r[9] || 26 !== r[10] || 10 !== r[11]) return void console.error("texture missing KTX identifier");
      const n = Uint32Array.BYTES_PER_ELEMENT,
        i = new DataView(this.arrayBuffer, 12, 13 * n),
        s = 67305985 === i.getUint32(0, !0);
      this.glType = i.getUint32(1 * n, s), this.glTypeSize = i.getUint32(2 * n, s), this.glFormat = i.getUint32(3 * n, s), this.glInternalFormat = i.getUint32(4 * n, s), this.glBaseInternalFormat = i.getUint32(5 * n, s), this.pixelWidth = i.getUint32(6 * n, s), this.pixelHeight = i.getUint32(7 * n, s), this.pixelDepth = i.getUint32(8 * n, s), this.numberOfArrayElements = i.getUint32(9 * n, s), this.numberOfFaces = i.getUint32(10 * n, s), this.numberOfMipmapLevels = i.getUint32(11 * n, s), this.bytesOfKeyValueData = i.getUint32(12 * n, s), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t ? this.loadType = 0 : console.warn("number of faces expected" + t + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported");
    }
    mipmaps(e) {
      const t = [];
      let r = 64 + this.bytesOfKeyValueData,
        n = this.pixelWidth,
        i = this.pixelHeight;
      const s = e ? this.numberOfMipmapLevels : 1;
      for (let e = 0; e < s; e++) {
        const e = new Int32Array(this.arrayBuffer, r, 1)[0];
        r += 4;
        for (let s = 0; s < this.numberOfFaces; s++) {
          const s = new Uint8Array(this.arrayBuffer, r, e);
          t.push({
            data: s,
            width: n,
            height: i
          }), r += e, r += 3 - (e + 3) % 4;
        }
        n = Math.max(1, .5 * n), i = Math.max(1, .5 * i);
      }
      return t;
    }
  }
  class v_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e) {
      this._importer || (this._importer = new ir(__, ["ktx"], !1)), Js.Importers.push(this._importer);
    }
    async onDispose(e) {
      this._importer = void 0;
    }
    async onRemove(e) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  v_.PluginType = "KTXLoadPlugin";
  class A_ extends n.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }
  }
  class b_ extends n.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }
    load(e, t, r, n) {
      return super.load(e, e => {
        try {
          null == t || t(xt(e));
        } catch (e) {
          null == n || n(e);
        }
      }, r, n);
    }
  }
  class y_ {
    async parseAsync(e, t) {
      var r;
      return new Blob([JSON.stringify(e, null, null !== (r = t.jsonSpaces) && void 0 !== r ? r : 2)], {
        type: "application/json"
      });
    }
  }
  class x_ {
    async parseAsync(e, t) {
      return new Blob([e], {
        type: "text/plain"
      });
    }
  }
  class w_ {
    constructor() {
      this.pluginCallbacks = [], this.register(function (e) {
        return new B_(e);
      }), this.register(function (e) {
        return new R_(e);
      }), this.register(function (e) {
        return new L_(e);
      }), this.register(function (e) {
        return new U_(e);
      }), this.register(function (e) {
        return new N_(e);
      }), this.register(function (e) {
        return new O_(e);
      }), this.register(function (e) {
        return new j_(e);
      }), this.register(function (e) {
        return new F_(e);
      }), this.register(function (e) {
        return new z_(e);
      });
    }
    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }
    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }
    parse(e, t, r, n, i) {
      const s = i || new P_(),
        o = [];
      for (let e = 0, t = this.pluginCallbacks.length; e < t; e++) o.push(this.pluginCallbacks[e](s));
      s.setPlugins(o), s.write(e, t, n).catch(r);
    }
    parseAsync(e, t) {
      const r = this;
      return new Promise(function (n, i) {
        r.parse(e, n, i, t);
      });
    }
  }
  const E_ = 5121,
    S_ = 5123,
    C_ = {};
  C_[n.TyD] = 9728, C_[n.YLQ] = 9984, C_[n.aH4] = 9986, C_[n.wem] = 9729, C_[n.qyh] = 9985, C_[n.D1R] = 9987, C_[n.uWy] = 33071, C_[n.rpg] = 10497, C_[n.OoA] = 33648;
  const M_ = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
  };
  function T_(e, t) {
    return e.length === t.length && e.every(function (e, r) {
      return e === t[r];
    });
  }
  function I_(e) {
    return 4 * Math.ceil(e / 4);
  }
  function k_(e, t = 0) {
    const r = I_(e.byteLength);
    if (r !== e.byteLength) {
      const n = new Uint8Array(r);
      if (n.set(new Uint8Array(e)), 0 !== t) for (let i = e.byteLength; i < r; i++) n[i] = t;
      return n.buffer;
    }
    return e;
  }
  function D_(e, t) {
    if (void 0 !== e.toBlob) return new Promise(r => e.toBlob(r, t));
    let r;
    return "image/jpeg" === t ? r = .92 : "image/webp" === t && (r = .8), e.convertToBlob({
      type: t,
      quality: r
    });
  }
  class P_ {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = new Map(), this.uid = 0, this.json = {
        asset: {
          version: "2.0",
          generator: "THREE.GLTFExporter"
        }
      }, this.cache = {
        meshes: new Map(),
        attributes: new Map(),
        attributesNormalized: new Map(),
        materials: new Map(),
        textures: new Map(),
        images: new Map()
      };
    }
    setPlugins(e) {
      this.plugins = e;
    }
    async write(e, t, r) {
      this.options = Object.assign({}, {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      }, r), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
      const n = this,
        i = n.buffers,
        s = n.json;
      r = n.options;
      const o = n.extensionsUsed,
        a = new Blob(i, {
          type: "application/octet-stream"
        }),
        l = Object.keys(o);
      if (l.length > 0 && (s.extensionsUsed = l), s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = a.size), !0 === r.binary) {
        const e = new FileReader();
        e.readAsArrayBuffer(a), e.onloadend = function () {
          const r = k_(e.result),
            n = new DataView(new ArrayBuffer(8));
          n.setUint32(0, r.byteLength, !0), n.setUint32(4, 5130562, !0);
          const i = k_((o = JSON.stringify(s), new TextEncoder().encode(o).buffer), 32);
          var o;
          const a = new DataView(new ArrayBuffer(8));
          a.setUint32(0, i.byteLength, !0), a.setUint32(4, 1313821514, !0);
          const l = new ArrayBuffer(12),
            c = new DataView(l);
          c.setUint32(0, 1179937895, !0), c.setUint32(4, 2, !0);
          const u = 12 + a.byteLength + i.byteLength + n.byteLength + r.byteLength;
          c.setUint32(8, u, !0);
          const h = new Blob([l, a, i, n, r], {
              type: "application/octet-stream"
            }),
            p = new FileReader();
          p.readAsArrayBuffer(h), p.onloadend = function () {
            t(p.result);
          };
        };
      } else if (s.buffers && s.buffers.length > 0) {
        const e = new FileReader();
        e.readAsDataURL(a), e.onloadend = function () {
          const r = e.result;
          s.buffers[0].uri = r, t(s);
        };
      } else t(s);
    }
    serializeUserData(e, t) {
      if (0 === Object.keys(e.userData).length) return;
      const r = this.options,
        n = this.extensionsUsed;
      try {
        const i = JSON.parse(JSON.stringify(e.userData));
        if (r.includeCustomExtensions && i.gltfExtensions) {
          void 0 === t.extensions && (t.extensions = {});
          for (const e in i.gltfExtensions) t.extensions[e] = i.gltfExtensions[e], n[e] = !0;
          delete i.gltfExtensions;
        }
        Object.keys(i).length > 0 && (t.extras = i);
      } catch (t) {
        console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message), console.warn({
          ...e.userData
        });
      }
    }
    getUID(e, t = !1) {
      if (!1 === this.uids.has(e)) {
        const t = new Map();
        t.set(!0, this.uid++), t.set(!1, this.uid++), this.uids.set(e, t);
      }
      return this.uids.get(e).get(t);
    }
    isNormalizedNormalAttribute(e) {
      if (this.cache.attributesNormalized.has(e)) return !1;
      const t = new n.Pa4();
      for (let r = 0, n = e.count; r < n; r++) if (Math.abs(t.fromBufferAttribute(e, r).length() - 1) > 5e-4) return !1;
      return !0;
    }
    createNormalizedNormalAttribute(e) {
      const t = this.cache;
      if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
      const r = e.clone(),
        i = new n.Pa4();
      for (let e = 0, t = r.count; e < t; e++) i.fromBufferAttribute(r, e), 0 === i.x && 0 === i.y && 0 === i.z ? i.setX(1) : i.normalize(), r.setXYZ(e, i.x, i.y, i.z);
      return t.attributesNormalized.set(e, r), r;
    }
    applyTextureTransform(e, t) {
      let r = !1;
      const n = {};
      0 === t.offset.x && 0 === t.offset.y || (n.offset = t.offset.toArray(), r = !0), 0 !== t.rotation && (n.rotation = t.rotation, r = !0), 1 === t.repeat.x && 1 === t.repeat.y || (n.scale = t.repeat.toArray(), r = !0), r && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = n, this.extensionsUsed.KHR_texture_transform = !0);
    }
    buildMetalRoughTexture(e, t) {
      if (e === t) return e;
      function r(e) {
        return e.encoding === n.knz ? function (e) {
          return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
        } : function (e) {
          return e;
        };
      }
      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
      const i = e ? e.image : void 0,
        s = t ? t.image : void 0,
        o = Math.max(i ? i.width : 0, s ? s.width : 0),
        a = Math.max(i ? i.height : 0, s ? s.height : 0),
        l = document.createElement("canvas");
      l.width = o, l.height = a;
      const c = l.getContext("2d");
      c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
      const u = c.getImageData(0, 0, o, a);
      if (i) {
        c.drawImage(i, 0, 0, o, a);
        const t = r(e),
          n = c.getImageData(0, 0, o, a).data;
        for (let e = 2; e < n.length; e += 4) u.data[e] = 256 * t(n[e] / 256);
      }
      if (s) {
        c.drawImage(s, 0, 0, o, a);
        const e = r(t),
          n = c.getImageData(0, 0, o, a).data;
        for (let t = 1; t < n.length; t += 4) u.data[t] = 256 * e(n[t] / 256);
      }
      c.putImageData(u, 0, 0);
      const h = (e || t).clone();
      return h.source = new n.Hw6(l), h.encoding = n.rnI, h;
    }
    processBuffer(e) {
      const t = this.json,
        r = this.buffers;
      return t.buffers || (t.buffers = [{
        byteLength: 0
      }]), r.push(e), 0;
    }
    processBufferView(e, t, r, n, i) {
      const s = this.json;
      let o;
      s.bufferViews || (s.bufferViews = []), o = t === E_ ? 1 : t === S_ ? 2 : 4;
      const a = I_(n * e.itemSize * o),
        l = new DataView(new ArrayBuffer(a));
      let c = 0;
      for (let i = r; i < r + n; i++) for (let r = 0; r < e.itemSize; r++) {
        let n;
        e.itemSize > 4 ? n = e.array[i * e.itemSize + r] : 0 === r ? n = e.getX(i) : 1 === r ? n = e.getY(i) : 2 === r ? n = e.getZ(i) : 3 === r && (n = e.getW(i)), 5126 === t ? l.setFloat32(c, n, !0) : 5125 === t ? l.setUint32(c, n, !0) : t === S_ ? l.setUint16(c, n, !0) : t === E_ && l.setUint8(c, n), c += o;
      }
      const u = {
        buffer: this.processBuffer(l.buffer),
        byteOffset: this.byteOffset,
        byteLength: a
      };
      return void 0 !== i && (u.target = i), 34962 === i && (u.byteStride = e.itemSize * o), this.byteOffset += a, s.bufferViews.push(u), {
        id: s.bufferViews.length - 1,
        byteLength: 0
      };
    }
    processBufferViewImage(e) {
      const t = this,
        r = t.json;
      return r.bufferViews || (r.bufferViews = []), new Promise(function (n) {
        const i = new FileReader();
        i.readAsArrayBuffer(e), i.onloadend = function () {
          const e = k_(i.result),
            s = {
              buffer: t.processBuffer(e),
              byteOffset: t.byteOffset,
              byteLength: e.byteLength
            };
          t.byteOffset += e.byteLength, n(r.bufferViews.push(s) - 1);
        };
      });
    }
    processAccessor(e, t, r, n) {
      const i = this.options,
        s = this.json;
      let o;
      if (e.array.constructor === Float32Array) o = 5126;else if (e.array.constructor === Uint32Array) o = 5125;else if (e.array.constructor === Uint16Array) o = S_;else {
        if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        o = E_;
      }
      if (void 0 === r && (r = 0), void 0 === n && (n = e.count), i.truncateDrawRange && void 0 !== t && null === t.index) {
        const i = r + n,
          s = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
        r = Math.max(r, t.drawRange.start), n = Math.min(i, s) - r, n < 0 && (n = 0);
      }
      if (0 === n) return null;
      const a = function (e, t, r) {
        const n = {
          min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
          max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
        };
        for (let i = t; i < t + r; i++) for (let t = 0; t < e.itemSize; t++) {
          let r;
          e.itemSize > 4 ? r = e.array[i * e.itemSize + t] : 0 === t ? r = e.getX(i) : 1 === t ? r = e.getY(i) : 2 === t ? r = e.getZ(i) : 3 === t && (r = e.getW(i)), n.min[t] = Math.min(n.min[t], r), n.max[t] = Math.max(n.max[t], r);
        }
        return n;
      }(e, r, n);
      let l;
      void 0 !== t && (l = e === t.index ? 34963 : 34962);
      const c = this.processBufferView(e, o, r, n, l),
        u = {
          bufferView: c.id,
          byteOffset: c.byteOffset,
          componentType: o,
          count: n,
          max: a.max,
          min: a.min,
          type: {
            1: "SCALAR",
            2: "VEC2",
            3: "VEC3",
            4: "VEC4",
            16: "MAT4"
          }[e.itemSize]
        };
      return s.accessors || (s.accessors = []), s.accessors.push(u) - 1;
    }
    processImage(e, t, r, i = "image/png") {
      const s = this,
        o = s.cache,
        a = s.json,
        l = s.options,
        c = s.pending;
      o.images.has(e) || o.images.set(e, {});
      const u = o.images.get(e),
        h = i + ":flipY/" + r.toString();
      if (void 0 !== u[h]) return u[h];
      a.images || (a.images = []);
      const p = {
          mimeType: i
        },
        d = "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
      d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
      const f = d.getContext("2d");
      if (!0 === r && (f.translate(0, d.height), f.scale(1, -1)), void 0 !== e.data) {
        t !== n.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported."), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const r = new Uint8ClampedArray(e.height * e.width * 4);
        for (let t = 0; t < r.length; t += 4) r[t + 0] = e.data[t + 0], r[t + 1] = e.data[t + 1], r[t + 2] = e.data[t + 2], r[t + 3] = e.data[t + 3];
        f.putImageData(new ImageData(r, e.width, e.height), 0, 0);
      } else f.drawImage(e, 0, 0, d.width, d.height);
      !0 === l.binary ? c.push(D_(d, i).then(e => s.processBufferViewImage(e)).then(e => {
        p.bufferView = e;
      })) : void 0 !== d.toDataURL ? p.uri = d.toDataURL(i) : c.push(D_(d, i).then(e => new FileReader().readAsDataURL(e)).then(e => {
        p.uri = e;
      }));
      const m = a.images.push(p) - 1;
      return u[h] = m, m;
    }
    processSampler(e) {
      const t = this.json;
      t.samplers || (t.samplers = []);
      const r = {
        magFilter: C_[e.magFilter],
        minFilter: C_[e.minFilter],
        wrapS: C_[e.wrapS],
        wrapT: C_[e.wrapT]
      };
      return t.samplers.push(r) - 1;
    }
    processTexture(e) {
      const t = this.cache,
        r = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      r.textures || (r.textures = []);
      let n = e.userData.mimeType;
      "image/webp" === n && (n = "image/png"), "image/jpg" === n && (n = "image/jpeg");
      const i = ["image/jpeg", "image/png"];
      n && !i.includes(n) && console.error("GLTFExporter: Unsupported mime type: " + n + ". Cannot export texture.", e);
      const s = {
        sampler: this.processSampler(e),
        source: !n || i.includes(n) ? this.processImage(e.image, e.format, e.flipY, n) : null
      };
      e.name && (s.name = e.name), this._invokeAll(function (t) {
        t.writeTexture && t.writeTexture(e, s);
      });
      const o = r.textures.push(s) - 1;
      return t.textures.set(e, o), o;
    }
    processMaterial(e) {
      const t = this.cache,
        r = this.json;
      if (t.materials.has(e)) return t.materials.get(e);
      if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      r.materials || (r.materials = []);
      const i = {
        pbrMetallicRoughness: {}
      };
      !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const s = e.color.toArray().concat([e.opacity]);
      if (T_(s, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = e.metalness, i.pbrMetallicRoughness.roughnessFactor = e.roughness) : (i.pbrMetallicRoughness.metallicFactor = .5, i.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
        const t = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap),
          r = {
            index: this.processTexture(t)
          };
        this.applyTextureTransform(r, t), i.pbrMetallicRoughness.metallicRoughnessTexture = r;
      }
      if (e.map) {
        const t = {
          index: this.processTexture(e.map)
        };
        this.applyTextureTransform(t, e.map), i.pbrMetallicRoughness.baseColorTexture = t;
      }
      if (e.emissive) {
        const t = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
          r = Math.max(t.r, t.g, t.b);
        if (r > 1 && (t.multiplyScalar(1 / r), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), r > 0 && (i.emissiveFactor = t.toArray()), e.emissiveMap) {
          const t = {
            index: this.processTexture(e.emissiveMap)
          };
          this.applyTextureTransform(t, e.emissiveMap), i.emissiveTexture = t;
        }
      }
      if (e.normalMap) {
        const t = {
          index: this.processTexture(e.normalMap)
        };
        e.normalScale && 1 !== e.normalScale.x && (t.scale = e.normalScale.x), this.applyTextureTransform(t, e.normalMap), i.normalTexture = t;
      }
      if (e.aoMap) {
        const t = {
          index: this.processTexture(e.aoMap),
          texCoord: 1
        };
        1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity), this.applyTextureTransform(t, e.aoMap), i.occlusionTexture = t;
      }
      e.transparent ? i.alphaMode = "BLEND" : e.alphaTest > 0 && (i.alphaMode = "MASK", i.alphaCutoff = e.alphaTest), e.side === n.ehD && (i.doubleSided = !0), "" !== e.name && (i.name = e.name), this.serializeUserData(e, i), this._invokeAll(function (t) {
        t.writeMaterial && t.writeMaterial(e, i);
      });
      const o = r.materials.push(i) - 1;
      return t.materials.set(e, o), o;
    }
    processMesh(e) {
      const t = this.cache,
        r = this.json,
        i = [e.geometry.uuid];
      if (Array.isArray(e.material)) for (let t = 0, r = e.material.length; t < r; t++) i.push(e.material[t].uuid);else i.push(e.material.uuid);
      const s = i.join(":");
      if (t.meshes.has(s)) return t.meshes.get(s);
      const o = e.geometry;
      let a;
      a = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4;
      const l = {},
        c = {},
        u = [],
        h = [],
        p = {
          uv: "TEXCOORD_0",
          uv2: "TEXCOORD_1",
          color: "COLOR_0",
          skinWeight: "WEIGHTS_0",
          skinIndex: "JOINTS_0"
        },
        d = o.getAttribute("normal");
      void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
      let f = null;
      for (let e in o.attributes) {
        if ("morph" === e.slice(0, 5)) continue;
        const r = o.attributes[e];
        if (e = p[e] || e.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e) || (e = "_" + e), t.attributes.has(this.getUID(r))) {
          c[e] = t.attributes.get(this.getUID(r));
          continue;
        }
        f = null;
        const i = r.array;
        "JOINTS_0" !== e || i instanceof Uint16Array || i instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new n.TlE(new Uint16Array(i), r.itemSize, r.normalized));
        const s = this.processAccessor(f || r, o);
        null !== s && (c[e] = s, t.attributes.set(this.getUID(r), s));
      }
      if (void 0 !== d && o.setAttribute("normal", d), 0 === Object.keys(c).length) return null;
      if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
        const r = [],
          n = [],
          i = {};
        if (void 0 !== e.morphTargetDictionary) for (const t in e.morphTargetDictionary) i[e.morphTargetDictionary[t]] = t;
        for (let s = 0; s < e.morphTargetInfluences.length; ++s) {
          const a = {};
          let l = !1;
          for (const e in o.morphAttributes) {
            if ("position" !== e && "normal" !== e) {
              l || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l = !0);
              continue;
            }
            const r = o.morphAttributes[e][s],
              n = e.toUpperCase(),
              i = o.attributes[e];
            if (t.attributes.has(this.getUID(r, !0))) {
              a[n] = t.attributes.get(this.getUID(r, !0));
              continue;
            }
            const c = r.clone();
            if (!o.morphTargetsRelative) for (let e = 0, t = r.count; e < t; e++) c.setXYZ(e, r.getX(e) - i.getX(e), r.getY(e) - i.getY(e), r.getZ(e) - i.getZ(e));
            a[n] = this.processAccessor(c, o), t.attributes.set(this.getUID(i, !0), a[n]);
          }
          h.push(a), r.push(e.morphTargetInfluences[s]), void 0 !== e.morphTargetDictionary && n.push(i[s]);
        }
        l.weights = r, n.length > 0 && (l.extras = {}, l.extras.targetNames = n);
      }
      const m = Array.isArray(e.material);
      if (m && 0 === o.groups.length) return null;
      const _ = m ? e.material : [e.material],
        g = m ? o.groups : [{
          materialIndex: 0,
          start: void 0,
          count: void 0
        }];
      for (let e = 0, r = g.length; e < r; e++) {
        const r = {
          mode: a,
          attributes: c
        };
        if (this.serializeUserData(o, r), h.length > 0 && (r.targets = h), null !== o.index) {
          let n = this.getUID(o.index);
          void 0 === g[e].start && void 0 === g[e].count || (n += ":" + g[e].start + ":" + g[e].count), t.attributes.has(n) ? r.indices = t.attributes.get(n) : (r.indices = this.processAccessor(o.index, o, g[e].start, g[e].count), t.attributes.set(n, r.indices)), null === r.indices && delete r.indices;
        }
        const n = this.processMaterial(_[g[e].materialIndex]);
        null !== n && (r.material = n), u.push(r);
      }
      l.primitives = u, r.meshes || (r.meshes = []), this._invokeAll(function (t) {
        t.writeMesh && t.writeMesh(e, l);
      });
      const v = r.meshes.push(l) - 1;
      return t.meshes.set(s, v), v;
    }
    processCamera(e) {
      const t = this.json;
      t.cameras || (t.cameras = []);
      const r = e.isOrthographicCamera,
        i = {
          type: r ? "orthographic" : "perspective"
        };
      return r ? i.orthographic = {
        xmag: 2 * e.right,
        ymag: 2 * e.top,
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      } : i.perspective = {
        aspectRatio: e.aspect,
        yfov: n.M8C.degToRad(e.fov),
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      }, "" !== e.name && (i.name = e.type), t.cameras.push(i) - 1;
    }
    processAnimation(e, t) {
      const r = this.json,
        i = this.nodeMap;
      r.animations || (r.animations = []);
      const s = (e = w_.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks,
        o = [],
        a = [];
      for (let e = 0; e < s.length; ++e) {
        const r = s[e],
          l = n.iUV.parseTrackName(r.name);
        let c = n.iUV.findNode(t, l.nodeName);
        const u = M_[l.propertyName];
        if ("bones" === l.objectName && (c = !0 === c.isSkinnedMesh ? c.skeleton.getBoneByName(l.objectIndex) : void 0), !c || !u) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', r.name), null;
        const h = 1;
        let p,
          d = r.values.length / r.times.length;
        u === M_.morphTargetInfluences && (d /= c.morphTargetInfluences.length), !0 === r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (p = "CUBICSPLINE", d /= 3) : p = r.getInterpolation() === n.Syv ? "STEP" : "LINEAR", a.push({
          input: this.processAccessor(new n.TlE(r.times, h)),
          output: this.processAccessor(new n.TlE(r.values, d)),
          interpolation: p
        }), o.push({
          sampler: a.length - 1,
          target: {
            node: i.get(c),
            path: u
          }
        });
      }
      return r.animations.push({
        name: e.name || "clip_" + r.animations.length,
        samplers: a,
        channels: o
      }), r.animations.length - 1;
    }
    processSkin(e) {
      const t = this.json,
        r = this.nodeMap,
        i = t.nodes[r.get(e)],
        s = e.skeleton;
      if (void 0 === s) return null;
      const o = e.skeleton.bones[0];
      if (void 0 === o) return null;
      const a = [],
        l = new Float32Array(16 * s.bones.length),
        c = new n.yGw();
      for (let t = 0; t < s.bones.length; ++t) a.push(r.get(s.bones[t])), c.copy(s.boneInverses[t]), c.multiply(e.bindMatrix).toArray(l, 16 * t);
      return void 0 === t.skins && (t.skins = []), t.skins.push({
        inverseBindMatrices: this.processAccessor(new n.TlE(l, 16)),
        joints: a,
        skeleton: r.get(o)
      }), i.skin = t.skins.length - 1;
    }
    processNode(e) {
      const t = this.json,
        r = this.options,
        n = this.nodeMap;
      t.nodes || (t.nodes = []);
      const i = {};
      if (r.trs) {
        const t = e.quaternion.toArray(),
          r = e.position.toArray(),
          n = e.scale.toArray();
        T_(t, [0, 0, 0, 1]) || (i.rotation = t), T_(r, [0, 0, 0]) || (i.translation = r), T_(n, [1, 1, 1]) || (i.scale = n);
      } else e.matrixAutoUpdate && e.updateMatrix(), !1 === T_(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i.matrix = e.matrix.elements);
      if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
        const t = this.processMesh(e);
        null !== t && (i.mesh = t);
      } else e.isCamera && (i.camera = this.processCamera(e));
      if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
        const t = [];
        for (let n = 0, i = e.children.length; n < i; n++) {
          const i = e.children[n];
          if (i.visible || !1 === r.onlyVisible) {
            const e = this.processNode(i);
            null !== e && t.push(e);
          }
        }
        t.length > 0 && (i.children = t);
      }
      this._invokeAll(function (t) {
        t.writeNode && t.writeNode(e, i);
      });
      const s = t.nodes.push(i) - 1;
      return n.set(e, s), s;
    }
    processScene(e) {
      const t = this.json,
        r = this.options;
      t.scenes || (t.scenes = [], t.scene = 0);
      const n = {};
      "" !== e.name && (n.name = e.name), t.scenes.push(n);
      const i = [];
      for (let t = 0, n = e.children.length; t < n; t++) {
        const n = e.children[t];
        if (n.visible || !1 === r.onlyVisible) {
          const e = this.processNode(n);
          null !== e && i.push(e);
        }
      }
      i.length > 0 && (n.nodes = i), this.serializeUserData(e, n);
    }
    processObjects(e) {
      const t = new n.xsS();
      t.name = "AuxScene";
      for (let r = 0; r < e.length; r++) t.children.push(e[r]);
      this.processScene(t);
    }
    processInput(e) {
      const t = this.options;
      e = e instanceof Array ? e : [e], this._invokeAll(function (t) {
        t.beforeParse && t.beforeParse(e);
      });
      const r = [];
      for (let t = 0; t < e.length; t++) e[t] instanceof n.xsS ? this.processScene(e[t]) : r.push(e[t]);
      r.length > 0 && this.processObjects(r);
      for (let e = 0; e < this.skins.length; ++e) this.processSkin(this.skins[e]);
      for (let r = 0; r < t.animations.length; ++r) this.processAnimation(t.animations[r], e[0]);
      this._invokeAll(function (t) {
        t.afterParse && t.afterParse(e);
      });
    }
    _invokeAll(e) {
      for (let t = 0, r = this.plugins.length; t < r; t++) e(this.plugins[t]);
    }
  }
  class B_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_lights_punctual";
    }
    writeNode(e, t) {
      if (!e.isLight) return;
      if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      const r = this.writer,
        n = r.json,
        i = r.extensionsUsed,
        s = {};
      e.name && (s.name = e.name), s.color = e.color.toArray(), s.intensity = e.intensity, e.isDirectionalLight ? s.type = "directional" : e.isPointLight ? (s.type = "point", e.distance > 0 && (s.range = e.distance)) : e.isSpotLight && (s.type = "spot", e.distance > 0 && (s.range = e.distance), s.spot = {}, s.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, s.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (n.extensions = n.extensions || {}, n.extensions[this.name] = {
        lights: []
      }, i[this.name] = !0);
      const o = n.extensions[this.name].lights;
      o.push(s), t.extensions = t.extensions || {}, t.extensions[this.name] = {
        light: o.length - 1
      };
    }
  }
  class R_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_unlit";
    }
    writeMaterial(e, t) {
      if (!e.isMeshBasicMaterial) return;
      const r = this.writer.extensionsUsed;
      t.extensions = t.extensions || {}, t.extensions[this.name] = {}, r[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9;
    }
  }
  class L_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness";
    }
    writeMaterial(e, t) {
      if (!e.isGLTFSpecularGlossinessMaterial) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      t.pbrMetallicRoughness.baseColorFactor && (i.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
      const s = [1, 1, 1];
      if (e.specular.toArray(s, 0), i.specularFactor = s, i.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (i.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
        const t = {
          index: r.processTexture(e.specularMap)
        };
        r.applyTextureTransform(t, e.specularMap), i.specularGlossinessTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class O_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
        const t = {
          index: r.processTexture(e.clearcoatMap)
        };
        r.applyTextureTransform(t, e.clearcoatMap), i.clearcoatTexture = t;
      }
      if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
        const t = {
          index: r.processTexture(e.clearcoatRoughnessMap)
        };
        r.applyTextureTransform(t, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = t;
      }
      if (e.clearcoatNormalMap) {
        const t = {
          index: r.processTexture(e.clearcoatNormalMap)
        };
        r.applyTextureTransform(t, e.clearcoatNormalMap), i.clearcoatNormalTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class F_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_iridescence";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
        const t = {
          index: r.processTexture(e.iridescenceMap)
        };
        r.applyTextureTransform(t, e.iridescenceMap), i.iridescenceTexture = t;
      }
      if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
        const t = {
          index: r.processTexture(e.iridescenceThicknessMap)
        };
        r.applyTextureTransform(t, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class U_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_transmission";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.transmissionFactor = e.transmission, e.transmissionMap) {
        const t = {
          index: r.processTexture(e.transmissionMap)
        };
        r.applyTextureTransform(t, e.transmissionMap), i.transmissionTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class N_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_volume";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.thicknessFactor = e.thickness, e.thicknessMap) {
        const t = {
          index: r.processTexture(e.thicknessMap)
        };
        r.applyTextureTransform(t, e.thicknessMap), i.thicknessTexture = t;
      }
      i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class j_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_sheen";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || e.sheen < .01) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.sheenColorFactor = e.sheenColor.toArray(), e.sheenColorMap) {
        const t = {
          index: r.processTexture(e.sheenColorMap)
        };
        r.applyTextureTransform(t, e.sheenColorMap), i.sheenColorTexture = t;
      }
      if (i.sheenRoughnessFactor = e.sheenRoughness, e.sheenRoughnessMap) {
        const t = {
          index: r.processTexture(e.sheenRoughnessMap)
        };
        r.applyTextureTransform(t, e.sheenRoughnessMap), i.sheenRoughnessTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, t.extras = t.extras || {}, t.extras.sheenFactor = e.sheen, n[this.name] = !0;
    }
  }
  class z_ {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_ior";
    }
    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const r = this.writer.extensionsUsed,
        n = {};
      n.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0;
    }
  }
  w_.Utils = {
    GLTFWriter: P_,
    insertKeyframe: function (e, t) {
      const r = .001,
        n = e.getValueSize(),
        i = new e.TimeBufferType(e.times.length + 1),
        s = new e.ValueBufferType(e.values.length + n),
        o = e.createInterpolant(new e.ValueBufferType(n));
      let a;
      if (0 === e.times.length) {
        i[0] = t;
        for (let e = 0; e < n; e++) s[e] = 0;
        a = 0;
      } else if (t < e.times[0]) {
        if (Math.abs(e.times[0] - t) < r) return 0;
        i[0] = t, i.set(e.times, 1), s.set(o.evaluate(t), 0), s.set(e.values, n), a = 0;
      } else if (t > e.times[e.times.length - 1]) {
        if (Math.abs(e.times[e.times.length - 1] - t) < r) return e.times.length - 1;
        i[i.length - 1] = t, i.set(e.times, 0), s.set(e.values, 0), s.set(o.evaluate(t), e.values.length), a = i.length - 1;
      } else for (let l = 0; l < e.times.length; l++) {
        if (Math.abs(e.times[l] - t) < r) return l;
        if (e.times[l] < t && e.times[l + 1] > t) {
          i.set(e.times.slice(0, l + 1), 0), i[l + 1] = t, i.set(e.times.slice(l + 1), l + 2), s.set(e.values.slice(0, (l + 1) * n), 0), s.set(o.evaluate(t), (l + 1) * n), s.set(e.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;
          break;
        }
      }
      return e.times = i, e.values = s, a;
    },
    mergeMorphTargetTracks: function (e, t) {
      const r = [],
        i = {},
        s = e.tracks;
      for (let e = 0; e < s.length; ++e) {
        let o = s[e];
        const a = n.iUV.parseTrackName(o.name),
          l = n.iUV.findNode(t, a.nodeName);
        if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
          r.push(o);
          continue;
        }
        if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
          if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
          console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(n.NMF);
        }
        const c = l.morphTargetInfluences.length,
          u = l.morphTargetDictionary[a.propertyIndex];
        if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
        let h;
        if (void 0 === i[l.uuid]) {
          h = o.clone();
          const e = new h.ValueBufferType(c * h.times.length);
          for (let t = 0; t < h.times.length; t++) e[t * c + u] = h.values[t];
          h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = e, i[l.uuid] = h, r.push(h);
          continue;
        }
        const p = o.createInterpolant(new o.ValueBufferType(1));
        h = i[l.uuid];
        for (let e = 0; e < h.times.length; e++) h.values[e * c + u] = p.evaluate(h.times[e]);
        for (let e = 0; e < o.times.length; e++) {
          const t = this.insertKeyframe(h, o.times[e]);
          h.values[t * c + u] = o.values[e];
        }
      }
      return e.tracks = r, e;
    }
  };
  class G_ extends w_.Utils.GLTFWriter {
    constructor() {
      super(...arguments), this._defaultMaterial = new n.Wid();
    }
    serializeUserData(e, t) {
      const r = e.userData,
        n = {};
      r.__disposed && console.error("Serializing a disposed object", e), Object.entries(r).forEach(([e, t]) => {
        (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("_") || "uuid" !== e && (Ue.includes(e) || Ne.includes(e) || ye.includes(e))) && (n[e] = t, delete r[e]);
      }), super.serializeUserData(e, t), Object.entries(n).forEach(([e, t]) => {
        r[e] = t, delete n[e];
      });
    }
    processObjects(e) {
      var t;
      1 === e.length && (null === (t = e[0]) || void 0 === t ? void 0 : t.userData.rootSceneModelRoot) ? this.processScene(e[0]) : super.processObjects(e);
    }
    processMaterial(e) {
      if (this.cache.materials.has(e)) return this.cache.materials.get(e);
      let t = e;
      t && !t.isShaderMaterial || (t = this._defaultMaterial);
      const r = super.processMaterial(t);
      if (!e || t === e) return r;
      const n = JSON.stringify(this.json.materials[r]),
        i = JSON.parse(n);
      this.serializeUserData(e, i), this._invokeAll(t => {
        t.writeMaterial && t.writeMaterial(e, i);
      });
      const s = this.json.materials.push(i) - 1;
      return this.cache.materials.set(e, s), s;
    }
    processImageBlob(e, t) {
      if (!e) return -1;
      const r = this.cache,
        n = this.options,
        i = this.pending,
        s = this.json,
        o = t.image;
      r.images.has(o) || r.images.set(o, {});
      const a = r.images.get(o),
        l = e.type + ":flipY/" + t.flipY.toString();
      if (void 0 !== a[l]) return a[l];
      s.images || (s.images = []);
      const c = {
        mimeType: e.type
      };
      !0 === n.binary ? i.push(new Promise(t => {
        this.processBufferViewImage(e).then(e => {
          c.bufferView = e, t();
        });
      })) : i.push(xt(e).then(e => {
        c.uri = e;
      }));
      const u = s.images.push(c) - 1;
      return a[l] = u, u;
    }
    processSampler(e) {
      return super.processSampler(e);
    }
    processTexture(e) {
      const t = this.cache,
        r = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      const n = e.source.data,
        i = e.userData.mimeType;
      e.userData.rootPath && !this.options.embedUrlImages && (e.source.data = null, delete e.userData.mimeType);
      const s = super.processTexture(e),
        o = r.textures[s];
      if (!o) return console.error("No texture def", s, e), s;
      const a = r.images ? r.images[o.source] : null;
      if (a && (a.extras || (a.extras = {}), e.source && (a.extras.uuid = e.source.uuid), a.extras.t_uuid = e.uuid), e.userData.rootPath && !this.options.embedUrlImages) {
        if (e.source.data = n, e.userData.mimeType = i, !o) return console.error("textureDef is null", s, e), s;
        o.source >= 0 ? console.warn("textureDef.source is already set", s, e) : o.source = this.processImageUri(e.image, e.userData.rootPath, e.flipY, i);
      }
      return o.source < 0 && console.error("textureDef.source cannot be saved", o, e), s;
    }
    processImage(e, t, r, n = "image/png") {
      return e ? super.processImage(e, t, r, n) : -1;
    }
    processImageUri(e, t, r, n = "image/png") {
      const i = this.cache,
        s = this.json;
      i.images.has(e) || i.images.set(e, {});
      const o = i.images.get(e),
        a = n + ":flipY/" + r.toString();
      if (void 0 !== o[a]) return o[a];
      s.images || (s.images = []);
      const l = {
          mimeType: n,
          uri: t,
          extras: {
            flipY: r
          }
        },
        c = s.images.push(l) - 1;
      return o[a] = c, c;
    }
  }
  class V_ extends w_ {
    register(e) {
      return super.register(e);
    }
    async parseAsync(e, t) {
      var r;
      if (!e) throw new Error("No object to export");
      const n = e.__isGLTFOutput || !Array.isArray(e) && !e.isObject3D ? e : await new Promise((r, n) => this.parse(e, r, n, t));
      if (n && "object" == typeof n && !n.byteLength) return new Blob([JSON.stringify(n, (e, t) => e.startsWith("__") ? void 0 : t, null !== (r = t.jsonSpaces) && void 0 !== r ? r : 2)], {
        type: "model/gltf+json"
      });
      if (n) return new Blob([n], {
        type: "model/gltf+binary"
      });
      throw new Error("GLTFExporter2.parse() failed");
    }
    parse(e, t, r, n = {}) {
      var i;
      const s = {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        externalImagesInExtras: !n.embedUrlImages && n.externalImagesInExtras || !1,
        embedUrlImages: null !== (i = n.embedUrlImages) && void 0 !== i && i,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !0
      };
      return "glb" === n.exportExt && (s.binary = !0), !1 !== n.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        e.uuid && (e.userData.gltfUUID = e.uuid);
      })), (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        if (e.animations) for (const t of e.animations) !1 === t.__gltfExport || s.animations.includes(t) || s.animations.push(...e.animations);
      })), super.parse(e, r => {
        !1 !== n.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
          delete e.userData.gltfUUID;
        })), t(Object.assign(r, {
          __isGLTFOutput: !0
        }));
      }, r, s, new G_());
    }
  }
  function Q_(e, t) {
    const r = e.getPlugin(to).exportViewerConfig();
    t.json.textures && t.json.samplers && t.json.images && r.resources.textures && Object.entries(r.resources.textures).forEach(([e, n]) => {
      const i = t.json.textures.find(r => {
        var n, i, s, o, a;
        return (null === (n = r.extras) || void 0 === n ? void 0 : n.uuid) === e || (null === (s = null === (i = t.json.samplers[r.sampler]) || void 0 === i ? void 0 : i.extras) || void 0 === s ? void 0 : s.uuid) === e || (null === (a = null === (o = t.json.images[r.source]) || void 0 === o ? void 0 : o.extras) || void 0 === a ? void 0 : a.t_uuid) === e;
      });
      i && (n.image && r.resources.images && r.resources.images[n.image] && delete r.resources.images[n.image], r.resources.textures[e] = {});
    }), t.json.materials && r.resources.materials && Object.entries(r.resources.materials).forEach(([e, n]) => {
      const i = t.json.materials.find(t => {
        var r;
        return (null === (r = t.extras) || void 0 === r ? void 0 : r.uuid) === e;
      });
      i && (r.resources.materials[e] = {});
    });
    const i = [];
    Object.values(r.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && (e.url.data instanceof Uint16Array || (e.url.data = new Uint16Array(e.url.data)), i.push(e.url)), "Uint8Array" === e.url.type && e.url.data && (e.url.data instanceof Uint8Array || (e.url.data = new Uint8Array(e.url.data)), i.push(e.url)));
      });
    });
    for (const e of i) {
      let r = "application/octet-stream";
      if ("Uint16Array" === e.type) {
        const t = H_(e.data, 4),
          i = new ImageData(t, e.width, e.height),
          s = n.PpQ.getDataURL(i, !0).split(",")[1];
        r = "image/png", e.data = atob(s), e.encoding = "rgbe";
      }
      const i = new Blob([e.data], {
        type: r
      });
      t.json.images || (t.json.images = []);
      const s = {
          mimeType: r
        },
        o = t.json.images.push(s) - 1;
      e.data = {
        image: o
      }, t.pending.push(t.processBufferViewImage(i).then(e => {
        s.bufferView = e;
      }));
    }
    return r;
  }
  function H_(e, t = 3, r) {
    let n, i, s, o, a;
    const l = e.byteLength / (2 * t) | 0;
    r = r || new Uint8ClampedArray(4 * l);
    for (let c = 0; c < l; c++) {
      n = e[c * t], i = e[c * t + 1], s = e[c * t + 2], o = Math.max(Math.max(n, i), s);
      const l = Math.ceil(Math.log2(o));
      a = Math.pow(2, l - 8), r[4 * c] = n / a | 0, r[4 * c + 1] = i / a | 0, r[4 * c + 2] = s / a | 0, r[4 * c + 3] = l + 128;
    }
    return r;
  }
  function W_(e, t = V_, r) {
    var n;
    if (!e) return;
    const i = eg.Exporters.findIndex(e => e.ext.includes("gltf") || e.ext.includes("glb")),
      s = [];
    i >= 0 ? (s.push(...(null !== (n = eg.Exporters[i].extensions) && void 0 !== n ? n : [])), eg.Exporters.splice(i, 1)) : (s.push(Y_), s.push(X_), s.push(q_), s.push(e => new K_(e)), s.push(e => new J_(e)), s.push(e => new Z_(e)), s.push(e => new $_(e))), eg.Exporters.push({
      ctor: () => {
        const n = new t();
        return s.forEach(e => n.register(e)), n.register(t => ({
          afterParse: r => {
            var n, i;
            if (!(null === (n = null == (r = Array.isArray(r) ? r[0] : r) ? void 0 : r.userData) || void 0 === n ? void 0 : n.rootSceneModelRoot) || !1 === (null === (i = null == r ? void 0 : r.userData) || void 0 === i ? void 0 : i.__exportViewerConfig)) return;
            const s = t.json.scenes[t.json.scene || 0];
            s.extensions || (s.extensions = {}), s.extensions[on] = Q_(e, t), t.extensionsUsed[on] = !0;
          }
        })), null == r || r(n), n;
      },
      ext: ["gltf", "glb"],
      extensions: s
    });
  }
  const q_ = e => ({
      writeNode: (t, r) => {
        if (!(null == t ? void 0 : t.isLight)) return;
        r.extensions || (r.extensions = {});
        const n = {};
        t.shadow && (n.shadow = t.shadow.toJSON()), Object.keys(n).length > 0 && (r.extensions[ln] = n, e.extensionsUsed[ln] = !0);
      }
    }),
    X_ = e => ({
      writeNode: (t, r) => {
        if (!(null == t ? void 0 : t.isObject3D)) return;
        r.extensions || (r.extensions = {});
        const n = {};
        void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), !1 === t.visible && (n.visible = !1), !1 === t.frustumCulled && (n.frustumCulled = !1), 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), 1 !== t.layers.mask && (n.layers = t.layers.mask), !1 === t.matrixAutoUpdate && (n.matrixAutoUpdate = !1), Object.keys(n).length > 0 && (r.extensions[cn] = n, e.extensionsUsed[cn] = !0);
      }
    }),
    Y_ = e => ({
      writeMaterial(t, r) {
        var i;
        if (!(null == t ? void 0 : t.isMaterial)) return;
        r.extensions || (r.extensions = {});
        const s = {};
        if (void 0 !== t.emissiveIntensity && (null === (i = t.emissive) || void 0 === i ? void 0 : i.isColor)) {
          const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
            r = Math.max(e.r, e.g, e.b);
          r > 1 && (s.emissiveIntensity = r);
        }
        void 0 !== t.fog && (s.fog = t.fog), void 0 !== t.flatShading && (s.flatShading = t.flatShading), void 0 !== t.blending && (s.blending = t.blending), void 0 !== t.side && t.side !== n.ehD && (s.side = t.side), void 0 !== t.shadowSide && (s.shadowSide = t.shadowSide), void 0 !== t.depthFunc && (s.depthFunc = t.depthFunc), void 0 !== t.depthTest && (s.depthTest = t.depthTest), void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (s.colorWrite = t.colorWrite), void 0 !== t.wireframe && (s.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (s.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (s.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (s.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (s.rotation = t.rotation), void 0 !== t.polygonOffset && (s.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (s.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (s.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (s.dithering = t.dithering), void 0 !== t.alphaToCoverage && (s.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (s.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.toneMapped && (s.toneMapped = t.toneMapped);
        const o = this.materialExternalResources[t.uuid];
        o && Object.entries(o).forEach(([e, t]) => {
          e.startsWith("_") || (s[e] = ke(t, !1, this.serializedMeta));
        }), Object.keys(s).length > 0 && (r.extensions[un] = s, e.extensionsUsed[un] = !0);
      },
      materialExternalResources: {},
      serializedMeta: {
        images: {},
        textures: {}
      },
      beforeParse(t) {
        if (this.materialExternalResources = {}, !e.options.externalImagesInExtras) return;
        const r = [];
        (Array.isArray(t) ? t : [t]).forEach(e => {
          null == e || e.traverse(e => {
            var t;
            e && (null === (t = e.material) || void 0 === t ? void 0 : t.isMaterial) && r.push(e.material);
          });
        }), r.forEach(e => {
          e && (this.materialExternalResources[e.uuid] || (this.materialExternalResources[e.uuid] = {}), this.materialExternalResources[e.uuid].__materialRef = e, Object.entries(e).forEach(([t, r]) => {
            t.startsWith("_") || r && r.isTexture && r.userData.rootPath && (e[t] = null, this.materialExternalResources[e.uuid][t] = r);
          }));
        });
      },
      afterParse(t) {
        const r = Object.values(this.materialExternalResources);
        if (r.length < 1) return;
        r.forEach(e => {
          const t = e.__materialRef;
          t && (Object.entries(e).forEach(([e, r]) => {
            e.startsWith("_") || r && (t[e] = r);
          }), delete this.materialExternalResources[t.uuid]);
        });
        const n = e.json.scenes[e.json.scene || 0];
        n.extensions || (n.extensions = {}), n.extensions[un] = {
          resources: this.serializedMeta
        }, e.extensionsUsed[un] = !0;
      }
    });
  class K_ {
    constructor(e) {
      this.writer = e, this.name = mn;
    }
    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.bumpScale) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.bumpScale = e.bumpScale, e.bumpMap) {
        const t = {
          index: r.processTexture(e.bumpMap)
        };
        r.applyTextureTransform(t, e.bumpMap), i.bumpTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class J_ {
    constructor(e) {
      this.writer = e, this.name = _n;
    }
    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.displacementScale) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.displacementScale = e.displacementScale, i.displacementBias = e.displacementBias, e.displacementMap) {
        const t = {
          index: r.processTexture(e.displacementMap)
        };
        r.applyTextureTransform(t, e.displacementMap), i.displacementTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class Z_ {
    constructor(e) {
      this.writer = e, this.name = vn;
    }
    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.lightMapIntensity) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (i.lightMapIntensity = e.lightMapIntensity, e.lightMap) {
        const t = {
          index: r.processTexture(e.lightMap)
        };
        r.applyTextureTransform(t, e.lightMap), i.lightMapTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class $_ {
    constructor(e) {
      this.writer = e, this.name = gn;
    }
    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || !e.alphaMap) return;
      const r = this.writer,
        n = r.extensionsUsed,
        i = {};
      if (e.alphaMap) {
        const t = {
          index: r.processTexture(e.alphaMap)
        };
        r.applyTextureTransform(t, e.alphaMap), i.alphaTexture = t;
      }
      t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
    }
  }
  class eg extends r {
    constructor(e, t = {}) {
      super(), this._processors = new cr(), this._cachedParsers = [], W_(e);
    }
    get processors() {
      return this._processors;
    }
    getExporter(...e) {
      return eg.Exporters.find(t => t.ext.some(t => e.includes(t)));
    }
    async exportObject(e, t = {}) {
      var r, n, i, s;
      if (!(null == e ? void 0 : e.assetType)) return void console.error("Object has no asset type");
      (null === (n = null === (r = e) || void 0 === r ? void 0 : r.userData) || void 0 === n ? void 0 : n.rootSceneModelRoot) && !1 === t.viewerConfig && (e.userData.__exportViewerConfig = !1);
      const o = await this._exportFile(e, t);
      return (null === (s = null === (i = e) || void 0 === i ? void 0 : i.userData) || void 0 === s ? void 0 : s.rootSceneModelRoot) && !1 === t.viewerConfig && delete e.userData.__exportViewerConfig, o;
    }
    async _exportFile(e, t = {}) {
      var r, n, i;
      let s;
      this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "processing"
      });
      try {
        const o = await this.processBeforeExport(e, t),
          a = null !== (n = null !== (r = t.exportExt) && void 0 !== r ? r : null == o ? void 0 : o.typeExt) && void 0 !== n ? n : null == o ? void 0 : o.ext;
        if (!o || !a) throw new Error(`Unable to preprocess before export ${a}`);
        const l = this._getParser(a);
        this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "exporting"
        });
        const c = await l.parseAsync(o.obj, {
          exportExt: null !== (i = o.ext) && void 0 !== i ? i : a,
          ...t
        });
        c.ext = o.ext, s = c;
      } catch (t) {
        return console.error("AssetExporter: Unable to Export file", e), console.error(t), void this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "error",
          error: t
        });
      }
      return this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "done"
      }), s;
    }
    _createParser(e) {
      const t = eg.Exporters.find(t => t.ext.includes(e));
      if (!t) throw new Error(`No exporter found for extension ${e}`);
      const r = null == t ? void 0 : t.ctor(this);
      if (!r) throw new Error(`Unable to create parser for extension ${e}`);
      return this._cachedParsers.push({
        ext: t.ext,
        parser: r
      }), this.dispatchEvent({
        type: "exporterCreate",
        exporter: t,
        parser: r
      }), r;
    }
    _getParser(e) {
      var t, r;
      return null !== (r = null === (t = this._cachedParsers.find(t => t.ext.includes(e))) || void 0 === t ? void 0 : t.parser) && void 0 !== r ? r : this._createParser(e);
    }
    async processBeforeExport(e, t = {}) {
      switch (null != e.assetType && (e = await this._processors.process(e.assetType, e, t)), e.assetType) {
        case "light":
          return void console.error("AssetExporter: light export not implemented");
        case "model":
          return {
            obj: e,
            ext: "glb"
          };
        case "material":
          return {
            obj: e.toJSON(),
            ext: e.typeSlug || "json",
            typeExt: "json"
          };
        case "texture":
          return {
            obj: e.toJSON(),
            ext: "json"
          };
        default:
          console.error("AssetExporter: unknown asset type", e.assetType);
      }
    }
    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }
  }
  eg.Exporters = [{
    ctor: () => new y_(),
    ext: ["json"]
  }, {
    ctor: () => new x_(),
    ext: ["txt", "text"]
  }];
  class tg extends ro {
    constructor(e) {
      super(), this.enabled = !0, this.exportOptions = {
        compress: !1,
        name: "scene",
        viewerConfig: !0,
        convertMeshToIndexed: !1,
        embedUrlImages: !1
      }, this.exporter = e, this.exportScene = this.exportScene.bind(this);
    }
    async onAdded(e) {
      await super.onAdded(e), this.exporter || (this.exporter = new eg(e)), this.exporter.processors.add("model", {
        forAssetType: "model",
        processAsync: async (e, t) => {
          var r;
          return t.convertMeshToIndexed && (null === (r = e.modelObject) || void 0 === r || r.traverse(e => {
            var t;
            e.geometry && (e.geometry.attributes.index || null === (t = e.setGeometry) || void 0 === t || t.call(e, Y(e.geometry)));
          })), e;
        }
      });
    }
    async onRemove(e) {
      return super.onRemove(e);
    }
    async exportScene(e) {
      var t, r;
      return null === (t = this.exporter) || void 0 === t ? void 0 : t.exportObject(null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot, e || {
        ...this.exportOptions
      });
    }
    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
      const e = this._viewer;
      e.addEventListener("addPlugin", e => {
        var t;
        "function" == typeof (null === (t = e.plugin) || void 0 === t ? void 0 : t.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ");
      });
      const t = Object.entries(e.plugins).filter(([e, t]) => "function" == typeof (null == t ? void 0 : t.toJSON)).map(([e, t]) => ({
        label: e,
        type: "checkbox",
        value: !0
      }));
      return this._uiConfig = {
        type: "folder",
        label: "Asset Export",
        limitedUi: !0,
        children: [{
          type: "input",
          property: [this.exportOptions, "name"],
          limitedUi: !0
        }, {
          type: "folder",
          label: "GLB Export",
          limitedUi: !0,
          children: [{
            type: "checkbox",
            label: "DRACO Compress",
            property: [this.exportOptions, "compress"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Scene Settings",
            property: [this.exportOptions, "viewerConfig"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Indexed meshes only",
            property: [this.exportOptions, "convertMeshToIndexed"]
          }, {
            type: "button",
            label: "Export GLB",
            limitedUi: !0,
            value: async () => {
              const e = await this.exportScene(this.exportOptions);
              e && yt(e, this.exportOptions.name + "." + e.ext);
            }
          }]
        }, {
          type: "folder",
          label: "Preset/Config export",
          children: [{
            type: "folder",
            label: "Plugins",
            children: t
          }, {
            type: "button",
            label: "Select none",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !1, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Select all",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !0, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Export Plugins",
            limitedUi: !0,
            value: async () => {
              const r = new Blob([JSON.stringify(e.getPlugin(to).exportPluginPresets(t.filter(e => !!e.value).map(e => A(e.label) || "")), null, 2)], {
                type: "application/json"
              });
              r && yt(r, this.exportOptions.name + "." + to.ViewerTypeSlug);
            }
          }, {
            type: "button",
            label: "Export All Viewer Config",
            limitedUi: !0,
            value: async () => {
              const t = new Blob([JSON.stringify(e.getPlugin(to).exportViewerConfig(), null, 2)], {
                type: "application/json"
              });
              t && yt(t, this.exportOptions.name + "." + to.ViewerTypeSlug);
            }
          }]
        }]
      };
    }
  }
  tg.PluginType = "AssetExporterPlugin";
  class rg {
    constructor() {
      this._listeners = {};
    }
    addEventListener(e, t) {
      const r = this._listeners;
      return void 0 === r[e] && (r[e] = []), -1 === r[e].indexOf(t) && r[e].push(t), this;
    }
    removeEventListener(e, t) {
      if (void 0 === this._listeners) return this;
      const r = this._listeners[e];
      if (void 0 !== r) {
        const e = r.indexOf(t);
        -1 !== e && r.splice(e, 1);
      }
      return this;
    }
    dispatchEvent(e) {
      if (void 0 === this._listeners) return this;
      const t = this._listeners[e.type];
      if (void 0 !== t) {
        const r = t.slice(0);
        for (let t = 0, n = r.length; t < n; t++) r[t].call(this, e);
      }
      return this;
    }
    dispose() {
      for (const e in this._listeners) delete this._listeners[e];
    }
  }
  class ng extends rg {
    constructor(e, t, r, n = {}) {
      if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = !1, this._name = e, this._parent = t, this._child = r, this._attributes = n, !t.isOnGraph(r)) throw new Error("Cannot connect disconnected graphs.");
    }
    getName() {
      return this._name;
    }
    getParent() {
      return this._parent;
    }
    getChild() {
      return this._child;
    }
    setChild(e) {
      return this._child = e, this;
    }
    getAttributes() {
      return this._attributes;
    }
    dispose() {
      this._disposed || (this._disposed = !0, this.dispatchEvent({
        type: "dispose",
        target: this
      }), super.dispose());
    }
    isDisposed() {
      return this._disposed;
    }
  }
  class ig extends rg {
    constructor(...e) {
      super(...e), this._emptySet = new Set(), this._edges = new Set(), this._parentEdges = new Map(), this._childEdges = new Map();
    }
    listEdges() {
      return Array.from(this._edges);
    }
    listParentEdges(e) {
      return Array.from(this._childEdges.get(e) || this._emptySet);
    }
    listParents(e) {
      return this.listParentEdges(e).map(e => e.getParent());
    }
    listChildEdges(e) {
      return Array.from(this._parentEdges.get(e) || this._emptySet);
    }
    listChildren(e) {
      return this.listChildEdges(e).map(e => e.getChild());
    }
    disconnectParents(e, t) {
      let r = this.listParentEdges(e);
      return t && (r = r.filter(e => t(e.getParent()))), r.forEach(e => e.dispose()), this;
    }
    createEdge(e, t, r, n) {
      return this._registerEdge(new ng(e, t, r, n));
    }
    _registerEdge(e) {
      this._edges.add(e);
      const t = e.getParent();
      this._parentEdges.has(t) || this._parentEdges.set(t, new Set()), this._parentEdges.get(t).add(e);
      const r = e.getChild();
      return this._childEdges.has(r) || this._childEdges.set(r, new Set()), this._childEdges.get(r).add(e), e.addEventListener("dispose", () => this._removeEdge(e)), e;
    }
    _removeEdge(e) {
      return this._edges.delete(e), this._parentEdges.get(e.getParent()).delete(e), this._childEdges.get(e.getChild()).delete(e), this;
    }
  }
  function sg() {
    return sg = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }, sg.apply(this, arguments);
  }
  function og(e) {
    return e instanceof ng;
  }
  function ag(e) {
    return Array.isArray(e) && e[0] instanceof ng;
  }
  function lg(e) {
    return !!(e && "object" == typeof e && Object.values(e)[0] instanceof ng);
  }
  const cg = Symbol("attributes"),
    ug = Symbol("immutableKeys");
  class hg extends rg {
    constructor(e) {
      super(), this._disposed = !1, this.graph = void 0, this[cg] = void 0, this[ug] = void 0, this.graph = e, this[ug] = new Set(), this[cg] = this._createAttributes();
    }
    getDefaults() {
      return {};
    }
    _createAttributes() {
      const e = this.getDefaults(),
        t = {};
      for (const r in e) {
        const n = e[r];
        if (n instanceof hg) {
          const e = this.graph.createEdge(r, this, n);
          e.addEventListener("dispose", () => n.dispose()), this[ug].add(r), t[r] = e;
        } else t[r] = n;
      }
      return t;
    }
    isOnGraph(e) {
      return this.graph === e.graph;
    }
    isDisposed() {
      return this._disposed;
    }
    dispose() {
      this._disposed || (this.graph.listChildEdges(this).forEach(e => e.dispose()), this.graph.disconnectParents(this), this._disposed = !0, this.dispatchEvent({
        type: "dispose"
      }));
    }
    detach() {
      return this.graph.disconnectParents(this), this;
    }
    swap(e, t) {
      for (const r in this[cg]) {
        const n = this[cg][r];
        if (og(n)) {
          const i = n;
          i.getChild() === e && this.setRef(r, t, i.getAttributes());
        } else if (ag(n)) {
          const i = n.find(t => t.getChild() === e);
          if (i) {
            const n = i.getAttributes();
            this.removeRef(r, e).addRef(r, t, n);
          }
        } else if (lg(n)) {
          const i = n;
          for (const n in i) {
            const s = i[n];
            s.getChild() === e && this.setRefMap(r, n, t, s.getAttributes());
          }
        }
      }
      return this;
    }
    get(e) {
      return this[cg][e];
    }
    set(e, t) {
      return this[cg][e] = t, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }
    getRef(e) {
      const t = this[cg][e];
      return t ? t.getChild() : null;
    }
    setRef(e, t, r) {
      if (this[ug].has(e)) throw new Error(`Cannot overwrite immutable attribute, "${e}".`);
      const n = this[cg][e];
      if (n && n.dispose(), !t) return this;
      const i = this.graph.createEdge(e, this, t, r);
      return i.addEventListener("dispose", () => {
        delete this[cg][e], this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this[cg][e] = i, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }
    listRefs(e) {
      return this[cg][e].map(e => e.getChild());
    }
    addRef(e, t, r) {
      const n = this.graph.createEdge(e, this, t, r),
        i = this[cg][e];
      return i.push(n), n.addEventListener("dispose", () => {
        const t = i.filter(e => e !== n);
        i.length = 0;
        for (const e of t) i.push(e);
        this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }
    removeRef(e, t) {
      return this[cg][e].filter(e => e.getChild() === t).forEach(e => e.dispose()), this;
    }
    listRefMapKeys(e) {
      return Object.keys(this[cg][e]);
    }
    listRefMapValues(e) {
      return Object.values(this[cg][e]).map(e => e.getChild());
    }
    getRefMap(e, t) {
      const r = this[cg][e];
      return r[t] ? r[t].getChild() : null;
    }
    setRefMap(e, t, r, n) {
      const i = this[cg][e],
        s = i[t];
      if (s && s.dispose(), !r) return this;
      n = Object.assign(n || {}, {
        key: t
      });
      const o = this.graph.createEdge(e, this, r, sg({}, n, {
        key: t
      }));
      return o.addEventListener("dispose", () => {
        delete i[t], this.dispatchEvent({
          type: "change",
          attribute: e,
          key: t
        });
      }), i[t] = o, this.dispatchEvent({
        type: "change",
        attribute: e,
        key: t
      });
    }
    dispatchEvent(e) {
      return super.dispatchEvent(sg({}, e, {
        target: this
      })), this.graph.dispatchEvent(sg({}, e, {
        target: this,
        type: `node:${e.type}`
      })), this;
    }
  }
  var pg,
    dg,
    fg,
    mg,
    _g,
    gg,
    vg = "undefined" != typeof Float32Array ? Float32Array : Array;
  function Ag(e) {
    var t = e[0],
      r = e[1],
      n = e[2];
    return Math.hypot(t, r, n);
  }
  function bg(e, t, r) {
    var n = t[0],
      i = t[1],
      s = t[2],
      o = r[3] * n + r[7] * i + r[11] * s + r[15];
    return o = o || 1, e[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / o, e[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / o, e[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / o, e;
  }
  function yg(e, t, r) {
    var n = t[0],
      i = t[1],
      s = t[2],
      o = t[3],
      a = t[4],
      l = t[5],
      c = t[6],
      u = t[7],
      h = t[8],
      p = t[9],
      d = t[10],
      f = t[11],
      m = t[12],
      _ = t[13],
      g = t[14],
      v = t[15],
      A = r[0],
      b = r[1],
      y = r[2],
      x = r[3];
    return e[0] = A * n + b * a + y * h + x * m, e[1] = A * i + b * l + y * p + x * _, e[2] = A * s + b * c + y * d + x * g, e[3] = A * o + b * u + y * f + x * v, A = r[4], b = r[5], y = r[6], x = r[7], e[4] = A * n + b * a + y * h + x * m, e[5] = A * i + b * l + y * p + x * _, e[6] = A * s + b * c + y * d + x * g, e[7] = A * o + b * u + y * f + x * v, A = r[8], b = r[9], y = r[10], x = r[11], e[8] = A * n + b * a + y * h + x * m, e[9] = A * i + b * l + y * p + x * _, e[10] = A * s + b * c + y * d + x * g, e[11] = A * o + b * u + y * f + x * v, A = r[12], b = r[13], y = r[14], x = r[15], e[12] = A * n + b * a + y * h + x * m, e[13] = A * i + b * l + y * p + x * _, e[14] = A * s + b * c + y * d + x * g, e[15] = A * o + b * u + y * f + x * v, e;
  }
  function xg(e, t) {
    const r = {
      min: [1 / 0, 1 / 0, 1 / 0],
      max: [-1 / 0, -1 / 0, -1 / 0]
    };
    for (const n of e.listPrimitives()) {
      const e = n.getAttribute("POSITION");
      if (!e) continue;
      let i = [0, 0, 0],
        s = [0, 0, 0];
      for (let n = 0; n < e.getCount(); n++) i = e.getElement(n, i), s = bg(s, i, t), wg(s, r);
    }
    return r;
  }
  function wg(e, t) {
    for (let r = 0; r < 3; r++) t.min[r] = Math.min(e[r], t.min[r]), t.max[r] = Math.max(e[r], t.max[r]);
  }
  Math.random, Math.PI, Math.hypot || (Math.hypot = function () {
    for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
    return Math.sqrt(e);
  }), pg = new vg(3), vg != Float32Array && (pg[0] = 0, pg[1] = 0, pg[2] = 0), function (e) {
    e.ACCESSOR = "Accessor", e.ANIMATION = "Animation", e.ANIMATION_CHANNEL = "AnimationChannel", e.ANIMATION_SAMPLER = "AnimationSampler", e.BUFFER = "Buffer", e.CAMERA = "Camera", e.MATERIAL = "Material", e.MESH = "Mesh", e.PRIMITIVE = "Primitive", e.PRIMITIVE_TARGET = "PrimitiveTarget", e.NODE = "Node", e.ROOT = "Root", e.SCENE = "Scene", e.SKIN = "Skin", e.TEXTURE = "Texture", e.TEXTURE_INFO = "TextureInfo";
  }(dg || (dg = {})), function (e) {
    e.INTERLEAVED = "interleaved", e.SEPARATE = "separate";
  }(fg || (fg = {})), function (e) {
    e.ARRAY_BUFFER = "ARRAY_BUFFER", e.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e.OTHER = "OTHER";
  }(mg || (mg = {})), function (e) {
    e[e.R = 4096] = "R", e[e.G = 256] = "G", e[e.B = 16] = "B", e[e.A = 1] = "A";
  }(_g || (_g = {})), function (e) {
    e.GLTF = "GLTF", e.GLB = "GLB";
  }(gg || (gg = {}));
  class Eg {
    static createBufferFromDataURI(e) {
      if ("undefined" == typeof Buffer) {
        const t = atob(e.split(",")[1]),
          r = new Uint8Array(t.length);
        for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
        return r;
      }
      {
        const t = e.split(",")[1],
          r = e.indexOf("base64") >= 0;
        return Buffer.from(t, r ? "base64" : "utf8");
      }
    }
    static encodeText(e) {
      return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
    }
    static decodeText(e) {
      return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
    }
    static concat(e) {
      let t = 0;
      for (const r of e) t += r.byteLength;
      const r = new Uint8Array(t);
      let n = 0;
      for (const t of e) r.set(t, n), n += t.byteLength;
      return r;
    }
    static pad(e, t = 0) {
      const r = this.padNumber(e.byteLength);
      if (r === e.byteLength) return e;
      const n = new Uint8Array(r);
      if (n.set(e), 0 !== t) for (let i = e.byteLength; i < r; i++) n[i] = t;
      return n;
    }
    static padNumber(e) {
      return 4 * Math.ceil(e / 4);
    }
    static equals(e, t) {
      if (e === t) return !0;
      if (e.byteLength !== t.byteLength) return !1;
      let r = e.byteLength;
      for (; r--;) if (e[r] !== t[r]) return !1;
      return !0;
    }
    static toView(e, t = 0, r = 1 / 0) {
      return new Uint8Array(e.buffer, e.byteOffset + t, Math.min(e.byteLength, r));
    }
    static assertView(e) {
      if (e && !ArrayBuffer.isView(e)) throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);
      return e;
    }
  }
  class Sg {
    static hexToFactor(e, t) {
      e = Math.floor(e);
      const r = t;
      return r[0] = (e >> 16 & 255) / 255, r[1] = (e >> 8 & 255) / 255, r[2] = (255 & e) / 255, this.convertSRGBToLinear(t, t);
    }
    static factorToHex(e) {
      const t = [...e],
        [r, n, i] = this.convertLinearToSRGB(e, t);
      return 255 * r << 16 ^ 255 * n << 8 ^ 255 * i << 0;
    }
    static convertSRGBToLinear(e, t) {
      const r = e,
        n = t;
      for (let e = 0; e < 3; e++) n[e] = r[e] < .04045 ? .0773993808 * r[e] : Math.pow(.9478672986 * r[e] + .0521327014, 2.4);
      return t;
    }
    static convertLinearToSRGB(e, t) {
      const r = e,
        n = t;
      for (let e = 0; e < 3; e++) n[e] = r[e] < .0031308 ? 12.92 * r[e] : 1.055 * Math.pow(r[e], .41666) - .055;
      return t;
    }
  }
  class Cg {
    match(e) {
      return e.length >= 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7];
    }
    getSize(e) {
      const t = new DataView(e.buffer, e.byteOffset);
      return Eg.decodeText(e.slice(12, 16)) === Cg.PNG_FRIED_CHUNK_NAME ? [t.getUint32(32, !1), t.getUint32(36, !1)] : [t.getUint32(16, !1), t.getUint32(20, !1)];
    }
    getChannels(e) {
      return 4;
    }
  }
  Cg.PNG_FRIED_CHUNK_NAME = "CgBI";
  class Mg {
    static registerFormat(e, t) {
      this.impls[e] = t;
    }
    static getMimeType(e) {
      for (const t in this.impls) if (this.impls[t].match(e)) return t;
      return null;
    }
    static getSize(e, t) {
      return this.impls[t] ? this.impls[t].getSize(e) : null;
    }
    static getChannels(e, t) {
      return this.impls[t] ? this.impls[t].getChannels(e) : null;
    }
    static getMemSize(e, t) {
      if (!this.impls[t]) return null;
      if (this.impls[t].getGPUByteLength) return this.impls[t].getGPUByteLength(e);
      let r = 0;
      const n = this.getSize(e, t);
      if (!n) return null;
      for (; n[0] > 1 || n[1] > 1;) r += n[0] * n[1] * 4, n[0] = Math.max(Math.floor(n[0] / 2), 1), n[1] = Math.max(Math.floor(n[1] / 2), 1);
      return r += 4, r;
    }
    static mimeTypeToExtension(e) {
      return "image/jpeg" === e ? "jpg" : e.split("/").pop();
    }
    static extensionToMimeType(e) {
      return "jpg" === e ? "image/jpeg" : `image/${e}`;
    }
  }
  function Tg(e, t) {
    if (t > e.byteLength) throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e.getUint8(t)) throw new TypeError("Invalid JPG, marker table corrupted");
    return e;
  }
  Mg.impls = {
    "image/jpeg": new class {
      match(e) {
        return e.length >= 3 && 255 === e[0] && 216 === e[1] && 255 === e[2];
      }
      getSize(e) {
        let t,
          r,
          n = new DataView(e.buffer, e.byteOffset + 4);
        for (; n.byteLength;) {
          if (t = n.getUint16(0, !1), Tg(n, t), r = n.getUint8(t + 1), 192 === r || 193 === r || 194 === r) return [n.getUint16(t + 7, !1), n.getUint16(t + 5, !1)];
          n = new DataView(e.buffer, n.byteOffset + t + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
      getChannels(e) {
        return 3;
      }
    }(),
    "image/png": new Cg()
  };
  class Ig {
    static basename(e) {
      const t = e.split(/[\\/]/).pop();
      return t.substring(0, t.lastIndexOf("."));
    }
    static extension(e) {
      if (e.startsWith("data:image/")) {
        const t = e.match(/data:(image\/\w+)/)[1];
        return Mg.mimeTypeToExtension(t);
      }
      return e.startsWith("data:model/gltf+json") ? "gltf" : e.startsWith("data:model/gltf-binary") ? "glb" : e.startsWith("data:application/") ? "bin" : e.split(/[\\/]/).pop().split(/[.]/).pop();
    }
  }
  function kg(e) {
    return "[object Object]" === Object.prototype.toString.call(e);
  }
  function Dg(e) {
    if (!1 === kg(e)) return !1;
    const t = e.constructor;
    if (void 0 === t) return !0;
    const r = t.prototype;
    return !1 !== kg(r) && !1 !== Object.prototype.hasOwnProperty.call(r, "isPrototypeOf");
  }
  class Pg {
    constructor(e) {
      this.verbosity = void 0, this.verbosity = e;
    }
    debug(e) {
      this.verbosity <= Pg.Verbosity.DEBUG && console.debug(e);
    }
    info(e) {
      this.verbosity <= Pg.Verbosity.INFO && console.info(e);
    }
    warn(e) {
      this.verbosity <= Pg.Verbosity.WARN && console.warn(e);
    }
    error(e) {
      this.verbosity <= Pg.Verbosity.ERROR && console.error(e);
    }
  }
  Pg.Verbosity = {
    SILENT: 4,
    ERROR: 3,
    WARN: 2,
    INFO: 1,
    DEBUG: 0
  }, Pg.DEFAULT_INSTANCE = new Pg(Pg.Verbosity.INFO);
  class Bg {
    static identity(e) {
      return e;
    }
    static eq(e, t) {
      if (e.length !== t.length) return !1;
      for (let r = 0; r < e.length; r++) if (Math.abs(e[r] - t[r]) > 1e-5) return !1;
      return !0;
    }
    static denormalize(e, t) {
      switch (t) {
        case 5126:
          return e;
        case 5123:
          return e / 65535;
        case 5121:
          return e / 255;
        case 5122:
          return Math.max(e / 32767, -1);
        case 5120:
          return Math.max(e / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static normalize(e, t) {
      switch (t) {
        case 5126:
          return e;
        case 5123:
          return Math.round(65535 * e);
        case 5121:
          return Math.round(255 * e);
        case 5122:
          return Math.round(32767 * e);
        case 5120:
          return Math.round(127 * e);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static decompose(e, t, r, n) {
      let i = Ag([e[0], e[1], e[2]]);
      const s = Ag([e[4], e[5], e[6]]),
        o = Ag([e[8], e[9], e[10]]);
      (function (e) {
        var t = e[0],
          r = e[1],
          n = e[2],
          i = e[3],
          s = e[4],
          o = e[5],
          a = e[6],
          l = e[7],
          c = e[8],
          u = e[9],
          h = e[10],
          p = e[11],
          d = e[12],
          f = e[13],
          m = e[14],
          _ = e[15];
        return (t * o - r * s) * (h * _ - p * m) - (t * a - n * s) * (u * _ - p * f) + (t * l - i * s) * (u * m - h * f) + (r * a - n * o) * (c * _ - p * d) - (r * l - i * o) * (c * m - h * d) + (n * l - i * a) * (c * f - u * d);
      })(e) < 0 && (i = -i), t[0] = e[12], t[1] = e[13], t[2] = e[14];
      const a = e.slice(),
        l = 1 / i,
        c = 1 / s,
        u = 1 / o;
      a[0] *= l, a[1] *= l, a[2] *= l, a[4] *= c, a[5] *= c, a[6] *= c, a[8] *= u, a[9] *= u, a[10] *= u, function (e, t) {
        var r = new vg(3);
        !function (e, t) {
          var r = t[0],
            n = t[1],
            i = t[2],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[8],
            c = t[9],
            u = t[10];
          e[0] = Math.hypot(r, n, i), e[1] = Math.hypot(s, o, a), e[2] = Math.hypot(l, c, u);
        }(r, t);
        var n = 1 / r[0],
          i = 1 / r[1],
          s = 1 / r[2],
          o = t[0] * n,
          a = t[1] * i,
          l = t[2] * s,
          c = t[4] * n,
          u = t[5] * i,
          h = t[6] * s,
          p = t[8] * n,
          d = t[9] * i,
          f = t[10] * s,
          m = o + u + f,
          _ = 0;
        m > 0 ? (_ = 2 * Math.sqrt(m + 1), e[3] = .25 * _, e[0] = (h - d) / _, e[1] = (p - l) / _, e[2] = (a - c) / _) : o > u && o > f ? (_ = 2 * Math.sqrt(1 + o - u - f), e[3] = (h - d) / _, e[0] = .25 * _, e[1] = (a + c) / _, e[2] = (p + l) / _) : u > f ? (_ = 2 * Math.sqrt(1 + u - o - f), e[3] = (p - l) / _, e[0] = (a + c) / _, e[1] = .25 * _, e[2] = (h + d) / _) : (_ = 2 * Math.sqrt(1 + f - o - u), e[3] = (a - c) / _, e[0] = (p + l) / _, e[1] = (h + d) / _, e[2] = .25 * _);
      }(r, a), n[0] = i, n[1] = s, n[2] = o;
    }
    static compose(e, t, r, n) {
      const i = n,
        s = t[0],
        o = t[1],
        a = t[2],
        l = t[3],
        c = s + s,
        u = o + o,
        h = a + a,
        p = s * c,
        d = s * u,
        f = s * h,
        m = o * u,
        _ = o * h,
        g = a * h,
        v = l * c,
        A = l * u,
        b = l * h,
        y = r[0],
        x = r[1],
        w = r[2];
      return i[0] = (1 - (m + g)) * y, i[1] = (d + b) * y, i[2] = (f - A) * y, i[3] = 0, i[4] = (d - b) * x, i[5] = (1 - (p + g)) * x, i[6] = (_ + v) * x, i[7] = 0, i[8] = (f + A) * w, i[9] = (_ - v) * w, i[10] = (1 - (p + m)) * w, i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i;
    }
  }
  function Rg(e, t) {
    if (!!e != !!t) return !1;
    const r = e.getChild(),
      n = t.getChild();
    return r === n || r.equals(n);
  }
  function Lg(e, t) {
    if (!!e != !!t) return !1;
    if (e.length !== t.length) return !1;
    for (let r = 0; r < e.length; r++) {
      const n = e[r],
        i = t[r];
      if (n.getChild() !== i.getChild() && !n.getChild().equals(i.getChild())) return !1;
    }
    return !0;
  }
  function Og(e, t) {
    if (!!e != !!t) return !1;
    const r = Object.keys(e),
      n = Object.keys(t);
    if (r.length !== n.length) return !1;
    for (const r in e) {
      const n = e[r],
        i = t[r];
      if (!!n != !!i) return !1;
      const s = n.getChild(),
        o = i.getChild();
      if (s !== o && !s.equals(o)) return !1;
    }
    return !0;
  }
  function Fg(e, t) {
    if (e === t) return !0;
    if (!!e != !!t || !e || !t) return !1;
    if (e.length !== t.length) return !1;
    for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
    return !0;
  }
  function Ug(e, t) {
    if (e === t) return !0;
    if (!!e != !!t) return !1;
    if (!Dg(e) || !Dg(t)) return e === t;
    const r = e,
      n = t;
    let i,
      s = 0,
      o = 0;
    for (i in r) s++;
    for (i in n) o++;
    if (s !== o) return !1;
    for (i in r) {
      const e = r[i],
        t = n[i];
      if (Ng(e) && Ng(t)) {
        if (!Fg(e, t)) return !1;
      } else if (Dg(e) && Dg(t)) {
        if (!Ug(e, t)) return !1;
      } else if (e !== t) return !1;
    }
    return !0;
  }
  function Ng(e) {
    return Array.isArray(e) || ArrayBuffer.isView(e);
  }
  const jg = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",
    zg = new Set(),
    Gg = function () {
      let e = "";
      for (let t = 0; t < 6; t++) e += jg.charAt(Math.floor(Math.random() * jg.length));
      return e;
    };
  class Vg {
    static dirname(e) {
      const t = e.lastIndexOf("/");
      return -1 === t ? "./" : e.substring(0, t + 1);
    }
    static basename(e) {
      return Ig.basename(new URL(e, "https://null.example").pathname);
    }
    static extension(e) {
      return Ig.extension(new URL(e, "https://null.example").pathname);
    }
    static resolve(e, t) {
      if (!this.isRelativePath(t)) return t;
      const r = e.split("/"),
        n = t.split("/");
      r.pop();
      for (let e = 0; e < n.length; e++) "." !== n[e] && (".." === n[e] ? r.pop() : r.push(n[e]));
      return r.join("/");
    }
    static isAbsoluteURL(e) {
      return this.PROTOCOL_REGEXP.test(e);
    }
    static isRelativePath(e) {
      return !/^(?:[a-zA-Z]+:)?\//.test(e);
    }
  }
  Vg.DEFAULT_INIT = {}, Vg.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
  const Qg = e => e,
    Hg = new Set();
  class Wg extends hg {
    constructor(e, t = "") {
      super(e), this[cg].name = t, this.init(), this.dispatchEvent({
        type: "create"
      });
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        name: "",
        extras: {}
      });
    }
    getName() {
      return this.get("name");
    }
    setName(e) {
      return this.set("name", e);
    }
    getExtras() {
      return this.get("extras");
    }
    setExtras(e) {
      return this.set("extras", e);
    }
    clone() {
      return new (0, this.constructor)(this.graph).copy(this, Qg);
    }
    copy(e, t = Qg) {
      for (const e in this[cg]) {
        const t = this[cg][e];
        if (t instanceof ng) this[ug].has(e) || t.dispose();else if (Array.isArray(t) && t[0] instanceof ng) for (const e of t) e.dispose();else if (Dg(t) && Object.values(t)[0] instanceof ng) for (const e in t) t[e].dispose();
      }
      for (const r in e[cg]) {
        const n = this[cg][r],
          i = e[cg][r];
        if (i instanceof ng) this[ug].has(r) ? n.getChild().copy(t(i.getChild()), t) : this.setRef(r, t(i.getChild()), i.getAttributes());else if (Array.isArray(i) && i[0] instanceof ng) for (const e of i) this.addRef(r, t(e.getChild()), e.getAttributes());else if (Dg(i) && Object.values(i)[0] instanceof ng) for (const e in i) {
          const n = i[e];
          this.setRefMap(r, e, t(n.getChild()), n.getAttributes());
        } else this[cg][r] = Dg(i) ? JSON.parse(JSON.stringify(i)) : Array.isArray(i) || i instanceof ArrayBuffer || ArrayBuffer.isView(i) ? i.slice() : i;
      }
      return this;
    }
    equals(e, t = Hg) {
      if (this === e) return !0;
      if (this.propertyType !== e.propertyType) return !1;
      for (const r in this[cg]) {
        if (t.has(r)) continue;
        const n = this[cg][r],
          i = e[cg][r];
        if (og(n) || og(i)) {
          if (!Rg(n, i)) return !1;
        } else if (ag(n) || ag(i)) {
          if (!Lg(n, i)) return !1;
        } else if (lg(n) || lg(i)) {
          if (!Og(n, i)) return !1;
        } else if (Dg(n) || Dg(i)) {
          if (!Ug(n, i)) return !1;
        } else if (Ng(n) || Ng(i)) {
          if (!Fg(n, i)) return !1;
        } else if (n !== i) return !1;
      }
      return !0;
    }
    detach() {
      return this.graph.disconnectParents(this, e => "Root" !== e.propertyType), this;
    }
    listParents() {
      return this.graph.listParents(this);
    }
  }
  class qg extends Wg {
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        extensions: {}
      });
    }
    getExtension(e) {
      return this.getRefMap("extensions", e);
    }
    setExtension(e, t) {
      return t && t.t(this), this.setRefMap("extensions", e, t);
    }
    listExtensions() {
      return this.listRefMapValues("extensions");
    }
  }
  class Xg extends qg {
    constructor(...e) {
      super(...e), this.i = Bg.identity, this.o = Bg.identity;
    }
    init() {
      this.propertyType = dg.ACCESSOR;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        array: null,
        type: Xg.Type.SCALAR,
        componentType: Xg.ComponentType.FLOAT,
        normalized: !1,
        buffer: null
      });
    }
    copy(e, t = Qg) {
      return super.copy(e, t), this.i = e.i, this.o = e.o, this;
    }
    static getElementSize(e) {
      switch (e) {
        case Xg.Type.SCALAR:
          return 1;
        case Xg.Type.VEC2:
          return 2;
        case Xg.Type.VEC3:
          return 3;
        case Xg.Type.VEC4:
        case Xg.Type.MAT2:
          return 4;
        case Xg.Type.MAT3:
          return 9;
        case Xg.Type.MAT4:
          return 16;
        default:
          throw new Error("Unexpected type: " + e);
      }
    }
    static getComponentSize(e) {
      switch (e) {
        case Xg.ComponentType.BYTE:
        case Xg.ComponentType.UNSIGNED_BYTE:
          return 1;
        case Xg.ComponentType.SHORT:
        case Xg.ComponentType.UNSIGNED_SHORT:
          return 2;
        case Xg.ComponentType.UNSIGNED_INT:
        case Xg.ComponentType.FLOAT:
          return 4;
        default:
          throw new Error("Unexpected component type: " + e);
      }
    }
    getMinNormalized(e) {
      const t = this.getElementSize();
      this.getMin(e);
      for (let r = 0; r < t; r++) e[r] = this.o(e[r]);
      return e;
    }
    getMin(e) {
      const t = this.get("array"),
        r = this.getCount(),
        n = this.getElementSize();
      for (let t = 0; t < n; t++) e[t] = 1 / 0;
      for (let i = 0; i < r * n; i += n) for (let r = 0; r < n; r++) {
        const n = t[i + r];
        Number.isFinite(n) && (e[r] = Math.min(e[r], n));
      }
      return e;
    }
    getMaxNormalized(e) {
      const t = this.getElementSize();
      this.getMax(e);
      for (let r = 0; r < t; r++) e[r] = this.o(e[r]);
      return e;
    }
    getMax(e) {
      const t = this.get("array"),
        r = this.getCount(),
        n = this.getElementSize();
      for (let t = 0; t < n; t++) e[t] = -1 / 0;
      for (let i = 0; i < r * n; i += n) for (let r = 0; r < n; r++) {
        const n = t[i + r];
        Number.isFinite(n) && (e[r] = Math.max(e[r], n));
      }
      return e;
    }
    getCount() {
      const e = this.get("array");
      return e ? e.length / this.getElementSize() : 0;
    }
    getType() {
      return this.get("type");
    }
    setType(e) {
      return this.set("type", e);
    }
    getElementSize() {
      return Xg.getElementSize(this.get("type"));
    }
    getComponentSize() {
      return this.get("array").BYTES_PER_ELEMENT;
    }
    getComponentType() {
      return this.get("componentType");
    }
    getNormalized() {
      return this.get("normalized");
    }
    setNormalized(e) {
      return this.set("normalized", e), e ? (this.o = e => Bg.denormalize(e, this.get("componentType")), this.i = e => Bg.normalize(e, this.get("componentType"))) : (this.o = Bg.identity, this.i = Bg.identity), this;
    }
    getScalar(e) {
      const t = this.getElementSize();
      return this.o(this.get("array")[e * t]);
    }
    setScalar(e, t) {
      return this.get("array")[e * this.getElementSize()] = this.i(t), this;
    }
    getElement(e, t) {
      const r = this.getElementSize(),
        n = this.get("array");
      for (let i = 0; i < r; i++) t[i] = this.o(n[e * r + i]);
      return t;
    }
    setElement(e, t) {
      const r = this.getElementSize(),
        n = this.get("array");
      for (let i = 0; i < r; i++) n[e * r + i] = this.i(t[i]);
      return this;
    }
    getBuffer() {
      return this.getRef("buffer");
    }
    setBuffer(e) {
      return this.setRef("buffer", e);
    }
    getArray() {
      return this.get("array");
    }
    setArray(e) {
      return this.set("componentType", e ? function (e) {
        switch (e.constructor) {
          case Float32Array:
            return Xg.ComponentType.FLOAT;
          case Uint32Array:
            return Xg.ComponentType.UNSIGNED_INT;
          case Uint16Array:
            return Xg.ComponentType.UNSIGNED_SHORT;
          case Uint8Array:
            return Xg.ComponentType.UNSIGNED_BYTE;
          case Int16Array:
            return Xg.ComponentType.SHORT;
          case Int8Array:
            return Xg.ComponentType.BYTE;
          default:
            throw new Error("Unknown accessor componentType.");
        }
      }(e) : Xg.ComponentType.FLOAT), this.set("array", e), this;
    }
    getByteLength() {
      const e = this.get("array");
      return e ? e.byteLength : 0;
    }
  }
  Xg.Type = {
    SCALAR: "SCALAR",
    VEC2: "VEC2",
    VEC3: "VEC3",
    VEC4: "VEC4",
    MAT2: "MAT2",
    MAT3: "MAT3",
    MAT4: "MAT4"
  }, Xg.ComponentType = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_INT: 5125,
    FLOAT: 5126
  };
  class Yg extends qg {
    init() {
      this.propertyType = dg.ANIMATION;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        channels: [],
        samplers: []
      });
    }
    addChannel(e) {
      return this.addRef("channels", e);
    }
    removeChannel(e) {
      return this.removeRef("channels", e);
    }
    listChannels() {
      return this.listRefs("channels");
    }
    addSampler(e) {
      return this.addRef("samplers", e);
    }
    removeSampler(e) {
      return this.removeRef("samplers", e);
    }
    listSamplers() {
      return this.listRefs("samplers");
    }
  }
  class Kg extends qg {
    init() {
      this.propertyType = dg.ANIMATION_CHANNEL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        targetPath: null,
        targetNode: null,
        sampler: null
      });
    }
    getTargetPath() {
      return this.get("targetPath");
    }
    setTargetPath(e) {
      return this.set("targetPath", e);
    }
    getTargetNode() {
      return this.getRef("targetNode");
    }
    setTargetNode(e) {
      return this.setRef("targetNode", e);
    }
    getSampler() {
      return this.getRef("sampler");
    }
    setSampler(e) {
      return this.setRef("sampler", e);
    }
  }
  Kg.TargetPath = {
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights"
  };
  class Jg extends qg {
    init() {
      this.propertyType = dg.ANIMATION_SAMPLER;
    }
    getDefaultAttributes() {
      return Object.assign(super.getDefaults(), {
        interpolation: Jg.Interpolation.LINEAR,
        input: null,
        output: null
      });
    }
    getInterpolation() {
      return this.get("interpolation");
    }
    setInterpolation(e) {
      return this.set("interpolation", e);
    }
    getInput() {
      return this.getRef("input");
    }
    setInput(e) {
      return this.setRef("input", e, {
        usage: mg.OTHER
      });
    }
    getOutput() {
      return this.getRef("output");
    }
    setOutput(e) {
      return this.setRef("output", e, {
        usage: mg.OTHER
      });
    }
  }
  Jg.Interpolation = {
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
  };
  class Zg extends qg {
    init() {
      this.propertyType = dg.BUFFER;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        uri: ""
      });
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e) {
      return this.set("uri", e);
    }
  }
  class $g extends qg {
    init() {
      this.propertyType = dg.CAMERA;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        type: $g.Type.PERSPECTIVE,
        znear: .1,
        zfar: 100,
        aspectRatio: null,
        yfov: 2 * Math.PI * 50 / 360,
        xmag: 1,
        ymag: 1
      });
    }
    getType() {
      return this.get("type");
    }
    setType(e) {
      return this.set("type", e);
    }
    getZNear() {
      return this.get("znear");
    }
    setZNear(e) {
      return this.set("znear", e);
    }
    getZFar() {
      return this.get("zfar");
    }
    setZFar(e) {
      return this.set("zfar", e);
    }
    getAspectRatio() {
      return this.get("aspectRatio");
    }
    setAspectRatio(e) {
      return this.set("aspectRatio", e);
    }
    getYFov() {
      return this.get("yfov");
    }
    setYFov(e) {
      return this.set("yfov", e);
    }
    getXMag() {
      return this.get("xmag");
    }
    setXMag(e) {
      return this.set("xmag", e);
    }
    getYMag() {
      return this.get("ymag");
    }
    setYMag(e) {
      return this.set("ymag", e);
    }
  }
  $g.Type = {
    PERSPECTIVE: "perspective",
    ORTHOGRAPHIC: "orthographic"
  };
  class ev extends Wg {
    t(e) {
      if (!this.parentTypes.includes(e.propertyType)) throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`);
    }
  }
  ev.EXTENSION_NAME = void 0;
  class tv extends qg {
    init() {
      this.propertyType = dg.TEXTURE_INFO;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        texCoord: 0,
        magFilter: null,
        minFilter: null,
        wrapS: tv.WrapMode.REPEAT,
        wrapT: tv.WrapMode.REPEAT
      });
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e) {
      return this.set("texCoord", e);
    }
    getMagFilter() {
      return this.get("magFilter");
    }
    setMagFilter(e) {
      return this.set("magFilter", e);
    }
    getMinFilter() {
      return this.get("minFilter");
    }
    setMinFilter(e) {
      return this.set("minFilter", e);
    }
    getWrapS() {
      return this.get("wrapS");
    }
    setWrapS(e) {
      return this.set("wrapS", e);
    }
    getWrapT() {
      return this.get("wrapT");
    }
    setWrapT(e) {
      return this.set("wrapT", e);
    }
  }
  tv.WrapMode = {
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
  }, tv.MagFilter = {
    NEAREST: 9728,
    LINEAR: 9729
  }, tv.MinFilter = {
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987
  };
  const {
    R: rv,
    G: nv,
    B: iv,
    A: sv
  } = _g;
  class ov extends qg {
    init() {
      this.propertyType = dg.MATERIAL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        alphaMode: ov.AlphaMode.OPAQUE,
        alphaCutoff: .5,
        doubleSided: !1,
        baseColorFactor: [1, 1, 1, 1],
        baseColorTexture: null,
        baseColorTextureInfo: new tv(this.graph, "baseColorTextureInfo"),
        emissiveFactor: [0, 0, 0],
        emissiveTexture: null,
        emissiveTextureInfo: new tv(this.graph, "emissiveTextureInfo"),
        normalScale: 1,
        normalTexture: null,
        normalTextureInfo: new tv(this.graph, "normalTextureInfo"),
        occlusionStrength: 1,
        occlusionTexture: null,
        occlusionTextureInfo: new tv(this.graph, "occlusionTextureInfo"),
        roughnessFactor: 1,
        metallicFactor: 1,
        metallicRoughnessTexture: null,
        metallicRoughnessTextureInfo: new tv(this.graph, "metallicRoughnessTextureInfo")
      });
    }
    getDoubleSided() {
      return this.get("doubleSided");
    }
    setDoubleSided(e) {
      return this.set("doubleSided", e);
    }
    getAlpha() {
      return this.get("baseColorFactor")[3];
    }
    setAlpha(e) {
      const t = this.get("baseColorFactor").slice();
      return t[3] = e, this.set("baseColorFactor", t);
    }
    getAlphaMode() {
      return this.get("alphaMode");
    }
    setAlphaMode(e) {
      return this.set("alphaMode", e);
    }
    getAlphaCutoff() {
      return this.get("alphaCutoff");
    }
    setAlphaCutoff(e) {
      return this.set("alphaCutoff", e);
    }
    getBaseColorFactor() {
      return this.get("baseColorFactor");
    }
    setBaseColorFactor(e) {
      return this.set("baseColorFactor", e);
    }
    getBaseColorHex() {
      return Sg.factorToHex(this.get("baseColorFactor"));
    }
    setBaseColorHex(e) {
      const t = this.get("baseColorFactor").slice();
      return this.set("baseColorFactor", Sg.hexToFactor(e, t));
    }
    getBaseColorTexture() {
      return this.getRef("baseColorTexture");
    }
    getBaseColorTextureInfo() {
      return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
    }
    setBaseColorTexture(e) {
      return this.setRef("baseColorTexture", e, {
        channels: rv | nv | iv | sv
      });
    }
    getEmissiveFactor() {
      return this.get("emissiveFactor");
    }
    setEmissiveFactor(e) {
      return this.set("emissiveFactor", e);
    }
    getEmissiveHex() {
      return Sg.factorToHex(this.get("emissiveFactor"));
    }
    setEmissiveHex(e) {
      const t = this.get("emissiveFactor").slice();
      return this.set("emissiveFactor", Sg.hexToFactor(e, t));
    }
    getEmissiveTexture() {
      return this.getRef("emissiveTexture");
    }
    getEmissiveTextureInfo() {
      return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
    }
    setEmissiveTexture(e) {
      return this.setRef("emissiveTexture", e, {
        channels: rv | nv | iv
      });
    }
    getNormalScale() {
      return this.get("normalScale");
    }
    setNormalScale(e) {
      return this.set("normalScale", e);
    }
    getNormalTexture() {
      return this.getRef("normalTexture");
    }
    getNormalTextureInfo() {
      return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
    }
    setNormalTexture(e) {
      return this.setRef("normalTexture", e, {
        channels: rv | nv | iv
      });
    }
    getOcclusionStrength() {
      return this.get("occlusionStrength");
    }
    setOcclusionStrength(e) {
      return this.set("occlusionStrength", e);
    }
    getOcclusionTexture() {
      return this.getRef("occlusionTexture");
    }
    getOcclusionTextureInfo() {
      return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
    }
    setOcclusionTexture(e) {
      return this.setRef("occlusionTexture", e, {
        channels: rv
      });
    }
    getRoughnessFactor() {
      return this.get("roughnessFactor");
    }
    setRoughnessFactor(e) {
      return this.set("roughnessFactor", e);
    }
    getMetallicFactor() {
      return this.get("metallicFactor");
    }
    setMetallicFactor(e) {
      return this.set("metallicFactor", e);
    }
    getMetallicRoughnessTexture() {
      return this.getRef("metallicRoughnessTexture");
    }
    getMetallicRoughnessTextureInfo() {
      return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
    }
    setMetallicRoughnessTexture(e) {
      return this.setRef("metallicRoughnessTexture", e, {
        channels: nv | iv
      });
    }
  }
  ov.AlphaMode = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  class av extends qg {
    init() {
      this.propertyType = dg.MESH;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        weights: [],
        primitives: []
      });
    }
    addPrimitive(e) {
      return this.addRef("primitives", e);
    }
    removePrimitive(e) {
      return this.removeRef("primitives", e);
    }
    listPrimitives() {
      return this.listRefs("primitives");
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e) {
      return this.set("weights", e);
    }
  }
  class lv extends qg {
    constructor(...e) {
      super(...e), this.u = null;
    }
    init() {
      this.propertyType = dg.NODE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        translation: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scale: [1, 1, 1],
        weights: [],
        camera: null,
        mesh: null,
        skin: null,
        children: []
      });
    }
    copy(e, t = Qg) {
      if (t === Qg) throw new Error("Node cannot be copied.");
      return super.copy(e, t);
    }
    getTranslation() {
      return this.get("translation");
    }
    getRotation() {
      return this.get("rotation");
    }
    getScale() {
      return this.get("scale");
    }
    setTranslation(e) {
      return this.set("translation", e);
    }
    setRotation(e) {
      return this.set("rotation", e);
    }
    setScale(e) {
      return this.set("scale", e);
    }
    getMatrix() {
      return Bg.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
    }
    setMatrix(e) {
      const t = this.get("translation").slice(),
        r = this.get("rotation").slice(),
        n = this.get("scale").slice();
      return Bg.decompose(e, t, r, n), this.set("translation", t).set("rotation", r).set("scale", n);
    }
    getWorldTranslation() {
      const e = [0, 0, 0];
      return Bg.decompose(this.getWorldMatrix(), e, [0, 0, 0, 1], [1, 1, 1]), e;
    }
    getWorldRotation() {
      const e = [0, 0, 0, 1];
      return Bg.decompose(this.getWorldMatrix(), [0, 0, 0], e, [1, 1, 1]), e;
    }
    getWorldScale() {
      const e = [1, 1, 1];
      return Bg.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e), e;
    }
    getWorldMatrix() {
      const e = [];
      for (let t = this; t instanceof lv; t = t.u) e.push(t);
      let t;
      const r = e.pop().getMatrix();
      for (; t = e.pop();) yg(r, r, t.getMatrix());
      return r;
    }
    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[cg].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }
    removeChild(e) {
      return this.removeRef("children", e);
    }
    listChildren() {
      return this.listRefs("children");
    }
    getParent() {
      return this.u;
    }
    getMesh() {
      return this.getRef("mesh");
    }
    setMesh(e) {
      return this.setRef("mesh", e);
    }
    getCamera() {
      return this.getRef("camera");
    }
    setCamera(e) {
      return this.setRef("camera", e);
    }
    getSkin() {
      return this.getRef("skin");
    }
    setSkin(e) {
      return this.setRef("skin", e);
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e) {
      return this.set("weights", e);
    }
    traverse(e) {
      e(this);
      for (const t of this.listChildren()) t.traverse(e);
      return this;
    }
  }
  class cv extends qg {
    init() {
      this.propertyType = dg.PRIMITIVE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mode: cv.Mode.TRIANGLES,
        material: null,
        indices: null,
        attributes: {},
        targets: []
      });
    }
    getIndices() {
      return this.getRef("indices");
    }
    setIndices(e) {
      return this.setRef("indices", e, {
        usage: mg.ELEMENT_ARRAY_BUFFER
      });
    }
    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }
    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: mg.ARRAY_BUFFER
      });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e) {
      return this.setRef("material", e);
    }
    getMode() {
      return this.get("mode");
    }
    setMode(e) {
      return this.set("mode", e);
    }
    listTargets() {
      return this.listRefs("targets");
    }
    addTarget(e) {
      return this.addRef("targets", e);
    }
    removeTarget(e) {
      return this.removeRef("targets", e);
    }
  }
  cv.Mode = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  class uv extends Wg {
    init() {
      this.propertyType = dg.PRIMITIVE_TARGET;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }
    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }
    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: mg.ARRAY_BUFFER
      });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  function hv() {
    return (hv = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }).apply(this, arguments);
  }
  class pv extends qg {
    init() {
      this.propertyType = dg.SCENE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        children: []
      });
    }
    copy(e, t = Qg) {
      if (t === Qg) throw new Error("Scene cannot be copied.");
      return super.copy(e, t);
    }
    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[cg].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }
    removeChild(e) {
      return this.removeRef("children", e);
    }
    listChildren() {
      return this.listRefs("children");
    }
    traverse(e) {
      for (const t of this.listChildren()) t.traverse(e);
      return this;
    }
  }
  class dv extends qg {
    init() {
      this.propertyType = dg.SKIN;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        skeleton: null,
        inverseBindMatrices: null,
        joints: []
      });
    }
    getSkeleton() {
      return this.getRef("skeleton");
    }
    setSkeleton(e) {
      return this.setRef("skeleton", e);
    }
    getInverseBindMatrices() {
      return this.getRef("inverseBindMatrices");
    }
    setInverseBindMatrices(e) {
      return this.setRef("inverseBindMatrices", e, {
        usage: mg.INVERSE_BIND_MATRICES
      });
    }
    addJoint(e) {
      return this.addRef("joints", e);
    }
    removeJoint(e) {
      return this.removeRef("joints", e);
    }
    listJoints() {
      return this.listRefs("joints");
    }
  }
  class fv extends qg {
    init() {
      this.propertyType = dg.TEXTURE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        image: null,
        mimeType: "",
        uri: ""
      });
    }
    getMimeType() {
      return this.get("mimeType") || Mg.extensionToMimeType(Ig.extension(this.get("uri")));
    }
    setMimeType(e) {
      return this.set("mimeType", e);
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e) {
      return this.set("uri", e), this.set("mimeType", Mg.extensionToMimeType(Ig.extension(e))), this;
    }
    getImage() {
      return this.get("image");
    }
    setImage(e) {
      return this.set("image", Eg.assertView(e));
    }
    getSize() {
      const e = this.get("image");
      return e ? Mg.getSize(e, this.getMimeType()) : null;
    }
  }
  class mv extends qg {
    init() {
      this.propertyType = dg.ROOT;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        asset: {
          generator: "glTF-Transform v2.2.3",
          version: "2.0"
        },
        defaultScene: null,
        accessors: [],
        animations: [],
        buffers: [],
        cameras: [],
        materials: [],
        meshes: [],
        nodes: [],
        scenes: [],
        skins: [],
        textures: []
      });
    }
    constructor(e) {
      super(e), this.h = new Set(), e.addEventListener("node:create", e => {
        this.l(e.target);
      });
    }
    clone() {
      throw new Error("Root cannot be cloned.");
    }
    copy(e, t = Qg) {
      if (t === Qg) throw new Error("Root cannot be copied.");
      this.set("asset", hv({}, e.get("asset"))), this.setName(e.getName()), this.setExtras(hv({}, e.getExtras())), this.setDefaultScene(e.getDefaultScene() ? t(e.getDefaultScene()) : null);
      for (const r of e.listRefMapKeys("extensions")) {
        const n = e.getExtension(r);
        this.setExtension(r, t(n));
      }
      return this;
    }
    l(e) {
      return e instanceof pv ? this.addRef("scenes", e) : e instanceof lv ? this.addRef("nodes", e) : e instanceof $g ? this.addRef("cameras", e) : e instanceof dv ? this.addRef("skins", e) : e instanceof av ? this.addRef("meshes", e) : e instanceof ov ? this.addRef("materials", e) : e instanceof fv ? this.addRef("textures", e) : e instanceof Yg ? this.addRef("animations", e) : e instanceof Xg ? this.addRef("accessors", e) : e instanceof Zg && this.addRef("buffers", e), this;
    }
    getAsset() {
      return this.get("asset");
    }
    listExtensionsUsed() {
      return Array.from(this.h);
    }
    listExtensionsRequired() {
      return this.listExtensionsUsed().filter(e => e.isRequired());
    }
    g(e) {
      return this.h.add(e), this;
    }
    p(e) {
      return this.h.delete(e), this;
    }
    listScenes() {
      return this.listRefs("scenes");
    }
    setDefaultScene(e) {
      return this.setRef("defaultScene", e);
    }
    getDefaultScene() {
      return this.getRef("defaultScene");
    }
    listNodes() {
      return this.listRefs("nodes");
    }
    listCameras() {
      return this.listRefs("cameras");
    }
    listSkins() {
      return this.listRefs("skins");
    }
    listMeshes() {
      return this.listRefs("meshes");
    }
    listMaterials() {
      return this.listRefs("materials");
    }
    listTextures() {
      return this.listRefs("textures");
    }
    listAnimations() {
      return this.listRefs("animations");
    }
    listAccessors() {
      return this.listRefs("accessors");
    }
    listBuffers() {
      return this.listRefs("buffers");
    }
  }
  class _v {
    constructor() {
      this.m = new ig(), this.T = new mv(this.m), this.v = Pg.DEFAULT_INSTANCE;
    }
    getRoot() {
      return this.T;
    }
    getGraph() {
      return this.m;
    }
    getLogger() {
      return this.v;
    }
    setLogger(e) {
      return this.v = e, this;
    }
    clone() {
      return new _v().setLogger(this.v).merge(this);
    }
    merge(e) {
      for (const t of e.getRoot().listExtensionsUsed()) {
        const e = this.createExtension(t.constructor);
        t.isRequired() && e.setRequired(!0);
      }
      const t = new Set(),
        r = new Map();
      t.add(e.T), r.set(e.T, this.T);
      for (const n of e.m.listEdges()) for (const e of [n.getParent(), n.getChild()]) {
        if (t.has(e)) continue;
        let n;
        n = e.propertyType === dg.TEXTURE_INFO ? e : new (0, e.constructor)(this.m), r.set(e, n), t.add(e);
      }
      const n = e => {
        const t = r.get(e);
        if (!t) throw new Error("Could resolve property.");
        return t;
      };
      for (const e of t) {
        const t = r.get(e);
        if (!t) throw new Error("Could resolve property.");
        t.propertyType !== dg.TEXTURE_INFO && t.copy(e, n);
      }
      return this;
    }
    async transform(...e) {
      const t = e.map(e => e.name);
      for (const r of e) await r(this, {
        stack: t
      });
      return this;
    }
    createExtension(e) {
      const t = e.EXTENSION_NAME;
      return this.getRoot().listExtensionsUsed().find(e => e.extensionName === t) || new e(this);
    }
    createScene(e = "") {
      return new pv(this.m, e);
    }
    createNode(e = "") {
      return new lv(this.m, e);
    }
    createCamera(e = "") {
      return new $g(this.m, e);
    }
    createSkin(e = "") {
      return new dv(this.m, e);
    }
    createMesh(e = "") {
      return new av(this.m, e);
    }
    createPrimitive() {
      return new cv(this.m);
    }
    createPrimitiveTarget(e = "") {
      return new uv(this.m, e);
    }
    createMaterial(e = "") {
      return new ov(this.m, e);
    }
    createTexture(e = "") {
      return new fv(this.m, e);
    }
    createAnimation(e = "") {
      return new Yg(this.m, e);
    }
    createAnimationChannel(e = "") {
      return new Kg(this.m, e);
    }
    createAnimationSampler(e = "") {
      return new Jg(this.m, e);
    }
    createAccessor(e = "", t = null) {
      return t || (t = this.getRoot().listBuffers()[0]), new Xg(this.m, e).setBuffer(t);
    }
    createBuffer(e = "") {
      return new Zg(this.m, e);
    }
  }
  class gv {
    constructor(e) {
      this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = !1, this.properties = new Set(), this.S = void 0, this.document = e, e.getRoot().g(this), this.S = e => {
        const t = e,
          r = t.target;
        r instanceof ev && r.extensionName === this.extensionName && ("node:create" === t.type && this.M(r), "node:dispose" === t.type && this.I(r));
      };
      const t = e.getGraph();
      t.addEventListener("node:create", this.S), t.addEventListener("node:dispose", this.S);
    }
    dispose() {
      this.document.getRoot().p(this);
      const e = this.document.getGraph();
      e.removeEventListener("node:create", this.S), e.removeEventListener("node:dispose", this.S);
      for (const e of this.properties) e.dispose();
    }
    static register() {}
    isRequired() {
      return this.required;
    }
    setRequired(e) {
      return this.required = e, this;
    }
    M(e) {
      return this.properties.add(e), this;
    }
    I(e) {
      return this.properties.delete(e), this;
    }
    install(e, t) {
      return this;
    }
    preread(e, t) {
      return this;
    }
    prewrite(e, t) {
      return this;
    }
  }
  gv.EXTENSION_NAME = void 0;
  class vv {
    constructor(e) {
      this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e;
    }
    setTextureInfo(e, t) {
      this.textureInfos.set(e, t), void 0 !== t.texCoord && e.setTexCoord(t.texCoord);
      const r = this.jsonDoc.json.textures[t.index];
      if (void 0 === r.sampler) return;
      const n = this.jsonDoc.json.samplers[r.sampler];
      void 0 !== n.magFilter && e.setMagFilter(n.magFilter), void 0 !== n.minFilter && e.setMinFilter(n.minFilter), void 0 !== n.wrapS && e.setWrapS(n.wrapS), void 0 !== n.wrapT && e.setWrapT(n.wrapT);
    }
  }
  const Av = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    },
    bv = {
      logger: Pg.DEFAULT_INSTANCE,
      extensions: [],
      dependencies: {}
    };
  function yv(e, t) {
    const r = t.bufferViews[e.bufferView],
      n = t.jsonDoc.json.bufferViews[e.bufferView],
      i = Av[e.componentType],
      s = Xg.getElementSize(e.type),
      o = i.BYTES_PER_ELEMENT;
    if (void 0 !== n.byteStride && n.byteStride !== s * o) return function (e, t) {
      const r = t.bufferViews[e.bufferView],
        n = t.jsonDoc.json.bufferViews[e.bufferView],
        i = Av[e.componentType],
        s = Xg.getElementSize(e.type),
        o = i.BYTES_PER_ELEMENT,
        a = e.byteOffset || 0,
        l = new i(e.count * s),
        c = new DataView(r.buffer, r.byteOffset, r.byteLength),
        u = n.byteStride;
      for (let t = 0; t < e.count; t++) for (let r = 0; r < s; r++) {
        const n = a + t * u + r * o;
        let i;
        switch (e.componentType) {
          case Xg.ComponentType.FLOAT:
            i = c.getFloat32(n, !0);
            break;
          case Xg.ComponentType.UNSIGNED_INT:
            i = c.getUint32(n, !0);
            break;
          case Xg.ComponentType.UNSIGNED_SHORT:
            i = c.getUint16(n, !0);
            break;
          case Xg.ComponentType.UNSIGNED_BYTE:
            i = c.getUint8(n);
            break;
          case Xg.ComponentType.SHORT:
            i = c.getInt16(n, !0);
            break;
          case Xg.ComponentType.BYTE:
            i = c.getInt8(n);
            break;
          default:
            throw new Error(`Unexpected componentType "${e.componentType}".`);
        }
        l[t * s + r] = i;
      }
      return l;
    }(e, t);
    const a = r.byteOffset + (e.byteOffset || 0);
    return new i(r.buffer.slice(a, a + e.count * s * o));
  }
  var xv;
  !function (e) {
    e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(xv || (xv = {}));
  class wv {
    constructor(e, t, r) {
      this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = new Map(), this.animationIndexMap = new Map(), this.bufferIndexMap = new Map(), this.cameraIndexMap = new Map(), this.skinIndexMap = new Map(), this.materialIndexMap = new Map(), this.meshIndexMap = new Map(), this.nodeIndexMap = new Map(), this.imageIndexMap = new Map(), this.textureDefIndexMap = new Map(), this.textureInfoDefMap = new Map(), this.samplerDefIndexMap = new Map(), this.sceneIndexMap = new Map(), this.imageBufferViews = [], this.otherBufferViews = new Map(), this.otherBufferViewsIndexMap = new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = new Map(), this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]), this.accessorParents = new Map(), this.N = e, this.jsonDoc = t, this.options = r;
      const n = e.getRoot(),
        i = n.listBuffers().length,
        s = n.listTextures().length;
      this.bufferURIGenerator = new Ev(i > 1, r.basename), this.imageURIGenerator = new Ev(s > 1, r.basename), this.logger = e.getLogger();
    }
    createTextureInfoDef(e, t) {
      const r = {
          magFilter: t.getMagFilter() || void 0,
          minFilter: t.getMinFilter() || void 0,
          wrapS: t.getWrapS(),
          wrapT: t.getWrapT()
        },
        n = JSON.stringify(r);
      this.samplerDefIndexMap.has(n) || (this.samplerDefIndexMap.set(n, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(r));
      const i = {
          source: this.imageIndexMap.get(e),
          sampler: this.samplerDefIndexMap.get(n)
        },
        s = JSON.stringify(i);
      this.textureDefIndexMap.has(s) || (this.textureDefIndexMap.set(s, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i));
      const o = {
        index: this.textureDefIndexMap.get(s)
      };
      return 0 !== t.getTexCoord() && (o.texCoord = t.getTexCoord()), this.textureInfoDefMap.set(t, o), o;
    }
    createPropertyDef(e) {
      const t = {};
      return e.getName() && (t.name = e.getName()), Object.keys(e.getExtras()).length > 0 && (t.extras = e.getExtras()), t;
    }
    createAccessorDef(e) {
      const t = this.createPropertyDef(e);
      return t.type = e.getType(), t.componentType = e.getComponentType(), t.count = e.getCount(), this.N.getGraph().listParentEdges(e).some(e => "attributes" === e.getName() && "POSITION" === e.getAttributes().key || "input" === e.getName()) && (t.max = e.getMax([]).map(Math.fround), t.min = e.getMin([]).map(Math.fround)), e.getNormalized() && (t.normalized = e.getNormalized()), t;
    }
    createImageData(e, t, r) {
      if (this.options.format === gg.GLB) this.imageBufferViews.push(t), e.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({
        buffer: 0,
        byteOffset: -1,
        byteLength: t.byteLength
      });else {
        const n = Mg.mimeTypeToExtension(r.getMimeType());
        e.uri = this.imageURIGenerator.createURI(r, n), this.jsonDoc.resources[e.uri] = t;
      }
    }
    getAccessorUsage(e) {
      const t = this.O.get(e);
      if (t) return t;
      for (const t of this.N.getGraph().listParentEdges(e)) {
        const {
          usage: e
        } = t.getAttributes();
        if (e) return e;
        t.getParent().propertyType !== dg.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t.getName()}".`);
      }
      return wv.BufferViewUsage.OTHER;
    }
    addAccessorToUsageGroup(e, t) {
      const r = this.O.get(e);
      if (r && r !== t) throw new Error(`Accessor with usage "${r}" cannot be reused as "${t}".`);
      return this.O.set(e, t), this;
    }
    listAccessorUsageGroups() {
      const e = {};
      for (const [t, r] of Array.from(this.O.entries())) e[r] = e[r] || [], e[r].push(t);
      return e;
    }
  }
  wv.BufferViewTarget = xv, wv.BufferViewUsage = mg, wv.USAGE_TO_TARGET = {
    [mg.ARRAY_BUFFER]: xv.ARRAY_BUFFER,
    [mg.ELEMENT_ARRAY_BUFFER]: xv.ELEMENT_ARRAY_BUFFER
  };
  class Ev {
    constructor(e, t) {
      this.multiple = void 0, this.basename = void 0, this.counter = 1, this.multiple = e, this.basename = t;
    }
    createURI(e, t) {
      return e.getURI() ? e.getURI() : this.multiple ? `${this.basename}_${this.counter++}.${t}` : `${this.basename}.${t}`;
    }
  }
  const {
    BufferViewUsage: Sv
  } = wv;
  var Cv;
  !function (e) {
    e[e.JSON = 1313821514] = "JSON", e[e.BIN = 5130562] = "BIN";
  }(Cv || (Cv = {}));
  class Mv extends class {
    constructor() {
      this.v = Pg.DEFAULT_INSTANCE, this.h = new Set(), this.C = {}, this.F = fg.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
    }
    setLogger(e) {
      return this.v = e, this;
    }
    registerExtensions(e) {
      for (const t of e) this.h.add(t), t.register();
      return this;
    }
    registerDependencies(e) {
      return Object.assign(this.C, e), this;
    }
    setVertexLayout(e) {
      return this.F = e, this;
    }
    async read(e) {
      return await this.readJSON(await this.readAsJSON(e));
    }
    async readAsJSON(e) {
      return e.match(/^data:application\/octet-stream;/) || this.detectFormat(e) === gg.GLB ? this.U(e) : this.P(e);
    }
    async readJSON(e) {
      return e = this.j(e), this.L(e), class {
        static read(e, t = bv) {
          const r = hv({}, bv, t),
            {
              json: n
            } = e,
            i = new _v();
          this.validate(e, r);
          const s = new vv(e),
            o = n.asset,
            a = i.getRoot().getAsset();
          o.copyright && (a.copyright = o.copyright), o.extras && (a.extras = o.extras), void 0 !== n.extras && i.getRoot().setExtras(hv({}, n.extras));
          const l = n.extensionsUsed || [],
            c = n.extensionsRequired || [];
          for (const e of r.extensions) if (l.includes(e.EXTENSION_NAME)) {
            const t = i.createExtension(e).setRequired(c.includes(e.EXTENSION_NAME));
            for (const e of t.readDependencies) t.install(e, r.dependencies[e]);
          }
          const u = n.buffers || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(dg.BUFFER)).forEach(e => e.preread(s, dg.BUFFER)), s.buffers = u.map(e => {
            const t = i.createBuffer(e.name);
            return e.extras && t.setExtras(e.extras), e.uri && 0 !== e.uri.indexOf("__") && t.setURI(e.uri), t;
          }), s.bufferViewBuffers = (n.bufferViews || []).map((t, r) => {
            if (!s.bufferViews[r]) {
              const n = e.json.buffers[t.buffer];
              s.bufferViews[r] = Eg.toView(n.uri ? e.resources[n.uri] : e.resources["@glb.bin"], t.byteOffset || 0, t.byteLength);
            }
            return s.buffers[t.buffer];
          }), s.accessors = (n.accessors || []).map(e => {
            const t = i.createAccessor(e.name, s.bufferViewBuffers[e.bufferView]).setType(e.type);
            if (e.extras && t.setExtras(e.extras), void 0 !== e.normalized && t.setNormalized(e.normalized), void 0 === e.bufferView && !e.sparse) return t;
            let r;
            return r = void 0 !== e.sparse ? function (e, t) {
              const r = Av[e.componentType],
                n = Xg.getElementSize(e.type);
              let i;
              i = void 0 !== e.bufferView ? yv(e, t) : new r(e.count * n);
              const s = e.sparse,
                o = s.count,
                a = hv({}, e, s.indices, {
                  count: o,
                  type: "SCALAR"
                }),
                l = hv({}, e, s.values, {
                  count: o
                }),
                c = yv(a, t),
                u = yv(l, t);
              for (let e = 0; e < a.count; e++) for (let t = 0; t < n; t++) i[c[e] * n + t] = u[e * n + t];
              return i;
            }(e, s) : yv(e, s), t.setArray(r), t;
          });
          const h = n.images || [],
            p = n.textures || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(dg.TEXTURE)).forEach(e => e.preread(s, dg.TEXTURE)), s.textures = h.map(t => {
            const r = i.createTexture(t.name);
            if (t.extras && r.setExtras(t.extras), void 0 !== t.bufferView) {
              const i = n.bufferViews[t.bufferView],
                s = e.json.buffers[i.buffer],
                o = i.byteOffset || 0,
                a = (s.uri ? e.resources[s.uri] : e.resources["@glb.bin"]).slice(o, o + i.byteLength);
              r.setImage(a);
            } else void 0 !== t.uri && (r.setImage(e.resources[t.uri]), 0 !== t.uri.indexOf("__") && r.setURI(t.uri));
            if (void 0 !== t.mimeType) r.setMimeType(t.mimeType);else if (t.uri) {
              const e = Ig.extension(t.uri);
              r.setMimeType(Mg.extensionToMimeType(e));
            }
            return r;
          }), s.materials = (n.materials || []).map(e => {
            const t = i.createMaterial(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.alphaMode && t.setAlphaMode(e.alphaMode), void 0 !== e.alphaCutoff && t.setAlphaCutoff(e.alphaCutoff), void 0 !== e.doubleSided && t.setDoubleSided(e.doubleSided);
            const r = e.pbrMetallicRoughness || {};
            if (void 0 !== r.baseColorFactor && t.setBaseColorFactor(r.baseColorFactor), void 0 !== e.emissiveFactor && t.setEmissiveFactor(e.emissiveFactor), void 0 !== r.metallicFactor && t.setMetallicFactor(r.metallicFactor), void 0 !== r.roughnessFactor && t.setRoughnessFactor(r.roughnessFactor), void 0 !== r.baseColorTexture) {
              const e = r.baseColorTexture;
              t.setBaseColorTexture(s.textures[p[e.index].source]), s.setTextureInfo(t.getBaseColorTextureInfo(), e);
            }
            if (void 0 !== e.emissiveTexture) {
              const r = e.emissiveTexture;
              t.setEmissiveTexture(s.textures[p[r.index].source]), s.setTextureInfo(t.getEmissiveTextureInfo(), r);
            }
            if (void 0 !== e.normalTexture) {
              const r = e.normalTexture;
              t.setNormalTexture(s.textures[p[r.index].source]), s.setTextureInfo(t.getNormalTextureInfo(), r), void 0 !== e.normalTexture.scale && t.setNormalScale(e.normalTexture.scale);
            }
            if (void 0 !== e.occlusionTexture) {
              const r = e.occlusionTexture;
              t.setOcclusionTexture(s.textures[p[r.index].source]), s.setTextureInfo(t.getOcclusionTextureInfo(), r), void 0 !== e.occlusionTexture.strength && t.setOcclusionStrength(e.occlusionTexture.strength);
            }
            if (void 0 !== r.metallicRoughnessTexture) {
              const e = r.metallicRoughnessTexture;
              t.setMetallicRoughnessTexture(s.textures[p[e.index].source]), s.setTextureInfo(t.getMetallicRoughnessTextureInfo(), e);
            }
            return t;
          });
          const d = n.meshes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(dg.PRIMITIVE)).forEach(e => e.preread(s, dg.PRIMITIVE)), s.meshes = d.map(e => {
            const t = i.createMesh(e.name);
            return e.extras && t.setExtras(e.extras), void 0 !== e.weights && t.setWeights(e.weights), (e.primitives || []).forEach(r => {
              const n = i.createPrimitive();
              r.extras && n.setExtras(r.extras), void 0 !== r.material && n.setMaterial(s.materials[r.material]), void 0 !== r.mode && n.setMode(r.mode);
              for (const [e, t] of Object.entries(r.attributes || {})) n.setAttribute(e, s.accessors[t]);
              void 0 !== r.indices && n.setIndices(s.accessors[r.indices]);
              const o = e.extras && e.extras.targetNames || [];
              (r.targets || []).forEach((e, t) => {
                const r = o[t] || t.toString(),
                  a = i.createPrimitiveTarget(r);
                for (const [t, r] of Object.entries(e)) a.setAttribute(t, s.accessors[r]);
                n.addTarget(a);
              }), t.addPrimitive(n);
            }), t;
          }), s.cameras = (n.cameras || []).map(e => {
            const t = i.createCamera(e.name).setType(e.type);
            if (e.extras && t.setExtras(e.extras), e.type === $g.Type.PERSPECTIVE) {
              const r = e.perspective;
              t.setYFov(r.yfov), t.setZNear(r.znear), void 0 !== r.zfar && t.setZFar(r.zfar), void 0 !== r.aspectRatio && t.setAspectRatio(r.aspectRatio);
            } else {
              const r = e.orthographic;
              t.setZNear(r.znear).setZFar(r.zfar).setXMag(r.xmag).setYMag(r.ymag);
            }
            return t;
          });
          const f = n.nodes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(dg.NODE)).forEach(e => e.preread(s, dg.NODE)), s.nodes = f.map(e => {
            const t = i.createNode(e.name);
            if (e.extras && t.setExtras(e.extras), void 0 !== e.translation && t.setTranslation(e.translation), void 0 !== e.rotation && t.setRotation(e.rotation), void 0 !== e.scale && t.setScale(e.scale), void 0 !== e.matrix) {
              const r = [0, 0, 0],
                n = [0, 0, 0, 1],
                i = [1, 1, 1];
              Bg.decompose(e.matrix, r, n, i), t.setTranslation(r), t.setRotation(n), t.setScale(i);
            }
            return void 0 !== e.weights && t.setWeights(e.weights), t;
          }), s.skins = (n.skins || []).map(e => {
            const t = i.createSkin(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.inverseBindMatrices && t.setInverseBindMatrices(s.accessors[e.inverseBindMatrices]), void 0 !== e.skeleton && t.setSkeleton(s.nodes[e.skeleton]);
            for (const r of e.joints) t.addJoint(s.nodes[r]);
            return t;
          }), f.map((e, t) => {
            const r = s.nodes[t];
            (e.children || []).forEach(e => r.addChild(s.nodes[e])), void 0 !== e.mesh && r.setMesh(s.meshes[e.mesh]), void 0 !== e.camera && r.setCamera(s.cameras[e.camera]), void 0 !== e.skin && r.setSkin(s.skins[e.skin]);
          }), s.animations = (n.animations || []).map(e => {
            const t = i.createAnimation(e.name);
            e.extras && t.setExtras(e.extras);
            const r = (e.samplers || []).map(e => {
              const r = i.createAnimationSampler().setInput(s.accessors[e.input]).setOutput(s.accessors[e.output]).setInterpolation(e.interpolation || Jg.Interpolation.LINEAR);
              return e.extras && r.setExtras(e.extras), t.addSampler(r), r;
            });
            return (e.channels || []).forEach(e => {
              const n = i.createAnimationChannel().setSampler(r[e.sampler]).setTargetPath(e.target.path);
              void 0 !== e.target.node && n.setTargetNode(s.nodes[e.target.node]), e.extras && n.setExtras(e.extras), t.addChannel(n);
            }), t;
          });
          const m = n.scenes || [];
          return i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(dg.SCENE)).forEach(e => e.preread(s, dg.SCENE)), s.scenes = m.map(e => {
            const t = i.createScene(e.name);
            return e.extras && t.setExtras(e.extras), (e.nodes || []).map(e => s.nodes[e]).forEach(e => t.addChild(e)), t;
          }), void 0 !== n.scene && i.getRoot().setDefaultScene(s.scenes[n.scene]), i.getRoot().listExtensionsUsed().forEach(e => e.read(s)), i;
        }
        static validate(e, t) {
          const r = e.json;
          if ("2.0" !== r.asset.version) throw new Error(`Unsupported glTF version, "${r.asset.version}".`);
          if (r.extensionsRequired) for (const e of r.extensionsRequired) if (!t.extensions.find(t => t.EXTENSION_NAME === e)) throw new Error(`Missing required extension, "${e}".`);
          if (r.extensionsUsed) for (const e of r.extensionsUsed) t.extensions.find(t => t.EXTENSION_NAME === e) || t.logger.warn(`Missing optional extension, "${e}".`);
        }
      }.read(e, {
        extensions: Array.from(this.h),
        dependencies: this.C,
        logger: this.v
      });
    }
    async binaryToJSON(e) {
      const t = this._(Eg.assertView(e));
      this.L(t);
      const r = t.json;
      if (r.buffers && r.buffers.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources);
      }(t, e))) throw new Error("Cannot resolve external buffers with binaryToJSON().");
      if (r.images && r.images.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources) && void 0 === t.bufferView;
      }(t, e))) throw new Error("Cannot resolve external images with binaryToJSON().");
      return t;
    }
    async readBinary(e) {
      return this.readJSON(await this.binaryToJSON(Eg.assertView(e)));
    }
    async writeJSON(e, t = {}) {
      if (t.format === gg.GLB && e.getRoot().listBuffers().length > 1) throw new Error("GLB must have 0–1 buffers.");
      return class {
        static write(e, t) {
          const r = e.getRoot(),
            n = {
              asset: hv({
                generator: "glTF-Transform v2.2.3"
              }, r.getAsset()),
              extras: hv({}, r.getExtras())
            },
            i = {
              json: n,
              resources: {}
            },
            s = new wv(e, i, t),
            o = t.logger || Pg.DEFAULT_INSTANCE,
            a = new Set(t.extensions.map(e => e.EXTENSION_NAME)),
            l = e.getRoot().listExtensionsUsed().filter(e => a.has(e.extensionName)),
            c = e.getRoot().listExtensionsRequired().filter(e => a.has(e.extensionName));
          l.length < e.getRoot().listExtensionsUsed().length && o.debug("Some extensions were not registered for I/O, and will not be written.");
          for (const e of l) for (const r of e.writeDependencies) e.install(r, t.dependencies[r]);
          function u(e, t, r, i) {
            const o = [];
            let a = 0;
            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = n.bufferViews.length;
              const r = t.getArray(),
                i = Eg.pad(Eg.toView(r));
              e.byteOffset = a, a += i.byteLength, o.push(i), s.accessorIndexMap.set(t, n.accessors.length), n.accessors.push(e);
            }
            const l = {
              buffer: t,
              byteOffset: r,
              byteLength: Eg.concat(o).byteLength
            };
            return i && (l.target = i), n.bufferViews.push(l), {
              buffers: o,
              byteLength: a
            };
          }
          function h(e, t, r) {
            const i = e[0].getCount();
            let o = 0;
            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = n.bufferViews.length, e.byteOffset = o;
              const r = t.getElementSize(),
                i = t.getComponentSize();
              o += Eg.padNumber(r * i), s.accessorIndexMap.set(t, n.accessors.length), n.accessors.push(e);
            }
            const a = i * o,
              l = new ArrayBuffer(a),
              c = new DataView(l);
            for (let t = 0; t < i; t++) {
              let r = 0;
              for (const n of e) {
                const e = n.getElementSize(),
                  i = n.getComponentSize(),
                  s = n.getComponentType(),
                  a = n.getArray();
                for (let n = 0; n < e; n++) {
                  const l = t * o + r + n * i,
                    u = a[t * e + n];
                  switch (s) {
                    case Xg.ComponentType.FLOAT:
                      c.setFloat32(l, u, !0);
                      break;
                    case Xg.ComponentType.BYTE:
                      c.setInt8(l, u);
                      break;
                    case Xg.ComponentType.SHORT:
                      c.setInt16(l, u, !0);
                      break;
                    case Xg.ComponentType.UNSIGNED_BYTE:
                      c.setUint8(l, u);
                      break;
                    case Xg.ComponentType.UNSIGNED_SHORT:
                      c.setUint16(l, u, !0);
                      break;
                    case Xg.ComponentType.UNSIGNED_INT:
                      c.setUint32(l, u, !0);
                      break;
                    default:
                      throw new Error("Unexpected component type: " + s);
                  }
                }
                r += Eg.padNumber(e * i);
              }
            }
            return n.bufferViews.push({
              buffer: t,
              byteOffset: r,
              byteLength: a,
              byteStride: o,
              target: wv.BufferViewTarget.ARRAY_BUFFER
            }), {
              byteLength: a,
              buffers: [new Uint8Array(l)]
            };
          }
          const p = new Map();
          for (const t of e.getGraph().listEdges()) {
            if (t.getParent() === r) continue;
            const e = t.getChild();
            if (e instanceof Xg) {
              const r = p.get(e) || [];
              r.push(t), p.set(e, r);
            }
          }
          if (n.accessors = [], n.bufferViews = [], n.samplers = [], n.textures = [], n.images = r.listTextures().map((e, t) => {
            const r = s.createPropertyDef(e);
            e.getMimeType() && (r.mimeType = e.getMimeType());
            const n = e.getImage();
            return n && s.createImageData(r, n, e), s.imageIndexMap.set(e, t), r;
          }), l.filter(e => e.prewriteTypes.includes(dg.ACCESSOR)).forEach(e => e.prewrite(s, dg.ACCESSOR)), r.listAccessors().forEach(e => {
            const t = s.accessorUsageGroupedByParent,
              r = s.accessorParents;
            if (s.accessorIndexMap.has(e)) return;
            const n = p.get(e) || [],
              i = s.getAccessorUsage(e);
            if (s.addAccessorToUsageGroup(e, i), t.has(i)) {
              const t = n[0].getParent(),
                i = r.get(t) || new Set();
              i.add(e), r.set(t, i);
            }
          }), l.filter(e => e.prewriteTypes.includes(dg.BUFFER)).forEach(e => e.prewrite(s, dg.BUFFER)), (r.listAccessors().length > 0 || r.listTextures().length > 0 || s.otherBufferViews.size > 0) && 0 === r.listBuffers().length) throw new Error("Buffer required for Document resources, but none was found.");
          n.buffers = [], r.listBuffers().forEach((e, r) => {
            const o = s.createPropertyDef(e),
              a = s.accessorUsageGroupedByParent,
              l = s.accessorParents,
              c = e.listParents().filter(e => e instanceof Xg),
              p = new Set(c),
              d = [],
              f = n.buffers.length;
            let m = 0;
            const _ = s.listAccessorUsageGroups();
            for (const e in _) if (a.has(e)) for (const r of Array.from(l.values())) {
              const n = Array.from(r).filter(e => p.has(e)).filter(t => s.getAccessorUsage(t) === e);
              if (n.length) if (e !== Sv.ARRAY_BUFFER || t.vertexLayout === fg.INTERLEAVED) {
                const t = e === Sv.ARRAY_BUFFER ? h(n, f, m) : u(n, f, m);
                m += t.byteLength, d.push(...t.buffers);
              } else for (const e of n) {
                const t = h([e], f, m);
                m += t.byteLength, d.push(...t.buffers);
              }
            } else {
              const t = _[e].filter(e => p.has(e));
              if (!t.length) continue;
              const r = u(t, f, m, e === Sv.ELEMENT_ARRAY_BUFFER ? wv.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
              m += r.byteLength, d.push(...r.buffers);
            }
            if (s.imageBufferViews.length && 0 === r) for (let e = 0; e < s.imageBufferViews.length; e++) if (n.bufferViews[n.images[e].bufferView].byteOffset = m, m += s.imageBufferViews[e].byteLength, d.push(s.imageBufferViews[e]), m % 8) {
              const e = 8 - m % 8;
              m += e, d.push(new Uint8Array(e));
            }
            if (s.otherBufferViews.has(e)) for (const t of s.otherBufferViews.get(e)) n.bufferViews.push({
              buffer: f,
              byteOffset: m,
              byteLength: t.byteLength
            }), s.otherBufferViewsIndexMap.set(t, n.bufferViews.length - 1), m += t.byteLength, d.push(t);
            if (m) {
              let r;
              t.format === gg.GLB ? r = "@glb.bin" : (r = s.bufferURIGenerator.createURI(e, "bin"), o.uri = r), o.byteLength = m, i.resources[r] = Eg.concat(d);
            }
            n.buffers.push(o), s.bufferIndexMap.set(e, r);
          }), r.listAccessors().find(e => !e.getBuffer()) && o.warn("Skipped writing one or more Accessors: no Buffer assigned."), n.materials = r.listMaterials().map((e, t) => {
            const r = s.createPropertyDef(e);
            if (e.getAlphaMode() !== ov.AlphaMode.OPAQUE && (r.alphaMode = e.getAlphaMode()), e.getAlphaMode() === ov.AlphaMode.MASK && (r.alphaCutoff = e.getAlphaCutoff()), e.getDoubleSided() && (r.doubleSided = !0), r.pbrMetallicRoughness = {}, Bg.eq(e.getBaseColorFactor(), [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = e.getBaseColorFactor()), Bg.eq(e.getEmissiveFactor(), [0, 0, 0]) || (r.emissiveFactor = e.getEmissiveFactor()), 1 !== e.getRoughnessFactor() && (r.pbrMetallicRoughness.roughnessFactor = e.getRoughnessFactor()), 1 !== e.getMetallicFactor() && (r.pbrMetallicRoughness.metallicFactor = e.getMetallicFactor()), e.getBaseColorTexture()) {
              const t = e.getBaseColorTexture(),
                n = e.getBaseColorTextureInfo();
              r.pbrMetallicRoughness.baseColorTexture = s.createTextureInfoDef(t, n);
            }
            if (e.getEmissiveTexture()) {
              const t = e.getEmissiveTexture(),
                n = e.getEmissiveTextureInfo();
              r.emissiveTexture = s.createTextureInfoDef(t, n);
            }
            if (e.getNormalTexture()) {
              const t = e.getNormalTexture(),
                n = e.getNormalTextureInfo(),
                i = s.createTextureInfoDef(t, n);
              1 !== e.getNormalScale() && (i.scale = e.getNormalScale()), r.normalTexture = i;
            }
            if (e.getOcclusionTexture()) {
              const t = e.getOcclusionTexture(),
                n = e.getOcclusionTextureInfo(),
                i = s.createTextureInfoDef(t, n);
              1 !== e.getOcclusionStrength() && (i.strength = e.getOcclusionStrength()), r.occlusionTexture = i;
            }
            if (e.getMetallicRoughnessTexture()) {
              const t = e.getMetallicRoughnessTexture(),
                n = e.getMetallicRoughnessTextureInfo();
              r.pbrMetallicRoughness.metallicRoughnessTexture = s.createTextureInfoDef(t, n);
            }
            return s.materialIndexMap.set(e, t), r;
          }), n.meshes = r.listMeshes().map((e, t) => {
            const r = s.createPropertyDef(e);
            let n = null;
            return r.primitives = e.listPrimitives().map(e => {
              const t = {
                attributes: {}
              };
              t.mode = e.getMode();
              const r = e.getMaterial();
              r && (t.material = s.materialIndexMap.get(r)), Object.keys(e.getExtras()).length && (t.extras = e.getExtras());
              const i = e.getIndices();
              i && (t.indices = s.accessorIndexMap.get(i));
              for (const r of e.listSemantics()) t.attributes[r] = s.accessorIndexMap.get(e.getAttribute(r));
              for (const r of e.listTargets()) {
                const e = {};
                for (const t of r.listSemantics()) e[t] = s.accessorIndexMap.get(r.getAttribute(t));
                t.targets = t.targets || [], t.targets.push(e);
              }
              return e.listTargets().length && !n && (n = e.listTargets().map(e => e.getName())), t;
            }), e.getWeights().length && (r.weights = e.getWeights()), n && (r.extras = r.extras || {}, r.extras.targetNames = n), s.meshIndexMap.set(e, t), r;
          }), n.cameras = r.listCameras().map((e, t) => {
            const r = s.createPropertyDef(e);
            if (r.type = e.getType(), r.type === $g.Type.PERSPECTIVE) {
              r.perspective = {
                znear: e.getZNear(),
                zfar: e.getZFar(),
                yfov: e.getYFov()
              };
              const t = e.getAspectRatio();
              null !== t && (r.perspective.aspectRatio = t);
            } else r.orthographic = {
              znear: e.getZNear(),
              zfar: e.getZFar(),
              xmag: e.getXMag(),
              ymag: e.getYMag()
            };
            return s.cameraIndexMap.set(e, t), r;
          }), n.nodes = r.listNodes().map((e, t) => {
            const r = s.createPropertyDef(e);
            return Bg.eq(e.getTranslation(), [0, 0, 0]) || (r.translation = e.getTranslation()), Bg.eq(e.getRotation(), [0, 0, 0, 1]) || (r.rotation = e.getRotation()), Bg.eq(e.getScale(), [1, 1, 1]) || (r.scale = e.getScale()), e.getWeights().length && (r.weights = e.getWeights()), s.nodeIndexMap.set(e, t), r;
          }), n.skins = r.listSkins().map((e, t) => {
            const r = s.createPropertyDef(e),
              n = e.getInverseBindMatrices();
            n && (r.inverseBindMatrices = s.accessorIndexMap.get(n));
            const i = e.getSkeleton();
            return i && (r.skeleton = s.nodeIndexMap.get(i)), r.joints = e.listJoints().map(e => s.nodeIndexMap.get(e)), s.skinIndexMap.set(e, t), r;
          }), r.listNodes().forEach((e, t) => {
            const r = n.nodes[t],
              i = e.getMesh();
            i && (r.mesh = s.meshIndexMap.get(i));
            const o = e.getCamera();
            o && (r.camera = s.cameraIndexMap.get(o));
            const a = e.getSkin();
            a && (r.skin = s.skinIndexMap.get(a)), e.listChildren().length > 0 && (r.children = e.listChildren().map(e => s.nodeIndexMap.get(e)));
          }), n.animations = r.listAnimations().map((e, t) => {
            const r = s.createPropertyDef(e),
              n = new Map();
            return r.samplers = e.listSamplers().map((e, t) => {
              const r = s.createPropertyDef(e);
              return r.input = s.accessorIndexMap.get(e.getInput()), r.output = s.accessorIndexMap.get(e.getOutput()), r.interpolation = e.getInterpolation(), n.set(e, t), r;
            }), r.channels = e.listChannels().map(e => {
              const t = s.createPropertyDef(e);
              return t.sampler = n.get(e.getSampler()), t.target = {
                node: s.nodeIndexMap.get(e.getTargetNode()),
                path: e.getTargetPath()
              }, t;
            }), s.animationIndexMap.set(e, t), r;
          }), n.scenes = r.listScenes().map((e, t) => {
            const r = s.createPropertyDef(e);
            return r.nodes = e.listChildren().map(e => s.nodeIndexMap.get(e)), s.sceneIndexMap.set(e, t), r;
          });
          const d = r.getDefaultScene();
          return d && (n.scene = r.listScenes().indexOf(d)), n.extensionsUsed = l.map(e => e.extensionName), n.extensionsRequired = c.map(e => e.extensionName), l.forEach(e => e.write(s)), function (e) {
            const t = [];
            for (const r in e) {
              const n = e[r];
              (Array.isArray(n) && 0 === n.length || null === n || "" === n || n && "object" == typeof n && 0 === Object.keys(n).length) && t.push(r);
            }
            for (const r of t) delete e[r];
          }(n), i;
        }
      }.write(e, {
        format: t.format || gg.GLTF,
        basename: t.basename || "",
        logger: this.v,
        vertexLayout: this.F,
        dependencies: hv({}, this.C),
        extensions: Array.from(this.h)
      });
    }
    async writeBinary(e) {
      const {
          json: t,
          resources: r
        } = await this.writeJSON(e, {
          format: gg.GLB
        }),
        n = new Uint32Array([1179937895, 2, 12]),
        i = JSON.stringify(t),
        s = Eg.pad(Eg.encodeText(i), 32),
        o = Eg.toView(new Uint32Array([s.byteLength, 1313821514])),
        a = Eg.concat([o, s]);
      n[n.length - 1] += a.byteLength;
      const l = Object.values(r)[0];
      if (!l || !l.byteLength) return Eg.concat([Eg.toView(n), a]);
      const c = Eg.pad(l, 0),
        u = Eg.toView(new Uint32Array([c.byteLength, 5130562])),
        h = Eg.concat([u, c]);
      return n[n.length - 1] += h.byteLength, Eg.concat([Eg.toView(n), a, h]);
    }
    detectFormat(e) {
      return "glb" === (Vg.isAbsoluteURL(e) ? Vg.extension(e) : Ig.extension(e)) ? gg.GLB : gg.GLTF;
    }
    async P(e) {
      this.lastReadBytes = 0;
      const t = await this.readURI(e, "text");
      this.lastReadBytes += t.length;
      const r = {
        json: JSON.parse(t),
        resources: {}
      };
      return await this.D(r, this.dirname(e)), this.L(r), r;
    }
    async U(e) {
      const t = await this.readURI(e, "view");
      this.lastReadBytes = t.byteLength;
      const r = this._(t);
      return await this.D(r, this.dirname(e)), this.L(r), r;
    }
    async D(e, t) {
      var r = this;
      const n = [...(e.json.images || []), ...(e.json.buffers || [])].map(async function (n) {
        const i = n.uri;
        if (!i || i.match(/data:/)) return Promise.resolve();
        e.resources[i] = await r.readURI(r.resolve(t, i), "view"), r.lastReadBytes += e.resources[i].byteLength;
      });
      await Promise.all(n);
    }
    L(e) {
      function t(t) {
        if (t.uri) if (t.uri in e.resources) Eg.assertView(e.resources[t.uri]);else if (t.uri.match(/data:/)) {
          const r = `__${function () {
            for (let e = 0; e < 999; e++) {
              const e = Gg();
              if (!zg.has(e)) return zg.add(e), e;
            }
            return "";
          }()}.${Ig.extension(t.uri)}`;
          e.resources[r] = Eg.createBufferFromDataURI(t.uri), t.uri = r;
        }
      }
      (e.json.images || []).forEach(e => {
        if (void 0 === e.bufferView && void 0 === e.uri) throw new Error("Missing resource URI or buffer view.");
        t(e);
      }), (e.json.buffers || []).forEach(t);
    }
    j(e) {
      const {
        images: t,
        buffers: r
      } = e.json;
      return e = {
        json: hv({}, e.json),
        resources: hv({}, e.resources)
      }, t && (e.json.images = t.map(e => hv({}, e))), r && (e.json.buffers = r.map(e => hv({}, e))), e;
    }
    _(e) {
      const t = new Uint32Array(e.buffer, e.byteOffset, 3);
      if (1179937895 !== t[0]) throw new Error("Invalid glTF asset.");
      if (2 !== t[1]) throw new Error(`Unsupported glTF binary version, "${t[1]}".`);
      const r = new Uint32Array(e.buffer, e.byteOffset + 12, 2);
      if (r[1] !== Cv.JSON) throw new Error("Missing required GLB JSON chunk.");
      const n = r[0],
        i = Eg.decodeText(Eg.toView(e, 20, n)),
        s = JSON.parse(i),
        o = 20 + n;
      if (e.byteLength <= o) return {
        json: s,
        resources: {}
      };
      const a = new Uint32Array(e.buffer, e.byteOffset + o, 2);
      if (a[1] !== Cv.BIN) throw new Error("Expected GLB BIN in second chunk.");
      return {
        json: s,
        resources: {
          "@glb.bin": Eg.toView(e, o + 8, a[0])
        }
      };
    }
  } {
    constructor(e = Vg.DEFAULT_INIT) {
      super(), this.V = void 0, this.V = e;
    }
    async readURI(e, t) {
      const r = await fetch(e, this.V);
      switch (t) {
        case "view":
          return new Uint8Array(await r.arrayBuffer());
        case "text":
          return r.text();
      }
    }
    resolve(e, t) {
      return Vg.resolve(e, t);
    }
    dirname(e) {
      return Vg.dirname(e);
    }
    detectFormat(e) {
      return "glb" === Vg.extension(e) ? gg.GLB : gg.GLTF;
    }
  }
  class Tv {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }
  }
  class Iv {
    constructor(e, t, r, n) {
      this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, r), this._littleEndian = n, this._offset = 0;
    }
    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);
      return this._offset += 1, e;
    }
    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e;
    }
    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e;
    }
    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e;
    }
    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e;
    }
    _skip(e) {
      return this._offset += e, this;
    }
    _scan(e, t = 0) {
      const r = this._offset;
      let n = 0;
      for (; this._dataView.getUint8(this._offset) !== t && n < e;) n++, this._offset++;
      return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r, n);
    }
  }
  new Uint8Array([0]);
  const kv = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function Dv(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }
  function Pv(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, kv.length);
    if (t[0] !== kv[0] || t[1] !== kv[1] || t[2] !== kv[2] || t[3] !== kv[3] || t[4] !== kv[4] || t[5] !== kv[5] || t[6] !== kv[6] || t[7] !== kv[7] || t[8] !== kv[8] || t[9] !== kv[9] || t[10] !== kv[10] || t[11] !== kv[11]) throw new Error("Missing KTX 2.0 identifier.");
    const r = new Tv(),
      n = 17 * Uint32Array.BYTES_PER_ELEMENT,
      i = new Iv(e, kv.length, n, !0);
    r.vkFormat = i._nextUint32(), r.typeSize = i._nextUint32(), r.pixelWidth = i._nextUint32(), r.pixelHeight = i._nextUint32(), r.pixelDepth = i._nextUint32(), r.layerCount = i._nextUint32(), r.faceCount = i._nextUint32();
    const s = i._nextUint32();
    r.supercompressionScheme = i._nextUint32();
    const o = i._nextUint32(),
      a = i._nextUint32(),
      l = i._nextUint32(),
      c = i._nextUint32(),
      u = i._nextUint64(),
      h = i._nextUint64(),
      p = new Iv(e, kv.length + n, 3 * s * 8, !0);
    for (let t = 0; t < s; t++) r.levels.push({
      levelData: new Uint8Array(e.buffer, e.byteOffset + p._nextUint64(), p._nextUint64()),
      uncompressedByteLength: p._nextUint64()
    });
    const d = new Iv(e, o, a, !0),
      f = {
        vendorId: d._skip(4)._nextUint16(),
        descriptorType: d._nextUint16(),
        versionNumber: d._nextUint16(),
        descriptorBlockSize: d._nextUint16(),
        colorModel: d._nextUint8(),
        colorPrimaries: d._nextUint8(),
        transferFunction: d._nextUint8(),
        flags: d._nextUint8(),
        texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        samples: []
      },
      m = (f.descriptorBlockSize / 4 - 6) / 4;
    for (let e = 0; e < m; e++) {
      const t = {
        bitOffset: d._nextUint16(),
        bitLength: d._nextUint8(),
        channelType: d._nextUint8(),
        samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        sampleLower: -1 / 0,
        sampleUpper: 1 / 0
      };
      64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
    }
    r.dataFormatDescriptor.length = 0, r.dataFormatDescriptor.push(f);
    const _ = new Iv(e, l, c, !0);
    for (; _._offset < c;) {
      const e = _._nextUint32(),
        t = _._scan(e),
        n = Dv(t),
        i = _._scan(e - t.byteLength);
      r.keyValue[n] = n.match(/^ktx/i) ? Dv(i) : i, _._offset % 4 && _._skip(4 - _._offset % 4);
    }
    if (h <= 0) return r;
    const g = new Iv(e, u, h, !0),
      v = g._nextUint16(),
      A = g._nextUint16(),
      b = g._nextUint32(),
      y = g._nextUint32(),
      x = g._nextUint32(),
      w = g._nextUint32(),
      E = [];
    for (let e = 0; e < s; e++) E.push({
      imageFlags: g._nextUint32(),
      rgbSliceByteOffset: g._nextUint32(),
      rgbSliceByteLength: g._nextUint32(),
      alphaSliceByteOffset: g._nextUint32(),
      alphaSliceByteLength: g._nextUint32()
    });
    const S = u + g._offset,
      C = S + b,
      M = C + y,
      T = M + x,
      I = new Uint8Array(e.buffer, e.byteOffset + S, b),
      k = new Uint8Array(e.buffer, e.byteOffset + C, y),
      D = new Uint8Array(e.buffer, e.byteOffset + M, x),
      P = new Uint8Array(e.buffer, e.byteOffset + T, w);
    return r.globalData = {
      endpointCount: v,
      selectorCount: A,
      imageDescs: E,
      endpointsData: I,
      selectorsData: k,
      tablesData: D,
      extendedData: P
    }, r;
  }
  class Bv extends ev {
    init() {
      this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [dg.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }
    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }
    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: "INSTANCE_ATTRIBUTE"
      });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  Bv.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
  const Rv = "EXT_mesh_gpu_instancing";
  function Lv() {
    return (Lv = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }).apply(this, arguments);
  }
  var Ov, Fv, Uv;
  (class extends gv {
    constructor(...e) {
      super(...e), this.extensionName = Rv, this.provideTypes = [dg.NODE], this.prewriteTypes = [dg.ACCESSOR];
    }
    createInstancedMesh() {
      return new Bv(this.document.getGraph());
    }
    read(e) {
      return (e.jsonDoc.json.nodes || []).forEach((t, r) => {
        if (!t.extensions || !t.extensions[Rv]) return;
        const n = t.extensions[Rv],
          i = this.createInstancedMesh();
        for (const t in n.attributes) i.setAttribute(t, e.accessors[n.attributes[t]]);
        e.nodes[r].setExtension(Rv, i);
      }), this;
    }
    prewrite(e) {
      e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");
      for (const t of this.properties) for (const r of t.listAttributes()) e.addAccessorToUsageGroup(r, "INSTANCE_ATTRIBUTE");
      return this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listNodes().forEach(r => {
        const n = r.getExtension(Rv);
        if (n) {
          const i = e.nodeIndexMap.get(r),
            s = t.json.nodes[i],
            o = {
              attributes: {}
            };
          n.listSemantics().forEach(t => {
            const r = n.getAttribute(t);
            o.attributes[t] = e.accessorIndexMap.get(r);
          }), s.extensions = s.extensions || {}, s.extensions[Rv] = o;
        }
      }), this;
    }
  }).EXTENSION_NAME = Rv, function (e) {
    e.QUANTIZE = "quantize", e.FILTER = "filter";
  }(Ov || (Ov = {})), function (e) {
    e.ATTRIBUTES = "ATTRIBUTES", e.TRIANGLES = "TRIANGLES", e.INDICES = "INDICES";
  }(Fv || (Fv = {})), function (e) {
    e.NONE = "NONE", e.OCTAHEDRAL = "OCTAHEDRAL", e.QUATERNION = "QUATERNION", e.EXPONENTIAL = "EXPONENTIAL";
  }(Uv || (Uv = {}));
  const {
      BYTE: Nv,
      SHORT: jv,
      FLOAT: zv
    } = Xg.ComponentType,
    {
      normalize: Gv,
      denormalize: Vv
    } = Bg;
  function Qv(e, t, r, n) {
    const {
        filter: i,
        bits: s
      } = n,
      o = {
        array: e.getArray(),
        byteStride: e.getElementSize() * e.getComponentSize(),
        componentType: e.getComponentType(),
        normalized: e.getNormalized()
      };
    if (r !== Fv.ATTRIBUTES) return o;
    if (i !== Uv.NONE) {
      let r = e.getNormalized() ? function (e) {
        const t = e.getComponentType(),
          r = e.getArray(),
          n = new Float32Array(r.length);
        for (let e = 0; e < r.length; e++) n[e] = Vv(r[e], t);
        return n;
      }(e) : new Float32Array(o.array);
      switch (i) {
        case Uv.EXPONENTIAL:
          o.byteStride = 4 * e.getElementSize(), o.componentType = zv, o.normalized = !1, o.array = t.encodeFilterExp(r, e.getCount(), o.byteStride, s);
          break;
        case Uv.OCTAHEDRAL:
          o.byteStride = s > 8 ? 8 : 4, o.componentType = s > 8 ? jv : Nv, o.normalized = !0, r = 3 === e.getElementSize() ? function (e) {
            const t = new Float32Array(4 * e.length / 3);
            for (let r = 0, n = e.length / 3; r < n; r++) t[4 * r] = e[3 * r], t[4 * r + 1] = e[3 * r + 1], t[4 * r + 2] = e[3 * r + 2];
            return t;
          }(r) : r, o.array = t.encodeFilterOct(r, e.getCount(), o.byteStride, s);
          break;
        case Uv.QUATERNION:
          o.byteStride = 8, o.componentType = jv, o.normalized = !0, o.array = t.encodeFilterQuat(r, e.getCount(), o.byteStride, s);
          break;
        default:
          throw new Error("Invalid filter.");
      }
      o.min = e.getMin([]), o.max = e.getMax([]), e.getNormalized() && (o.min = o.min.map(t => Vv(t, e.getComponentType())), o.max = o.max.map(t => Vv(t, e.getComponentType()))), o.normalized && (o.min = o.min.map(e => Gv(e, o.componentType)), o.max = o.max.map(e => Gv(e, o.componentType)));
    } else o.byteStride % 4 && (o.array = function (e, t) {
      const r = Eg.padNumber(e.BYTES_PER_ELEMENT * t) / e.BYTES_PER_ELEMENT,
        n = new e.constructor(e.length / t * r);
      for (let i = 0; i * t < e.length; i++) for (let s = 0; s < t; s++) n[i * r + s] = e[i * t + s];
      return n;
    }(o.array, e.getElementSize()), o.byteStride = o.array.byteLength / e.getCount());
    return o;
  }
  function Hv(e, t) {
    return t === wv.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e.listParents().some(e => e instanceof cv && e.getMode() === cv.Mode.TRIANGLES) ? Fv.TRIANGLES : Fv.INDICES : Fv.ATTRIBUTES;
  }
  function Wv(e, t) {
    const r = t.getGraph().listParentEdges(e).filter(e => !(e.getParent() instanceof mv));
    for (const t of r) {
      const r = t.getName(),
        n = t.getAttributes().key || "";
      if ("indices" === r) return {
        filter: Uv.NONE
      };
      if ("attributes" === r) {
        if ("POSITION" === n) return {
          filter: Uv.NONE
        };
        if ("TEXCOORD_0" === n) return {
          filter: Uv.NONE
        };
        if ("NORMAL" === n) return {
          filter: Uv.OCTAHEDRAL,
          bits: 8
        };
        if ("TANGENT" === n) return {
          filter: Uv.OCTAHEDRAL,
          bits: 8
        };
        if (n.startsWith("JOINTS_")) return {
          filter: Uv.NONE
        };
        if (n.startsWith("WEIGHTS_")) return {
          filter: Uv.NONE
        };
      }
      if ("output" === r) {
        const t = qv(e);
        return "rotation" === t ? {
          filter: Uv.QUATERNION,
          bits: 16
        } : "translation" === t || "scale" === t ? {
          filter: Uv.EXPONENTIAL,
          bits: 12
        } : {
          filter: Uv.NONE
        };
      }
      if ("input" === r) return {
        filter: Uv.NONE
      };
      if ("inverseBindMatrices" === r) return {
        filter: Uv.NONE
      };
    }
    return {
      filter: Uv.NONE
    };
  }
  function qv(e) {
    for (const t of e.listParents()) if (t instanceof Jg) for (const e of t.listParents()) if (e instanceof Kg) return e.getTargetPath();
    return null;
  }
  const Xv = "EXT_meshopt_compression",
    Yv = {
      method: Ov.QUANTIZE
    };
  class Kv extends gv {
    constructor(...e) {
      super(...e), this.extensionName = Xv, this.prereadTypes = [dg.BUFFER, dg.PRIMITIVE], this.prewriteTypes = [dg.BUFFER, dg.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = new Map(), this._encoder = null, this._encoderOptions = Yv, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
    }
    install(e, t) {
      return "meshopt.decoder" === e && (this._decoder = t), "meshopt.encoder" === e && (this._encoder = t), this;
    }
    setEncoderOptions(e) {
      return this._encoderOptions = Lv({}, Yv, e), this;
    }
    preread(e, t) {
      if (!this._decoder) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Xv}] Please install extension dependency, "meshopt.decoder".`);
      }
      if (!this._decoder.supported) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Xv}]: Missing WASM support.`);
      }
      return t === dg.BUFFER ? this._prereadBuffers(e) : t === dg.PRIMITIVE && this._prereadPrimitives(e), this;
    }
    _prereadBuffers(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach((r, n) => {
        if (!r.extensions || !r.extensions[Xv]) return;
        const i = r.extensions[Xv],
          s = i.byteOffset || 0,
          o = i.byteLength || 0,
          a = i.count,
          l = i.byteStride,
          c = new Uint8Array(a * l),
          u = t.json.buffers[r.buffer],
          h = Eg.toView(u.uri ? t.resources[u.uri] : t.resources["@glb.bin"], s, o);
        this._decoder.decodeGltfBuffer(c, a, l, h, i.mode, i.filter), e.bufferViews[n] = c;
      });
    }
    _prereadPrimitives(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach(r => {
        var n;
        r.extensions && r.extensions[Xv] && (n = t.json.buffers[r.buffer]).extensions && n.extensions.EXT_meshopt_compression && n.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e.buffers[r.buffer], e.buffers[r.extensions[Xv].buffer]);
      });
    }
    read(e) {
      if (!this.isRequired()) return this;
      for (const [e, t] of this._decoderFallbackBufferMap) {
        for (const r of e.listParents()) r instanceof Xg && r.swap(e, t);
        e.dispose();
      }
      return this;
    }
    prewrite(e, t) {
      return t === dg.ACCESSOR ? this._prewriteAccessors(e) : t === dg.BUFFER && this._prewriteBuffers(e), this;
    }
    _prewriteAccessors(e) {
      const t = e.jsonDoc.json,
        r = this._encoder,
        n = this._encoderOptions,
        i = this.document.createBuffer(),
        s = this.document.getRoot().listBuffers().indexOf(i);
      this._encoderFallbackBuffer = i, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
      for (const i of this.document.getRoot().listAccessors()) {
        if ("weights" === qv(i)) continue;
        const o = e.getAccessorUsage(i),
          a = Hv(i, o),
          l = n.method === Ov.FILTER ? Wv(i, this.document) : {
            filter: Uv.NONE
          },
          c = Qv(i, r, a, l),
          {
            array: u,
            byteStride: h
          } = c,
          p = i.getBuffer();
        if (!p) throw new Error(`${Xv}: Missing buffer for accessor.`);
        const d = this.document.getRoot().listBuffers().indexOf(p),
          f = [o, a, l.filter, h, d].join(":");
        let m = this._encoderBufferViews[f],
          _ = this._encoderBufferViewData[f],
          g = this._encoderBufferViewAccessors[f];
        m && _ || (g = this._encoderBufferViewAccessors[f] = [], _ = this._encoderBufferViewData[f] = [], m = this._encoderBufferViews[f] = {
          buffer: s,
          target: wv.USAGE_TO_TARGET[o],
          byteOffset: 0,
          byteLength: 0,
          byteStride: o === wv.BufferViewUsage.ARRAY_BUFFER ? h : void 0,
          extensions: {
            [Xv]: {
              buffer: d,
              byteOffset: 0,
              byteLength: 0,
              mode: a,
              filter: l.filter !== Uv.NONE ? l.filter : void 0,
              byteStride: h,
              count: 0
            }
          }
        });
        const v = e.createAccessorDef(i);
        v.componentType = c.componentType, v.normalized = c.normalized, v.byteOffset = m.byteLength, v.min && c.min && (v.min = c.min), v.max && c.max && (v.max = c.max), e.accessorIndexMap.set(i, t.accessors.length), t.accessors.push(v), g.push(v), _.push(new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), m.byteLength += u.byteLength, m.extensions.EXT_meshopt_compression.count += i.getCount();
      }
    }
    _prewriteBuffers(e) {
      const t = this._encoder;
      for (const r in this._encoderBufferViews) {
        const n = this._encoderBufferViews[r],
          i = this._encoderBufferViewData[r],
          s = this.document.getRoot().listBuffers()[n.extensions[Xv].buffer],
          o = e.otherBufferViews.get(s) || [],
          {
            count: a,
            byteStride: l,
            mode: c
          } = n.extensions[Xv],
          u = Eg.concat(i),
          h = t.encodeGltfBuffer(u, a, l, c),
          p = Eg.pad(h);
        n.extensions[Xv].byteLength = h.byteLength, i.length = 0, i.push(p), o.push(p), e.otherBufferViews.set(s, o);
      }
    }
    write(e) {
      let t = 0;
      for (const r in this._encoderBufferViews) {
        const n = this._encoderBufferViews[r],
          i = e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[r][0]),
          s = this._encoderBufferViewAccessors[r];
        for (const e of s) e.bufferView = i;
        const o = e.jsonDoc.json.bufferViews[i],
          a = o.byteOffset || 0;
        Object.assign(o, n), o.byteOffset = t, o.extensions[Xv].byteOffset = a, t += Eg.padNumber(n.byteLength);
      }
      const r = this._encoderFallbackBuffer,
        n = e.bufferIndexMap.get(r),
        i = e.jsonDoc.json.buffers[n];
      return i.byteLength = t, i.extensions = {
        [Xv]: {
          fallback: !0
        }
      }, r.dispose(), this;
    }
  }
  Kv.EXTENSION_NAME = Xv, Kv.EncoderMethod = Ov;
  const Jv = "EXT_texture_webp";
  class Zv {
    match(e) {
      return e.length >= 12 && 87 === e[8] && 69 === e[9] && 66 === e[10] && 80 === e[11];
    }
    getSize(e) {
      const t = Eg.decodeText(e.slice(0, 4)),
        r = Eg.decodeText(e.slice(8, 12));
      if ("RIFF" !== t || "WEBP" !== r) return null;
      const n = new DataView(e.buffer, e.byteOffset);
      let i = 12;
      for (; i < n.byteLength;) {
        const e = Eg.decodeText(new Uint8Array([n.getUint8(i), n.getUint8(i + 1), n.getUint8(i + 2), n.getUint8(i + 3)])),
          t = n.getUint32(i + 4, !0);
        if ("VP8 " === e) return [16383 & n.getInt16(i + 14, !0), 16383 & n.getInt16(i + 16, !0)];
        if ("VP8L" === e) {
          const e = n.getUint8(i + 9),
            t = n.getUint8(i + 10),
            r = n.getUint8(i + 11);
          return [1 + ((63 & t) << 8 | e), 1 + ((15 & n.getUint8(i + 12)) << 10 | r << 2 | (192 & t) >> 6)];
        }
        i += 8 + t + t % 2;
      }
      return null;
    }
    getChannels(e) {
      return 4;
    }
  }
  (class extends gv {
    constructor(...e) {
      super(...e), this.extensionName = Jv, this.prereadTypes = [dg.TEXTURE];
    }
    static register() {
      Mg.registerFormat("image/webp", new Zv());
    }
    preread(e) {
      return (e.jsonDoc.json.textures || []).forEach(e => {
        e.extensions && e.extensions.EXT_texture_webp && (e.source = e.extensions.EXT_texture_webp.source);
      }), this;
    }
    read(e) {
      return this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(r => {
        if ("image/webp" === r.getMimeType()) {
          const n = e.imageIndexMap.get(r);
          (t.json.textures || []).forEach(e => {
            e.source === n && (e.extensions = e.extensions || {}, e.extensions.EXT_texture_webp = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }
  }).EXTENSION_NAME = Jv;
  const $v = "KHR_draco_mesh_compression";
  let eA, tA, rA, nA;
  function iA(e, t) {
    const r = new eA.DecoderBuffer();
    try {
      if (r.Init(t, t.length), e.GetEncodedGeometryType(r) !== eA.TRIANGULAR_MESH) throw new Error(`[${$v}] Unknown geometry type.`);
      const n = new eA.Mesh();
      if (!e.DecodeBufferToMesh(r, n).ok() || 0 === n.ptr) throw new Error(`[${$v}] Decoding failure.`);
      return n;
    } finally {
      eA.destroy(r);
    }
  }
  function sA(e, t) {
    const r = 3 * t.num_faces();
    let n, i;
    if (t.num_points() <= 65534) {
      const s = r * Uint16Array.BYTES_PER_ELEMENT;
      n = eA._malloc(s), e.GetTrianglesUInt16Array(t, s, n), i = new Uint16Array(eA.HEAPU16.buffer, n, r).slice();
    } else {
      const s = r * Uint32Array.BYTES_PER_ELEMENT;
      n = eA._malloc(s), e.GetTrianglesUInt32Array(t, s, n), i = new Uint32Array(eA.HEAPU32.buffer, n, r).slice();
    }
    return eA._free(n), i;
  }
  function oA(e, t, r, n) {
    const i = rA[n.componentType],
      s = tA[n.componentType],
      o = r.num_components(),
      a = t.num_points() * o,
      l = a * s.BYTES_PER_ELEMENT,
      c = eA._malloc(l);
    e.GetAttributeDataArrayForAllPoints(t, r, i, l, c);
    const u = new s(eA.HEAPF32.buffer, c, a).slice();
    return eA._free(c), u;
  }
  var aA, lA;
  !function (e) {
    e[e.EDGEBREAKER = 1] = "EDGEBREAKER", e[e.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(aA || (aA = {})), function (e) {
    e.POSITION = "POSITION", e.NORMAL = "NORMAL", e.COLOR = "COLOR", e.TEX_COORD = "TEX_COORD", e.GENERIC = "GENERIC";
  }(lA || (lA = {}));
  const cA = {
      [lA.POSITION]: 14,
      [lA.NORMAL]: 10,
      [lA.COLOR]: 8,
      [lA.TEX_COORD]: 12,
      [lA.GENERIC]: 12
    },
    uA = {
      decodeSpeed: 5,
      encodeSpeed: 5,
      method: aA.EDGEBREAKER,
      quantizationBits: cA,
      quantizationVolume: "mesh"
    };
  function hA(e, t = uA) {
    const r = Lv({}, uA, t);
    r.quantizationBits = Lv({}, cA, t.quantizationBits);
    const n = new nA.Encoder(),
      i = new nA.MeshBuilder(),
      s = new nA.Mesh(),
      o = {},
      a = new nA.DracoInt8Array();
    for (const t of e.listSemantics()) {
      const a = e.getAttribute(t),
        l = pA(t),
        c = dA(i, a.getComponentType(), s, nA[l], a.getCount(), a.getElementSize(), a.getArray());
      if (-1 === c) throw new Error(`Error compressing "${t}" attribute.`);
      if (o[t] = c, "mesh" === r.quantizationVolume || "POSITION" !== t) n.SetAttributeQuantization(nA[l], r.quantizationBits[l]);else {
        if ("object" != typeof r.quantizationVolume) throw new Error("Invalid quantization volume state.");
        {
          const {
              quantizationVolume: e
            } = r,
            t = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], e.max[2] - e.min[2]);
          n.SetAttributeExplicitQuantization(nA[l], r.quantizationBits[l], a.getElementSize(), e.min, t);
        }
      }
    }
    const l = e.getIndices();
    if (!l) throw new Error("Primitive must have indices.");
    i.AddFacesToMesh(s, l.getCount() / 3, l.getArray()), n.SetSpeedOptions(r.encodeSpeed, r.decodeSpeed), n.SetTrackEncodedProperties(!0), r.method === aA.SEQUENTIAL || e.listTargets().length > 0 ? n.SetEncodingMethod(nA.MESH_SEQUENTIAL_ENCODING) : n.SetEncodingMethod(nA.MESH_EDGEBREAKER_ENCODING);
    const c = n.EncodeMeshToDracoBuffer(s, a);
    if (c <= 0) throw new Error("Error applying Draco compression.");
    const u = new Uint8Array(c);
    for (let e = 0; e < c; ++e) u[e] = a.GetValue(e);
    const h = e.getAttribute("POSITION").getCount(),
      p = n.GetNumberOfEncodedPoints(),
      d = 3 * n.GetNumberOfEncodedFaces();
    if (e.listTargets().length > 0 && p !== h) throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');
    return nA.destroy(a), nA.destroy(s), nA.destroy(i), nA.destroy(n), {
      numVertices: p,
      numIndices: d,
      data: u,
      attributeIDs: o
    };
  }
  function pA(e) {
    return "POSITION" === e ? lA.POSITION : "NORMAL" === e ? lA.NORMAL : e.startsWith("COLOR_") ? lA.COLOR : e.startsWith("TEXCOORD_") ? lA.TEX_COORD : lA.GENERIC;
  }
  function dA(e, t, r, n, i, s, o) {
    switch (t) {
      case Xg.ComponentType.UNSIGNED_BYTE:
        return e.AddUInt8Attribute(r, n, i, s, o);
      case Xg.ComponentType.BYTE:
        return e.AddInt8Attribute(r, n, i, s, o);
      case Xg.ComponentType.UNSIGNED_SHORT:
        return e.AddUInt16Attribute(r, n, i, s, o);
      case Xg.ComponentType.SHORT:
        return e.AddInt16Attribute(r, n, i, s, o);
      case Xg.ComponentType.UNSIGNED_INT:
        return e.AddUInt32Attribute(r, n, i, s, o);
      case Xg.ComponentType.FLOAT:
        return e.AddFloatAttribute(r, n, i, s, o);
      default:
        throw new Error(`Unexpected component type, "${t}".`);
    }
  }
  const fA = "KHR_draco_mesh_compression";
  class mA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = fA, this.prereadTypes = [dg.PRIMITIVE], this.prewriteTypes = [dg.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {};
    }
    install(e, t) {
      return "draco3d.decoder" === e && (this._decoderModule = t, eA = this._decoderModule, tA = {
        [Xg.ComponentType.FLOAT]: Float32Array,
        [Xg.ComponentType.UNSIGNED_INT]: Uint32Array,
        [Xg.ComponentType.UNSIGNED_SHORT]: Uint16Array,
        [Xg.ComponentType.UNSIGNED_BYTE]: Uint8Array,
        [Xg.ComponentType.SHORT]: Int16Array,
        [Xg.ComponentType.BYTE]: Int8Array
      }, rA = {
        [Xg.ComponentType.FLOAT]: eA.DT_FLOAT32,
        [Xg.ComponentType.UNSIGNED_INT]: eA.DT_UINT32,
        [Xg.ComponentType.UNSIGNED_SHORT]: eA.DT_UINT16,
        [Xg.ComponentType.UNSIGNED_BYTE]: eA.DT_UINT8,
        [Xg.ComponentType.SHORT]: eA.DT_INT16,
        [Xg.ComponentType.BYTE]: eA.DT_INT8
      }), "draco3d.encoder" === e && (this._encoderModule = t, nA = this._encoderModule), this;
    }
    setEncoderOptions(e) {
      return this._encoderOptions = e, this;
    }
    preread(e) {
      if (!this._decoderModule) throw new Error(`[${fA}] Please install extension dependency, "draco3d.decoder".`);
      const t = this.document.getLogger(),
        r = e.jsonDoc,
        n = new Map();
      try {
        const i = r.json.meshes || [];
        for (const s of i) for (const i of s.primitives) {
          if (!i.extensions || !i.extensions[fA]) continue;
          const s = i.extensions[fA];
          let [o, a] = n.get(s.bufferView) || [];
          if (!a || !o) {
            const e = r.json.bufferViews[s.bufferView],
              i = r.json.buffers[e.buffer],
              l = Eg.toView(i.uri ? r.resources[i.uri] : r.resources["@glb.bin"], e.byteOffset || 0, e.byteLength);
            o = new this._decoderModule.Decoder(), a = iA(o, l), n.set(s.bufferView, [o, a]), t.debug(`[${fA}] Decompressed ${l.byteLength} bytes.`);
          }
          for (const t in i.attributes) {
            const r = e.jsonDoc.json.accessors[i.attributes[t]],
              n = o.GetAttributeByUniqueId(a, s.attributes[t]),
              l = oA(o, a, n, r);
            e.accessors[i.attributes[t]].setArray(l);
          }
          void 0 !== i.indices && e.accessors[i.indices].setArray(sA(o, a));
        }
      } finally {
        for (const [e, t] of Array.from(n.values())) this._decoderModule.destroy(e), this._decoderModule.destroy(t);
      }
      return this;
    }
    read(e) {
      return this;
    }
    prewrite(e, t) {
      if (!this._encoderModule) throw new Error(`[${fA}] Please install extension dependency, "draco3d.encoder".`);
      const r = this.document.getLogger();
      r.debug(`[${fA}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
      const n = function (e) {
          const t = e.getLogger(),
            r = new Set(),
            n = new Set();
          for (const i of e.getRoot().listMeshes()) for (const e of i.listPrimitives()) e.getIndices() ? e.getMode() !== cv.Mode.TRIANGLES ? (n.add(e), t.warn(`[${fA}] Skipping Draco compression on non-TRIANGLES primitive.`)) : r.add(e) : (n.add(e), t.warn(`[${fA}] Skipping Draco compression on non-indexed primitive.`));
          const i = e.getRoot().listAccessors(),
            s = new Map();
          for (let e = 0; e < i.length; e++) s.set(i[e], e);
          const o = new Map(),
            a = new Set(),
            l = new Map();
          for (const t of Array.from(r)) {
            let r = _A(t, s);
            if (a.has(r)) l.set(t, r);else {
              if (o.has(t.getIndices())) {
                const r = t.getIndices(),
                  n = r.clone();
                s.set(n, e.getRoot().listAccessors().length - 1), t.swap(r, n);
              }
              for (const r of t.listAttributes()) if (o.has(r)) {
                const n = r.clone();
                s.set(n, e.getRoot().listAccessors().length - 1), t.swap(r, n);
              }
              r = _A(t, s), a.add(r), l.set(t, r), o.set(t.getIndices(), r);
              for (const e of t.listAttributes()) o.set(e, r);
            }
          }
          for (const e of Array.from(o.keys())) {
            const t = new Set(e.listParents().map(e => e.propertyType));
            if (2 !== t.size || !t.has(dg.PRIMITIVE) || !t.has(dg.ROOT)) throw new Error(`[${fA}] Compressed accessors must only be used as indices or vertex attributes.`);
          }
          for (const e of Array.from(r)) {
            const t = l.get(e),
              r = e.getIndices();
            if (o.get(r) !== t || e.listAttributes().some(e => o.get(e) !== t)) throw new Error(`[${fA}] Draco primitives must share all, or no, accessors.`);
          }
          for (const e of Array.from(n)) {
            const t = e.getIndices();
            if (o.has(t) || e.listAttributes().some(e => o.has(e))) throw new Error(`[${fA}] Accessor cannot be shared by compressed and uncompressed primitives.`);
          }
          return l;
        }(this.document),
        i = new Map();
      let s = "mesh";
      "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? r.warn(`[${fA}]: quantizationVolume=scene requires exactly 1 scene.`) : s = function (e) {
        const t = {
            min: [1 / 0, 1 / 0, 1 / 0],
            max: [-1 / 0, -1 / 0, -1 / 0]
          },
          r = e.propertyType === dg.NODE ? [e] : e.listChildren();
        for (const e of r) e.traverse(e => {
          const r = e.getMesh();
          if (!r) return;
          const n = xg(r, e.getWorldMatrix());
          wg(n.min, t), wg(n.max, t);
        });
        return t;
      }(this.document.getRoot().listScenes().pop()));
      for (const t of Array.from(n.keys())) {
        const r = n.get(t);
        if (!r) throw new Error("Unexpected primitive.");
        if (i.has(r)) {
          i.set(r, i.get(r));
          continue;
        }
        const o = t.getIndices(),
          a = e.jsonDoc.json.accessors,
          l = hA(t, Lv({}, this._encoderOptions, {
            quantizationVolume: s
          }));
        i.set(r, l);
        const c = e.createAccessorDef(o);
        c.count = l.numIndices, e.accessorIndexMap.set(o, a.length), a.push(c);
        for (const r of t.listSemantics()) {
          const n = t.getAttribute(r),
            i = e.createAccessorDef(n);
          i.count = l.numVertices, e.accessorIndexMap.set(n, a.length), a.push(i);
        }
        const u = t.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
        e.otherBufferViews.has(u) || e.otherBufferViews.set(u, []), e.otherBufferViews.get(u).push(l.data);
      }
      return r.debug(`[${fA}] Compressed ${n.size} primitives.`), e.extensionData[fA] = {
        primitiveHashMap: n,
        primitiveEncodingMap: i
      }, this;
    }
    write(e) {
      const t = e.extensionData[fA];
      for (const r of this.document.getRoot().listMeshes()) {
        const n = e.jsonDoc.json.meshes[e.meshIndexMap.get(r)];
        for (let i = 0; i < r.listPrimitives().length; i++) {
          const s = r.listPrimitives()[i],
            o = n.primitives[i],
            a = t.primitiveHashMap.get(s);
          if (!a) continue;
          const l = t.primitiveEncodingMap.get(a);
          o.extensions = o.extensions || {}, o.extensions[fA] = {
            bufferView: e.otherBufferViewsIndexMap.get(l.data),
            attributes: l.attributeIDs
          };
        }
      }
      if (!t.primitiveHashMap.size) {
        const t = e.jsonDoc.json;
        t.extensionsUsed = (t.extensionsUsed || []).filter(e => e !== fA), t.extensionsRequired = (t.extensionsRequired || []).filter(e => e !== fA);
      }
      return this;
    }
  }
  function _A(e, t) {
    const r = [],
      n = e.getIndices();
    r.push(t.get(n));
    for (const n of e.listAttributes()) r.push(t.get(n));
    return r.sort().join("|");
  }
  mA.EXTENSION_NAME = fA, mA.EncoderMethod = aA;
  class gA extends ev {
    init() {
      this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [dg.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        color: [1, 1, 1],
        intensity: 1,
        type: gA.Type.POINT,
        range: null,
        innerConeAngle: 0,
        outerConeAngle: Math.PI / 4
      });
    }
    getColor() {
      return this.get("color");
    }
    setColor(e) {
      return this.set("color", e);
    }
    getColorHex() {
      return Sg.factorToHex(this.getColor());
    }
    setColorHex(e) {
      const t = this.getColor().slice();
      return Sg.hexToFactor(e, t), this.setColor(t);
    }
    getIntensity() {
      return this.get("intensity");
    }
    setIntensity(e) {
      return this.set("intensity", e);
    }
    getType() {
      return this.get("type");
    }
    setType(e) {
      return this.set("type", e);
    }
    getRange() {
      return this.get("range");
    }
    setRange(e) {
      return this.set("range", e);
    }
    getInnerConeAngle() {
      return this.get("innerConeAngle");
    }
    setInnerConeAngle(e) {
      return this.set("innerConeAngle", e);
    }
    getOuterConeAngle() {
      return this.get("outerConeAngle");
    }
    setOuterConeAngle(e) {
      return this.set("outerConeAngle", e);
    }
  }
  gA.EXTENSION_NAME = "KHR_lights_punctual", gA.Type = {
    POINT: "point",
    SPOT: "spot",
    DIRECTIONAL: "directional"
  };
  const vA = "KHR_lights_punctual";
  class AA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = vA;
    }
    createLight(e = "") {
      return new gA(this.document.getGraph(), e);
    }
    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions.KHR_lights_punctual) return this;
      const r = (t.json.extensions.KHR_lights_punctual.lights || []).map(e => {
        var t, r;
        const n = this.createLight().setName(e.name || "").setType(e.type);
        return void 0 !== e.color && n.setColor(e.color), void 0 !== e.intensity && n.setIntensity(e.intensity), void 0 !== e.range && n.setRange(e.range), void 0 !== (null == (t = e.spot) ? void 0 : t.innerConeAngle) && n.setInnerConeAngle(e.spot.innerConeAngle), void 0 !== (null == (r = e.spot) ? void 0 : r.outerConeAngle) && n.setOuterConeAngle(e.spot.outerConeAngle), n;
      });
      return t.json.nodes.forEach((t, n) => {
        t.extensions && t.extensions.KHR_lights_punctual && e.nodes[n].setExtension(vA, r[t.extensions.KHR_lights_punctual.light]);
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      if (0 === this.properties.size) return this;
      const r = [],
        n = new Map();
      for (const e of this.properties) {
        const t = e,
          i = {
            type: t.getType()
          };
        Bg.eq(t.getColor(), [1, 1, 1]) || (i.color = t.getColor()), 1 !== t.getIntensity() && (i.intensity = t.getIntensity()), null != t.getRange() && (i.range = t.getRange()), t.getName() && (i.name = t.getName()), t.getType() === gA.Type.SPOT && (i.spot = {
          innerConeAngle: t.getInnerConeAngle(),
          outerConeAngle: t.getOuterConeAngle()
        }), r.push(i), n.set(t, r.length - 1);
      }
      return this.document.getRoot().listNodes().forEach(r => {
        const i = r.getExtension(vA);
        if (i) {
          const s = e.nodeIndexMap.get(r),
            o = t.json.nodes[s];
          o.extensions = o.extensions || {}, o.extensions.KHR_lights_punctual = {
            light: n.get(i)
          };
        }
      }), t.json.extensions = t.json.extensions || {}, t.json.extensions.KHR_lights_punctual = {
        lights: r
      }, this;
    }
  }
  AA.EXTENSION_NAME = vA;
  const {
    R: bA,
    G: yA,
    B: xA
  } = _g;
  class wA extends ev {
    init() {
      this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        clearcoatFactor: 0,
        clearcoatTexture: null,
        clearcoatTextureInfo: new tv(this.graph, "clearcoatTextureInfo"),
        clearcoatRoughnessFactor: 0,
        clearcoatRoughnessTexture: null,
        clearcoatRoughnessTextureInfo: new tv(this.graph, "clearcoatRoughnessTextureInfo"),
        clearcoatNormalScale: 1,
        clearcoatNormalTexture: null,
        clearcoatNormalTextureInfo: new tv(this.graph, "clearcoatNormalTextureInfo")
      });
    }
    getClearcoatFactor() {
      return this.get("clearcoatFactor");
    }
    setClearcoatFactor(e) {
      return this.set("clearcoatFactor", e);
    }
    getClearcoatTexture() {
      return this.getRef("clearcoatTexture");
    }
    getClearcoatTextureInfo() {
      return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
    }
    setClearcoatTexture(e) {
      return this.setRef("clearcoatTexture", e, {
        channels: bA
      });
    }
    getClearcoatRoughnessFactor() {
      return this.get("clearcoatRoughnessFactor");
    }
    setClearcoatRoughnessFactor(e) {
      return this.set("clearcoatRoughnessFactor", e);
    }
    getClearcoatRoughnessTexture() {
      return this.getRef("clearcoatRoughnessTexture");
    }
    getClearcoatRoughnessTextureInfo() {
      return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
    }
    setClearcoatRoughnessTexture(e) {
      return this.setRef("clearcoatRoughnessTexture", e, {
        channels: yA
      });
    }
    getClearcoatNormalScale() {
      return this.get("clearcoatNormalScale");
    }
    setClearcoatNormalScale(e) {
      return this.set("clearcoatNormalScale", e);
    }
    getClearcoatNormalTexture() {
      return this.getRef("clearcoatNormalTexture");
    }
    getClearcoatNormalTextureInfo() {
      return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
    }
    setClearcoatNormalTexture(e) {
      return this.setRef("clearcoatNormalTexture", e, {
        channels: bA | yA | xA
      });
    }
  }
  wA.EXTENSION_NAME = "KHR_materials_clearcoat";
  const EA = "KHR_materials_clearcoat";
  class SA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = EA;
    }
    createClearcoat() {
      return new wA(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[EA]) {
          const i = this.createClearcoat();
          e.materials[n].setExtension(EA, i);
          const s = t.extensions[EA];
          if (void 0 !== s.clearcoatFactor && i.setClearcoatFactor(s.clearcoatFactor), void 0 !== s.clearcoatRoughnessFactor && i.setClearcoatRoughnessFactor(s.clearcoatRoughnessFactor), void 0 !== s.clearcoatTexture) {
            const t = s.clearcoatTexture;
            i.setClearcoatTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getClearcoatTextureInfo(), t);
          }
          if (void 0 !== s.clearcoatRoughnessTexture) {
            const t = s.clearcoatRoughnessTexture;
            i.setClearcoatRoughnessTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getClearcoatRoughnessTextureInfo(), t);
          }
          if (void 0 !== s.clearcoatNormalTexture) {
            const t = s.clearcoatNormalTexture;
            i.setClearcoatNormalTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getClearcoatNormalTextureInfo(), t), void 0 !== t.scale && i.setClearcoatNormalScale(t.scale);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(EA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[EA] = {
            clearcoatFactor: n.getClearcoatFactor(),
            clearcoatRoughnessFactor: n.getClearcoatRoughnessFactor()
          };
          if (n.getClearcoatTexture()) {
            const t = n.getClearcoatTexture(),
              r = n.getClearcoatTextureInfo();
            o.clearcoatTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getClearcoatRoughnessTexture()) {
            const t = n.getClearcoatRoughnessTexture(),
              r = n.getClearcoatRoughnessTextureInfo();
            o.clearcoatRoughnessTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getClearcoatNormalTexture()) {
            const t = n.getClearcoatNormalTexture(),
              r = n.getClearcoatNormalTextureInfo();
            o.clearcoatNormalTexture = e.createTextureInfoDef(t, r), 1 !== n.getClearcoatNormalScale() && (o.clearcoatNormalTexture.scale = n.getClearcoatNormalScale());
          }
        }
      }), this;
    }
  }
  SA.EXTENSION_NAME = EA;
  class CA extends ev {
    init() {
      this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        emissiveStrength: 1
      });
    }
    getEmissiveStrength() {
      return this.get("emissiveStrength");
    }
    setEmissiveStrength(e) {
      return this.set("emissiveStrength", e);
    }
  }
  CA.EXTENSION_NAME = "KHR_materials_emissive_strength";
  const MA = "KHR_materials_emissive_strength";
  class TA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = MA;
    }
    createEmissiveStrength() {
      return new CA(this.document.getGraph());
    }
    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[MA]) {
          const n = this.createEmissiveStrength();
          e.materials[r].setExtension(MA, n);
          const i = t.extensions[MA];
          void 0 !== i.emissiveStrength && n.setEmissiveStrength(i.emissiveStrength);
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(MA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions[MA] = {
            emissiveStrength: n.getEmissiveStrength()
          };
        }
      }), this;
    }
  }
  TA.EXTENSION_NAME = MA;
  class IA extends ev {
    init() {
      this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        ior: 0
      });
    }
    getIOR() {
      return this.get("ior");
    }
    setIOR(e) {
      return this.set("ior", e);
    }
  }
  IA.EXTENSION_NAME = "KHR_materials_ior";
  const kA = "KHR_materials_ior";
  class DA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = kA;
    }
    createIOR() {
      return new IA(this.document.getGraph());
    }
    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions.KHR_materials_ior) {
          const n = this.createIOR();
          e.materials[r].setExtension(kA, n);
          const i = t.extensions.KHR_materials_ior;
          void 0 !== i.ior && n.setIOR(i.ior);
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(kA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions.KHR_materials_ior = {
            ior: n.getIOR()
          };
        }
      }), this;
    }
  }
  DA.EXTENSION_NAME = kA;
  const {
    R: PA,
    G: BA
  } = _g;
  class RA extends ev {
    init() {
      this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        iridescenceFactor: 0,
        iridescenceTexture: null,
        iridescenceTextureInfo: new tv(this.graph, "iridescenceTextureInfo"),
        iridescenceIOR: 1.3,
        iridescenceThicknessMinimum: 100,
        iridescenceThicknessMaximum: 400,
        iridescenceThicknessTexture: null,
        iridescenceThicknessTextureInfo: new tv(this.graph, "iridescenceThicknessTextureInfo")
      });
    }
    getIridescenceFactor() {
      return this.get("iridescenceFactor");
    }
    setIridescenceFactor(e) {
      return this.set("iridescenceFactor", e);
    }
    getIridescenceTexture() {
      return this.getRef("iridescenceTexture");
    }
    getIridescenceTextureInfo() {
      return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
    }
    setIridescenceTexture(e) {
      return this.setRef("iridescenceTexture", e, {
        channels: PA
      });
    }
    getIridescenceIOR() {
      return this.get("iridescenceIOR");
    }
    setIridescenceIOR(e) {
      return this.set("iridescenceIOR", e);
    }
    getIridescenceThicknessMinimum() {
      return this.get("iridescenceThicknessMinimum");
    }
    setIridescenceThicknessMinimum(e) {
      return this.set("iridescenceThicknessMinimum", e);
    }
    getIridescenceThicknessMaximum() {
      return this.get("iridescenceThicknessMaximum");
    }
    setIridescenceThicknessMaximum(e) {
      return this.set("iridescenceThicknessMaximum", e);
    }
    getIridescenceThicknessTexture() {
      return this.getRef("iridescenceThicknessTexture");
    }
    getIridescenceThicknessTextureInfo() {
      return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
    }
    setIridescenceThicknessTexture(e) {
      return this.setRef("iridescenceThicknessTexture", e, {
        channels: BA
      });
    }
  }
  RA.EXTENSION_NAME = "KHR_materials_iridescence";
  const LA = "KHR_materials_iridescence";
  class OA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = LA;
    }
    createIridescence() {
      return new RA(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[LA]) {
          const i = this.createIridescence();
          e.materials[n].setExtension(LA, i);
          const s = t.extensions[LA];
          if (void 0 !== s.iridescenceFactor && i.setIridescenceFactor(s.iridescenceFactor), void 0 !== s.iridescenceIor && i.setIridescenceIOR(s.iridescenceIor), void 0 !== s.iridescenceThicknessMinimum && i.setIridescenceThicknessMinimum(s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && i.setIridescenceThicknessMaximum(s.iridescenceThicknessMaximum), void 0 !== s.iridescenceTexture) {
            const t = s.iridescenceTexture;
            i.setIridescenceTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getIridescenceTextureInfo(), t);
          }
          if (void 0 !== s.iridescenceThicknessTexture) {
            const t = s.iridescenceThicknessTexture;
            i.setIridescenceThicknessTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getIridescenceThicknessTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(LA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[LA] = {};
          if (n.getIridescenceFactor() > 0 && (o.iridescenceFactor = n.getIridescenceFactor()), 1.3 !== n.getIridescenceIOR() && (o.iridescenceIor = n.getIridescenceIOR()), 100 !== n.getIridescenceThicknessMinimum() && (o.iridescenceThicknessMinimum = n.getIridescenceThicknessMinimum()), 400 !== n.getIridescenceThicknessMaximum() && (o.iridescenceThicknessMaximum = n.getIridescenceThicknessMaximum()), n.getIridescenceTexture()) {
            const t = n.getIridescenceTexture(),
              r = n.getIridescenceTextureInfo();
            o.iridescenceTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getIridescenceThicknessTexture()) {
            const t = n.getIridescenceThicknessTexture(),
              r = n.getIridescenceThicknessTextureInfo();
            o.iridescenceThicknessTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  OA.EXTENSION_NAME = LA;
  const {
    R: FA,
    G: UA,
    B: NA,
    A: jA
  } = _g;
  class zA extends ev {
    init() {
      this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        diffuseFactor: [1, 1, 1, 1],
        diffuseTexture: null,
        diffuseTextureInfo: new tv(this.graph, "diffuseTextureInfo"),
        specularFactor: [1, 1, 1],
        glossinessFactor: 1,
        specularGlossinessTexture: null,
        specularGlossinessTextureInfo: new tv(this.graph, "specularGlossinessTextureInfo")
      });
    }
    getDiffuseFactor() {
      return this.get("diffuseFactor");
    }
    setDiffuseFactor(e) {
      return this.set("diffuseFactor", e);
    }
    getDiffuseHex() {
      return Sg.factorToHex(this.getDiffuseFactor());
    }
    setDiffuseHex(e) {
      const t = this.getDiffuseFactor().slice();
      return this.setDiffuseFactor(Sg.hexToFactor(e, t));
    }
    getDiffuseTexture() {
      return this.getRef("diffuseTexture");
    }
    getDiffuseTextureInfo() {
      return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
    }
    setDiffuseTexture(e) {
      return this.setRef("diffuseTexture", e, {
        channels: FA | UA | NA | jA
      });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }
    getGlossinessFactor() {
      return this.get("glossinessFactor");
    }
    setGlossinessFactor(e) {
      return this.set("glossinessFactor", e);
    }
    getSpecularGlossinessTexture() {
      return this.getRef("specularGlossinessTexture");
    }
    getSpecularGlossinessTextureInfo() {
      return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
    }
    setSpecularGlossinessTexture(e) {
      return this.setRef("specularGlossinessTexture", e, {
        channels: FA | UA | NA | jA
      });
    }
  }
  zA.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
  const GA = "KHR_materials_pbrSpecularGlossiness";
  class VA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = GA;
    }
    createPBRSpecularGlossiness() {
      return new zA(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[GA]) {
          const i = this.createPBRSpecularGlossiness();
          e.materials[n].setExtension(GA, i);
          const s = t.extensions[GA];
          if (void 0 !== s.diffuseFactor && i.setDiffuseFactor(s.diffuseFactor), void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.glossinessFactor && i.setGlossinessFactor(s.glossinessFactor), void 0 !== s.diffuseTexture) {
            const t = s.diffuseTexture;
            i.setDiffuseTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getDiffuseTextureInfo(), t);
          }
          if (void 0 !== s.specularGlossinessTexture) {
            const t = s.specularGlossinessTexture;
            i.setSpecularGlossinessTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getSpecularGlossinessTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(GA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[GA] = {
            diffuseFactor: n.getDiffuseFactor(),
            specularFactor: n.getSpecularFactor(),
            glossinessFactor: n.getGlossinessFactor()
          };
          if (n.getDiffuseTexture()) {
            const t = n.getDiffuseTexture(),
              r = n.getDiffuseTextureInfo();
            o.diffuseTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getSpecularGlossinessTexture()) {
            const t = n.getSpecularGlossinessTexture(),
              r = n.getSpecularGlossinessTextureInfo();
            o.specularGlossinessTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  VA.EXTENSION_NAME = GA;
  const {
    R: QA,
    G: HA,
    B: WA,
    A: qA
  } = _g;
  class XA extends ev {
    init() {
      this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        sheenColorFactor: [0, 0, 0],
        sheenColorTexture: null,
        sheenColorTextureInfo: new tv(this.graph, "sheenColorTextureInfo"),
        sheenRoughnessFactor: 0,
        sheenRoughnessTexture: null,
        sheenRoughnessTextureInfo: new tv(this.graph, "sheenRoughnessTextureInfo")
      });
    }
    getSheenColorFactor() {
      return this.get("sheenColorFactor");
    }
    getSheenColorHex() {
      return Sg.factorToHex(this.getSheenColorFactor());
    }
    setSheenColorFactor(e) {
      return this.set("sheenColorFactor", e);
    }
    setSheenColorHex(e) {
      const t = this.getSheenColorFactor().slice();
      return this.set("sheenColorFactor", Sg.hexToFactor(e, t));
    }
    getSheenColorTexture() {
      return this.getRef("sheenColorTexture");
    }
    getSheenColorTextureInfo() {
      return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
    }
    setSheenColorTexture(e) {
      return this.setRef("sheenColorTexture", e, {
        channels: QA | HA | WA
      });
    }
    getSheenRoughnessFactor() {
      return this.get("sheenRoughnessFactor");
    }
    setSheenRoughnessFactor(e) {
      return this.set("sheenRoughnessFactor", e);
    }
    getSheenRoughnessTexture() {
      return this.getRef("sheenRoughnessTexture");
    }
    getSheenRoughnessTextureInfo() {
      return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
    }
    setSheenRoughnessTexture(e) {
      return this.setRef("sheenRoughnessTexture", e, {
        channels: qA
      });
    }
  }
  XA.EXTENSION_NAME = "KHR_materials_sheen";
  const YA = "KHR_materials_sheen";
  class KA extends gv {
    constructor(...e) {
      super(...e), this.extensionName = YA;
    }
    createSheen() {
      return new XA(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions.KHR_materials_sheen) {
          const i = this.createSheen();
          e.materials[n].setExtension(YA, i);
          const s = t.extensions.KHR_materials_sheen;
          if (void 0 !== s.sheenColorFactor && i.setSheenColorFactor(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && i.setSheenRoughnessFactor(s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture) {
            const t = s.sheenColorTexture;
            i.setSheenColorTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getSheenColorTextureInfo(), t);
          }
          if (void 0 !== s.sheenRoughnessTexture) {
            const t = s.sheenRoughnessTexture;
            i.setSheenRoughnessTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getSheenRoughnessTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(YA);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_sheen = {
            sheenColorFactor: n.getSheenColorFactor(),
            sheenRoughnessFactor: n.getSheenRoughnessFactor()
          };
          if (n.getSheenColorTexture()) {
            const t = n.getSheenColorTexture(),
              r = n.getSheenColorTextureInfo();
            o.sheenColorTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getSheenRoughnessTexture()) {
            const t = n.getSheenRoughnessTexture(),
              r = n.getSheenRoughnessTextureInfo();
            o.sheenRoughnessTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  KA.EXTENSION_NAME = YA;
  const {
    R: JA,
    G: ZA,
    B: $A,
    A: eb
  } = _g;
  class tb extends ev {
    init() {
      this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        specularFactor: 1,
        specularTexture: null,
        specularTextureInfo: new tv(this.graph, "specularTextureInfo"),
        specularColorFactor: [1, 1, 1],
        specularColorTexture: null,
        specularColorTextureInfo: new tv(this.graph, "specularColorTextureInfo")
      });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }
    getSpecularColorFactor() {
      return this.get("specularColorFactor");
    }
    setSpecularColorFactor(e) {
      return this.set("specularColorFactor", e);
    }
    getSpecularColorHex() {
      return Sg.factorToHex(this.getSpecularColorFactor());
    }
    setSpecularColorHex(e) {
      const t = this.getSpecularColorFactor().slice();
      return this.set("specularColorFactor", Sg.hexToFactor(e, t));
    }
    getSpecularTexture() {
      return this.getRef("specularTexture");
    }
    getSpecularTextureInfo() {
      return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
    }
    setSpecularTexture(e) {
      return this.setRef("specularTexture", e, {
        channels: eb
      });
    }
    getSpecularColorTexture() {
      return this.getRef("specularColorTexture");
    }
    getSpecularColorTextureInfo() {
      return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
    }
    setSpecularColorTexture(e) {
      return this.setRef("specularColorTexture", e, {
        channels: JA | ZA | $A
      });
    }
  }
  tb.EXTENSION_NAME = "KHR_materials_specular";
  const rb = "KHR_materials_specular";
  class nb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = rb;
    }
    createSpecular() {
      return new tb(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[rb]) {
          const i = this.createSpecular();
          e.materials[n].setExtension(rb, i);
          const s = t.extensions[rb];
          if (void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.specularColorFactor && i.setSpecularColorFactor(s.specularColorFactor), void 0 !== s.specularTexture) {
            const t = s.specularTexture;
            i.setSpecularTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getSpecularTextureInfo(), t);
          }
          if (void 0 !== s.specularColorTexture) {
            const t = s.specularColorTexture;
            i.setSpecularColorTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getSpecularColorTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(rb);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[rb] = {};
          if (1 !== n.getSpecularFactor() && (o.specularFactor = n.getSpecularFactor()), Bg.eq(n.getSpecularColorFactor(), [1, 1, 1]) || (o.specularColorFactor = n.getSpecularColorFactor()), n.getSpecularTexture()) {
            const t = n.getSpecularTexture(),
              r = n.getSpecularTextureInfo();
            o.specularTexture = e.createTextureInfoDef(t, r);
          }
          if (n.getSpecularColorTexture()) {
            const t = n.getSpecularColorTexture(),
              r = n.getSpecularColorTextureInfo();
            o.specularColorTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  nb.EXTENSION_NAME = rb;
  const {
    R: ib
  } = _g;
  class sb extends ev {
    init() {
      this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        transmissionFactor: 0,
        transmissionTexture: null,
        transmissionTextureInfo: new tv(this.graph, "transmissionTextureInfo")
      });
    }
    getTransmissionFactor() {
      return this.get("transmissionFactor");
    }
    setTransmissionFactor(e) {
      return this.set("transmissionFactor", e);
    }
    getTransmissionTexture() {
      return this.getRef("transmissionTexture");
    }
    getTransmissionTextureInfo() {
      return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
    }
    setTransmissionTexture(e) {
      return this.setRef("transmissionTexture", e, {
        channels: ib
      });
    }
  }
  sb.EXTENSION_NAME = "KHR_materials_transmission";
  const ob = "KHR_materials_transmission";
  class ab extends gv {
    constructor(...e) {
      super(...e), this.extensionName = ob;
    }
    createTransmission() {
      return new sb(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[ob]) {
          const i = this.createTransmission();
          e.materials[n].setExtension(ob, i);
          const s = t.extensions[ob];
          if (void 0 !== s.transmissionFactor && i.setTransmissionFactor(s.transmissionFactor), void 0 !== s.transmissionTexture) {
            const t = s.transmissionTexture;
            i.setTransmissionTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getTransmissionTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(ob);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[ob] = {
            transmissionFactor: n.getTransmissionFactor()
          };
          if (n.getTransmissionTexture()) {
            const t = n.getTransmissionTexture(),
              r = n.getTransmissionTextureInfo();
            o.transmissionTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  ab.EXTENSION_NAME = ob;
  class lb extends ev {
    init() {
      this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [dg.MATERIAL];
    }
  }
  lb.EXTENSION_NAME = "KHR_materials_unlit";
  const cb = "KHR_materials_unlit";
  class ub extends gv {
    constructor(...e) {
      super(...e), this.extensionName = cb;
    }
    createUnlit() {
      return new lb(this.document.getGraph());
    }
    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, r) => {
        t.extensions && t.extensions.KHR_materials_unlit && e.materials[r].setExtension(cb, this.createUnlit());
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        if (r.getExtension(cb)) {
          const n = e.materialIndexMap.get(r),
            i = t.json.materials[n];
          i.extensions = i.extensions || {}, i.extensions.KHR_materials_unlit = {};
        }
      }), this;
    }
  }
  ub.EXTENSION_NAME = cb;
  class hb extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        material: null,
        variants: []
      });
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e) {
      return this.setRef("material", e);
    }
    addVariant(e) {
      return this.addRef("variants", e);
    }
    removeVariant(e) {
      return this.removeRef("variants", e);
    }
    listVariants() {
      return this.listRefs("variants");
    }
  }
  hb.EXTENSION_NAME = "KHR_materials_variants";
  class pb extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [dg.PRIMITIVE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mappings: []
      });
    }
    addMapping(e) {
      return this.addRef("mappings", e);
    }
    removeMapping(e) {
      return this.removeRef("mappings", e);
    }
    listMappings() {
      return this.listRefs("mappings");
    }
  }
  pb.EXTENSION_NAME = "KHR_materials_variants";
  class db extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"];
    }
  }
  db.EXTENSION_NAME = "KHR_materials_variants";
  const fb = "KHR_materials_variants";
  class mb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = fb;
    }
    createMappingList() {
      return new pb(this.document.getGraph());
    }
    createVariant(e = "") {
      return new db(this.document.getGraph(), e);
    }
    createMapping() {
      return new hb(this.document.getGraph());
    }
    listVariants() {
      return Array.from(this.properties).filter(e => e instanceof db);
    }
    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions[fb]) return this;
      const r = (t.json.extensions[fb].variants || []).map(e => this.createVariant().setName(e.name || ""));
      return (t.json.meshes || []).forEach((t, n) => {
        const i = e.meshes[n];
        (t.primitives || []).forEach((t, n) => {
          if (!t.extensions || !t.extensions[fb]) return;
          const s = this.createMappingList(),
            o = t.extensions[fb];
          for (const t of o.mappings) {
            const n = this.createMapping();
            void 0 !== t.material && n.setMaterial(e.materials[t.material]);
            for (const e of t.variants || []) n.addVariant(r[e]);
            s.addMapping(n);
          }
          i.listPrimitives()[n].setExtension(fb, s);
        });
      }), this;
    }
    write(e) {
      const t = e.jsonDoc,
        r = this.listVariants();
      if (!r.length) return this;
      const n = [],
        i = new Map();
      for (const t of r) i.set(t, n.length), n.push(e.createPropertyDef(t));
      for (const t of this.document.getRoot().listMeshes()) {
        const r = e.meshIndexMap.get(t);
        t.listPrimitives().forEach((t, n) => {
          const s = t.getExtension(fb);
          if (!s) return;
          const o = e.jsonDoc.json.meshes[r].primitives[n],
            a = s.listMappings().map(t => {
              const r = e.createPropertyDef(t),
                n = t.getMaterial();
              return n && (r.material = e.materialIndexMap.get(n)), r.variants = t.listVariants().map(e => i.get(e)), r;
            });
          o.extensions = o.extensions || {}, o.extensions[fb] = {
            mappings: a
          };
        });
      }
      return t.json.extensions = t.json.extensions || {}, t.json.extensions[fb] = {
        variants: n
      }, this;
    }
  }
  mb.EXTENSION_NAME = fb;
  const {
    G: _b
  } = _g;
  class gb extends ev {
    init() {
      this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        thicknessFactor: 0,
        thicknessTexture: null,
        thicknessTextureInfo: new tv(this.graph, "thicknessTexture"),
        attenuationDistance: 1 / 0,
        attenuationColor: [1, 1, 1]
      });
    }
    getThicknessFactor() {
      return this.get("thicknessFactor");
    }
    setThicknessFactor(e) {
      return this.set("thicknessFactor", e);
    }
    getThicknessTexture() {
      return this.getRef("thicknessTexture");
    }
    getThicknessTextureInfo() {
      return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
    }
    setThicknessTexture(e) {
      return this.setRef("thicknessTexture", e, {
        channels: _b
      });
    }
    getAttenuationDistance() {
      return this.get("attenuationDistance");
    }
    setAttenuationDistance(e) {
      return this.set("attenuationDistance", e);
    }
    getAttenuationColor() {
      return this.get("attenuationColor");
    }
    setAttenuationColor(e) {
      return this.set("attenuationColor", e);
    }
    getAttenuationColorHex() {
      return Sg.factorToHex(this.getAttenuationColor());
    }
    setAttenuationColorHex(e) {
      const t = this.getAttenuationColor().slice();
      return this.set("attenuationColor", Sg.hexToFactor(e, t));
    }
  }
  gb.EXTENSION_NAME = "KHR_materials_volume";
  const vb = "KHR_materials_volume";
  class Ab extends gv {
    constructor(...e) {
      super(...e), this.extensionName = vb;
    }
    createVolume() {
      return new gb(this.document.getGraph());
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.textures || [];
      return (t.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions.KHR_materials_volume) {
          const i = this.createVolume();
          e.materials[n].setExtension(vb, i);
          const s = t.extensions.KHR_materials_volume;
          if (void 0 !== s.thicknessFactor && i.setThicknessFactor(s.thicknessFactor), void 0 !== s.attenuationDistance && i.setAttenuationDistance(s.attenuationDistance), void 0 !== s.attenuationColor && i.setAttenuationColor(s.attenuationColor), void 0 !== s.thicknessTexture) {
            const t = s.thicknessTexture;
            i.setThicknessTexture(e.textures[r[t.index].source]), e.setTextureInfo(i.getThicknessTextureInfo(), t);
          }
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(vb);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_volume = {};
          if (n.getThicknessFactor() > 0 && (o.thicknessFactor = n.getThicknessFactor()), Number.isFinite(n.getAttenuationDistance()) && (o.attenuationDistance = n.getAttenuationDistance()), Bg.eq(n.getAttenuationColor(), [1, 1, 1]) || (o.attenuationColor = n.getAttenuationColor()), n.getThicknessTexture()) {
            const t = n.getThicknessTexture(),
              r = n.getThicknessTextureInfo();
            o.thicknessTexture = e.createTextureInfoDef(t, r);
          }
        }
      }), this;
    }
  }
  Ab.EXTENSION_NAME = vb;
  const bb = "KHR_mesh_quantization";
  class yb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = bb;
    }
    read(e) {
      return this;
    }
    write(e) {
      return this;
    }
  }
  yb.EXTENSION_NAME = bb;
  const xb = "KHR_texture_basisu";
  class wb {
    match(e) {
      return 171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 50 === e[5] && 48 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11];
    }
    getSize(e) {
      const t = Pv(e);
      return [t.pixelWidth, t.pixelHeight];
    }
    getChannels(e) {
      const t = Pv(e).dataFormatDescriptor[0];
      if (163 === t.colorModel) return 2 === t.samples.length && 15 == (15 & t.samples[1].channelType) ? 4 : 3;
      if (166 === t.colorModel) return 3 == (15 & t.samples[0].channelType) ? 4 : 3;
      throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`);
    }
    getGPUByteLength(e) {
      const t = Pv(e),
        r = this.getChannels(e) > 3;
      let n = 0;
      for (let e = 0; e < t.levels.length; e++) {
        const i = t.levels[e];
        n += i.uncompressedByteLength ? i.uncompressedByteLength : Math.max(1, Math.floor(t.pixelWidth / Math.pow(2, e))) / 4 * (Math.max(1, Math.floor(t.pixelHeight / Math.pow(2, e))) / 4) * (r ? 16 : 8);
      }
      return n;
    }
  }
  class Eb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = xb, this.prereadTypes = [dg.TEXTURE];
    }
    static register() {
      Mg.registerFormat("image/ktx2", new wb());
    }
    preread(e) {
      return e.jsonDoc.json.textures.forEach(e => {
        e.extensions && e.extensions.KHR_texture_basisu && (e.source = e.extensions.KHR_texture_basisu.source);
      }), this;
    }
    read(e) {
      return this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(r => {
        if ("image/ktx2" === r.getMimeType()) {
          const n = e.imageIndexMap.get(r);
          t.json.textures.forEach(e => {
            e.source === n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_basisu = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }
  }
  Eb.EXTENSION_NAME = xb;
  class Sb extends ev {
    init() {
      this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [dg.TEXTURE_INFO];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        offset: [0, 0],
        rotation: 0,
        scale: [1, 1],
        texCoord: null
      });
    }
    getOffset() {
      return this.get("offset");
    }
    setOffset(e) {
      return this.set("offset", e);
    }
    getRotation() {
      return this.get("rotation");
    }
    setRotation(e) {
      return this.set("rotation", e);
    }
    getScale() {
      return this.get("scale");
    }
    setScale(e) {
      return this.set("scale", e);
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e) {
      return this.set("texCoord", e);
    }
  }
  Sb.EXTENSION_NAME = "KHR_texture_transform";
  const Cb = "KHR_texture_transform";
  class Mb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = Cb;
    }
    createTransform() {
      return new Sb(this.document.getGraph());
    }
    read(e) {
      for (const [t, r] of Array.from(e.textureInfos.entries())) {
        if (!r.extensions || !r.extensions.KHR_texture_transform) continue;
        const e = this.createTransform(),
          n = r.extensions.KHR_texture_transform;
        void 0 !== n.offset && e.setOffset(n.offset), void 0 !== n.rotation && e.setRotation(n.rotation), void 0 !== n.scale && e.setScale(n.scale), void 0 !== n.texCoord && e.setTexCoord(n.texCoord), t.setExtension(Cb, e);
      }
      return this;
    }
    write(e) {
      const t = Array.from(e.textureInfoDefMap.entries());
      for (const [e, r] of t) {
        const t = e.getExtension(Cb);
        if (!t) continue;
        r.extensions = r.extensions || {};
        const n = {},
          i = Bg.eq;
        i(t.getOffset(), [0, 0]) || (n.offset = t.getOffset()), 0 !== t.getRotation() && (n.rotation = t.getRotation()), i(t.getScale(), [1, 1]) || (n.scale = t.getScale()), null != t.getTexCoord() && (n.texCoord = t.getTexCoord()), r.extensions.KHR_texture_transform = n;
      }
      return this;
    }
  }
  Mb.EXTENSION_NAME = Cb;
  const Tb = [dg.ROOT, dg.SCENE, dg.NODE, dg.MESH, dg.MATERIAL, dg.TEXTURE, dg.ANIMATION];
  class Ib extends ev {
    init() {
      this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = Tb;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        context: {},
        properties: {}
      });
    }
    getContext() {
      return this.get("context");
    }
    setContext(e) {
      return this.set("context", Lv({}, e));
    }
    listProperties() {
      return Object.keys(this.get("properties"));
    }
    getProperty(e) {
      const t = this.get("properties");
      return e in t ? t[e] : null;
    }
    setProperty(e, t) {
      this._assertContext(e);
      const r = Lv({}, this.get("properties"));
      return t ? r[e] = t : delete r[e], this.set("properties", r);
    }
    toJSONLD() {
      return Lv({
        "@context": kb(this.get("context"))
      }, kb(this.get("properties")));
    }
    fromJSONLD(e) {
      const t = (e = kb(e))["@context"];
      return t && this.set("context", t), delete e["@context"], this.set("properties", e);
    }
    _assertContext(e) {
      if (!(e.split(":")[0] in this.get("context"))) throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`);
    }
  }
  function kb(e) {
    return JSON.parse(JSON.stringify(e));
  }
  Ib.EXTENSION_NAME = "KHR_xmp_json_ld";
  const Db = "KHR_xmp_json_ld";
  class Pb extends gv {
    constructor(...e) {
      super(...e), this.extensionName = Db;
    }
    createPacket() {
      return new Ib(this.document.getGraph());
    }
    listPackets() {
      return Array.from(this.properties);
    }
    read(e) {
      var t;
      const r = null == (t = e.jsonDoc.json.extensions) ? void 0 : t.KHR_xmp_json_ld;
      if (!r || !r.packets) return this;
      const n = e.jsonDoc.json,
        i = this.document.getRoot(),
        s = r.packets.map(e => this.createPacket().fromJSONLD(e)),
        o = [[n.asset], n.scenes, n.nodes, n.meshes, n.materials, n.images, n.animations],
        a = [[i], i.listScenes(), i.listNodes(), i.listMeshes(), i.listMaterials(), i.listTextures(), i.listAnimations()];
      for (let e = 0; e < o.length; e++) {
        const t = o[e] || [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          n.extensions && n.extensions.KHR_xmp_json_ld && a[e][r].setExtension(Db, s[n.extensions.KHR_xmp_json_ld.packet]);
        }
      }
      return this;
    }
    write(e) {
      const {
          json: t
        } = e.jsonDoc,
        r = [];
      for (const n of this.properties) {
        r.push(n.toJSONLD());
        for (const i of n.listParents()) {
          let n;
          switch (i.propertyType) {
            case dg.ROOT:
              n = t.asset;
              break;
            case dg.SCENE:
              n = t.scenes[e.sceneIndexMap.get(i)];
              break;
            case dg.NODE:
              n = t.nodes[e.nodeIndexMap.get(i)];
              break;
            case dg.MESH:
              n = t.meshes[e.meshIndexMap.get(i)];
              break;
            case dg.MATERIAL:
              n = t.materials[e.materialIndexMap.get(i)];
              break;
            case dg.TEXTURE:
              n = t.images[e.imageIndexMap.get(i)];
              break;
            case dg.ANIMATION:
              n = t.animations[e.animationIndexMap.get(i)];
              break;
            default:
              n = null, this.document.getLogger().warn(`[KHR_xmp_json_ld]: Unsupported parent property, "${i.propertyType}"`);
          }
          n && (n.extensions = n.extensions || {}, n.extensions.KHR_xmp_json_ld = {
            packet: r.length - 1
          });
        }
      }
      return r.length > 0 && (t.extensions = t.extensions || {}, t.extensions.KHR_xmp_json_ld = {
        packets: r
      }), this;
    }
  }
  Pb.EXTENSION_NAME = Db;
  const Bb = [mA, AA, SA, TA, DA, OA, VA, nb, KA, ab, ub, mb, Ab, yb, Eb, Mb, Pb];
  let Rb = class extends Gt {
    constructor(e, t, r) {
      super(e, t, null != r ? r : new Lb(), new Ae(0, 0, 0), 1), this.enabled = !0, this._firstCall = !0;
    }
    render(e, t, r, n, i) {
      this.enabled && super.render(e, t, r, n, i);
    }
  };
  Rb = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  }([lt("High precision Normal Buffer")], Rb);
  class Lb extends n.RSm {
    constructor() {
      super();
    }
    onBeforeRender(e, t, r, i, s) {
      var o, a;
      let l = s.material;
      Array.isArray(l) && (l = l[0]), this.normalMap = null !== (o = null == l ? void 0 : l.normalMap) && void 0 !== o ? o : null, this.needsUpdate = !0, this.side = null !== (a = l.side) && void 0 !== a ? a : n.ehD;
    }
  }
  class Ob extends io {
    constructor(e = !0) {
      super(), this.passId = "normalBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this.enabled = e;
    }
    passCtor(e) {
      this._normalTarget = e.renderer.createTarget({
        depthBuffer: !0,
        type: n.cLu,
        minFilter: n.TyD,
        magFilter: n.TyD,
        generateMipmaps: !1
      }), this._normalTarget.texture.name = "normalBuffer", this._normalTarget.texture.generateMipmaps = !1;
      const t = this._normalTarget,
        r = new Set(),
        i = new Set();
      return new class extends Rb {
        render(e, n, s, o, a) {
          const l = e.getRenderTarget(),
            c = e.getActiveCubeFace(),
            u = e.getActiveMipmapLevel();
          this.scene && (this.scene.traverse(({
            material: e
          }) => {
            e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (r.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (i.add([e, e.transmission]), e.transmission = 0));
          }), W(e, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1,
            mainRenderPass: !1
          }, () => super.render(e, n, t, o, a)), r.forEach(e => e.transparent = !e.transparent), r.clear(), i.forEach(([e, t]) => e.transmission = t), i.clear(), e.setRenderTarget(l, c, u));
        }
      }();
    }
    _update(e) {
      if (!super._update(e)) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, t.camera = e.scene.activeCamera.cameraObject, !0;
    }
    getNormalBuffer() {
      return this._normalTarget;
    }
    async onDispose(e) {}
    async onRemove(e) {
      var t, r;
      return e.renderer.disposeTarget(null === (r = null === (t = this._normalTarget) || void 0 === t ? void 0 : t.dispose) || void 0 === r ? void 0 : r.call(t)), super.onRemove(e);
    }
    updateShaderProperties(e) {
      var t, r;
      return e.uniforms.tNormalBuffer ? e.uniforms.tNormalBuffer.value = this.enabled && null !== (r = null === (t = this.getNormalBuffer()) || void 0 === t ? void 0 : t.texture) && void 0 !== r ? r : null : console.warn("BaseRenderer: no uniform: tNormalBuffer"), this;
    }
    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }
  }
  Ob.PluginType = "NormalBufferPlugin";
  function Fb(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._ssBevel || (t._ssBevel = {});
    const r = t._ssBevel;
    return r.hasSSBevel = !0, void 0 === r.radius && (r.radius = 0), e.isMaterial && (e.needsUpdate = !0), !0;
  }
  let Ub = class extends zt {
    constructor(e, t, r, i) {
      super({
        defines: {
          NUM_SAMPLES: 16
        },
        uniforms: {
          tNormalDepth: {
            value: null
          },
          tNormalBuffer: {
            value: null
          },
          tGBufferFlags: {
            value: null
          },
          edgeMaskBuffer: {
            value: null
          },
          screenSize: {
            value: new n.FM8()
          },
          radius: {
            value: 1
          },
          samples: {
            value: null
          },
          frameCount: {
            value: 0
          },
          cameraPositionWorld: {
            value: new n.Pa4(1, 1, 1)
          }
        },
        vertexShader: Io,
        fragmentShader: `\n\n            ${r}\n\n            ${Po}\n\n            uniform sampler2D tNormalBuffer;uniform sampler2D edgeMaskBuffer;uniform vec2 screenSize;const float depthStep=0.02;uniform vec2 samples[NUM_SAMPLES];uniform vec3 cameraPositionWorld;varying vec2 vUv;\n#include <common>\nvec3 smoothNormal(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 texel=texture2D(tNormalDepth,uv);vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 avgNormal=2.*texture2D(tNormalBuffer,uv).rgb-1.;float depth=pow(unpack16(texel.xy),2.);vec2 invScreenSize=vec2(1.)/screenSize;vec4 mask=texture2D(tGBufferFlags,uv);float weightSum=0.;float radius=mask.g*255.*2.;float randomAngle=6.2*random(frameCount*0.1);float theta=randomAngle;float snTheta=sin(theta);float csTheta=cos(theta);mat2 randomRotationMatrix=mat2(csTheta,snTheta,-snTheta,csTheta);float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(1./(1.+pow(d_,0.5)),0.,1.);for(int i=0;i<5;i++){float x=float(i)-2.;for(int j=0;j<5;j++){float y=float(j)-2.;vec2 offset=randomRotationMatrix*vec2(x,y)*radius*radiusModifier*invScreenSize;vec4 texel=texture2D(tNormalDepth,uv+offset);float offsetDepth=pow(unpack16(texel.xy),2.);float depthWeight=abs(offsetDepth-depth);depthWeight=(1.-step(depthStep,depthWeight));vec3 offsetNormal=2.*texture2D(tNormalBuffer,uv+offset).rgb-1.;if(dot(offsetNormal,offsetNormal)>0.){avgNormal+=offsetNormal*depthWeight;}}}return normalize(avgNormal);}void main(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 normal=vec3(0.);if(edgeMask.x>0.){normal=smoothNormal();}else{normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}gl_FragColor=vec4(vec3(0.5*normal+0.5),1.);}\n            \n            `
      }, "tDiffuse"), this.uiConfig = void 0, this.materialExtension = {
        shaderExtender: (e, t, r) => {
          var n, i;
          this.enabled && (null === (i = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._ssBevel) || void 0 === i ? void 0 : i.hasSSBevel) && (e.fragmentShader = qt(e.fragmentShader, "#include <normal_fragment_maps>", " \n                normal = 2. * texture2D(tSSBevelMap, viewToScreen(vViewPosition.xyz).xy).rgb - 1.;\n                normal = normalize(normal);\n                //geometryNormal = normal;\n            "));
        },
        onObjectRender: (e, t, r) => {
          var n, i;
          if (!this.enabled || !(null === (i = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._ssBevel) || void 0 === i ? void 0 : i.hasSSBevel)) return;
          const s = t.materialObject,
            o = this._target.texture;
          this.materialExtension.extraUniforms.tSSBevelMap.value !== o && (this.materialExtension.extraUniforms.tSSBevelMap.value = o, s.needsUpdate = !0);
        },
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "SSBevel (Dev)",
            children: [{
              type: "checkbox",
              label: "Enabled",
              get value() {
                var t;
                return (null === (t = e.materialObject.userData._ssBevel) || void 0 === t ? void 0 : t.hasSSBevel) || !1;
              },
              set value(r) {
                var n, i;
                r !== (null === (n = e.materialObject.userData._ssBevel) || void 0 === n ? void 0 : n.hasSSBevel) && (r ? Fb(e.materialObject) || alert("Cannot add screen space bevel.") : (e.materialObject.userData._ssBevel.hasSSBevel = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },
              onChange: this.setDirty
            }, () => ({
              type: "slider",
              bounds: [0, 8],
              label: "radius",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._ssBevel) || void 0 === t ? void 0 : t.hasSSBevel);
              },
              property: [e.materialObject.userData._ssBevel, "radius"],
              onChange: this.setDirty
            })]
          };
          return t;
        },
        parsFragmentSnippet: (e, t) => {
          var r, n;
          return this.enabled && (null === (n = null === (r = null == t ? void 0 : t.materialObject.userData) || void 0 === r ? void 0 : r._ssBevel) || void 0 === n ? void 0 : n.hasSSBevel) ? w`
            uniform sampler2D tSSBevelMap;
            ${Oo}
            ` : "";
        },
        extraUniforms: {
          tSSBevelMap: {
            value: null
          }
        },
        computeCacheKey: e => {
          var t, r;
          return (this.enabled ? "1" : "0") + ((null === (r = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._ssBevel) || void 0 === r ? void 0 : r.hasSSBevel) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this._target = t, this.needsSwap = !1, this.clear = !0, this._viewerApp = i, this._edgeMaterial = new Ut({
        uniforms: {
          tNormalDepth: {
            value: null
          },
          tNormalBuffer: {
            value: null
          },
          tGBufferFlags: {
            value: null
          },
          screenSize: {
            value: null
          },
          radius: {
            value: 10
          },
          cameraNearFar: {
            value: new n.FM8(1, 1)
          },
          cameraPositionWorld: {
            value: new n.Pa4(1, 1, 1)
          }
        },
        vertexShader: Io,
        fragmentShader: "uniform vec2 screenSize;uniform sampler2D tNormalDepth;uniform sampler2D tNormalBuffer;uniform sampler2D tGBufferFlags;uniform float radius;uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;const float depthStep=0.2;const float normalThreshold=0.9;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}void lookupNormalDepth(out float depth,out vec3 normal,vec2 off){vec2 uv=(gl_FragCoord.st+off)/screenSize;vec4 texel=texture2D(tNormalDepth,uv);depth=mix(cameraNearFar.x,cameraNearFar.y,pow(unpack16(texel.xy),2.));normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}float getBorderWeight(){float depth1,depth2,depth3,depth4;vec3 normal1,normal2,normal3,normal4;float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(3./(1.+pow(d_,0.5)),0.,1.);float modRad=radius;lookupNormalDepth(depth1,normal1,vec2(0.,modRad));lookupNormalDepth(depth2,normal2,vec2(0.,-modRad));lookupNormalDepth(depth3,normal3,vec2(modRad,0.));lookupNormalDepth(depth4,normal4,vec2(-modRad,0.));vec2 uv=(gl_FragCoord.st)/screenSize;float mask=step(0.0001,texture2D(tGBufferFlags,uv).g);float mask1=texture2D(tGBufferFlags,uv+vec2(0.,modRad)/screenSize).b*255.;float mask2=texture2D(tGBufferFlags,uv+vec2(0.,-modRad)/screenSize).b*255.;float mask3=texture2D(tGBufferFlags,uv+vec2(modRad,0.)/screenSize).b*255.;float mask4=texture2D(tGBufferFlags,uv+vec2(-modRad,0.)/screenSize).b*255.;float maskWeight=max(abs(mask1-mask2),abs(mask3-mask4))*255.;maskWeight=(step(maskWeight,0.01));float a1=dot(normal1,normal2);float a2=dot(normal3,normal4);float normalWeight=min(abs(a1),abs(a2));normalWeight=1.-step(normalThreshold,normalWeight);float depthWeight=max(abs(depth1-depth2),abs(depth3-depth4));depthWeight=(step(depthWeight,depthStep));return normalWeight*depthWeight*maskWeight*mask;}void main(){float weight=getBorderWeight();vec2 uv=gl_FragCoord.st/screenSize;vec4 texel=texture2D(tNormalDepth,uv);float depth=pow(unpack16(texel.xy),2.);vec3 outColor=vec3(0.);if(depth>0.999){weight=0.;}else{outColor=vec3(weight);}gl_FragColor=vec4(outColor,1.);}"
      }), this._separableBlurMaterial = new Ut({
        defines: {
          KERNEL_RADIUS: 3,
          SIGMA: 3
        },
        uniforms: {
          colorTexture: {
            value: null
          },
          maskTexture: {
            value: null
          },
          texSize: {
            value: new n.FM8(.5, .5)
          },
          direction: {
            value: new n.FM8(.5, .5)
          }
        },
        vertexShader: Io,
        fragmentShader: "varying vec2 vUv;uniform sampler2D colorTexture;uniform sampler2D maskTexture;uniform vec2 texSize;uniform vec2 direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1./texSize;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.,fSigma);vec4 mask=texture2D(maskTexture,vUv);vec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=direction*invSize*x;vec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.);}"
      });
    }
    render(e, t, r, i, s) {
      var o, a;
      if (!this.enabled) return;
      const l = e.baseRenderer,
        c = {
          minFilter: n.wem,
          magFilter: n.wem,
          isAntialiased: !1,
          format: n.wk1,
          depthBuffer: !1,
          generateMipmaps: !1
        },
        u = l.getTempTarget(c);
      this._renderEdges(l, u), this._blurEdges(l, u), this._viewerApp.scene.activeCamera.updateShaderProperties(this.material), null === (o = this._viewerApp.getPlugin(lo)) || void 0 === o || o.updateShaderProperties(this.material), null === (a = this._viewerApp.getPlugin(Ob)) || void 0 === a || a.updateShaderProperties(this.material), this._viewerApp.renderer.updateShaderProperties(this.material), this.uniforms.edgeMaskBuffer.value = u.texture, super.render(e, this._target, u, i, s), l.releaseTempTarget(u);
    }
    _initsamples() {
      const e = [],
        t = 1 / 8;
      return e.push(new n.FM8(-8, 0).multiplyScalar(t)), e.push(new n.FM8(-6, -4).multiplyScalar(t)), e.push(new n.FM8(-3, -2).multiplyScalar(t)), e.push(new n.FM8(-2, -6).multiplyScalar(t)), e.push(new n.FM8(1, -1).multiplyScalar(t)), e.push(new n.FM8(2, -5).multiplyScalar(t)), e.push(new n.FM8(6, -7).multiplyScalar(t)), e.push(new n.FM8(5, -3).multiplyScalar(t)), e.push(new n.FM8(4, 1).multiplyScalar(t)), e.push(new n.FM8(7, 4).multiplyScalar(t)), e.push(new n.FM8(3, 5).multiplyScalar(t)), e.push(new n.FM8(0, 7).multiplyScalar(t)), e.push(new n.FM8(-1, 3).multiplyScalar(t)), e.push(new n.FM8(-4, 6).multiplyScalar(t)), e.push(new n.FM8(-7, 8).multiplyScalar(t)), e.push(new n.FM8(-5, 2).multiplyScalar(t)), e;
    }
    _blurEdges(e, t) {
      var r, i;
      const s = {
          minFilter: n.wem,
          magFilter: n.wem,
          isAntialiased: !1,
          format: n.wk1,
          depthBuffer: !1,
          generateMipmaps: !1,
          sizeMultiplier: .5
        },
        o = e.getTempTarget(s),
        a = (null === (r = t.texture.image) || void 0 === r ? void 0 : r.width) || 1,
        l = (null === (i = t.texture.image) || void 0 === i ? void 0 : i.height) || 1;
      this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a, l), this._separableBlurMaterial.uniforms.colorTexture.value = t.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(1, 0), e.blit(void 0, o, {
        material: this._separableBlurMaterial
      }), this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a / 2, l / 2), this._separableBlurMaterial.uniforms.colorTexture.value = o.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(0, 1), e.blit(void 0, t, {
        material: this._separableBlurMaterial
      }), e.releaseTempTarget(o);
    }
    _renderEdges(e, t) {
      var r, i, s, o;
      const a = (null === (r = t.texture.image) || void 0 === r ? void 0 : r.width) || 1,
        l = (null === (i = t.texture.image) || void 0 === i ? void 0 : i.height) || 1;
      this._edgeMaterial.uniforms.screenSize.value = new n.FM8(a, l), this._viewerApp.scene.activeCamera.updateShaderProperties(this._edgeMaterial), null === (s = this._viewerApp.getPlugin(lo)) || void 0 === s || s.updateShaderProperties(this._edgeMaterial), null === (o = this._viewerApp.getPlugin(Ob)) || void 0 === o || o.updateShaderProperties(this._edgeMaterial), e.blit(void 0, t, {
        material: this._edgeMaterial
      });
    }
  };
  Ub = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  }([lt("SSBevel")], Ub);
  class Nb extends io {
    constructor(e = !0) {
      super(), this.passId = "ssBevel", this._beforeFilters = ["render"], this._afterFilters = ["gbuffer", "normalBuffer"], this._requiredFilters = ["render", "gbuffer", "normalBuffer"], this._lastEnabled = !1, this.dependencies = [to, lo, Ob], this.enabled = e, this.setDirty = this.setDirty.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }
    get bevelTarget() {
      return this._bevelTarget;
    }
    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new jb(e));
    }
    passCtor(e) {
      var t, r;
      this._bevelTarget = e.renderer.createTarget({
        depthBuffer: !0,
        type: n.cLu,
        minFilter: n.TyD,
        magFilter: n.TyD,
        generateMipmaps: !1
      }), this._bevelTarget.texture.name = "bevelBuffer", this._bevelTarget.texture.generateMipmaps = !1;
      const i = e.getPluginByType("debug");
      return i && i.addTexture("tempBuffer", () => this._bevelTarget.texture, [440, 50, 400, 200]), new Ub(e.renderer, this._bevelTarget, null !== (r = null === (t = e.getPlugin(lo)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== r ? r : "", e);
    }
    async onAdded(e) {
      var t, r, n, i, s, o, a;
      await super.onAdded(e);
      const l = e.getPlugin(to);
      return (null === (t = this.pass) || void 0 === t ? void 0 : t.passObject.materialExtension) && (null === (r = null == l ? void 0 : l.materials) || void 0 === r || r.registerMaterialExtension(null === (n = this.pass) || void 0 === n ? void 0 : n.passObject.materialExtension)), null === (i = null == l ? void 0 : l.importer) || void 0 === i || i.addEventListener("loaderCreate", this._loaderCreate), null === (a = null === (o = null === (s = null == l ? void 0 : l.exporter) || void 0 === s ? void 0 : s.getExporter("gltf", "glb")) || void 0 === o ? void 0 : o.extensions) || void 0 === a || a.push(zb), super.onAdded(e);
    }
    async onRemove(e) {
      return e.renderer.disposeTarget(this._bevelTarget), super.onRemove(e);
    }
    setDirty() {
      var e, t, r, n;
      null === (e = this._viewer) || void 0 === e || e.setDirty(), null === (n = null === (t = this.pass) || void 0 === t ? void 0 : (r = t.passObject.materialExtension).setDirty) || void 0 === n || n.call(r);
    }
    _update(e) {
      var t;
      let r = this.enabled;
      if (r && !this._lastEnabled) {
        const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("NormalBufferPlugin");
        confirm("SS Bevel Plugin needs to enable NormalBufferPlugin. Enable now?") ? e.enabled = !0 : (this.enabled = !1, e.enabled = !1, r = !1);
      }
      return this._lastEnabled = r, r;
    }
    get uiConfig() {
      var e, t, r, n, i;
      const s = null !== (r = null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== r ? r : {};
      return null === (i = null === (n = s.children) || void 0 === n ? void 0 : n.map(e => A(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }
  }
  Nb.PluginType = "SSBevelPlugin", Nb.SSBEVEL_GLTF_EXTENSION = "WEBGI_materials_ssbevel";
  class jb {
    constructor(e) {
      this.parser = e, this.name = Nb.SSBEVEL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return t.userData || (t.userData = {}), Fb(t), t.userData._ssBevel = De(n, t.userData._ssBevel, !1, {}), Promise.resolve();
    }
  }
  const zb = e => ({
    writeMaterial: (t, r) => {
      if (!t.isMeshStandardMaterial || !t.userData._ssBevel) return;
      if (!t.userData._ssBevel.hasSSBevel) return;
      r.extensions = r.extensions || {};
      const n = ke(t.userData._ssBevel, !1);
      r.extensions[Nb.SSBEVEL_GLTF_EXTENSION] = n, e.extensionsUsed[Nb.SSBEVEL_GLTF_EXTENSION] = !0;
    }
  });
  class Gb extends V_ {
    constructor(e) {
      super(), this._loadedLibs = !1, e = e || {
        method: mA.EncoderMethod.EDGEBREAKER,
        encodeSpeed: 5
      }, this._io = new Mv().registerExtensions(Bb).registerExtensions([Hb, Jb, Xb, Yb, Kb, Zb, $b, ey, ty, ry, ny, iy, sy, oy, ay]), this._encoderOptions = e;
    }
    preload() {
      return this._loadLibs(), this;
    }
    async _loadLibs() {
      if (this._loadedLibs || !this.loader) return;
      const e = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
      this._io.registerDependencies({
        "draco3d.encoder": e[0],
        "draco3d.decoder": e[1]
      }), this._loadedLibs = !0;
    }
    async parseAsync(e, {
      compress: t = !1,
      ...r
    }) {
      if (!this.loader) return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e, r);
      await this._loadLibs();
      const n = {
        ...r
      };
      t && (n.externalImagesInExtras = !0);
      const i = await new Promise((t, r) => this.parse(e, t, r, n)),
        s = await super.parseAsync(i, n);
      if (!t) return s;
      if (!i) throw new Error("GLTFDracoExporter: gltf is null");
      let o = i;
      const a = o.byteLength || 1 / 0,
        l = await ("object" != typeof o || o.byteLength ? this._io.readBinary(new Uint8Array(o)) : this._io.readJSON({
          json: o,
          resources: {}
        }));
      if (l.createExtension(mA).setRequired(!0).setEncoderOptions(this._encoderOptions), "glb" === n.exportExt) o = await this._io.writeBinary(l), isFinite(a) && console.log("DRACO Compression ratio: " + (o.byteLength / a).toFixed(5));else {
        const e = await this._io.writeJSON(l);
        o = e.json, Object.values(e.resources).filter(e => e).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), o.resources = e.resources);
      }
      o.__isGLTFOutput = !0;
      const c = await super.parseAsync(o, n);
      return c.__uncompressed = s, c;
    }
  }
  class Vb extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.dependencies = [to, tg];
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = e.getManager().importer;
      if (!t) throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
      !function (e, t) {
        W_(e, Gb, e => {
          const r = Xe() + ".drc",
            n = e;
          n.loader = t.registerFile(r), n.loader.setDecoderConfig({
            type: "js"
          }), n.loader.preload(!0, !0);
        });
      }(e, t);
    }
  }
  Vb.PluginType = "GLTFDracoExportPlugin";
  class Qb extends ev {
    constructor() {
      super(...arguments), this.extensionName = on, this.parentTypes = [dg.SCENE], this.propertyType = "ViewerJSON";
    }
    init() {}
  }
  class Hb extends gv {
    constructor() {
      super(...arguments), this.extensionName = on, this._viewerConfig = {}, this._texturesRef = [], this.required = !0;
    }
    read(e) {
      var t;
      return this._viewerConfig = {}, null === (t = e.jsonDoc.json.scenes) || void 0 === t || t.forEach((t, r) => {
        if (t.extensions && t.extensions[on]) {
          const n = new Qb(this.document.getGraph());
          e.scenes[r].setExtension(on, n);
          const i = t.extensions[on];
          this._viewerConfig = i;
        }
      }), this;
    }
    write(e) {
      return this.document.getRoot().listScenes().forEach(t => {
        var r;
        if (t.getExtension(on)) {
          const t = null === (r = e.jsonDoc.json.scenes) || void 0 === r ? void 0 : r[e.jsonDoc.json.scene || 0];
          t && this._viewerConfig !== {} && (t.extensions = t.extensions || {}, t.extensions[on] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {});
        }
      }), this;
    }
  }
  Hb.EXTENSION_NAME = on;
  class Wb extends ev {
    constructor(e, t, r) {
      super(e, t), this.parentTypes = [dg.MATERIAL, dg.MESH, dg.NODE, dg.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = r;
    }
    addTexture(e, t, r, n = 4369) {
      this.setRef(e, r, {
        channels: n
      }), this.textures[e] = [t, r];
    }
    copy(e, t = Qg) {
      return super.copy(e, t), this;
    }
    dispose() {
      Object.values(this.textures).forEach(([e, t]) => {
        null == e || e.dispose();
      }), super.dispose();
    }
    init() {}
  }
  class qb extends gv {
    constructor() {
      super(...arguments), this.textureChannels = {};
    }
    read(e) {
      const t = e.jsonDoc,
        r = t.json.materials || [],
        n = t.json.textures || [];
      return r.forEach((t, r) => {
        var i, s;
        if (t.extensions && t.extensions[this.extensionName]) {
          const o = new Wb(this.document.getGraph(), "", this.extensionName);
          e.materials[r].setExtension(this.extensionName, o);
          const a = {
            ...t.extensions[this.extensionName]
          };
          for (const [t, r] of Object.entries(a)) if ("number" == typeof (null == r ? void 0 : r.index)) {
            const l = r,
              c = null === (i = n[l.index]) || void 0 === i ? void 0 : i.source;
            if ("number" != typeof c) {
              console.warn("GLTF Pipeline: source texture not found for texture info", l);
              continue;
            }
            const u = e.textures[c],
              h = new tv(this.document.getGraph()),
              p = null !== (s = this.textureChannels[t]) && void 0 !== s ? s : 4369;
            o.addTexture(t, h, u, p), e.setTextureInfo(h, l), delete a[t];
          }
          o.setExtras(a);
        }
      }), (t.json.meshes || []).forEach((t, r) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const n = new Wb(this.document.getGraph(), "", this.extensionName);
          e.meshes[r].setExtension(this.extensionName, n);
          const i = t.extensions[this.extensionName];
          n.setExtras(i);
        }
      }), (t.json.nodes || []).forEach((t, r) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const n = new Wb(this.document.getGraph(), "", this.extensionName);
          e.nodes[r].setExtension(this.extensionName, n);
          const i = t.extensions[this.extensionName];
          n.setExtras(i);
        }
      }), (t.json.scenes || []).forEach((t, r) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const n = new Wb(this.document.getGraph(), "", this.extensionName);
          e.scenes[r].setExtension(this.extensionName, n);
          const i = t.extensions[this.extensionName];
          n.setExtras(i);
        }
      }), this;
    }
    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(r => {
        const n = r.getExtension(this.extensionName);
        if (n) {
          const i = e.materialIndexMap.get(r),
            s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = {
            ...n.getExtras()
          };
          for (const [t, r] of Object.entries(n.textures)) {
            const n = r[0],
              i = r[1];
            i && (o[t] = e.createTextureInfoDef(i, n));
          }
          s.extensions[this.extensionName] = o;
        }
      }), this.document.getRoot().listMeshes().forEach(r => {
        const n = r.getExtension(this.extensionName);
        if (n) {
          const i = e.meshIndexMap.get(r),
            s = t.json.meshes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = n.getExtras();
        }
      }), this.document.getRoot().listNodes().forEach(r => {
        const n = r.getExtension(this.extensionName);
        if (n) {
          const i = e.nodeIndexMap.get(r),
            s = t.json.nodes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = n.getExtras();
        }
      }), this.document.getRoot().listScenes().forEach(r => {
        const n = r.getExtension(this.extensionName);
        if (n) {
          const r = e.jsonDoc.json.scene || 0,
            i = t.json.scenes[r];
          if (!i) return;
          i.extensions = i.extensions || {}, i.extensions[this.extensionName] = n.getExtras();
        }
      }), this;
    }
  }
  class Xb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Xb.EXTENSION_NAME, this.textureChannels = {
        bumpTexture: _g.R
      };
    }
  }
  Xb.EXTENSION_NAME = mn;
  class Yb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Yb.EXTENSION_NAME, this.textureChannels = {
        lightMapTexture: _g.R | _g.G | _g.B
      };
    }
  }
  Yb.EXTENSION_NAME = vn;
  class Kb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Kb.EXTENSION_NAME, this.textureChannels = {
        alphaTexture: _g.G
      };
    }
  }
  Kb.EXTENSION_NAME = gn;
  class Jb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Jb.EXTENSION_NAME;
    }
  }
  Jb.EXTENSION_NAME = Gc.DIAMOND_GLTF_EXTENSION;
  class Zb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Zb.EXTENSION_NAME;
    }
  }
  Zb.EXTENSION_NAME = Wc.AnimationMarkersExtension;
  class $b extends qb {
    constructor() {
      super(...arguments), this.extensionName = $b.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: _g.R | _g.G | _g.B
      };
    }
  }
  $b.EXTENSION_NAME = xu.ANISOTROPY_GLTF_EXTENSION;
  class ey extends qb {
    constructor() {
      super(...arguments), this.extensionName = ey.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: _g.R | _g.G | _g.B
      };
    }
  }
  ey.EXTENSION_NAME = Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
  class ty extends qb {
    constructor() {
      super(...arguments), this.extensionName = ty.EXTENSION_NAME;
    }
  }
  ty.EXTENSION_NAME = ln;
  class ry extends qb {
    constructor() {
      super(...arguments), this.extensionName = ry.EXTENSION_NAME;
    }
  }
  ry.EXTENSION_NAME = cn;
  class ny extends qb {
    constructor() {
      super(...arguments), this.extensionName = ny.EXTENSION_NAME;
    }
  }
  ny.EXTENSION_NAME = un;
  class iy extends qb {
    constructor() {
      super(...arguments), this.extensionName = iy.EXTENSION_NAME;
    }
  }
  iy.EXTENSION_NAME = zu.CLEARCOAT_TINT_GLTF_EXTENSION;
  class sy extends qb {
    constructor() {
      super(...arguments), this.extensionName = sy.EXTENSION_NAME;
    }
  }
  sy.EXTENSION_NAME = Cu.THIN_FILM_LAYER_GLTF_EXTENSION;
  class oy extends qb {
    constructor() {
      super(...arguments), this.extensionName = oy.EXTENSION_NAME;
    }
  }
  oy.EXTENSION_NAME = Nb.SSBEVEL_GLTF_EXTENSION;
  class ay extends qb {
    constructor() {
      super(...arguments), this.extensionName = ay.EXTENSION_NAME;
    }
  }
  ay.EXTENSION_NAME = Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
  class ly extends r {
    constructor() {
      super(...arguments), this.processor = {
        forAssetType: "texture",
        process: (e, t) => e
      };
    }
    async onAdded(e) {}
    async onDispose(e) {}
    async onRemove(e) {
      this._pmrem = void 0;
    }
  }
  ly.PluginType = "PMREMGenerator";
  const cy = new n.Pa4(),
    uy = new n._fP(),
    hy = new n.Pa4();
  class py extends n.Tme {
    constructor(e = document.createElement("div")) {
      super(), this.isCSS3DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function () {
        this.traverse(function (e) {
          e.element instanceof Element && null !== e.element.parentNode && e.element.parentNode.removeChild(e.element);
        });
      });
    }
    copy(e, t) {
      return super.copy(e, t), this.element = e.element.cloneNode(!0), this;
    }
  }
  const dy = new n.yGw(),
    fy = new n.yGw();
  class my {
    constructor(e = {}) {
      const t = this;
      let r, n, i, s;
      const o = {
          camera: {
            fov: 0,
            style: ""
          },
          objects: new WeakMap()
        },
        a = void 0 !== e.element ? e.element : document.createElement("div");
      a.style.overflow = "hidden", this.domElement = a;
      const l = document.createElement("div");
      function c(e) {
        return Math.abs(e) < 1e-10 ? 0 : e;
      }
      function u(e) {
        const t = e.elements;
        return "matrix3d(" + c(t[0]) + "," + c(-t[1]) + "," + c(t[2]) + "," + c(t[3]) + "," + c(t[4]) + "," + c(-t[5]) + "," + c(t[6]) + "," + c(t[7]) + "," + c(t[8]) + "," + c(-t[9]) + "," + c(t[10]) + "," + c(t[11]) + "," + c(t[12]) + "," + c(-t[13]) + "," + c(t[14]) + "," + c(t[15]) + ")";
      }
      function h(e) {
        const t = e.elements;
        return "translate(-50%,-50%)matrix3d(" + c(t[0]) + "," + c(t[1]) + "," + c(t[2]) + "," + c(t[3]) + "," + c(-t[4]) + "," + c(-t[5]) + "," + c(-t[6]) + "," + c(-t[7]) + "," + c(t[8]) + "," + c(t[9]) + "," + c(t[10]) + "," + c(t[11]) + "," + c(t[12]) + "," + c(t[13]) + "," + c(t[14]) + "," + c(t[15]) + ")";
      }
      function p(e, r, n, i) {
        if (e.isCSS3DObject) {
          const i = !0 === e.visible && !0 === e.layers.test(n.layers);
          if (e.element.style.display = !0 === i ? "" : "none", !0 === i) {
            let i;
            e.onBeforeRender(t, r, n), e.isCSS3DSprite ? (dy.copy(n.matrixWorldInverse), dy.transpose(), 0 !== e.rotation2D && dy.multiply(fy.makeRotationZ(e.rotation2D)), e.matrixWorld.decompose(cy, uy, hy), dy.setPosition(cy), dy.scale(hy), dy.elements[3] = 0, dy.elements[7] = 0, dy.elements[11] = 0, dy.elements[15] = 1, i = h(dy)) : i = h(e.matrixWorld);
            const s = e.element,
              a = o.objects.get(e);
            if (void 0 === a || a.style !== i) {
              s.style.transform = i;
              const t = {
                style: i
              };
              o.objects.set(e, t);
            }
            s.parentNode !== l && l.appendChild(s), e.onAfterRender(t, r, n);
          }
        }
        for (let t = 0, s = e.children.length; t < s; t++) p(e.children[t], r, n, i);
      }
      l.style.transformStyle = "preserve-3d", l.style.pointerEvents = "none", a.appendChild(l), this.getSize = function () {
        return {
          width: r,
          height: n
        };
      }, this.render = function (e, t) {
        const r = t.projectionMatrix.elements[5] * s;
        let n, h;
        o.camera.fov !== r && (a.style.perspective = t.isPerspectiveCamera ? r + "px" : "", o.camera.fov = r), !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), t.isOrthographicCamera && (n = -(t.right + t.left) / 2, h = (t.top + t.bottom) / 2);
        const d = t.isOrthographicCamera ? "scale(" + r + ")translate(" + c(n) + "px," + c(h) + "px)" + u(t.matrixWorldInverse) : "translateZ(" + r + "px)" + u(t.matrixWorldInverse),
          f = d + "translate(" + i + "px," + s + "px)";
        o.camera.style !== f && (l.style.transform = f, o.camera.style = f), p(e, e, t, d);
      }, this.setSize = function (e, t) {
        r = e, n = t, i = r / 2, s = n / 2, a.style.width = e + "px", a.style.height = t + "px", l.style.width = e + "px", l.style.height = t + "px";
      };
    }
  }
  var _y,
    gy = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let vy = _y = class extends ro {
    constructor(e = !0) {
      super(), this._scene = new n.xsS(), this.overCanvas = !0, this._trackers = [], this.attachIFrameToSelected = async () => {
        var e, t, r, n, i;
        const s = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
        if (!(null == s ? void 0 : s.geometry)) return void (await (null === (r = this._viewer) || void 0 === r ? void 0 : r.alert("No Geometry: Selected object must have a geometry to apply the iframe to")));
        const o = (await (null === (n = this._viewer) || void 0 === n ? void 0 : n.prompt("URL: Enter the url for the webpage. (Make sure its allowed to be embedded in an iframe.)", "https://webgi.xyz/", !1))) || "https://webgi.pixotronics.com/";
        if (!o) return;
        const a = (await (null === (i = this._viewer) || void 0 === i ? void 0 : i.prompt("Width: Enter the width for the object.", "512", !1))) || "512";
        a && this.attachIFrame(s, o, parseInt(a));
      }, this._resizeObserver = new ResizeObserver(() => {
        var e;
        this.enabled && (null === (e = this._viewer) || void 0 === e || e.scene.setDirty({
          sceneUpdate: !0
        }));
      }), this.enabled = e, this._refreshCanvasInDOM = this._refreshCanvasInDOM.bind(this), this._refreshEnabled = this._refreshEnabled.bind(this);
    }
    _refreshEnabled() {}
    _refreshCanvasInDOM() {
      const e = this._viewer;
      e && this._renderer && (e.canvas.remove(), this.overCanvas ? this._renderer.domElement.insertAdjacentElement("afterbegin", e.canvas) : this._renderer.domElement.appendChild(e.canvas));
    }
    _initialize() {
      if (this._renderer) return;
      if (!this._viewer) return;
      this._renderer = new my();
      const e = this._viewer.renderer.rendererObject.getSize(new n.FM8());
      this._renderer.setSize(e.width, e.height);
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.top = "0", t.style.zIndex = "0", t.appendChild(this._renderer.domElement), this._viewer.canvas.style.position = "absolute", this._viewer.canvas.style.top = "0", this._viewer.canvas.style.left = "0", this._viewer.canvas.style.zIndex = "0", this._viewer.container.appendChild(t), this._refreshCanvasInDOM(), this._viewer.renderer.addEventListener("resize", () => {
        if (!this._viewer || !this._renderer) return;
        const e = this._viewer.renderer.rendererObject.getSize(new n.FM8());
        this._renderer.setSize(e.width, e.height);
      });
    }
    async onAdded(e) {
      await super.onAdded(e);
      let t = !0,
        r = !0;
      e.addEventListener("postFrame", i => {
        var s, o;
        t && this.enabled && (this._renderer || this._initialize(), this._renderer && (r && this._trackers.forEach(e => {
          var t, r;
          let i = !0;
          const s = e.modelObj.material.side;
          if (s !== n.ehD) {
            const o = new n.Pa4(0, 0, 1).applyQuaternion(e.cssObj.quaternion),
              a = null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera) || void 0 === r ? void 0 : r.cameraObject,
              l = o.dot(a.getWorldDirection(new n.Pa4()));
            i = s === n._Li ? l > 0 : l < 0;
          }
          e.cssObj.element.style.visibility = i ? "visible" : "hidden";
        }), this._trackers.filter(e => e.dirty).forEach(e => this._syncProperties(e)), null === (s = this._renderer) || void 0 === s || s.render(this._scene, null === (o = e.scene.activeCamera) || void 0 === o ? void 0 : o.cameraObject), t = !1));
      }), e.addEventListener("update", e => {
        this.enabled && (t = this._trackers.length > 0);
      }), e.scene.addEventListener("sceneUpdate", e => {
        this.enabled && (this._trackers.forEach(e => e.dirty = !0), t = this._trackers.length > 0);
      }), e.scene.addEventListener("activeCameraUpdate", e => {
        this.enabled && (t = this._trackers.length > 0, r = !0);
      });
      let i = !1;
      const s = new n.iMs();
      e.container.addEventListener("mousemove", e => {
        if (!this.enabled || !this._viewer || this.overCanvas) return;
        const t = this._viewer.canvas.getBoundingClientRect(),
          r = (e.clientX - t.x) / t.width * 2 - 1,
          n = -(e.clientY - t.y) / t.height * 2 + 1;
        s.setFromCamera({
          x: r,
          y: n
        }, this._viewer.scene.activeCamera.cameraObject);
        const o = this._trackers.map(e => e.modelObj),
          a = s.intersectObjects(o, !1);
        if (console.log(a), a.length) return this._viewer.canvas.style.pointerEvents = "none", i = !0, void console.log(this._viewer.canvas.style.pointerEvents);
        i && (this._viewer.canvas.style.pointerEvents = "auto", i = !1);
      });
    }
    attachIFrame(e, t, r) {
      const n = xy(e.modelObject),
        i = Ay(t, r, r * n.y / n.x, () => {
          var t;
          return null === (t = e.setDirty) || void 0 === t ? void 0 : t.call(e);
        });
      return this.attachCSS3DObject(i, e), i;
    }
    attachCSS3DObject(e, t) {
      var r, i, s, o, a;
      if (this._trackers.push({
        cssObj: e,
        modelObj: t.modelObject,
        dirty: !0
      }), e.element && (this._resizeObserver.observe(e.element), e.element.__isCSS3DObjectElement = !0, console.log(e.element, e.element.__isCSS3DObjectElement)), t.userData.__oldMaterial = t.material, !t.setMaterial) throw "model not processed?";
      const l = null === (r = this._viewer) || void 0 === r ? void 0 : r.createMaterial("basic", {
        opacity: 0,
        color: new n.Ilk("black"),
        blending: n.jFi,
        side: n.Wl3
      });
      if (!l) throw "cannot create mat";
      l.userData.forcedLinearDepth = 0, null === (i = t.setMaterial) || void 0 === i || i.call(t, l), by(t.modelObject), yy(t.modelObject), xy(t.modelObject), this._scene.add(e), null === (o = null === (s = this.uiConfig) || void 0 === s ? void 0 : s.uiRefresh) || void 0 === o || o.call(s), null === (a = t.setDirty) || void 0 === a || a.call(t);
    }
    _syncProperties(e) {
      const t = e.modelObj,
        r = e.cssObj;
      t.updateMatrixWorld();
      const i = e.cssObj.element.clientWidth < 1.5 ? 0 : (e.cssObj.element.clientWidth - 1.5) / xy(t).x,
        s = by(t);
      r.quaternion.setFromUnitVectors(new n.Pa4(0, 0, 1), s), r.position.copy(yy(t)), r.scale.set(1, 1, 1).multiplyScalar(1 / i), r.updateMatrixWorld(), r.applyMatrix4(t.matrixWorld), e.dirty = !1;
    }
    async onDispose(e) {
      return this._resizeObserver.disconnect(), super.onDispose(e);
    }
  };
  function Ay(e, t, r, n) {
    const i = document.createElement("div");
    i.style.width = t.toString() + "px", i.style.height = r.toString() + "px", i.style.backgroundColor = "transparent";
    const s = document.createElement("iframe", {
      is: "x-frame-bypass"
    });
    s.style.width = "100%", s.style.height = "100%", s.style.border = "0px";
    const o = () => {
      var e, t;
      try {
        s.contentWindow.name;
      } catch (r) {
        ("string" == typeof r ? r : null !== (t = null === (e = null == r ? void 0 : r.toString) || void 0 === e ? void 0 : e.call(r)) && void 0 !== t ? t : "").includes("cross-origin") ? console.warn("Trying to load cross-origin scripts, Install chrome extension if not able to load: https://chrome.google.com/webstore/detail/ignore-x-frame-headers/gleekbfjekiniecknbkamfmkohkpodhe") : console.error(r);
      }
      n(), s.removeEventListener("load", o);
    };
    return s.addEventListener("load", o), s.src = e, i.appendChild(s), new py(i);
  }
  function by(e) {
    if (e.geometry.userData.geometryNormal) return e.geometry.userData.geometryNormal;
    const t = e.geometry.attributes.normal,
      r = new n.Pa4(),
      i = new n.Pa4();
    for (let e = 0, n = t.count; e < n; e++) r.fromBufferAttribute(t, e), i.add(r);
    return i.normalize(), e.geometry.userData.geometryNormal = i, i;
  }
  function yy(e) {
    if (e.geometry.userData.geometryCenter) return e.geometry.userData.geometryCenter;
    const t = e.geometry;
    if (!t) return new n.Pa4(0, 0, 0);
    t.boundingBox || t.computeBoundingBox();
    const r = t.boundingBox.getCenter(new n.Pa4());
    return e.geometry.userData.geometryCenter = r, r;
  }
  function xy(e, t = new n.Pa4(0, 0, 1)) {
    if (e.geometry.userData.geometrySize) return e.geometry.userData.geometrySize;
    const r = e.geometry;
    if (!r) return new n.Pa4(0, 0, 0);
    const i = r.clone();
    i.applyMatrix4(new n.yGw().makeRotationFromQuaternion(new n._fP().setFromUnitVectors(t, by(e)).invert())), i.computeBoundingBox();
    const s = i.boundingBox.getSize(new n.Pa4());
    return e.geometry.userData.geometrySize = s, i.dispose(), s;
  }
  vy.PluginType = "CSS3DRenderer", gy([Je("Enabled"), M(_y.prototype._refreshEnabled), Ce()], vy.prototype, "enabled", void 0), gy([Je("Over canvas"), M(_y.prototype._refreshCanvasInDOM), Ce()], vy.prototype, "overCanvas", void 0), gy([rt("Attach iframe")], vy.prototype, "attachIFrameToSelected", void 0), vy = _y = gy([lt("CSS3D Renderer")], vy);
  const wy = 1e4,
    Ey = 50;
  class Sy {
    constructor(e = Ey) {
      this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e);
    }
    setDecayTime(e) {
      this.naturalFrequency = 1 / Math.max(.001, e);
    }
    update(e, t, r, n) {
      const i = 2e-4 * this.naturalFrequency;
      if (null == e || 0 === n) return t;
      if (e === t && 0 === this.velocity) return t;
      if (r < 0) return e;
      const s = e - t,
        o = this.velocity + this.naturalFrequency * s,
        a = s + r * o,
        l = Math.exp(-this.naturalFrequency * r),
        c = (o - this.naturalFrequency * a) * l,
        u = -this.naturalFrequency * (c + o * l);
      return Math.abs(c) < i * Math.abs(n) && u * s >= 0 ? (this.velocity = 0, t) : (this.velocity = c, t + a * l);
    }
  }
  const Cy = new n.Pa4();
  class My {
    constructor() {
      this.inputSource = null, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new n.Pa4(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new n.Pa4(), this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = !1, this.placementComplete = !1, this.xr = null, this.session = null, this._hitPosition = new n.Pa4(), this._hitMatrix = new n.yGw(), this.xDamper = new Sy(), this.yDamper = new Sy(), this.zDamper = new Sy(), this.yawDamper = new Sy(), this.scaleDamper = new Sy(), this.onSelectStart = e => {
        const t = this.transientHitTestSource;
        if (null == t) return;
        const r = this.frame.getHitTestResultsForTransientInput(t),
          n = this.presentedScene,
          i = this.placementBox;
        if (1 === r.length) {
          this.inputSource = e.inputSource;
          const {
              axes: t
            } = this.inputSource.gamepad || {
              axes: [0, 0]
            },
            r = i.getHit(n, t[0], t[1]);
          i.show = !0, null != r ? (this.isTranslating = !0, this.lastDragPosition.copy(r)) : this.placeOnWall || (this.isRotating = !0, this.lastAngle = 1.5 * t[0]);
        } else if (2 === r.length) {
          i.show = !0, this.isTwoFingering = !0;
          const {
            separation: e
          } = this.fingerPolar(r);
          this.firstRatio = e / n.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1;
      };
    }
    async setSession(e, t, r, n) {
      var i;
      this.transientHitTestSource = await (null === (i = e.requestHitTestSourceForTransientInput) || void 0 === i ? void 0 : i.call(e, {
        profile: "generic-touchscreen"
      })), this.presentedScene = t, this.placementBox = n, this.xr = r, this.session = e, this.placementComplete = !1, this.goalPosition.copy(t.position), this.goalYaw = t.rotation.y, this.goalScale = t.scale.x, e.addEventListener("selectstart", this.onSelectStart), e.addEventListener("selectend", this.onSelectEnd);
    }
    cancel() {
      this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = !1, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = !1, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null);
    }
    getHitPoint(e) {
      var t;
      const r = null === (t = this.xr) || void 0 === t ? void 0 : t.getReferenceSpace(),
        n = r ? e.getPose(r) : null;
      return n ? (this._hitMatrix.fromArray(n.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > .75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null;
    }
    moveScene(e) {
      if (!this.session) return;
      const t = this.presentedScene,
        r = t.position,
        n = t.rotation.y,
        i = this.placementBox,
        s = Math.max(i.boundingSize.x, i.boundingSize.y, i.boundingSize.z) / 2,
        o = this.goalPosition,
        a = t.scale.x;
      if (!o.equals(r) || this.goalScale !== a) {
        let {
          x: n,
          y: l,
          z: c
        } = r;
        n = this.xDamper.update(n, o.x, e, s), l = this.yDamper.update(l, o.y, e, s), c = this.zDamper.update(c, o.z, e, s), r.set(n, l, c);
        const u = this.scaleDamper.update(a, this.goalScale, e, 1);
        if (t.scale.set(u, u, u), !this.isTranslating) {
          const e = o.y - l;
          this.placementComplete && !this.placeOnWall ? i.offsetHeight = e / u : 0 === e && (this.placementComplete = !0, i.show = !1);
        }
      }
      i.updateOpacity(e), t.rotation.y = this.yawDamper.update(n, this.goalYaw, e, Math.PI);
    }
    processInput(e) {
      var t;
      this.frame = e;
      const r = this.transientHitTestSource;
      if (!r) return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
      const n = e.getHitTestResultsForTransientInput(r),
        i = this.presentedScene,
        s = i.scale.x;
      if (this.isTwoFingering) {
        if (n.length < 2) this.isTwoFingering = !1;else {
          const {
            separation: e,
            deltaYaw: t
          } = this.fingerPolar(n);
          if (this.placeOnWall || (this.goalYaw += t), !i.userData.__scaleDisabled) {
            const t = e / this.firstRatio;
            this.goalScale = t < 1.3 && t > .7692307692307692 ? 1 : t;
          }
        }
      } else if (2 !== n.length) {
        if (this.isRotating && (null === (t = this.inputSource) || void 0 === t ? void 0 : t.gamepad)) {
          const e = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += e - this.lastAngle, this.lastAngle = e;
        } else this.isTranslating && (console.log("translating"), n.forEach(e => {
          if (e.inputSource !== this.inputSource) return;
          let t = null;
          if (e.results.length > 0 && (t = this.getHitPoint(e.results[0])), null == t && (t = this.getTouchLocation()), null != t) {
            if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
              const e = t.y - this.lastDragPosition.y;
              if (e < 0) {
                this.placementBox.offsetHeight = e / s;
                const r = Cy.copy(this.xr.getCamera().position),
                  n = -e / (r.y - t.y);
                r.multiplyScalar(n), t.multiplyScalar(1 - n).add(r);
              }
            }
            this.goalPosition.add(t), this.lastDragPosition.copy(t);
          }
        }));
      } else {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
        const {
          separation: e
        } = this.fingerPolar(n);
        this.firstRatio = e / s;
      }
    }
    getTouchLocation() {
      var e, t;
      const {
          axes: r
        } = null !== (e = this.inputSource.gamepad) && void 0 !== e ? e : {
          axes: [0, 0]
        },
        n = this.placementBox.getExpandedHit(this.presentedScene, r[0], r[1]);
      return null != n && (Cy.copy(n).sub(null === (t = this.xr) || void 0 === t ? void 0 : t.getCamera().position), Cy.length() > 10) ? null : n;
    }
    fingerPolar(e) {
      var t, r, n, i, s, o;
      const a = null !== (n = null === (r = null === (t = e[0].inputSource) || void 0 === t ? void 0 : t.gamepad) || void 0 === r ? void 0 : r.axes) && void 0 !== n ? n : [0, 0],
        l = null !== (o = null === (s = null === (i = e[1].inputSource) || void 0 === i ? void 0 : i.gamepad) || void 0 === s ? void 0 : s.axes) && void 0 !== o ? o : [0, 0],
        c = l[0] - a[0],
        u = l[1] - a[1],
        h = Math.atan2(u, c);
      let p = this.lastAngle - h;
      return p > Math.PI ? p -= 2 * Math.PI : p < -Math.PI && (p += 2 * Math.PI), this.lastAngle = h, {
        separation: Math.sqrt(c * c + u * u),
        deltaYaw: p
      };
    }
  }
  const Ty = .2,
    Iy = Math.PI / 24,
    ky = new n.FM8(),
    Dy = (e, t, r) => {
      let n = t > 0 ? r > 0 ? 0 : -Math.PI / 2 : r > 0 ? Math.PI / 2 : Math.PI;
      for (let i = 0; i <= 12; ++i) e.push(t + .17 * Math.cos(n), r + .17 * Math.sin(n), 0, t + Ty * Math.cos(n), r + Ty * Math.sin(n), 0), n += Iy;
    };
  class Py extends n.Kj0 {
    constructor(e, t, r = !1) {
      super(((e, t) => {
        const r = new n.u9r(),
          i = [],
          s = [],
          o = e.getSize(new n.Pa4()),
          a = o.x / 2,
          l = (t ? o.y : o.z) / 2;
        Dy(s, a, l), Dy(s, -a, l), Dy(s, -a, -l), Dy(s, a, -l);
        const c = s.length / 3;
        for (let e = 0; e < c - 2; e += 2) i.push(e, e + 1, e + 3, e, e + 3, e + 2);
        const u = c - 2;
        return i.push(u, u + 1, 1, u, 1, 0), r.setAttribute("position", new n.a$l(s, 3)), r.setIndex(i), r;
      })(e, r)), this.boundingSize = new n.Pa4(), this._raycaster = new n.iMs(), this._camera = t, this._placeOnWall = r;
      const i = this.material;
      i.side = n.Wl3, i.color = new Ae(16711935), i.opacity = 0, this.userData.bboxVisible = !1;
      const s = e.getSize(this.boundingSize);
      console.log(e, r, s, this);
      const o = s.x / 2,
        a = (r ? s.y : s.z) / 2;
      this.hitPlane = new n.Kj0(new n._12(2 * (o + Ty), 2 * (a + Ty))), this.hitPlane.visible = !1, this.add(this.hitPlane), e.getCenter(this.position), r ? (this.shadowHeight = e.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0;
    }
    getHit(e, t, r) {
      ky.set(t, -r), this.hitPlane.visible = !0;
      const n = this._positionAndNormalFromPoint(ky, this.hitPlane);
      return this.hitPlane.visible = !1, null == n ? null : n.position;
    }
    getExpandedHit(e, t, r) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const n = this.getHit(e, t, r);
      return this.hitPlane.scale.set(1, 1, 1), n;
    }
    set offsetHeight(e) {
      e -= .001, this._placeOnWall ? this.position.z = this.shadowHeight + e : this.position.y = this.shadowHeight + e;
    }
    get offsetHeight() {
      return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }
    set show(e) {
      this.material.opacity = e ? .75 : 0;
    }
    get show() {
      return this.material.opacity > .01;
    }
    updateOpacity(e) {
      const t = this.material;
      this.visible = t.opacity > 0;
    }
    dispose() {
      var e;
      const {
        geometry: t,
        material: r
      } = this.hitPlane;
      t.dispose(), r.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e = this.parent) || void 0 === e || e.remove(this);
    }
    _positionAndNormalFromPoint(e, t) {
      if (!this._camera) return null;
      this._raycaster.setFromCamera(e, this._camera);
      const r = this._raycaster.intersectObject(t, !0);
      if (0 === r.length) return null;
      const i = r[0];
      return null == i.face ? null : null == i.uv ? {
        position: i.point,
        normal: i.face.normal,
        uv: null
      } : (i.face.normal.applyNormalMatrix(new n.Vkp().getNormalMatrix(i.object.matrixWorld)), {
        position: i.point,
        normal: i.face.normal,
        uv: i.uv
      });
    }
  }
  class By extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this._touchInputHelper = new My(), this._preRender = () => {
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession)) return;
        this._viewer.renderer.composer.renderToScreen = !1, this._xrManager.enabled = !1;
        const e = this._xrManager.getCamera(),
          t = e.cameras[0] || e,
          r = this._viewer.scene.activeCamera;
        r.cameraObject.projectionMatrix.copy(t.projectionMatrix), r.cameraObject.projectionMatrixInverse.copy(r.cameraObject.projectionMatrix).invert();
      }, this._postRender = () => {
        var e, t;
        if (!this._dirty || !this._viewer || !this._xrSession) return;
        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
        const r = this._viewer.renderer,
          n = null === (t = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera()) || void 0 === t ? void 0 : t.cameras[0].viewport;
        n ? r.rendererObject.setViewport(n) : console.warn("no viewport for ar camera"), W(r.rendererObject, {
          sceneRender: !0,
          opaqueRender: !0,
          shadowMapRender: !1,
          backgroundRender: !1,
          transparentRender: !1,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => {
          Ry.render(r.rendererObject, null, r.composer.readBuffer, 0, !1);
        }), this._xrManager.enabled = !0, this._viewer.renderer.composer.renderToScreen = !0;
      }, this._frameCount = 0, this._lastTime = 0, this._preFrame = ({
        xrFrame: e,
        deltaTime: t
      }) => {
        var r, n;
        if (this.dirty = !!e && (null === (r = this._xrManager) || void 0 === r ? void 0 : r.isPresenting) || !1, this._viewer.scene.activeCamera.interactionsEnabled = !this._dirty, this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, !this._dirty || !e) return void (this._xrSession && this._xrSessionEnd());
        if (!this._xrSession && !this._xrManager.getSession()) return console.error("no xr session found, shouldn't happen"), void (this.dirty = !1);
        this._xrSession || console.log("webxr: AR session init"), this._frameCount++;
        const i = this._xrManager.getReferenceSpace(),
          s = e.getViewerPose(i);
        if (null == s && this._frameCount, null == s || 0 === (null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.modelRoot.children.length)) return this.dirty = !1, void console.log("no pose or no model");
        if (!this._xrSession) {
          if (this._xrSession = this._xrManager.getSession() || void 0, !this._xrSession) return;
          this._frameCount = 0, this._cancelHitSources(), this._savePreXRState(), this._preSetupModel(), this._xrSessionStart();
        }
        const o = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o.cameraObject), o.setDirty(), this.moveToFloor(e), this._touchInputHelper.processInput(e), this._touchInputHelper.moveScene(t), this._updateShadow();
      }, this.placeOnWall = !1, this._preXRState = {
        viewerBg: null,
        modelScale: new n.Pa4(1, 1, 1),
        modelPosition: new n.Pa4(),
        modelRotation: new n._fP(),
        cameraPosition: new n.Pa4(0, 0, 5),
        cameraTarget: new n.Pa4(),
        cameraUp: new n.Pa4(0, 1, 0),
        cameraAspect: 1,
        cameraFov: 50,
        cameraZoom: 1,
        cameraNear: .01,
        cameraFar: 100,
        groundOffset: new n.Pa4(),
        groundScale: 1
      }, this._savePreXRState = () => {
        if (!this._viewer) return;
        this._preXRState.viewerBg = this._viewer.getBackground(!0);
        const e = this._viewer.scene.modelRoot,
          t = this._viewer.scene.activeCamera;
        e.updateMatrix(), e.updateMatrixWorld(!0), this._preXRState.modelScale.copy(e.scale), this._preXRState.modelPosition.copy(e.position), this._preXRState.modelRotation.copy(e.quaternion), this._preXRState.cameraPosition.copy(t.position), this._preXRState.cameraTarget.copy(t.target), this._preXRState.cameraUp.copy(t.cameraObject.up), t.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = t.cameraObject.fov, this._preXRState.cameraAspect = t.cameraObject.aspect), this._preXRState.cameraZoom = t.cameraObject.zoom, this._preXRState.cameraNear = t.cameraObject.near, this._preXRState.cameraFar = t.cameraObject.far;
        const r = this._viewer.getPluginByType("Ground");
        (null == r ? void 0 : r.mesh) && (this._preXRState.groundOffset.subVectors(e.position, r.mesh.modelObject.position), this._preXRState.groundScale = r.mesh.modelObject.scale.x, console.log("ground offset", this._preXRState.groundOffset, this._preXRState.groundScale), r.shadowBaker.enabled = !1);
      }, this._xrSessionStart = () => {
        if (!this._xrSession || !this._viewer) return;
        console.log("webxr: AR session start");
        const e = 20 * Math.PI / 180,
          t = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), {
            x: 0,
            y: -Math.sin(e),
            z: -Math.cos(e)
          });
        this._touchInputHelper.placeOnWall = this.placeOnWall, this._viewer.resize(), (async () => {
          var e, r;
          if (this._xrSession) {
            const n = await this._xrSession.requestReferenceSpace("viewer");
            this._hitTestSource = await (null === (r = (e = this._xrSession).requestHitTestSource) || void 0 === r ? void 0 : r.call(e, {
              space: n,
              offsetRay: t
            }));
          }
          this._xrSession && (await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._xrManager, this._placementBox));
        })();
      }, this._xrSessionEnd = () => {
        var e;
        console.log("webxr: AR session end"), this._frameCount = 0, null === (e = this._xrSession) || void 0 === e || e.removeEventListener("end", this._xrSessionEnd), this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._restorePreXRState(), this._viewer.resize());
      };
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = e.renderer.rendererObject.xr;
      t.enabled = !0, t.cameraAutoUpdate = !1, this._xrManager = t;
      const r = document.getElementById("tweakpaneUiContainer"),
        n = r ? {
          root: r
        } : void 0;
      document.body.appendChild(class {
        static createButton(e, t = {}) {
          const r = document.createElement("button");
          function n() {
            r.style.display = "", r.style.cursor = "auto", r.style.left = "calc(50% - 75px)", r.style.width = "150px", r.onmouseenter = null, r.onmouseleave = null, r.onclick = null;
          }
          function i(e) {
            e.style.position = "absolute", e.style.bottom = "20px", e.style.padding = "12px 6px", e.style.border = "1px solid #fff", e.style.borderRadius = "4px", e.style.background = "rgba(0,0,0,0.1)", e.style.color = "#fff", e.style.font = "normal 13px sans-serif", e.style.textAlign = "center", e.style.opacity = "0.5", e.style.outline = "none", e.style.zIndex = "999";
          }
          if ("xr" in navigator) return r.id = "ARButton", r.style.display = "none", i(r), navigator.xr.isSessionSupported("immersive-ar").then(function (i) {
            i ? function () {
              if (void 0 === t.domOverlay) {
                const e = document.createElement("div");
                e.style.display = "none", document.body.appendChild(e);
                const r = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                r.setAttribute("width", 38), r.setAttribute("height", 38), r.style.position = "absolute", r.style.right = "20px", r.style.top = "20px", r.addEventListener("click", function () {
                  n.end();
                }), e.appendChild(r);
                const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
                i.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), i.setAttribute("stroke", "#fff"), i.setAttribute("stroke-width", 2), r.appendChild(i), void 0 === t.optionalFeatures && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
                  root: e
                };
              }
              let n = null;
              async function i(i) {
                i.addEventListener("end", s), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(i), r.textContent = "STOP AR", t.domOverlay.root.style.display = "", n = i;
              }
              function s() {
                n.removeEventListener("end", s), r.textContent = "START AR", t.domOverlay.root.style.display = "none", n = null;
              }
              r.style.display = "", r.style.cursor = "pointer", r.style.left = "calc(50% - 50px)", r.style.width = "100px", r.textContent = "START AR", r.onmouseenter = function () {
                r.style.opacity = "1.0";
              }, r.onmouseleave = function () {
                r.style.opacity = "0.5";
              }, r.onclick = function () {
                null === n ? navigator.xr.requestSession("immersive-ar", t).then(i) : n.end();
              };
            }() : (n(), r.textContent = "AR NOT SUPPORTED");
          }).catch(function (e) {
            n(), console.warn("Exception when trying to call xr.isSessionSupported", e), r.textContent = "AR NOT ALLOWED";
          }), r;
          {
            const e = document.createElement("a");
            return !1 === window.isSecureContext ? (e.href = document.location.href.replace(/^http:/, "https:"), e.innerHTML = "WEBXR NEEDS HTTPS") : (e.href = "https://immersiveweb.dev/", e.innerHTML = "WEBXR NOT AVAILABLE"), e.style.left = "calc(50% - 90px)", e.style.width = "180px", e.style.textDecoration = "none", i(e), e;
          }
        }
      }.createButton(e.renderer.rendererObject, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: n
      })), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame);
    }
    _updateShadow() {
      if (!this._viewer) return;
      const e = this._viewer.scene.modelRoot,
        t = this._viewer.getPluginByType("Ground");
      t && (t.groundReflection = !1, t.mesh.modelObject.position.copy(this._preXRState.groundOffset).multiplyScalar(e.modelObject.scale.x).sub(e.modelObject.position).negate(), t.mesh.modelObject.scale.setScalar(e.modelObject.scale.x * this._preXRState.groundScale));
    }
    moveToFloor(e) {
      if (!this._dirty || !this._hitTestSource || !this._xrManager) return;
      const t = e.getHitTestResults(this._hitTestSource);
      if (!t.length) return;
      const r = t[0],
        n = this._touchInputHelper.getHitPoint(r);
      n && (this._placementBox.show = !0, this._viewer.scene.modelRoot, this.placeOnWall ? this._touchInputHelper.goalPosition.copy(n) : this._touchInputHelper.goalPosition.y = n.y, this._hitTestSource.cancel(), this._hitTestSource = void 0, console.log("move to initial hit point", n));
    }
    _removePlacementBox() {
      this._placementBox && (this._placementBox.dispose(), this._placementBox = void 0);
    }
    _preSetupModel() {
      var e;
      const t = this._viewer.scene.modelRoot,
        r = this._viewer.scene.activeCamera,
        i = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera(),
        s = i.cameras[0] || i;
      this._removePlacementBox();
      const o = this._viewer.scene.getBounds(!0, !0);
      o.getSize(new n.Pa4()).length() > .01 && (this._placementBox = new Py(o, i, this.placeOnWall), t.add(this._placementBox), this._placementBox.show = !1);
      const a = i.getWorldDirection(new n.Pa4());
      t.rotation.y = Math.atan2(-a.x, -a.z) - 0, r.cameraObject.zoom = s.zoom, r.cameraObject.near = s.near, r.cameraObject.far = s.far, r.cameraObject.isPerspectiveCamera ? (r.cameraObject.fov = s.fov, r.cameraObject.aspect = s.viewport.width / s.viewport.height) : console.warn("Perspective camera required."), r.cameraObject.updateProjectionMatrix(), t.position.set(0, 0, 0);
      const l = t.userData.arScale || 1;
      t.scale.set(l, l, l), t.position.copy(i.position).add(a.multiplyScalar(5)), t.visible = !0, this._viewer.setBackground(null);
    }
    _restorePreXRState() {
      if (!this._viewer) return;
      this._viewer.setBackground(this._preXRState.viewerBg), this._preXRState.viewerBg = null;
      const e = this._viewer.scene.modelRoot;
      e.scale.copy(this._preXRState.modelScale), e.position.copy(this._preXRState.modelPosition), e.quaternion.copy(this._preXRState.modelRotation), e.updateMatrix(), e.updateMatrixWorld(!0), e.visible = !0;
      const t = this._viewer.scene.activeCamera;
      t.position.copy(this._preXRState.cameraPosition), t.target.copy(this._preXRState.cameraTarget), t.cameraObject.up.copy(this._preXRState.cameraUp), t.cameraObject.near = this._preXRState.cameraNear, t.cameraObject.far = this._preXRState.cameraFar, t.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (t.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (t.cameraObject.aspect = this._preXRState.cameraAspect)), t.positionUpdated(!1), t.targetUpdated(!0), t.cameraObject.updateMatrixWorld(!0), t.cameraObject.updateProjectionMatrix();
    }
    _cancelHitSources() {
      this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel();
    }
  }
  By.PluginType = "WEBXR_ARPlugin";
  const Ry = new c({
    vertexShader: i.vertexShader,
    fragmentShader: "\n    uniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\t// gl_FragColor = vec4(1,0,1,1);\n\t\t\tgl_FragColor = texel;\n\n\t\t}\n\t\t",
    uniforms: i.uniforms
  });
  async function Ly(e, t) {
    if (e.createWriter) {
      const r = await e.createWriter();
      return await r.write(0, t), void (await r.close());
    }
    const r = await e.createWritable();
    await r.write(t), await r.close();
  }
  async function Oy(e, t) {
    const r = {};
    return t && (r.writable = !0, r.mode = "readwrite"), "granted" === (await e.queryPermission(r)) || "granted" === (await e.requestPermission(r));
  }
  Ry.renderToScreen = !1, Ry.useExistingRenderTarget = !0, Ry.clear = !1;
  class Fy extends r {
    constructor(e, t) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = !1, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = e => {
        var t;
        if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
          const e = new Blob(this._currentRecording, {
            type: this._options.mimeType
          });
          null === (t = this._recordingCallback) || void 0 === t || t.call(this, e);
        } else this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);
        this._recorder = void 0, this.dispatchEvent({
          type: "stop"
        });
      }, this._onstart = e => {
        var t;
        this._state = "recording", this._frameCount = 0, this.dispatchEvent({
          type: "start"
        }), this.stepMode && (null === (t = this._recorder) || void 0 === t || t.pause());
      }, this._onresume = e => {
        if (!this.stepMode) return;
        const t = () => {
            var e;
            "recording" === this._state && (null === (e = this._recorder) || void 0 === e || e.pause());
          },
          r = Math.min(this._resumeSyncTime - Dt(), 0) + 1e3 / this._options.frameRate;
        r > 0 ? Dc(r).then(t) : t();
      }, this._onpause = e => {}, this._ondataavailable = e => {
        e.data && e.data.size > 0 && this._currentRecording.push(e.data);
      }, this._onerror = e => {
        this._state = "error", this._console.error(e), this.dispatchEvent({
          type: "error",
          error: e
        }), this._recorder = void 0;
      }, this._canvas = e;
      const r = null == t ? void 0 : t.mimeType;
      this._options = {
        mimeType: r || "auto",
        frameRate: 30
      }, this._setOptions(t || this._options);
    }
    _setOptions(e) {
      var t, r;
      Object.assign(this._options, e), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t = Fy.GetSupportedMimeTypes([], ["h264"], !0)) && void 0 !== t ? t : Fy.GetSupportedMimeTypes(void 0, void 0, !0)), this._options.mimeType && !(null === (r = this._options.mimeType) || void 0 === r ? void 0 : r.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"));
    }
    setOptions(e) {
      this._setOptions(e);
    }
    isRecording() {
      return "recording" === this._state;
    }
    start() {
      var e, t, r;
      if ("recording" === this._state) return void this._console.log("Already recording canvas");
      if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder) return "paused" === this._state ? (this.dispatchEvent({
        type: "starting"
      }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
      if ("paused" === this._state) return this.dispatchEvent({
        type: "starting"
      }), void (this._state = "recording");
      const n = {
        mimeType: this._options.mimeType,
        videoBitsPerSecond: this._options.videoBitsPerSecond
      };
      if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e = n.mimeType) || void 0 === e ? void 0 : e.startsWith("video")) {
        if (!window.MediaRecorder) return this._console.error("MediaRecorder not supported, use image sequence"), void (this._state = "error");
        {
          const e = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate),
            r = null === (t = e.getVideoTracks()) || void 0 === t ? void 0 : t[0];
          this._track = r, this._recorder = new window.MediaRecorder(e, n), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }
      this.dispatchEvent({
        type: "starting"
      }), this._recorder ? (this._state = "recording", null === (r = this._recorder) || void 0 === r || r.start()) : window.showDirectoryPicker && window.showDirectoryPicker().then(async e => {
        const t = await (null == e ? void 0 : e.getDirectoryHandle("i-" + Math.floor(Date.now()), {
          create: !0
        }));
        this._imgDirectory = t, this._state = "recording", this._onstart({});
      }).catch(e => {
        this._onerror({
          detail: e
        });
      });
    }
    async requestFrame() {
      if ("recording" !== this._state) return;
      this._frameCount++;
      const e = this._options.mimeType;
      if (!this._recorder && e.startsWith("image/")) {
        const t = this._canvas.toDataURL(e, 90);
        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e.includes("png") ? ".png" : ".jpg"), t]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []);
      }
      this._recorder && this._track && this.stepMode && (this._resumeSyncTime = Dt(), this._track.requestFrame(), this._recorder.resume());
    }
    pause() {
      "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused");
    }
    stop(e) {
      "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e, this.dispatchEvent({
        type: "stopping"
      }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }
    get state() {
      return this._state;
    }
    dispose() {
      this._recorder && "error" !== this._state ? this.stop(e => {
        this._console.warn("disposed with blob", e), this.dispose();
      }) : this._recorder = void 0;
    }
    async _writeImages(e) {
      if (!this._imgDirectory) return;
      const t = await Promise.all(e.map(async ([e, t]) => await (await fetch(t)).blob())),
        r = [];
      for (let n = 0; n < e.length; n++) {
        const i = await this._imgDirectory.getFileHandle(e[n][0], {
          create: !0
        });
        r.push(Ly(i, t[n]));
      }
      await Promise.all(r);
    }
    static GetSupportedMimeTypes(e, t, r = !1) {
      if (!window.MediaRecorder) return r ? void 0 : [];
      const n = ["webm", "ogg", "mp4", "x-matroska"].filter(t => !e || e.length < 1 || e.includes(t)),
        i = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter(e => !t || t.length < 1 || t.includes(e)),
        s = [];
      return n.forEach(e => {
        const t = `video/${e}`;
        i.forEach(e => {
          [`${t};codecs=${e}`, `${t};codecs:${e}`, `${t};codecs=${e.toUpperCase()}`, `${t};codecs:${e.toUpperCase()}`, `${t}`].forEach(e => {
            MediaRecorder.isTypeSupported(e) && s.push(e);
          });
        });
      }), r ? s.length > 0 ? s[0] : void 0 : s;
    }
  }
  var Uy = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class Ny extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.convergeMode = !1, this.mimeType = "auto", this.videoFrameRate = 30, this._renderToScreenDisabled = !1, this._preRender = () => {
        var e, t, r;
        if (this.convergeMode && (null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording())) {
          const e = this._viewer.renderer.composer.renderToScreen;
          this._viewer.renderer.composer.renderToScreen = (null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Progressive")) || void 0 === r ? void 0 : r.isConverged()) || !1, e && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = !0);
        }
      }, this._postRender = () => {
        var e, t, r;
        if ((null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && (!this.convergeMode || (null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Progressive")) || void 0 === r ? void 0 : r.isConverged(!0)))) {
          const e = () => {
            var e;
            return null === (e = this._recorder) || void 0 === e ? void 0 : e.requestFrame();
          };
          this.convergeMode ? Dc(1).then(e) : e();
        }
        this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = !0);
      };
    }
    get recorder() {
      return this._recorder;
    }
    isRecording() {
      var e, t;
      return null !== (t = null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && void 0 !== t && t;
    }
    refreshRecorderOptions() {
      this._recorder && (this._recorder.setOptions({
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), this._recorder.stepMode = this.convergeMode);
    }
    async onAdded(e) {
      await super.onAdded(e), this._recorder = new Fy(e.canvas, {
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), this._recorder.addEventListener("starting", () => this._stateChange(!1)), this._recorder.addEventListener("start", () => {
        this.dispatchEvent({
          type: "start"
        }), this._stateChange(!this.convergeMode);
      }), this._recorder.addEventListener("error", () => {
        this.dispatchEvent({
          type: "error"
        });
      }), this._recorder.addEventListener("pause", () => this._stateChange(!1)), this._recorder.addEventListener("resume", () => this._stateChange(!this.convergeMode)), this._recorder.addEventListener("stop", () => {
        this.dispatchEvent({
          type: "stop"
        }), this._stateChange(!1);
      });
    }
    _stateChange(e) {
      var t, r, n;
      this.dirty = e, null === (t = this._viewer) || void 0 === t || t.setDirty(), null === (n = null === (r = this._uiConfig) || void 0 === r ? void 0 : r.children) || void 0 === n || n.map(e => A(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }
    async onRemove(e) {
      var t;
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("preRender", this._postRender), null === (t = this._recorder) || void 0 === t || t.dispose(), super.onRemove(e);
    }
    startRecording() {
      var e;
      return !!this.enabled && !1 === (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) && (this.recorder.stepMode = this.convergeMode, this.recorder.start(), !0);
    }
    async stopRecording() {
      var e;
      if (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) return new Promise((e, t) => {
        var r;
        return null === (r = this.recorder) || void 0 === r ? void 0 : r.stop(e);
      });
    }
    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
      const e = this;
      return this._uiConfig = {
        type: "folder",
        label: "Video Export",
        children: [{
          type: "slider",
          label: "Frame Rate",
          bounds: [1, 60],
          stepSize: 1,
          property: [this, "videoFrameRate"]
        }, {
          type: "checkbox",
          limitedUi: !0,
          property: [this, "convergeMode"]
        }, {
          type: "dropdown",
          label: "Mime type",
          limitedUi: !0,
          property: [this, "mimeType"],
          children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "input",
          disabled: !0,
          label: "State",
          limitedUi: !0,
          get value() {
            var t, r;
            return null !== (r = null === (t = e.recorder) || void 0 === t ? void 0 : t.state) && void 0 !== r ? r : "not initialized";
          },
          set value(e) {}
        }, {
          type: "button",
          get label() {
            var t;
            return (null === (t = e.recorder) || void 0 === t ? void 0 : t.isRecording()) ? "Stop" : "Start";
          },
          value: () => {
            var t;
            (null === (t = e.recorder) || void 0 === t ? void 0 : t.isRecording()) ? this.stopRecording().then(e => {
              if (e) {
                console.log(e);
                const t = e.type.split(";")[0].split("/").pop() || "mp4";
                yt(e, "test." + t);
              }
            }) : this.startRecording();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views",
          hidden: () => {
            var t, r;
            return !!(null === (t = e.recorder) || void 0 === t ? void 0 : t.isRecording()) || !(null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("CameraViews"));
          },
          value: () => {
            var e, t;
            null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("CameraViews")) || void 0 === t || t.recordAllViews();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views + GLTF Anim",
          hidden: () => {
            var t, r, n, i;
            return !!(null === (t = e.recorder) || void 0 === t ? void 0 : t.isRecording()) || !(null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("CameraViews")) || !(null === (i = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("GLTFAnimation")) || void 0 === i ? void 0 : i.animations.length);
          },
          value: () => {
            var e, t, r, n;
            const i = "playing" === (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t ? void 0 : t.animationState);
            null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("CameraViews")) || void 0 === n || n.recordAllViews(() => {
              var e, t;
              null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.playAnimation();
            }).then(() => {
              var e, t;
              i || null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.stopAnimation();
            });
          }
        }]
      };
    }
  }
  Ny.PluginType = "CanvasRecorder", Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "convergeMode", void 0), Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "mimeType", void 0), Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "videoFrameRate", void 0);
  var jy = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const zy = new n.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      h: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  zy.depthTest = !1;
  const Gy = new n.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      v: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  Gy.depthTest = !1;
  class Vy extends fu {
    constructor(e = {}, t = !1) {
      super(e), this.contactShadows = !0, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new n.iKG(-1, 1, 1, -1, .001, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t, t && this.dependencies.push(Yc);
    }
    async onAdded(e) {
      const t = e.renderer.createTarget({
        type: n.ywz,
        format: n.wk1,
        encoding: n.rnI,
        size: {
          width: 512,
          height: 512
        },
        generateMipmaps: !1,
        depthBuffer: !0,
        minFilter: n.wem,
        magFilter: n.wem
      });
      t.texture.name = "groundContactDepthTexture";
      const r = new n.lRF({
        depthPacking: n.z81
      });
      r.onBeforeCompile = function (e) {
        e.uniforms.opacity.value = 1, e.fragmentShader = `\n\t\t\t\t\t\t${e.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}\n\t\t\t\t\t`;
      };
      const i = new ao(t, r);
      this._depthPass = i, await super.onAdded(e);
    }
    _postFrame() {
      super._postFrame(), this._viewer;
    }
    _preRender() {
      if (super._preRender(), !this._viewer) return;
      if (!this._depthPass) return;
      this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject);
      const e = this._viewer.renderer.getTempTarget({
        type: n.ywz,
        format: n.wk1,
        encoding: n.rnI,
        size: {
          width: 1024,
          height: 1024
        },
        generateMipmaps: !1,
        depthBuffer: !1,
        minFilter: n.wem,
        magFilter: n.wem
      });
      this._blurShadow(e), this._blurShadow(e, .4), this._viewer.renderer.releaseTempTarget(e);
    }
    _blurShadow(e, t = 1) {
      this._viewer && this._depthPass && (zy.uniforms.h.value = t * this.blurAmount / 256, Gy.uniforms.v.value = t * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e, {
        material: zy,
        clear: !0
      }), this._viewer.renderer.blit(e.texture, this._depthPass.target, {
        material: Gy,
        clear: !0
      }));
    }
    async onDispose(e) {
      return super.onDispose(e);
    }
    async onRemove(e) {
      return super.onRemove(e);
    }
    _refreshTransform() {
      super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new n.Pa4())), this.shadowCamera.setRotationFromEuler(new n.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size);
    }
    _refreshShadowCameraFrustum() {
      this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
    }
    _setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    _removeMaterial() {
      this._material && super._removeMaterial();
    }
    refreshOptions() {
      this._viewer && super.refreshOptions();
    }
    _refreshMaterial() {
      var e;
      if (!this._viewer) return !1;
      const t = super._refreshMaterial();
      return this._material ? (this._material.alphaMap = (null === (e = this._depthPass) || void 0 === e ? void 0 : e.target.texture) || null, t && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = !0, this._material.materialObject.userData.ssreflDisabled = !0, this._material.materialObject.userData.ssreflNonPhysical = !1), t) : t;
    }
    _extraUiConfig() {
      return [{
        label: "Contact Shadows",
        type: "checkbox",
        property: [this, "contactShadows"]
      }, {
        label: "Shadow Scale",
        type: "slider",
        bounds: [0, 2],
        property: [this, "shadowScale"]
      }, {
        label: "Shadow Height",
        type: "slider",
        bounds: [0, 20],
        property: [this, "shadowHeight"]
      }, {
        label: "Blur Amount",
        type: "slider",
        bounds: [0, 10],
        property: [this, "blurAmount"]
      }, ...super._extraUiConfig()];
    }
  }
  Vy.PluginType = "ContactShadowGroundPlugin", jy([M(Vy.prototype.refreshOptions), Ce()], Vy.prototype, "contactShadows", void 0), jy([Ce(), M(Vy.prototype._setDirty)], Vy.prototype, "blurAmount", void 0), jy([Ce(), M(Vy.prototype._refreshShadowCameraFrustum)], Vy.prototype, "shadowScale", void 0), jy([Ce(), M(Vy.prototype._refreshShadowCameraFrustum)], Vy.prototype, "shadowHeight", void 0);
  const Qy = new n.cPb(45, 1, .1, 1e3);
  function Hy(e, t, r, i = 7, s = new n.Pa4(0, 0, 1.5)) {
    r = null != r ? r : e.scene.modelObject;
    const o = new k().expandByObject(null != r ? r : t, !0, !0),
      a = o.getCenter(new n.Pa4()),
      l = o.getSize(new n.Pa4());
    Qy.position.copy(a).add(s.clone().multiplyScalar(Math.max(l.x, l.y, l.z))), Qy.lookAt(a), t && t.traverseVisible(e => {
      e.layers.enable(i);
    }), i > 0 ? Qy.layers.set(i) : Qy.layers.enableAll();
    const c = null == t ? void 0 : t.visible;
    t && (t.visible = !0), e.renderer.rendererObject.setRenderTarget(null), e.renderer.rendererObject.render(r, Qy);
    const u = e.renderer.rendererObject.domElement.toDataURL("image/png");
    return t && (t.visible = c, t.traverseVisible(e => {
      e.layers.disable(i);
    }), Qy.layers.enableAll()), e.setDirty(), u;
  }
  class Wy {
    constructor(e) {
      this.viewer = e, this._lights = [], this.shapes = {
        sphere: new n.Kj0(new n.xo$(1)),
        cube: new n.Kj0(new n.DvJ(1, 1, 1)),
        cylinder: new n.Kj0(new n.fHI(.5, .5, 1))
      };
      const t = new n.xsS();
      this._channel = 7;
      const r = new n.vmT(16777215, 4473924, 1);
      r.position.set(0, 10, 0), r.layers.set(this._channel), t.add(r), this._lights.push(r), this._scene = t;
    }
    dispose() {
      [...this._lights].forEach(e => e.dispose()), Object.values(this.shapes).forEach(e => {
        e.geometry && e.geometry.dispose();
      });
    }
    generate(e, t = "sphere") {
      const r = this.shapes[t] || new n.Kj0(new n.xo$(1));
      r.material = e.materialObject, r.geometry.attributes.tangent || r.geometry.computeTangents(), this._scene.add(r), this._scene.environment = this.viewer.scene.getEnvironment();
      const i = r.material.envMapIntensity;
      "number" == typeof i && (r.material.envMapIntensity = Math.max(i, 2));
      const s = Hy(this.viewer, r, this._scene, this._channel, new n.Pa4(0, 0, 1.5));
      return "number" == typeof i && (r.material.envMapIntensity = i), this._scene.remove(r), r.material = void 0, s;
    }
  }
  class qy extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
      }, this.dependencies = [to], this.variations = [], this._selectedMaterial = () => {
        var e, t;
        return (null === (t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0 === t ? void 0 : t.material) || void 0;
      }, this.uiConfig = {
        label: "Material Configurator",
        type: "folder",
        children: [() => {
          var e;
          return [{
            type: "input",
            label: "uuid",
            property: [this._selectedMaterial(), "uuid"],
            hidden: () => !this._selectedMaterial(),
            disabled: !0
          }, {
            type: "input",
            label: "title",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "title"],
            onChange: async () => this.refreshUi()
          }, {
            type: "dropdown",
            label: "Preview Type",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "preview"],
            onChange: async () => this.refreshUi(),
            children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Xt).filter(e => e.endsWith("Map"))].map(e => ({
              label: e,
              value: e
            }))
          }, ...((null === (e = this.getSelectedVariation()) || void 0 === e ? void 0 : e.materials.map(e => e.uiConfig ? Object.assign(e.uiConfig, {
            expanded: !1
          }) : {})) || []), {
            type: "button",
            label: "Remove All",
            hidden: () => !this._selectedMaterial(),
            value: async () => {
              const e = this.getSelectedVariation();
              e && (await this._viewer.confirm("Material configurator: Remove all variations for this material?")) && (e.materials = []), this.refreshUi();
            }
          }, {
            type: "button",
            label: "Remove Variation",
            hidden: () => !this._selectedMaterial(),
            value: async () => {
              const e = this.getSelectedVariation();
              e && (await this._viewer.confirm("Material configurator: Remove this variation?")) && this.removeVariation(e);
            }
          }, {
            type: "button",
            label: "Add Variation",
            hidden: () => !this._selectedMaterial(),
            value: () => this.addVariation(this._selectedMaterial())
          }, {
            type: "button",
            label: "Refresh Ui",
            value: () => this.refreshUi()
          }];
        }]
      };
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new Wy(this._viewer), null === (r = this._picking) || void 0 === r || r.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }
    fromJSON(e, t) {
      return this.variations = [], super.fromJSON(e, t);
    }
    async onRemove(e) {
      var t, r;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (r = this._picking) || void 0 === r || r.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }
    findVariation(e) {
      return e ? this.variations.find(t => t.uuid === e) : void 0;
    }
    getSelectedVariation() {
      var e, t;
      return this.findVariation(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid) || this.findVariation(null === (t = this._selectedMaterial()) || void 0 === t ? void 0 : t.name);
    }
    applyVariation(e, t) {
      var r, n;
      const i = e.materials.find(e => e.uuid === t);
      if (i) {
        const t = null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.getManager()) || void 0 === n ? void 0 : n.materials;
        let s = null == t ? void 0 : t.findMaterialsByName(e.uuid);
        (!s || s.length < 1) && (s = [null == t ? void 0 : t.findMaterial(e.uuid)]), s.forEach(e => {
          if (!e) return;
          const t = e.name;
          e.copyProps(i), e.name = t;
        });
      }
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }
    async _refreshUi() {
      return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = !1, this._refreshUiConfig(), 0));
    }
    removeVariationForMaterial(e) {
      let t = this.findVariation(e.uuid);
      !t && e.name.length > 0 && (t = this.findVariation(e.name)), t && this.removeVariation(t);
    }
    removeVariation(e) {
      e && (this.variations.splice(this.variations.indexOf(e), 1), this.refreshUi());
    }
    addVariation(e) {
      var t;
      const r = null === (t = null == e ? void 0 : e.clone) || void 0 === t ? void 0 : t.call(e);
      if (e && r) {
        let t = this.findVariation(e.uuid);
        !t && e.name.length > 0 && (t = this.findVariation(e.name)), t || this.variations.push(t = {
          uuid: e.name.length > 0 ? e.name : e.uuid,
          title: "Name",
          preview: "generate:sphere",
          materials: []
        }), t.materials.push(r), this.refreshUi();
      }
    }
  }
  qy.PluginType = "MaterialConfiguratorBasePlugin", function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Ce()], qy.prototype, "variations", void 0);
  const Xy = (e, t = !0) => {
      const r = new Ae().set(e);
      return t && r.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${r.getHexString()}'/%3E%3C/svg%3E%0A`;
    },
    Yy = (e, t = !0) => {
      const r = new Ae().set(e);
      return t && r.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${r.getHexString()}'/%3E%3C/svg%3E%0A`;
    },
    Ky = e => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e}%3C/text%3E%3C/svg%3E%0A`,
    Jy = async (e, t) => Ot(await Ct(e), t),
    Zy = async (e, t) => await Jy(e, t).then(e => e.toDataURL("image/png"));
  class $y {
    static _initialize() {
      this._inited = !0, Mt(E`
  .customContextGrid {
    background: #28223C;
    //backdrop-filter: blur(8px);
    border: 0.5px solid rgba(220, 220, 220, 0.3);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);

    color: white;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }
  .customContextGridItems:hover {
    color: white;
    background-color: #017AFF;
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 0.12rem;
    font-size: 0.85rem;
  }

        `);
    }
    static Create(e, t, r, n, i, s, o) {
      var a;
      this._inited || this._initialize();
      const l = Pt(),
        c = l ? .15 : .25,
        u = l ? 1.5 : 2.5,
        h = St({
          classList: ["customContextGrid"],
          addToBody: !1,
          innerHTML: `\n            <div class="customContextGridHeading"> ${t} </div>\n            `
        });
      h.style.top = i + "px", h.style.left = n + "px", h.style.gap = c + "rem", h.style.width = (u + c) * r - c + "rem", h.dataset.tag = e;
      for (const e of s) {
        const t = St({
          classList: ["customContextGridItems"],
          addToBody: !1,
          innerHTML: `\n            <img src="${e.image}" class="customContextGridItemImage">\n            `
        });
        t.style.width = u + "rem", t.style.height = u + "rem", h.appendChild(t), t.onclick = () => {
          var t;
          return null === (t = e.onClick) || void 0 === t ? void 0 : t.call(e, e.id);
        }, o(t, e);
      }
      return null === (a = this.Elements) || void 0 === a || a.push(h), h;
    }
    static RemoveAll(e) {
      if (e) {
        const t = this.Elements.filter(t => t.dataset.tag === e);
        for (const e of t) e.remove();
        this.Elements = this.Elements.filter(t => t.dataset.tag !== e);
      } else {
        for (const e of this.Elements) e.remove();
        this.Elements = [];
      }
    }
    static RebuildUi(e) {
      if (0 === this.Elements.length) return;
      e || (e = document.body);
      for (const e of this.Elements) e.remove();
      let t = 20;
      for (const r of this.Elements) r.style.top = t + "px", e.appendChild(r), t += r.clientHeight + 20;
    }
  }
  function ex(e) {
    if (null == e) return window;
    if ("[object Window]" !== e.toString()) {
      var t = e.ownerDocument;
      return t && t.defaultView || window;
    }
    return e;
  }
  function tx(e) {
    return e instanceof ex(e).Element || e instanceof Element;
  }
  function rx(e) {
    return e instanceof ex(e).HTMLElement || e instanceof HTMLElement;
  }
  function nx(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof ex(e).ShadowRoot || e instanceof ShadowRoot);
  }
  $y.Elements = [], $y._inited = !1;
  var ix = Math.max,
    sx = Math.min,
    ox = Math.round;
  function ax(e, t) {
    void 0 === t && (t = !1);
    var r = e.getBoundingClientRect(),
      n = 1,
      i = 1;
    if (rx(e) && t) {
      var s = e.offsetHeight,
        o = e.offsetWidth;
      o > 0 && (n = ox(r.width) / o || 1), s > 0 && (i = ox(r.height) / s || 1);
    }
    return {
      width: r.width / n,
      height: r.height / i,
      top: r.top / i,
      right: r.right / n,
      bottom: r.bottom / i,
      left: r.left / n,
      x: r.left / n,
      y: r.top / i
    };
  }
  function lx(e) {
    var t = ex(e);
    return {
      scrollLeft: t.pageXOffset,
      scrollTop: t.pageYOffset
    };
  }
  function cx(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }
  function ux(e) {
    return ((tx(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }
  function hx(e) {
    return ax(ux(e)).left + lx(e).scrollLeft;
  }
  function px(e) {
    return ex(e).getComputedStyle(e);
  }
  function dx(e) {
    var t = px(e),
      r = t.overflow,
      n = t.overflowX,
      i = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(r + i + n);
  }
  function fx(e, t, r) {
    void 0 === r && (r = !1);
    var n,
      i,
      s = rx(t),
      o = rx(t) && function (e) {
        var t = e.getBoundingClientRect(),
          r = ox(t.width) / e.offsetWidth || 1,
          n = ox(t.height) / e.offsetHeight || 1;
        return 1 !== r || 1 !== n;
      }(t),
      a = ux(t),
      l = ax(e, o),
      c = {
        scrollLeft: 0,
        scrollTop: 0
      },
      u = {
        x: 0,
        y: 0
      };
    return (s || !s && !r) && (("body" !== cx(t) || dx(a)) && (c = (n = t) !== ex(n) && rx(n) ? {
      scrollLeft: (i = n).scrollLeft,
      scrollTop: i.scrollTop
    } : lx(n)), rx(t) ? ((u = ax(t, !0)).x += t.clientLeft, u.y += t.clientTop) : a && (u.x = hx(a))), {
      x: l.left + c.scrollLeft - u.x,
      y: l.top + c.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }
  function mx(e) {
    var t = ax(e),
      r = e.offsetWidth,
      n = e.offsetHeight;
    return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: r,
      height: n
    };
  }
  function _x(e) {
    return "html" === cx(e) ? e : e.assignedSlot || e.parentNode || (nx(e) ? e.host : null) || ux(e);
  }
  function gx(e) {
    return ["html", "body", "#document"].indexOf(cx(e)) >= 0 ? e.ownerDocument.body : rx(e) && dx(e) ? e : gx(_x(e));
  }
  function vx(e, t) {
    var r;
    void 0 === t && (t = []);
    var n = gx(e),
      i = n === (null == (r = e.ownerDocument) ? void 0 : r.body),
      s = ex(n),
      o = i ? [s].concat(s.visualViewport || [], dx(n) ? n : []) : n,
      a = t.concat(o);
    return i ? a : a.concat(vx(_x(o)));
  }
  function Ax(e) {
    return ["table", "td", "th"].indexOf(cx(e)) >= 0;
  }
  function bx(e) {
    return rx(e) && "fixed" !== px(e).position ? e.offsetParent : null;
  }
  function yx(e) {
    for (var t = ex(e), r = bx(e); r && Ax(r) && "static" === px(r).position;) r = bx(r);
    return r && ("html" === cx(r) || "body" === cx(r) && "static" === px(r).position) ? t : r || function (e) {
      var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && rx(e) && "fixed" === px(e).position) return null;
      var r = _x(e);
      for (nx(r) && (r = r.host); rx(r) && ["html", "body"].indexOf(cx(r)) < 0;) {
        var n = px(r);
        if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || t && "filter" === n.willChange || t && n.filter && "none" !== n.filter) return r;
        r = r.parentNode;
      }
      return null;
    }(e) || t;
  }
  var xx = "top",
    wx = "bottom",
    Ex = "right",
    Sx = "left",
    Cx = "auto",
    Mx = [xx, wx, Ex, Sx],
    Tx = "start",
    Ix = "end",
    kx = "clippingParents",
    Dx = "viewport",
    Px = "popper",
    Bx = "reference",
    Rx = Mx.reduce(function (e, t) {
      return e.concat([t + "-" + Tx, t + "-" + Ix]);
    }, []),
    Lx = [].concat(Mx, [Cx]).reduce(function (e, t) {
      return e.concat([t, t + "-" + Tx, t + "-" + Ix]);
    }, []),
    Ox = "beforeRead",
    Fx = "read",
    Ux = "afterRead",
    Nx = "beforeMain",
    jx = "main",
    zx = "afterMain",
    Gx = "beforeWrite",
    Vx = "write",
    Qx = "afterWrite",
    Hx = [Ox, Fx, Ux, Nx, jx, zx, Gx, Vx, Qx];
  function Wx(e) {
    var t = new Map(),
      r = new Set(),
      n = [];
    function i(e) {
      r.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
        if (!r.has(e)) {
          var n = t.get(e);
          n && i(n);
        }
      }), n.push(e);
    }
    return e.forEach(function (e) {
      t.set(e.name, e);
    }), e.forEach(function (e) {
      r.has(e.name) || i(e);
    }), n;
  }
  var qx = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Xx() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return !t.some(function (e) {
      return !(e && "function" == typeof e.getBoundingClientRect);
    });
  }
  function Yx(e) {
    void 0 === e && (e = {});
    var t = e,
      r = t.defaultModifiers,
      n = void 0 === r ? [] : r,
      i = t.defaultOptions,
      s = void 0 === i ? qx : i;
    return function (e, t, r) {
      void 0 === r && (r = s);
      var i,
        o,
        a = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, qx, s),
          modifiersData: {},
          elements: {
            reference: e,
            popper: t
          },
          attributes: {},
          styles: {}
        },
        l = [],
        c = !1,
        u = {
          state: a,
          setOptions: function (r) {
            var i = "function" == typeof r ? r(a.options) : r;
            h(), a.options = Object.assign({}, s, a.options, i), a.scrollParents = {
              reference: tx(e) ? vx(e) : e.contextElement ? vx(e.contextElement) : [],
              popper: vx(t)
            };
            var o,
              c,
              p = function (e) {
                var t = Wx(e);
                return Hx.reduce(function (e, r) {
                  return e.concat(t.filter(function (e) {
                    return e.phase === r;
                  }));
                }, []);
              }((o = [].concat(n, a.options.modifiers), c = o.reduce(function (e, t) {
                var r = e[t.name];
                return e[t.name] = r ? Object.assign({}, r, t, {
                  options: Object.assign({}, r.options, t.options),
                  data: Object.assign({}, r.data, t.data)
                }) : t, e;
              }, {}), Object.keys(c).map(function (e) {
                return c[e];
              })));
            return a.orderedModifiers = p.filter(function (e) {
              return e.enabled;
            }), a.orderedModifiers.forEach(function (e) {
              var t = e.name,
                r = e.options,
                n = void 0 === r ? {} : r,
                i = e.effect;
              if ("function" == typeof i) {
                var s = i({
                  state: a,
                  name: t,
                  instance: u,
                  options: n
                });
                l.push(s || function () {});
              }
            }), u.update();
          },
          forceUpdate: function () {
            if (!c) {
              var e = a.elements,
                t = e.reference,
                r = e.popper;
              if (Xx(t, r)) {
                a.rects = {
                  reference: fx(t, yx(r), "fixed" === a.options.strategy),
                  popper: mx(r)
                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (e) {
                  return a.modifiersData[e.name] = Object.assign({}, e.data);
                });
                for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {
                  var i = a.orderedModifiers[n],
                    s = i.fn,
                    o = i.options,
                    l = void 0 === o ? {} : o,
                    h = i.name;
                  "function" == typeof s && (a = s({
                    state: a,
                    options: l,
                    name: h,
                    instance: u
                  }) || a);
                } else a.reset = !1, n = -1;
              }
            }
          },
          update: (i = function () {
            return new Promise(function (e) {
              u.forceUpdate(), e(a);
            });
          }, function () {
            return o || (o = new Promise(function (e) {
              Promise.resolve().then(function () {
                o = void 0, e(i());
              });
            })), o;
          }),
          destroy: function () {
            h(), c = !0;
          }
        };
      if (!Xx(e, t)) return u;
      function h() {
        l.forEach(function (e) {
          return e();
        }), l = [];
      }
      return u.setOptions(r).then(function (e) {
        !c && r.onFirstUpdate && r.onFirstUpdate(e);
      }), u;
    };
  }
  var Kx = Yx(),
    Jx = {
      passive: !0
    },
    Zx = {
      name: "eventListeners",
      enabled: !0,
      phase: "write",
      fn: function () {},
      effect: function (e) {
        var t = e.state,
          r = e.instance,
          n = e.options,
          i = n.scroll,
          s = void 0 === i || i,
          o = n.resize,
          a = void 0 === o || o,
          l = ex(t.elements.popper),
          c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
        return s && c.forEach(function (e) {
          e.addEventListener("scroll", r.update, Jx);
        }), a && l.addEventListener("resize", r.update, Jx), function () {
          s && c.forEach(function (e) {
            e.removeEventListener("scroll", r.update, Jx);
          }), a && l.removeEventListener("resize", r.update, Jx);
        };
      },
      data: {}
    };
  function $x(e) {
    return e.split("-")[0];
  }
  function ew(e) {
    return e.split("-")[1];
  }
  function tw(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
  }
  function rw(e) {
    var t,
      r = e.reference,
      n = e.element,
      i = e.placement,
      s = i ? $x(i) : null,
      o = i ? ew(i) : null,
      a = r.x + r.width / 2 - n.width / 2,
      l = r.y + r.height / 2 - n.height / 2;
    switch (s) {
      case xx:
        t = {
          x: a,
          y: r.y - n.height
        };
        break;
      case wx:
        t = {
          x: a,
          y: r.y + r.height
        };
        break;
      case Ex:
        t = {
          x: r.x + r.width,
          y: l
        };
        break;
      case Sx:
        t = {
          x: r.x - n.width,
          y: l
        };
        break;
      default:
        t = {
          x: r.x,
          y: r.y
        };
    }
    var c = s ? tw(s) : null;
    if (null != c) {
      var u = "y" === c ? "height" : "width";
      switch (o) {
        case Tx:
          t[c] = t[c] - (r[u] / 2 - n[u] / 2);
          break;
        case Ix:
          t[c] = t[c] + (r[u] / 2 - n[u] / 2);
      }
    }
    return t;
  }
  var nw = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (e) {
        var t = e.state,
          r = e.name;
        t.modifiersData[r] = rw({
          reference: t.rects.reference,
          element: t.rects.popper,
          strategy: "absolute",
          placement: t.placement
        });
      },
      data: {}
    },
    iw = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
  function sw(e) {
    var t,
      r = e.popper,
      n = e.popperRect,
      i = e.placement,
      s = e.variation,
      o = e.offsets,
      a = e.position,
      l = e.gpuAcceleration,
      c = e.adaptive,
      u = e.roundOffsets,
      h = e.isFixed,
      p = o.x,
      d = void 0 === p ? 0 : p,
      f = o.y,
      m = void 0 === f ? 0 : f,
      _ = "function" == typeof u ? u({
        x: d,
        y: m
      }) : {
        x: d,
        y: m
      };
    d = _.x, m = _.y;
    var g = o.hasOwnProperty("x"),
      v = o.hasOwnProperty("y"),
      A = Sx,
      b = xx,
      y = window;
    if (c) {
      var x = yx(r),
        w = "clientHeight",
        E = "clientWidth";
      x === ex(r) && "static" !== px(x = ux(r)).position && "absolute" === a && (w = "scrollHeight", E = "scrollWidth"), (i === xx || (i === Sx || i === Ex) && s === Ix) && (b = wx, m -= (h && x === y && y.visualViewport ? y.visualViewport.height : x[w]) - n.height, m *= l ? 1 : -1), i !== Sx && (i !== xx && i !== wx || s !== Ix) || (A = Ex, d -= (h && x === y && y.visualViewport ? y.visualViewport.width : x[E]) - n.width, d *= l ? 1 : -1);
    }
    var S,
      C = Object.assign({
        position: a
      }, c && iw),
      M = !0 === u ? function (e) {
        var t = e.x,
          r = e.y,
          n = window.devicePixelRatio || 1;
        return {
          x: ox(t * n) / n || 0,
          y: ox(r * n) / n || 0
        };
      }({
        x: d,
        y: m
      }) : {
        x: d,
        y: m
      };
    return d = M.x, m = M.y, l ? Object.assign({}, C, ((S = {})[b] = v ? "0" : "", S[A] = g ? "0" : "", S.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + m + "px)" : "translate3d(" + d + "px, " + m + "px, 0)", S)) : Object.assign({}, C, ((t = {})[b] = v ? m + "px" : "", t[A] = g ? d + "px" : "", t.transform = "", t));
  }
  var ow = {
      name: "computeStyles",
      enabled: !0,
      phase: "beforeWrite",
      fn: function (e) {
        var t = e.state,
          r = e.options,
          n = r.gpuAcceleration,
          i = void 0 === n || n,
          s = r.adaptive,
          o = void 0 === s || s,
          a = r.roundOffsets,
          l = void 0 === a || a,
          c = {
            placement: $x(t.placement),
            variation: ew(t.placement),
            popper: t.elements.popper,
            popperRect: t.rects.popper,
            gpuAcceleration: i,
            isFixed: "fixed" === t.options.strategy
          };
        null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, sw(Object.assign({}, c, {
          offsets: t.modifiersData.popperOffsets,
          position: t.options.strategy,
          adaptive: o,
          roundOffsets: l
        })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, sw(Object.assign({}, c, {
          offsets: t.modifiersData.arrow,
          position: "absolute",
          adaptive: !1,
          roundOffsets: l
        })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
          "data-popper-placement": t.placement
        });
      },
      data: {}
    },
    aw = {
      name: "applyStyles",
      enabled: !0,
      phase: "write",
      fn: function (e) {
        var t = e.state;
        Object.keys(t.elements).forEach(function (e) {
          var r = t.styles[e] || {},
            n = t.attributes[e] || {},
            i = t.elements[e];
          rx(i) && cx(i) && (Object.assign(i.style, r), Object.keys(n).forEach(function (e) {
            var t = n[e];
            !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
          }));
        });
      },
      effect: function (e) {
        var t = e.state,
          r = {
            popper: {
              position: t.options.strategy,
              left: "0",
              top: "0",
              margin: "0"
            },
            arrow: {
              position: "absolute"
            },
            reference: {}
          };
        return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function () {
          Object.keys(t.elements).forEach(function (e) {
            var n = t.elements[e],
              i = t.attributes[e] || {},
              s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : r[e]).reduce(function (e, t) {
                return e[t] = "", e;
              }, {});
            rx(n) && cx(n) && (Object.assign(n.style, s), Object.keys(i).forEach(function (e) {
              n.removeAttribute(e);
            }));
          });
        };
      },
      requires: ["computeStyles"]
    },
    lw = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (e) {
        var t = e.state,
          r = e.options,
          n = e.name,
          i = r.offset,
          s = void 0 === i ? [0, 0] : i,
          o = Lx.reduce(function (e, r) {
            return e[r] = function (e, t, r) {
              var n = $x(e),
                i = [Sx, xx].indexOf(n) >= 0 ? -1 : 1,
                s = "function" == typeof r ? r(Object.assign({}, t, {
                  placement: e
                })) : r,
                o = s[0],
                a = s[1];
              return o = o || 0, a = (a || 0) * i, [Sx, Ex].indexOf(n) >= 0 ? {
                x: a,
                y: o
              } : {
                x: o,
                y: a
              };
            }(r, t.rects, s), e;
          }, {}),
          a = o[t.placement],
          l = a.x,
          c = a.y;
        null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = o;
      }
    },
    cw = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
  function uw(e) {
    return e.replace(/left|right|bottom|top/g, function (e) {
      return cw[e];
    });
  }
  var hw = {
    start: "end",
    end: "start"
  };
  function pw(e) {
    return e.replace(/start|end/g, function (e) {
      return hw[e];
    });
  }
  function dw(e, t) {
    var r = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (r && nx(r)) {
      var n = t;
      do {
        if (n && e.isSameNode(n)) return !0;
        n = n.parentNode || n.host;
      } while (n);
    }
    return !1;
  }
  function fw(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }
  function mw(e, t) {
    return t === Dx ? fw(function (e) {
      var t = ex(e),
        r = ux(e),
        n = t.visualViewport,
        i = r.clientWidth,
        s = r.clientHeight,
        o = 0,
        a = 0;
      return n && (i = n.width, s = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = n.offsetLeft, a = n.offsetTop)), {
        width: i,
        height: s,
        x: o + hx(e),
        y: a
      };
    }(e)) : tx(t) ? function (e) {
      var t = ax(e);
      return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
    }(t) : fw(function (e) {
      var t,
        r = ux(e),
        n = lx(e),
        i = null == (t = e.ownerDocument) ? void 0 : t.body,
        s = ix(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = ix(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        a = -n.scrollLeft + hx(e),
        l = -n.scrollTop;
      return "rtl" === px(i || r).direction && (a += ix(r.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: a,
        y: l
      };
    }(ux(e)));
  }
  function _w(e) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e);
  }
  function gw(e, t) {
    return t.reduce(function (t, r) {
      return t[r] = e, t;
    }, {});
  }
  function vw(e, t) {
    void 0 === t && (t = {});
    var r = t,
      n = r.placement,
      i = void 0 === n ? e.placement : n,
      s = r.boundary,
      o = void 0 === s ? kx : s,
      a = r.rootBoundary,
      l = void 0 === a ? Dx : a,
      c = r.elementContext,
      u = void 0 === c ? Px : c,
      h = r.altBoundary,
      p = void 0 !== h && h,
      d = r.padding,
      f = void 0 === d ? 0 : d,
      m = _w("number" != typeof f ? f : gw(f, Mx)),
      _ = u === Px ? Bx : Px,
      g = e.rects.popper,
      v = e.elements[p ? _ : u],
      A = function (e, t, r) {
        var n = "clippingParents" === t ? function (e) {
            var t = vx(_x(e)),
              r = ["absolute", "fixed"].indexOf(px(e).position) >= 0 && rx(e) ? yx(e) : e;
            return tx(r) ? t.filter(function (e) {
              return tx(e) && dw(e, r) && "body" !== cx(e);
            }) : [];
          }(e) : [].concat(t),
          i = [].concat(n, [r]),
          s = i[0],
          o = i.reduce(function (t, r) {
            var n = mw(e, r);
            return t.top = ix(n.top, t.top), t.right = sx(n.right, t.right), t.bottom = sx(n.bottom, t.bottom), t.left = ix(n.left, t.left), t;
          }, mw(e, s));
        return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
      }(tx(v) ? v : v.contextElement || ux(e.elements.popper), o, l),
      b = ax(e.elements.reference),
      y = rw({
        reference: b,
        element: g,
        strategy: "absolute",
        placement: i
      }),
      x = fw(Object.assign({}, g, y)),
      w = u === Px ? x : b,
      E = {
        top: A.top - w.top + m.top,
        bottom: w.bottom - A.bottom + m.bottom,
        left: A.left - w.left + m.left,
        right: w.right - A.right + m.right
      },
      S = e.modifiersData.offset;
    if (u === Px && S) {
      var C = S[i];
      Object.keys(E).forEach(function (e) {
        var t = [Ex, wx].indexOf(e) >= 0 ? 1 : -1,
          r = [xx, wx].indexOf(e) >= 0 ? "y" : "x";
        E[e] += C[r] * t;
      });
    }
    return E;
  }
  var Aw = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
        r = e.options,
        n = e.name;
      if (!t.modifiersData[n]._skip) {
        for (var i = r.mainAxis, s = void 0 === i || i, o = r.altAxis, a = void 0 === o || o, l = r.fallbackPlacements, c = r.padding, u = r.boundary, h = r.rootBoundary, p = r.altBoundary, d = r.flipVariations, f = void 0 === d || d, m = r.allowedAutoPlacements, _ = t.options.placement, g = $x(_), v = l || (g !== _ && f ? function (e) {
            if ($x(e) === Cx) return [];
            var t = uw(e);
            return [pw(e), t, pw(t)];
          }(_) : [uw(_)]), A = [_].concat(v).reduce(function (e, r) {
            return e.concat($x(r) === Cx ? function (e, t) {
              void 0 === t && (t = {});
              var r = t,
                n = r.placement,
                i = r.boundary,
                s = r.rootBoundary,
                o = r.padding,
                a = r.flipVariations,
                l = r.allowedAutoPlacements,
                c = void 0 === l ? Lx : l,
                u = ew(n),
                h = u ? a ? Rx : Rx.filter(function (e) {
                  return ew(e) === u;
                }) : Mx,
                p = h.filter(function (e) {
                  return c.indexOf(e) >= 0;
                });
              0 === p.length && (p = h);
              var d = p.reduce(function (t, r) {
                return t[r] = vw(e, {
                  placement: r,
                  boundary: i,
                  rootBoundary: s,
                  padding: o
                })[$x(r)], t;
              }, {});
              return Object.keys(d).sort(function (e, t) {
                return d[e] - d[t];
              });
            }(t, {
              placement: r,
              boundary: u,
              rootBoundary: h,
              padding: c,
              flipVariations: f,
              allowedAutoPlacements: m
            }) : r);
          }, []), b = t.rects.reference, y = t.rects.popper, x = new Map(), w = !0, E = A[0], S = 0; S < A.length; S++) {
          var C = A[S],
            M = $x(C),
            T = ew(C) === Tx,
            I = [xx, wx].indexOf(M) >= 0,
            k = I ? "width" : "height",
            D = vw(t, {
              placement: C,
              boundary: u,
              rootBoundary: h,
              altBoundary: p,
              padding: c
            }),
            P = I ? T ? Ex : Sx : T ? wx : xx;
          b[k] > y[k] && (P = uw(P));
          var B = uw(P),
            R = [];
          if (s && R.push(D[M] <= 0), a && R.push(D[P] <= 0, D[B] <= 0), R.every(function (e) {
            return e;
          })) {
            E = C, w = !1;
            break;
          }
          x.set(C, R);
        }
        if (w) for (var L = function (e) {
            var t = A.find(function (t) {
              var r = x.get(t);
              if (r) return r.slice(0, e).every(function (e) {
                return e;
              });
            });
            if (t) return E = t, "break";
          }, O = f ? 3 : 1; O > 0 && "break" !== L(O); O--);
        t.placement !== E && (t.modifiersData[n]._skip = !0, t.placement = E, t.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function bw(e, t, r) {
    return ix(e, sx(t, r));
  }
  var yw = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (e) {
        var t = e.state,
          r = e.options,
          n = e.name,
          i = r.mainAxis,
          s = void 0 === i || i,
          o = r.altAxis,
          a = void 0 !== o && o,
          l = r.boundary,
          c = r.rootBoundary,
          u = r.altBoundary,
          h = r.padding,
          p = r.tether,
          d = void 0 === p || p,
          f = r.tetherOffset,
          m = void 0 === f ? 0 : f,
          _ = vw(t, {
            boundary: l,
            rootBoundary: c,
            padding: h,
            altBoundary: u
          }),
          g = $x(t.placement),
          v = ew(t.placement),
          A = !v,
          b = tw(g),
          y = "x" === b ? "y" : "x",
          x = t.modifiersData.popperOffsets,
          w = t.rects.reference,
          E = t.rects.popper,
          S = "function" == typeof m ? m(Object.assign({}, t.rects, {
            placement: t.placement
          })) : m,
          C = "number" == typeof S ? {
            mainAxis: S,
            altAxis: S
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, S),
          M = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
          T = {
            x: 0,
            y: 0
          };
        if (x) {
          if (s) {
            var I,
              k = "y" === b ? xx : Sx,
              D = "y" === b ? wx : Ex,
              P = "y" === b ? "height" : "width",
              B = x[b],
              R = B + _[k],
              L = B - _[D],
              O = d ? -E[P] / 2 : 0,
              F = v === Tx ? w[P] : E[P],
              U = v === Tx ? -E[P] : -w[P],
              N = t.elements.arrow,
              j = d && N ? mx(N) : {
                width: 0,
                height: 0
              },
              z = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              },
              G = z[k],
              V = z[D],
              Q = bw(0, w[P], j[P]),
              H = A ? w[P] / 2 - O - Q - G - C.mainAxis : F - Q - G - C.mainAxis,
              W = A ? -w[P] / 2 + O + Q + V + C.mainAxis : U + Q + V + C.mainAxis,
              q = t.elements.arrow && yx(t.elements.arrow),
              X = q ? "y" === b ? q.clientTop || 0 : q.clientLeft || 0 : 0,
              Y = null != (I = null == M ? void 0 : M[b]) ? I : 0,
              K = B + W - Y,
              J = bw(d ? sx(R, B + H - Y - X) : R, B, d ? ix(L, K) : L);
            x[b] = J, T[b] = J - B;
          }
          if (a) {
            var Z,
              $ = "x" === b ? xx : Sx,
              ee = "x" === b ? wx : Ex,
              te = x[y],
              re = "y" === y ? "height" : "width",
              ne = te + _[$],
              ie = te - _[ee],
              se = -1 !== [xx, Sx].indexOf(g),
              oe = null != (Z = null == M ? void 0 : M[y]) ? Z : 0,
              ae = se ? ne : te - w[re] - E[re] - oe + C.altAxis,
              le = se ? te + w[re] + E[re] - oe - C.altAxis : ie,
              ce = d && se ? function (e, t, r) {
                var n = bw(e, t, r);
                return n > r ? r : n;
              }(ae, te, le) : bw(d ? ae : ne, te, d ? le : ie);
            x[y] = ce, T[y] = ce - te;
          }
          t.modifiersData[n] = T;
        }
      },
      requiresIfExists: ["offset"]
    },
    xw = {
      name: "arrow",
      enabled: !0,
      phase: "main",
      fn: function (e) {
        var t,
          r = e.state,
          n = e.name,
          i = e.options,
          s = r.elements.arrow,
          o = r.modifiersData.popperOffsets,
          a = $x(r.placement),
          l = tw(a),
          c = [Sx, Ex].indexOf(a) >= 0 ? "height" : "width";
        if (s && o) {
          var u = function (e, t) {
              return _w("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {
                placement: t.placement
              })) : e) ? e : gw(e, Mx));
            }(i.padding, r),
            h = mx(s),
            p = "y" === l ? xx : Sx,
            d = "y" === l ? wx : Ex,
            f = r.rects.reference[c] + r.rects.reference[l] - o[l] - r.rects.popper[c],
            m = o[l] - r.rects.reference[l],
            _ = yx(s),
            g = _ ? "y" === l ? _.clientHeight || 0 : _.clientWidth || 0 : 0,
            v = f / 2 - m / 2,
            A = u[p],
            b = g - h[c] - u[d],
            y = g / 2 - h[c] / 2 + v,
            x = bw(A, y, b),
            w = l;
          r.modifiersData[n] = ((t = {})[w] = x, t.centerOffset = x - y, t);
        }
      },
      effect: function (e) {
        var t = e.state,
          r = e.options.element,
          n = void 0 === r ? "[data-popper-arrow]" : r;
        null != n && ("string" != typeof n || (n = t.elements.popper.querySelector(n))) && dw(t.elements.popper, n) && (t.elements.arrow = n);
      },
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
  function ww(e, t, r) {
    return void 0 === r && (r = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - r.y,
      right: e.right - t.width + r.x,
      bottom: e.bottom - t.height + r.y,
      left: e.left - t.width - r.x
    };
  }
  function Ew(e) {
    return [xx, Ex, wx, Sx].some(function (t) {
      return e[t] >= 0;
    });
  }
  var Sw = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (e) {
        var t = e.state,
          r = e.name,
          n = t.rects.reference,
          i = t.rects.popper,
          s = t.modifiersData.preventOverflow,
          o = vw(t, {
            elementContext: "reference"
          }),
          a = vw(t, {
            altBoundary: !0
          }),
          l = ww(o, n),
          c = ww(a, i, s),
          u = Ew(l),
          h = Ew(c);
        t.modifiersData[r] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: u,
          hasPopperEscaped: h
        }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
          "data-popper-reference-hidden": u,
          "data-popper-escaped": h
        });
      }
    },
    Cw = Yx({
      defaultModifiers: [Zx, nw, ow, aw, lw, Aw, yw, xw, Sw]
    }),
    Mw = "tippy-content",
    Tw = "tippy-arrow",
    Iw = "tippy-svg-arrow",
    kw = {
      passive: !0,
      capture: !0
    },
    Dw = function () {
      return document.body;
    };
  function Pw(e, t, r) {
    if (Array.isArray(e)) {
      var n = e[t];
      return null == n ? Array.isArray(r) ? r[t] : r : n;
    }
    return e;
  }
  function Bw(e, t) {
    var r = {}.toString.call(e);
    return 0 === r.indexOf("[object") && r.indexOf(t + "]") > -1;
  }
  function Rw(e, t) {
    return "function" == typeof e ? e.apply(void 0, t) : e;
  }
  function Lw(e, t) {
    return 0 === t ? e : function (n) {
      clearTimeout(r), r = setTimeout(function () {
        e(n);
      }, t);
    };
    var r;
  }
  function Ow(e) {
    return [].concat(e);
  }
  function Fw(e, t) {
    -1 === e.indexOf(t) && e.push(t);
  }
  function Uw(e) {
    return [].slice.call(e);
  }
  function Nw(e) {
    return Object.keys(e).reduce(function (t, r) {
      return void 0 !== e[r] && (t[r] = e[r]), t;
    }, {});
  }
  function jw() {
    return document.createElement("div");
  }
  function zw(e) {
    return ["Element", "Fragment"].some(function (t) {
      return Bw(e, t);
    });
  }
  function Gw(e, t) {
    e.forEach(function (e) {
      e && (e.style.transitionDuration = t + "ms");
    });
  }
  function Vw(e, t) {
    e.forEach(function (e) {
      e && e.setAttribute("data-state", t);
    });
  }
  function Qw(e, t, r) {
    var n = t + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function (t) {
      e[n](t, r);
    });
  }
  function Hw(e, t) {
    for (var r = t; r;) {
      var n;
      if (e.contains(r)) return !0;
      r = null == r.getRootNode || null == (n = r.getRootNode()) ? void 0 : n.host;
    }
    return !1;
  }
  var Ww = {
      isTouch: !1
    },
    qw = 0;
  function Xw() {
    Ww.isTouch || (Ww.isTouch = !0, window.performance && document.addEventListener("mousemove", Yw));
  }
  function Yw() {
    var e = performance.now();
    e - qw < 20 && (Ww.isTouch = !1, document.removeEventListener("mousemove", Yw)), qw = e;
  }
  function Kw() {
    var e,
      t = document.activeElement;
    if ((e = t) && e._tippy && e._tippy.reference === e) {
      var r = t._tippy;
      t.blur && !r.state.isVisible && t.blur();
    }
  }
  var Jw = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto),
    Zw = Object.assign({
      appendTo: Dw,
      aria: {
        content: "auto",
        expanded: "auto"
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: !0,
      ignoreAttributes: !1,
      interactive: !1,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function () {},
      onBeforeUpdate: function () {},
      onCreate: function () {},
      onDestroy: function () {},
      onHidden: function () {},
      onHide: function () {},
      onMount: function () {},
      onShow: function () {},
      onShown: function () {},
      onTrigger: function () {},
      onUntrigger: function () {},
      onClickOutside: function () {},
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: !1,
      touch: !0,
      trigger: "mouseenter focus",
      triggerTarget: null
    }, {
      animateFill: !1,
      followCursor: !1,
      inlinePositioning: !1,
      sticky: !1
    }, {
      allowHTML: !1,
      animation: "fade",
      arrow: !0,
      content: "",
      inertia: !1,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999
    }),
    $w = Object.keys(Zw);
  function eE(e) {
    var t = (e.plugins || []).reduce(function (t, r) {
      var n,
        i = r.name,
        s = r.defaultValue;
      return i && (t[i] = void 0 !== e[i] ? e[i] : null != (n = Zw[i]) ? n : s), t;
    }, {});
    return Object.assign({}, e, t);
  }
  function tE(e, t) {
    var r = Object.assign({}, t, {
      content: Rw(t.content, [e])
    }, t.ignoreAttributes ? {} : function (e, t) {
      return (t ? Object.keys(eE(Object.assign({}, Zw, {
        plugins: t
      }))) : $w).reduce(function (t, r) {
        var n = (e.getAttribute("data-tippy-" + r) || "").trim();
        if (!n) return t;
        if ("content" === r) t[r] = n;else try {
          t[r] = JSON.parse(n);
        } catch (e) {
          t[r] = n;
        }
        return t;
      }, {});
    }(e, t.plugins));
    return r.aria = Object.assign({}, Zw.aria, r.aria), r.aria = {
      expanded: "auto" === r.aria.expanded ? t.interactive : r.aria.expanded,
      content: "auto" === r.aria.content ? t.interactive ? null : "describedby" : r.aria.content
    }, r;
  }
  function rE(e, t) {
    e.innerHTML = t;
  }
  function nE(e) {
    var t = jw();
    return !0 === e ? t.className = Tw : (t.className = Iw, zw(e) ? t.appendChild(e) : rE(t, e)), t;
  }
  function iE(e, t) {
    zw(t.content) ? (rE(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? rE(e, t.content) : e.textContent = t.content);
  }
  function sE(e) {
    var t = e.firstElementChild,
      r = Uw(t.children);
    return {
      box: t,
      content: r.find(function (e) {
        return e.classList.contains(Mw);
      }),
      arrow: r.find(function (e) {
        return e.classList.contains(Tw) || e.classList.contains(Iw);
      }),
      backdrop: r.find(function (e) {
        return e.classList.contains("tippy-backdrop");
      })
    };
  }
  function oE(e) {
    var t = jw(),
      r = jw();
    r.className = "tippy-box", r.setAttribute("data-state", "hidden"), r.setAttribute("tabindex", "-1");
    var n = jw();
    function i(r, n) {
      var i = sE(t),
        s = i.box,
        o = i.content,
        a = i.arrow;
      n.theme ? s.setAttribute("data-theme", n.theme) : s.removeAttribute("data-theme"), "string" == typeof n.animation ? s.setAttribute("data-animation", n.animation) : s.removeAttribute("data-animation"), n.inertia ? s.setAttribute("data-inertia", "") : s.removeAttribute("data-inertia"), s.style.maxWidth = "number" == typeof n.maxWidth ? n.maxWidth + "px" : n.maxWidth, n.role ? s.setAttribute("role", n.role) : s.removeAttribute("role"), r.content === n.content && r.allowHTML === n.allowHTML || iE(o, e.props), n.arrow ? a ? r.arrow !== n.arrow && (s.removeChild(a), s.appendChild(nE(n.arrow))) : s.appendChild(nE(n.arrow)) : a && s.removeChild(a);
    }
    return n.className = Mw, n.setAttribute("data-state", "hidden"), iE(n, e.props), t.appendChild(r), r.appendChild(n), i(e.props, e.props), {
      popper: t,
      onUpdate: i
    };
  }
  oE.$$tippy = !0;
  var aE = 1,
    lE = [],
    cE = [];
  function uE(e, t) {
    var r,
      n,
      i,
      s,
      o,
      a,
      l,
      c,
      u = tE(e, Object.assign({}, Zw, eE(Nw(t)))),
      h = !1,
      p = !1,
      d = !1,
      f = !1,
      m = [],
      _ = Lw(q, u.interactiveDebounce),
      g = aE++,
      v = (c = u.plugins).filter(function (e, t) {
        return c.indexOf(e) === t;
      }),
      A = {
        id: g,
        reference: e,
        popper: jw(),
        popperInstance: null,
        props: u,
        state: {
          isEnabled: !0,
          isVisible: !1,
          isDestroyed: !1,
          isMounted: !1,
          isShown: !1
        },
        plugins: v,
        clearDelayTimeouts: function () {
          clearTimeout(r), clearTimeout(n), cancelAnimationFrame(i);
        },
        setProps: function (t) {
          if (!A.state.isDestroyed) {
            B("onBeforeUpdate", [A, t]), H();
            var r = A.props,
              n = tE(e, Object.assign({}, r, Nw(t), {
                ignoreAttributes: !0
              }));
            A.props = n, Q(), r.interactiveDebounce !== n.interactiveDebounce && (O(), _ = Lw(q, n.interactiveDebounce)), r.triggerTarget && !n.triggerTarget ? Ow(r.triggerTarget).forEach(function (e) {
              e.removeAttribute("aria-expanded");
            }) : n.triggerTarget && e.removeAttribute("aria-expanded"), L(), P(), x && x(r, n), A.popperInstance && (J(), $().forEach(function (e) {
              requestAnimationFrame(e._tippy.popperInstance.forceUpdate);
            })), B("onAfterUpdate", [A, t]);
          }
        },
        setContent: function (e) {
          A.setProps({
            content: e
          });
        },
        show: function () {
          var e = A.state.isVisible,
            t = A.state.isDestroyed,
            r = !A.state.isEnabled,
            n = Ww.isTouch && !A.props.touch,
            i = Pw(A.props.duration, 0, Zw.duration);
          if (!(e || t || r || n || T().hasAttribute("disabled") || (B("onShow", [A], !1), !1 === A.props.onShow(A)))) {
            if (A.state.isVisible = !0, M() && (y.style.visibility = "visible"), P(), j(), A.state.isMounted || (y.style.transition = "none"), M()) {
              var s = k();
              Gw([s.box, s.content], 0);
            }
            var o, l, c;
            a = function () {
              var e;
              if (A.state.isVisible && !f) {
                if (f = !0, y.offsetHeight, y.style.transition = A.props.moveTransition, M() && A.props.animation) {
                  var t = k(),
                    r = t.box,
                    n = t.content;
                  Gw([r, n], i), Vw([r, n], "visible");
                }
                R(), L(), Fw(cE, A), null == (e = A.popperInstance) || e.forceUpdate(), B("onMount", [A]), A.props.animation && M() && function (e, t) {
                  G(e, function () {
                    A.state.isShown = !0, B("onShown", [A]);
                  });
                }(i);
              }
            }, l = A.props.appendTo, c = T(), (o = A.props.interactive && l === Dw || "parent" === l ? c.parentNode : Rw(l, [c])).contains(y) || o.appendChild(y), A.state.isMounted = !0, J();
          }
        },
        hide: function () {
          var e = !A.state.isVisible,
            t = A.state.isDestroyed,
            r = !A.state.isEnabled,
            n = Pw(A.props.duration, 1, Zw.duration);
          if (!(e || t || r) && (B("onHide", [A], !1), !1 !== A.props.onHide(A))) {
            if (A.state.isVisible = !1, A.state.isShown = !1, f = !1, h = !1, M() && (y.style.visibility = "hidden"), O(), z(), P(!0), M()) {
              var i = k(),
                s = i.box,
                o = i.content;
              A.props.animation && (Gw([s, o], n), Vw([s, o], "hidden"));
            }
            R(), L(), A.props.animation ? M() && function (e, t) {
              G(e, function () {
                !A.state.isVisible && y.parentNode && y.parentNode.contains(y) && t();
              });
            }(n, A.unmount) : A.unmount();
          }
        },
        hideWithInteractivity: function (e) {
          I().addEventListener("mousemove", _), Fw(lE, _), _(e);
        },
        enable: function () {
          A.state.isEnabled = !0;
        },
        disable: function () {
          A.hide(), A.state.isEnabled = !1;
        },
        unmount: function () {
          A.state.isVisible && A.hide(), A.state.isMounted && (Z(), $().forEach(function (e) {
            e._tippy.unmount();
          }), y.parentNode && y.parentNode.removeChild(y), cE = cE.filter(function (e) {
            return e !== A;
          }), A.state.isMounted = !1, B("onHidden", [A]));
        },
        destroy: function () {
          A.state.isDestroyed || (A.clearDelayTimeouts(), A.unmount(), H(), delete e._tippy, A.state.isDestroyed = !0, B("onDestroy", [A]));
        }
      };
    if (!u.render) return A;
    var b = u.render(A),
      y = b.popper,
      x = b.onUpdate;
    y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + A.id, A.popper = y, e._tippy = A, y._tippy = A;
    var w = v.map(function (e) {
        return e.fn(A);
      }),
      E = e.hasAttribute("aria-expanded");
    return Q(), L(), P(), B("onCreate", [A]), u.showOnCreate && ee(), y.addEventListener("mouseenter", function () {
      A.props.interactive && A.state.isVisible && A.clearDelayTimeouts();
    }), y.addEventListener("mouseleave", function () {
      A.props.interactive && A.props.trigger.indexOf("mouseenter") >= 0 && I().addEventListener("mousemove", _);
    }), A;
    function S() {
      var e = A.props.touch;
      return Array.isArray(e) ? e : [e, 0];
    }
    function C() {
      return "hold" === S()[0];
    }
    function M() {
      var e;
      return !(null == (e = A.props.render) || !e.$$tippy);
    }
    function T() {
      return l || e;
    }
    function I() {
      var e,
        t,
        r = T().parentNode;
      return r ? null != (t = Ow(r)[0]) && null != (e = t.ownerDocument) && e.body ? t.ownerDocument : document : document;
    }
    function k() {
      return sE(y);
    }
    function D(e) {
      return A.state.isMounted && !A.state.isVisible || Ww.isTouch || s && "focus" === s.type ? 0 : Pw(A.props.delay, e ? 0 : 1, Zw.delay);
    }
    function P(e) {
      void 0 === e && (e = !1), y.style.pointerEvents = A.props.interactive && !e ? "" : "none", y.style.zIndex = "" + A.props.zIndex;
    }
    function B(e, t, r) {
      var n;
      void 0 === r && (r = !0), w.forEach(function (r) {
        r[e] && r[e].apply(r, t);
      }), r && (n = A.props)[e].apply(n, t);
    }
    function R() {
      var t = A.props.aria;
      if (t.content) {
        var r = "aria-" + t.content,
          n = y.id;
        Ow(A.props.triggerTarget || e).forEach(function (e) {
          var t = e.getAttribute(r);
          if (A.state.isVisible) e.setAttribute(r, t ? t + " " + n : n);else {
            var i = t && t.replace(n, "").trim();
            i ? e.setAttribute(r, i) : e.removeAttribute(r);
          }
        });
      }
    }
    function L() {
      !E && A.props.aria.expanded && Ow(A.props.triggerTarget || e).forEach(function (e) {
        A.props.interactive ? e.setAttribute("aria-expanded", A.state.isVisible && e === T() ? "true" : "false") : e.removeAttribute("aria-expanded");
      });
    }
    function O() {
      I().removeEventListener("mousemove", _), lE = lE.filter(function (e) {
        return e !== _;
      });
    }
    function F(t) {
      if (!Ww.isTouch || !d && "mousedown" !== t.type) {
        var r = t.composedPath && t.composedPath()[0] || t.target;
        if (!A.props.interactive || !Hw(y, r)) {
          if (Ow(A.props.triggerTarget || e).some(function (e) {
            return Hw(e, r);
          })) {
            if (Ww.isTouch) return;
            if (A.state.isVisible && A.props.trigger.indexOf("click") >= 0) return;
          } else B("onClickOutside", [A, t]);
          !0 === A.props.hideOnClick && (A.clearDelayTimeouts(), A.hide(), p = !0, setTimeout(function () {
            p = !1;
          }), A.state.isMounted || z());
        }
      }
    }
    function U() {
      d = !0;
    }
    function N() {
      d = !1;
    }
    function j() {
      var e = I();
      e.addEventListener("mousedown", F, !0), e.addEventListener("touchend", F, kw), e.addEventListener("touchstart", N, kw), e.addEventListener("touchmove", U, kw);
    }
    function z() {
      var e = I();
      e.removeEventListener("mousedown", F, !0), e.removeEventListener("touchend", F, kw), e.removeEventListener("touchstart", N, kw), e.removeEventListener("touchmove", U, kw);
    }
    function G(e, t) {
      var r = k().box;
      function n(e) {
        e.target === r && (Qw(r, "remove", n), t());
      }
      if (0 === e) return t();
      Qw(r, "remove", o), Qw(r, "add", n), o = n;
    }
    function V(t, r, n) {
      void 0 === n && (n = !1), Ow(A.props.triggerTarget || e).forEach(function (e) {
        e.addEventListener(t, r, n), m.push({
          node: e,
          eventType: t,
          handler: r,
          options: n
        });
      });
    }
    function Q() {
      var e;
      C() && (V("touchstart", W, {
        passive: !0
      }), V("touchend", X, {
        passive: !0
      })), (e = A.props.trigger, e.split(/\s+/).filter(Boolean)).forEach(function (e) {
        if ("manual" !== e) switch (V(e, W), e) {
          case "mouseenter":
            V("mouseleave", X);
            break;
          case "focus":
            V(Jw ? "focusout" : "blur", Y);
            break;
          case "focusin":
            V("focusout", Y);
        }
      });
    }
    function H() {
      m.forEach(function (e) {
        var t = e.node,
          r = e.eventType,
          n = e.handler,
          i = e.options;
        t.removeEventListener(r, n, i);
      }), m = [];
    }
    function W(e) {
      var t,
        r = !1;
      if (A.state.isEnabled && !K(e) && !p) {
        var n = "focus" === (null == (t = s) ? void 0 : t.type);
        s = e, l = e.currentTarget, L(), !A.state.isVisible && Bw(e, "MouseEvent") && lE.forEach(function (t) {
          return t(e);
        }), "click" === e.type && (A.props.trigger.indexOf("mouseenter") < 0 || h) && !1 !== A.props.hideOnClick && A.state.isVisible ? r = !0 : ee(e), "click" === e.type && (h = !r), r && !n && te(e);
      }
    }
    function q(e) {
      var t = e.target,
        r = T().contains(t) || y.contains(t);
      if ("mousemove" !== e.type || !r) {
        var n = $().concat(y).map(function (e) {
          var t,
            r = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
          return r ? {
            popperRect: e.getBoundingClientRect(),
            popperState: r,
            props: u
          } : null;
        }).filter(Boolean);
        (function (e, t) {
          var r = t.clientX,
            n = t.clientY;
          return e.every(function (e) {
            var t = e.popperRect,
              i = e.popperState,
              s = e.props.interactiveBorder,
              o = i.placement.split("-")[0],
              a = i.modifiersData.offset;
            if (!a) return !0;
            var l = "bottom" === o ? a.top.y : 0,
              c = "top" === o ? a.bottom.y : 0,
              u = "right" === o ? a.left.x : 0,
              h = "left" === o ? a.right.x : 0,
              p = t.top - n + l > s,
              d = n - t.bottom - c > s,
              f = t.left - r + u > s,
              m = r - t.right - h > s;
            return p || d || f || m;
          });
        })(n, e) && (O(), te(e));
      }
    }
    function X(e) {
      K(e) || A.props.trigger.indexOf("click") >= 0 && h || (A.props.interactive ? A.hideWithInteractivity(e) : te(e));
    }
    function Y(e) {
      A.props.trigger.indexOf("focusin") < 0 && e.target !== T() || A.props.interactive && e.relatedTarget && y.contains(e.relatedTarget) || te(e);
    }
    function K(e) {
      return !!Ww.isTouch && C() !== e.type.indexOf("touch") >= 0;
    }
    function J() {
      Z();
      var t = A.props,
        r = t.popperOptions,
        n = t.placement,
        i = t.offset,
        s = t.getReferenceClientRect,
        o = t.moveTransition,
        l = M() ? sE(y).arrow : null,
        c = s ? {
          getBoundingClientRect: s,
          contextElement: s.contextElement || T()
        } : e,
        u = [{
          name: "offset",
          options: {
            offset: i
          }
        }, {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: "flip",
          options: {
            padding: 5
          }
        }, {
          name: "computeStyles",
          options: {
            adaptive: !o
          }
        }, {
          name: "$$tippy",
          enabled: !0,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function (e) {
            var t = e.state;
            if (M()) {
              var r = k().box;
              ["placement", "reference-hidden", "escaped"].forEach(function (e) {
                "placement" === e ? r.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? r.setAttribute("data-" + e, "") : r.removeAttribute("data-" + e);
              }), t.attributes.popper = {};
            }
          }
        }];
      M() && l && u.push({
        name: "arrow",
        options: {
          element: l,
          padding: 3
        }
      }), u.push.apply(u, (null == r ? void 0 : r.modifiers) || []), A.popperInstance = Cw(c, y, Object.assign({}, r, {
        placement: n,
        onFirstUpdate: a,
        modifiers: u
      }));
    }
    function Z() {
      A.popperInstance && (A.popperInstance.destroy(), A.popperInstance = null);
    }
    function $() {
      return Uw(y.querySelectorAll("[data-tippy-root]"));
    }
    function ee(e) {
      A.clearDelayTimeouts(), e && B("onTrigger", [A, e]), j();
      var t = D(!0),
        n = S(),
        i = n[0],
        s = n[1];
      Ww.isTouch && "hold" === i && s && (t = s), t ? r = setTimeout(function () {
        A.show();
      }, t) : A.show();
    }
    function te(e) {
      if (A.clearDelayTimeouts(), B("onUntrigger", [A, e]), A.state.isVisible) {
        if (!(A.props.trigger.indexOf("mouseenter") >= 0 && A.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && h)) {
          var t = D(!1);
          t ? n = setTimeout(function () {
            A.state.isVisible && A.hide();
          }, t) : i = requestAnimationFrame(function () {
            A.hide();
          });
        }
      } else z();
    }
  }
  function hE(e, t) {
    void 0 === t && (t = {});
    var r = Zw.plugins.concat(t.plugins || []);
    document.addEventListener("touchstart", Xw, kw), window.addEventListener("blur", Kw);
    var n,
      i = Object.assign({}, t, {
        plugins: r
      }),
      s = (n = e, zw(n) ? [n] : function (e) {
        return Bw(e, "NodeList");
      }(n) ? Uw(n) : Array.isArray(n) ? n : Uw(document.querySelectorAll(n))).reduce(function (e, t) {
        var r = t && uE(t, i);
        return r && e.push(r), e;
      }, []);
    return zw(e) ? s[0] : s;
  }
  hE.defaultProps = Zw, hE.setDefaultProps = function (e) {
    Object.keys(e).forEach(function (t) {
      Zw[t] = e[t];
    });
  }, hE.currentInput = Ww, Object.assign({}, aw, {
    effect: function (e) {
      var t = e.state,
        r = {
          popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
      Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow);
    }
  }), hE.setDefaultProps({
    render: oE
  });
  var pE = hE;
  class dE extends qy {
    async _refreshUi() {
      var e;
      if (!(await super._refreshUi())) return !1;
      $y.RemoveAll(dE.PluginType);
      for (const e of this.variations) $y.Create(dE.PluginType, e.title, 5, 20, 0, e.materials.map(t => {
        let r;
        if (e.preview.startsWith("generate:")) r = this._previewGenerator.generate(t, e.preview.split(":")[1]);else {
          const n = t[e.preview] || "#ff00ff";
          r = n.image ? It(n.image, 100) : void 0, r || (r = Yy(n, !0));
        }
        return {
          id: t.uuid,
          image: r,
          onClick: t => this.applyVariation(e, t),
          tooltip: t.name || t.uuid
        };
      }), (e, t) => pE(e, {
        placement: "bottom",
        content: t.tooltip
      }));
      return $y.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), !0;
    }
  }
  dE.PluginType = "MaterialConfiguratorPlugin";
  class fE extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      }, this.dependencies = [to], this._selectedObject = () => {
        var e;
        return (null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0;
      }, this._selectedMaterial = () => {
        var e;
        return (null === (e = this._selectedObject()) || void 0 === e ? void 0 : e.material) || void 0;
      };
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new Wy(this._viewer), null === (r = this._picking) || void 0 === r || r.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }
    async onRemove(e) {
      var t, r;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (r = this._picking) || void 0 === r || r.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }
    async _refreshUi() {
      return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = !1, !1;
    }
  }
  fE.PluginType = "MaterialLibraryBasePlugin", function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Je("Enabled")], fE.prototype, "enabled", void 0);
  class mE extends fE {
    constructor() {
      super(...arguments), this.replaceMaterial = !1, this.uiConfig = {
        type: "folder",
        label: "Material Library",
        uuid: Xe(),
        children: [...ot(this), () => {
          var e;
          return {
            type: "dropdown",
            label: "Apply Material",
            limitedUi: !0,
            hidden: () => !this._selectedObject(),
            children: [{
              label: "select one",
              value: ""
            }, [...(this._viewer.getPlugin(to).materials.getMaterialsOfType(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.typeSlug).map(e => ({
              label: e.name || e.uuid,
              value: e.uuid
            })) || [])]],
            getValue: () => {
              var e;
              return null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid;
            },
            setValue: e => {
              var t, r, n, i, s;
              const o = null === (n = null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(to)) || void 0 === r ? void 0 : r.materials) || void 0 === n ? void 0 : n.findMaterial(e);
              if (o) if (this.replaceMaterial) null === (s = null === (i = this._selectedObject()) || void 0 === i ? void 0 : i.setMaterial) || void 0 === s || s.call(i, o);else {
                const e = this._selectedMaterial();
                if (e) {
                  const t = e.name,
                    r = e.uuid;
                  e.copyProps(o), e.name = t, e.uuid = r, e.userData.uuid && (e.userData.uuid = r);
                }
              }
              this._refreshUi();
            }
          };
        }]
      };
    }
    async _refreshUi() {
      var e, t, r, n;
      if (!(await super._refreshUi())) return !1;
      const i = [Kt.TypeSlug, Zo.TypeSlug],
        s = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(to)) || void 0 === t ? void 0 : t.materials,
        o = i.map(e => [e, null == s ? void 0 : s.getMaterialsOfType(e)]);
      $y.RemoveAll(mE.PluginType);
      for (const [e, t] of o) $y.Create(mE.PluginType, e, 5, 20, 0, null === (r = t) || void 0 === r ? void 0 : r.filter(e => !e.userData.__runtimeMaterial).map(e => {
        let t;
        const r = "generate:sphere";
        if (r.startsWith("generate:")) t = this._previewGenerator.generate(e, r.split(":")[1]);else {
          const n = e[r] || "#ff00ff";
          t = n.image ? It(n.image, 100) : void 0, t || (t = Xy(n, !0));
        }
        return {
          id: e.uuid,
          image: t,
          onClick: e => {
            const t = null == s ? void 0 : s.findMaterial(e);
            if (console.log(null == t ? void 0 : t.name), t) {
              const e = t.userData.__appliedMeshes;
              if (null == e ? void 0 : e.size) {
                const t = e.keys().next().value;
                t.dispatchEvent({
                  type: "select",
                  value: t
                });
              }
            }
          },
          tooltip: e.name || e.uuid
        };
      }), (e, t) => pE(e, {
        placement: "bottom",
        content: t.tooltip
      }));
      return $y.RebuildUi(null === (n = this._viewer) || void 0 === n ? void 0 : n.container), !0;
    }
  }
  function _E(e, t, r, i) {
    e.traverse(e => {
      e && (e.userData.cloneRotI = t, e.userData.rotationCount = r, e.userData.rotationAxis = i, e.addEventListener("beforeRender", t => function (e, t) {
        var r;
        t && (null === (r = t.map) || void 0 === r ? void 0 : r.isTexture) && (t.extraUniformsToUpload || (t.extraUniformsToUpload = {}), t.extraUniformsToUpload.uvTransform || (t.extraUniformsToUpload.uvTransform = {
          value: new n.Vkp()
        }), t.extraUniformsToUpload.uvTransform.value.setUvTransform(t.map.offset.x * t.map.repeat.x * e.userData.cloneRotI / (e.userData.rotationCount || 1), t.map.offset.y * t.map.repeat.y * e.userData.cloneRotI / (e.userData.rotationCount || 1), t.map.repeat.x, t.map.repeat.y, t.map.rotation, t.map.center.x, t.map.center.y));
      }(e, t.material)));
    });
  }
  function gE(e, t, r, n = "x") {
    var i;
    if (e.userData.rotationCount > 1 && !e.userData.rotationRoot) return e;
    const s = e.parent;
    if (!s) throw new Error("No parent");
    if (e.userData.cloneParent) {
      const t = e.userData.cloneParent;
      if (!(e = s.children.find(e => t === e.uuid))) return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t, s), e;
    }
    let o = s.children.filter(t => {
      var r;
      return (null === (r = t.userData) || void 0 === r ? void 0 : r.cloneParent) === e.uuid;
    }).sort((e, t) => e.userData.cloneRotI - t.userData.cloneRotI);
    if (e.userData.rotationCount === t && t === o.length && void 0 === r && e.userData.rotationAxis === n) return e;
    if (null == r && (r = null !== (i = e.userData.rotationSkips) && void 0 !== i ? i : []), r !== e.userData.rotationSkips && (e.userData.rotationSkips = [...r]), _E(e, 0, t, n), e.userData.rotationRoot = !0, e.visible = !0, t <= o.length) {
      for (let e = t - 1; e < o.length; e++) s.remove(o[e]), o[e].traverse(e => e.userData = {
        __disposed: !0
      });
      o = o.slice(0, t);
    }
    for (let i = 1; i < t; i++) {
      const a = i <= o.length ? o[i - 1] : e.clone();
      a.rotation.copy(e.rotation), a.rotation[n] += i / t * Math.PI * 2, _E(a, i, t, n), i > o.length && s.add(a), a.visible = !r.includes(i);
    }
    return e.visible = !r.includes(0), e;
  }
  mE.PluginType = "MaterialLibraryPlugin", function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Je("Replace Material")], mE.prototype, "replaceMaterial", void 0);
  var vE,
    AE = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let bE = vE = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this);
    }
    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    _selectedObjectChanged() {
      var e, t, r, n, i, s, o, a, l;
      if (!this.enabled) return;
      const c = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      if (!c) return void (null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0));
      const u = c.userData.rotationRoot && null !== (i = c.userData.rotationCount) && void 0 !== i ? i : 1;
      this.rotations = u, this.skips = null !== (o = null === (s = c.userData.rotationSkips) || void 0 === s ? void 0 : s.join(",")) && void 0 !== o ? o : "", this.axis = c.userData.rotationAxis || "x", null === (l = (a = this.uiConfig).uiRefresh) || void 0 === l || l.call(a, "postFrame", !0);
    }
    _paramsChanged() {
      var e, t, r, i, s, o;
      if (!this.enabled) return;
      const a = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      if (a) {
        if (this.rotations > 1 || a.userData.rotationCount) {
          const e = a.userData.rotationCount,
            t = gE(a, this.rotations, this.skips.split(",").map(e => parseInt(e)).filter(e => isFinite(e)), this.axis),
            o = null == t ? void 0 : t.userData.rotationCount;
          if (o && o !== e) {
            const e = [];
            null == t || t.traverseAncestors(t => {
              e.push(t);
            });
            for (const t of e) if (t.userData.autoScaled) {
              X(t), null === (r = this._viewer) || void 0 === r || r.resetCamera({
                rootObject: t,
                centerOffset: new n.Pa4(4, 4, 4)
              });
              break;
            }
          }
          a.parent && !a.userData.__disposed || null === (s = null === (i = this._viewer) || void 0 === i ? void 0 : i.getPluginByType("Picking")) || void 0 === s || s.setSelectedObject(t, !0);
        }
        null === (o = this._viewer) || void 0 === o || o.scene.setDirty({
          frameFade: !1,
          sceneUpdate: !0
        });
      }
    }
  };
  bE.PluginType = "ObjectRotationPlugin", AE([Ce(), Je("Enabled"), M(vE.prototype._paramsChanged)], bE.prototype, "enabled", void 0), AE([$e("Rotation Count", [1, 100], 1, e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === r ? void 0 : r.getSelectedObject()) || !e.rotations;
    }
  })), M(vE.prototype._paramsChanged)], bE.prototype, "rotations", void 0), AE([tt("Axis", ["x", "y", "z"].map(e => ({
    label: e
  })), e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === r ? void 0 : r.getSelectedObject()) || !e.rotations;
    }
  })), M(vE.prototype._paramsChanged)], bE.prototype, "axis", void 0), AE([nt("Rotation Skips", e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === r ? void 0 : r.getSelectedObject()) || !e.rotations;
    }
  })), M(vE.prototype._paramsChanged)], bE.prototype, "skips", void 0), bE = vE = AE([lt("Object Rotations")], bE);
  var yE,
    xE = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let wE = yE = class extends ro {
    constructor(e = !0) {
      super(), this.enabled = !0, this.debugNormals = !1, this.debugHitHeight = !1, this._defines = {
        PARALLAX_NORMAL_MAP_QUALITY: 0
      }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = {
        shaderExtender: (e, t, r) => {
          if (t.materialObject.bumpMap && this.enabled) {
            e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_begin>", ""), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", ""), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");
            for (const t of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"]) e.fragmentShader = e.fragmentShader.replace(`#include <${t}>`, n.WdD[t].replace("vUv", "parallaxUv.xy"));
            (this.debugNormals || this.debugHitHeight) && (e.fragmentShader = e.fragmentShader.replace("texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", n.WdD.normal_fragment_maps.replace("#elif defined( TANGENTSPACE_NORMALMAP )", "#elif defined( TANGENTSPACE_NORMALMAP ) && !defined( USE_BUMPMAP )").replace("normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"));
          }
        },
        parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vUv,0.);float parallaxHeight;vec2 texCoords=vUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vUv);vec2 duv2=dFdy(vUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "",
        isCompatible: e => e.isMeshStandardMaterial2,
        computeCacheKey: e => {
          var t;
          return this.enabled + " " + (null === (t = e.materialObject.bumpMap) || void 0 === t ? void 0 : t.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  ";
        },
        onObjectRender: (e, {
          materialObject: t
        }, r) => {
          for (const [e, r] of Object.entries(this._defines)) {
            const n = "number" == typeof r ? r : r ? 1 : 0;
            t.defines[e] !== n && (t.defines[e] = n, t.needsUpdate = !0);
          }
        }
      }, this.dependencies = [to], this.enabled = e, this._updateExtension = this._updateExtension.bind(this);
    }
    _updateExtension() {
      var e, t, r;
      null === (t = null === (e = this._bumpMapExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (r = this._viewer) || void 0 === r || r.setDirty();
    }
    async onAdded(e) {
      var t, r;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e);
    }
    async onRemove(e) {
      var t, r;
      return null === (r = null === (t = e.getPlugin(to)) || void 0 === t ? void 0 : t.materials) || void 0 === r || r.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e);
    }
  };
  wE.PluginType = "ReliefParallaxMapping", xE([M(yE.prototype._updateExtension), Je("Enabled")], wE.prototype, "enabled", void 0), xE([M(yE.prototype._updateExtension), Je("Debug Normals")], wE.prototype, "debugNormals", void 0), xE([M(yE.prototype._updateExtension), Je("Debug Hit Height")], wE.prototype, "debugHitHeight", void 0), xE([V("PARALLAX_MAP_STEPS", void 0, !0, yE.prototype._updateExtension), $e("Step count", [1, 32], 1), Ce()], wE.prototype, "stepCount", void 0), xE([V("PARALLAX_MAP_B_STEPS", void 0, !0, yE.prototype._updateExtension), $e("Binary search steps", [1, 8], 1), Ce()], wE.prototype, "binaryStepCount", void 0), wE = yE = xE([lt("Parallax Mapping")], wE);
  var EE = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  class SE extends zt {
    constructor(e, t, r, i = !1) {
      super({
        vertexShader: Io,
        fragmentShader: `\n\n${Do}\n${ko}\n${Po}\n${Bo}\n${r}\n\n${Ro}\n\nvarying vec2 vUv;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);\n#endif\nreturn vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount)/(frameCount+1.));}\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 2.14
          },
          rayCount: {
            value: .1
          },
          objectRadius: {
            value: 1
          },
          autoRadius: {
            value: !i
          },
          power: {
            value: 1.1
          },
          bias: {
            value: .015
          },
          falloff: {
            value: .7
          },
          tolerance: {
            value: 1.5
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new n.yGw()
          },
          screenSize: {
            value: new n.FM8()
          },
          cameraPositionWorld: {
            value: new n.Pa4()
          },
          cameraNearFar: {
            value: new n.FM8(.1, 1e3)
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSGI_ENABLED: i ? 1 : 0
        }
      }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = {
        shaderExtender: (e, t, r) => {
          if (!e.defines.SSRTAO_ENABLED) return;
          const n = "vec3 totalDiffuse =";
          e.fragmentShader = e.fragmentShader.replace(n, `\n\n            \n            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0\nvec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);\n#endif\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\n#if !defined(SSR_ENABLED) || SSR_ENABLED < 1\nreflectedLight.indirectSpecular+=ssgiColor*material.specularColor;\n#endif\n#endif\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${n}`), e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", ""), e.vertexUvs = !0;
        },
        onObjectRender: (e, t, r) => {
          var n, i, s;
          this.materialExtension.extraUniforms.tSSGIMap.value = null === (n = this._target) || void 0 === n ? void 0 : n.texture;
          const o = t.materialObject,
            a = !o.transparent && o.transmission < .001;
          let l = this.enabled && a && (this.renderWithCamera || this._renderer.frameCount > 1) && !1 !== r.userData.screenSpaceRendering && !(null === (i = o.userData) || void 0 === i ? void 0 : i.ssrtaoDisabled) && !(null === (s = o.userData) || void 0 === s ? void 0 : s.ssaoDisabled) ? 1 : 0;
          o.defines.SSRTAO_ENABLED !== l && (o.defines.SSRTAO_ENABLED = l, o.needsUpdate = !0), l = this.material.defines.SSGI_ENABLED, o.defines.SSGI_ENABLED !== l && (o.defines.SSGI_ENABLED = l, o.needsUpdate = !0), l = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== l && (this.materialExtension.extraUniforms.tSSGIMap.value = l, o.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return w`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${U("tSSGIMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}

            ${Oo}

        `;
        },
        extraUniforms: {
          tSSGIMap: {
            value: null
          },
          ssaoPower: this.material.uniforms.power,
          ssgiIntensity: this.material.uniforms.intensity
        },
        computeCacheKey: e => {
          var t, r;
          return this.enabled ? "1" : "0" + (null === (r = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === r ? void 0 : r.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 2, this.power = 1.1, this.autoRadius = !0, this.objectRadius = 2, this.tolerance = 1, this.bias = .15, this.falloff = .7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = !0, this.renderWithCamera = !0, this.uiConfig = {
        type: "folder",
        label: "SS Global illumination (Dev)",
        children: [...ot(this), {
          type: "checkbox",
          label: "GI Enabled",
          hidden: () => !this._giActivated,
          property: [this, "ssgiEnabled"]
        }]
      }, this._renderer = e, this._target = t, this.needsSwap = !0, this._giActivated = i, this.ssgiEnabled = i, this.bilateralPass = new zo(this._target, r, "rgba");
    }
    get ssgiEnabled() {
      return parseInt(this.material.defines.SSGI_ENABLED) > .5;
    }
    set ssgiEnabled(e) {
      e = e && this._giActivated, this.material.defines.SSGI_ENABLED = e ? 1 : 0, this.material.needsUpdate = !0;
    }
    render(e, t, r, n, i) {
      this.needsSwap = !1, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, r, n, i), this.smoothEnabled && this.bilateralPass.render(e, t, r, n, i));
    }
  }
  EE([Ce()], SE.prototype, "bilateralPass", void 0), EE([$e("Intensity", [0, 4]), Ce(), G()], SE.prototype, "intensity", void 0), EE([$e("Power", [0, 3]), Ce(), G()], SE.prototype, "power", void 0), EE([Je("Auto radius"), Ce(), G()], SE.prototype, "autoRadius", void 0), EE([$e("Object Radius", [.01, 10]), Ce(), G()], SE.prototype, "objectRadius", void 0), EE([$e("Tolerance", [.1, 5]), Ce(), G()], SE.prototype, "tolerance", void 0), EE([$e("Bias", [-.3, .3]), Ce(), G()], SE.prototype, "bias", void 0), EE([$e("Falloff", [1e-4, 4]), Ce(), G()], SE.prototype, "falloff", void 0), EE([$e("Ray Count", [1, 5], 1), Ce(), G()], SE.prototype, "rayCount", void 0), EE([$e("Step count", [1, 16], 1), Ce(), V("RTAO_STEP_COUNT")], SE.prototype, "stepCount", void 0), EE([Je("Smooth Enabled"), Ce()], SE.prototype, "smoothEnabled", void 0), EE([Je("Render with Camera")], SE.prototype, "renderWithCamera", void 0);
  class CE extends So {
    constructor(e = !0) {
      super(), this.dependencies = [to, lo, To], this._initEnabled = !1, this.setDirty = this.setDirty.bind(this), this._initEnabled = e;
    }
    get rtgiTarget() {
      return this._rtgiTarget;
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this.enabled = this._initEnabled, null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t, "postFrame", !0);
    }
    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }
    set enabled(e) {
      var t;
      (null === (t = this.passes.ssrtgi) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssrtgi.passObject.enabled = e);
    }
    createPasses(e) {
      var t, r, n;
      this._rtgiTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      });
      let i = !1;
      return null === (t = this._viewer) || void 0 === t || t.getPluginByType("debug"), [no(e, {
        passId: "ssrtgi",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new SE(e.renderer, this._rtgiTarget, null !== (n = null === (r = e.getPlugin(lo)) || void 0 === r ? void 0 : r.getUnpackSnippet()) && void 0 !== n ? n : "", !0),
        update: () => {
          var t;
          let r = this.enabled;
          if (r && !i) {
            const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SSAO");
            (null == e ? void 0 : e.enabled) && (confirm("SSAO Plugin needs to be disabled to enable SSRTGI or SSRTAO. Disable now?") ? e.enabled = !1 : (this.enabled = !1, r = !1));
          }
          i = r, r && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e.getPlugin(lo)]);
        }
      }, () => [e.getPlugin(lo), e.getPlugin(To), e.scene.activeCamera, e.renderer])];
    }
    async onRemove(e) {
      return e.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e);
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    get uiConfig() {
      var e, t, r, n, i;
      const s = null !== (r = null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== r ? r : {};
      return null === (i = null === (n = s.children) || void 0 === n ? void 0 : n.map(e => A(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }
  }
  CE.PluginType = "SSGI";
  class ME extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this.dependencies = [to], this.variations = [], this._selectedSwitchNode = () => {
        var e;
        const t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject();
        if (!t) return;
        const r = this.variations.map(e => e.name);
        let n;
        return t.traverseAncestors(e => {
          n || r.includes(e.name) && (n = e);
        }), n;
      }, this.uiConfig = {
        label: "Switch Node",
        type: "folder",
        children: [() => [{
          type: "folder",
          label: "All nodes",
          expanded: !0,
          children: [this.variations.map(e => ({
            type: "input",
            label: e.title,
            property: [e, "name"],
            onChange: () => this.refreshUi()
          }))]
        }, {
          type: "button",
          label: "Add Node",
          value: () => {
            this.variations.push({
              name: "switch_node",
              selected: "",
              title: "Switch Node",
              camView: "front",
              camDistance: 1
            }), this.refreshUi();
          }
        }, {
          type: "button",
          label: "Refresh UI",
          value: () => this.refreshUi()
        }, {
          type: "input",
          label: "Selected node title",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();
            return e ? [this.variations.find(t => t.name === e.name), "title"] : [];
          },
          onChange: () => this.refreshUi()
        }, {
          type: "slider",
          bounds: [.01, 2],
          stepSize: .01,
          label: "Cam Distance",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();
            return e ? [this.variations.find(t => t.name === e.name), "camDistance"] : [];
          }
        }, {
          type: "dropdown",
          label: "Cam View",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();
            return e ? [this.variations.find(t => t.name === e.name), "camView"] : [];
          },
          onChange: () => this.refreshUi(),
          children: ["top", "bottom", "front", "back", "left", "right"].map(e => ({
            label: e,
            value: e
          }))
        }]]
      };
    }
    async onAdded(e) {
      var t, r;
      await super.onAdded(e), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), null === (r = this._picking) || void 0 === r || r.addEventListener("selectedObjectChanged", () => {
        var e, t;
        null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e);
      }), e.addEventListener("postFrame", () => {
        this._uiNeedRefresh && this._refreshUi();
      }), e.addEventListener("preRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);
          if (!t || t.children.length < 1) return;
          e.selected || (e.selected = t.children[0].name || t.children[0].uuid);
          for (const r of t.children) r.visible = (r.name || r.uuid) === e.selected;
        }
      }), e.addEventListener("postRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);
          if (!t || t.children.length < 1) return;
          for (const e of t.children) e.visible = !0;
        }
      }), this.addEventListener("deserialize", async () => {
        await Dc(200), this.refreshUi();
      });
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }
    _refreshUi() {
      var e, t, r;
      if (this.enabled && this._viewer) {
        this._uiNeedRefresh = !1, $y.RemoveAll(ME.PluginType);
        for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);
          t ? (t.children.length < 1 && console.warn("SwitchNode does not have enough children", e), $y.Create(ME.PluginType, e.title, Math.min(5, t.children.length), 20, 0, t.children.map(t => {
            const r = e.camView,
              i = new n.Pa4((r.includes("right") ? 1 : 0) - (r.includes("left") ? 1 : 0), (r.includes("top") ? 1 : 0) - (r.includes("bottom") ? 1 : 0), (r.includes("front") ? 1 : 0) - (r.includes("back") ? 1 : 0));
            e.camDistance || (e.camDistance = 1);
            const s = Hy(this._viewer, t, void 0, 7, i.multiplyScalar(.5 * e.camDistance));
            return {
              id: t.uuid,
              image: s,
              onClick: () => {
                var r;
                e.selected = t.name || t.uuid, null === (r = this._viewer) || void 0 === r || r.scene.setDirty({
                  sceneUpdate: !0,
                  frameFade: !0
                });
              },
              tooltip: t.name || t.uuid
            };
          }), (e, t) => pE(e, {
            placement: "bottom",
            content: t.tooltip
          }))) : console.warn("no object found for variation, skipping", e);
        }
        $y.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), null === (r = (t = this.uiConfig).uiRefresh) || void 0 === r || r.call(t);
      }
    }
  }
  ME.PluginType = "SwitchNodePlugin", function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    s > 3 && o && Object.defineProperty(t, r, o);
  }([Ce()], ME.prototype, "variations", void 0);
  class TE extends n.u9r {
    constructor(e, t, r = 32, i = 64, s = !1, o = new n.FM8(1, 1), a = "shape") {
      super(), this.type = "TubeShapeGeometry", this.parameters = {
        path: t,
        shape: e,
        shapeSegments: r,
        tubularSegments: i,
        closed: s,
        primary: a,
        shapeScale: o.clone()
      };
      const l = t.computeFrenetFrames(i, s);
      this.frames = l;
      const c = new n.Pa4(),
        u = new n.Pa4(),
        h = new n.Pa4(),
        p = new n.FM8();
      let d = new n.Pa4();
      const f = [],
        m = [],
        _ = [],
        g = e.getSpacedPoints(r);
      for (const e of g) e.multiply(o);
      !function () {
        for (let e = 0; e < i; e++) A(e);
        A(!1 === s ? i : 0), function () {
          for (let e = 0; e <= i; e++) for (let t = 0; t <= r; t++) p.x = e / i, p.y = t / r, m.push(p.x, p.y);
        }(), function () {
          const e = "shape" === a,
            t = e ? r : i,
            n = e ? i : r;
          for (let i = 1; i <= t; i++) for (let t = 1; t <= n; t++) {
            const [n, s] = e ? [t, i] : [i, t],
              o = (r + 1) * (n - 1) + (s - 1),
              a = (r + 1) * n + (s - 1),
              l = (r + 1) * n + s,
              c = (r + 1) * (n - 1) + s;
            _.push(o, a, c), _.push(a, l, c);
          }
        }();
      }(), this.setIndex(_), this.setAttribute("position", new n.a$l(f, 3)), this.setAttribute("uv", new n.a$l(m, 2)), this.computeVertexNormals();
      const v = this.attributes.normal;
      function A(e) {
        d = t.getPointAt(e / i, d);
        const n = l.normals[e],
          s = l.binormals[e];
        for (let e = 0; e <= r; e++) {
          const t = g[e % r];
          u.set(0, 0, 0).addScaledVector(n, t.x).addScaledVector(s, t.y), c.copy(d).add(u), f.push(c.x, c.y, c.z);
        }
      }
      !function () {
        for (let e = 1; e < r; e++) {
          const t = e + i * (r + 1);
          u.fromBufferAttribute(v, e), h.fromBufferAttribute(v, t), u.add(h).normalize(), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(t, u.x, u.y, u.z);
        }
        for (let e = 1; e < i; e++) {
          const t = e * (r + 1),
            n = t + r;
          u.fromBufferAttribute(v, t), h.fromBufferAttribute(v, n), u.add(h).normalize(), v.setXYZ(t, u.x, u.y, u.z), v.setXYZ(n, u.x, u.y, u.z);
        }
        u.fromBufferAttribute(v, 0), h.fromBufferAttribute(v, r), u.add(h);
        const e = i * (r + 1);
        h.fromBufferAttribute(v, e), u.add(h), h.fromBufferAttribute(v, e + r), u.add(h), u.normalize(), v.setXYZ(0, u.x, u.y, u.z), v.setXYZ(r, u.x, u.y, u.z), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(e + r, u.x, u.y, u.z), v.needsUpdate = !0;
      }();
    }
    createSplits(e) {
      this.clearGroups();
      const t = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments,
        r = this.index.count,
        n = [...e, 1].sort();
      let i = 0,
        s = 0;
      for (const e of n) {
        const n = Math.round(t * e) * r / t;
        this.addGroup(i, n - i, s++), i = n;
      }
      return this.groups.length;
    }
    toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e.shape = this.parameters.shape.toJSON(), e;
    }
  }
  var IE,
    kE = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let DE = IE = class extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new n.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = !0, this.extrudeCirceTube = async () => {
        var e, t;
        const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
        if (!r) return;
        let n = this._viewer.prompt("Radius: Radius for the circle", "1", !0);
        if (!n) return;
        n = parseFloat(n);
        const i = new PE(0, 0, n, n, 0, 2 * Math.PI, !0, 0);
        await this.extrudeObject(r, i);
      };
    }
    async onAdded(e) {
      await super.onAdded(e);
    }
    static CreateCurve(e, t) {
      var r, n;
      if ("circle" === e) return new PE(0, 0, null !== (r = t.radius) && void 0 !== r ? r : 1, null !== (n = t.radius) && void 0 !== n ? n : 1, 0, 2 * Math.PI, !0, 0);
      throw new Error("Unknown curve type");
    }
    async extrudeObject(e, t, r = this.shapeSegments, i = this.tubularSegments, s = this.shapeScale, o = this.materialSplits.split(",").map(e => parseFloat(e.trim())), a = this.horizontalSplits) {
      var l, c, u, h, p, d, f, m;
      if (e.userData.isExtrudedTube, e.userData._extrudeSource) {
        const t = e.userData._extrudeSource;
        if (e = null === (l = e.parent) || void 0 === l ? void 0 : l.children.find(e => t === e.uuid), !e) return void console.warn("Could not find extrude source with uuid", t);
      }
      if (e.userData.extrudedObject) {
        const t = e.userData.extrudedObject,
          r = null === (c = e.parent) || void 0 === c ? void 0 : c.children.find(e => t === e.uuid);
        r && (r.removeFromParent(), r.geometry.dispose(), r.geometry = null, r.material = null), delete e.userData.extrudedObject;
      }
      const _ = e.geometry;
      if (!_) return void (null === (u = this._viewer) || void 0 === u || u.alert("Extrude: No geometry to extrude"));
      const g = [e.material];
      let v;
      try {
        const e = IE.ConvertGeometryToFlatShape(_);
        v = new TE(e, t, r, i, !0, s, a ? "shape" : "path"), v.computeBoundingBox(), v.createSplits(o);
      } catch (e) {
        return void (null === (h = this._viewer) || void 0 === h || h.alert("string" == typeof e ? e : null == e ? void 0 : e.message));
      }
      g[0].color.set(16777215);
      for (let e = g.length; e < v.groups.length; e++) {
        const e = g[0].clone();
        g.push(e), e.color.set(16777215 * Math.random());
      }
      const A = new n.Kj0(v, g);
      A.userData._extrudeSource = e.uuid, A.userData.isExtrudedTube = !0, e.visible = !1, e.userData.bboxVisible = !1, A.name = e.name + "_extruded";
      const b = await (null === (f = null === (d = null === (p = this._viewer) || void 0 === p ? void 0 : p.getManager()) || void 0 === d ? void 0 : d.importer) || void 0 === f ? void 0 : f.processImportedSingle(A, {
        autoCenter: !1,
        autoScale: !1
      }));
      b && (null === (m = e.parent) || void 0 === m || m.add(b.modelObject), e.userData.extrudedObject = b.modelObject.uuid, b.dispatchEvent({
        type: "select",
        ui: !0,
        value: b
      }));
    }
    static ExtrudeShape(e, t, r, i, s, o, a, l) {
      const c = new TE(e, i, t, r, !0, new n.FM8(s, o), l ? "shape" : "path");
      c.computeBoundingBox(), c.createSplits(a);
      const u = new n.Kj0(c, []);
      return u.userData.isExtrudedTube = !0, u;
    }
    static ConvertGeometryToFlatShape(e, t = !0) {
      if (e.userData.__planarShape) return e.userData.__planarShape;
      let r = e.attributes.position;
      if (!r) throw "no position attribute";
      if (r.count > 500) throw "too large to extrude";
      const i = e;
      r = i.attributes.position, i.boundingBox || i.computeBoundingBox();
      const s = i.boundingBox.getSize(new n.Pa4()),
        o = s.x < .001 ? "x" : s.y < .001 ? "y" : s.z < .001 ? "z" : null;
      if (!o) throw "geometry is not axis aligned not planar";
      let a = [];
      for (let e = 0; e < r.count; e++) {
        const t = new n.FM8();
        "x" === o ? t.set(r.getY(e), r.getZ(e)) : "y" === o ? t.set(r.getX(e), r.getZ(e)) : t.set(r.getX(e), r.getY(e)), a.push(t);
      }
      if (t) {
        let e = 0;
        for (let t = 0; t < a.length; t++) (a[t].x < a[e].x || a[t].x === a[e].x && a[t].y < a[e].y) && (e = t);
        0 !== e && (a = a.slice(e).concat(a.slice(0, e)));
      }
      const l = new n.bnF(a);
      return e.userData.__planarShape = l, l;
    }
  };
  DE.PluginType = "ShapeTubeExtrudePlugin", kE([Je("Enabled")], DE.prototype, "enabled", void 0), kE([$e("Shape Segments (X)", [1, 100], 1, e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "shapeSegments", void 0), kE([$e("Tube Segments (Y)", [1, 100], 1, e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "tubularSegments", void 0), kE([et("Shape scale", [.01, 10], .01, e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "shapeScale", void 0), kE([nt("Material Splits", e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "materialSplits", void 0), kE([Je("Horizontal Splits", e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "horizontalSplits", void 0), kE([rt("Extrude Circle Tube", e => ({
    hidden: () => {
      var t, r;
      return !(null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject());
    }
  }))], DE.prototype, "extrudeCirceTube", void 0), DE = IE = kE([lt("Extrude Tube Shapes")], DE);
  class PE extends n.Ny0 {
    getPoint(e, t) {
      return super.getPoint(e, t || new n.Pa4());
    }
  }
  class BE extends ro {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = !1, this.disableFrameFade = !0, this._postFrame = () => {
        var e, t;
        if (!this._viewer) return;
        if (!this.enabled || Object.keys(this.animations).length < 1) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(BE.PluginType), this._fadeDisabled = !1));
        const r = Dt() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = r - 1 / 60);
        let n = r - this._lastFrameTime;
        this._lastFrameTime = r;
        const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
        if (i && i > 0 && (n = i), 0 !== i && (n *= 1e3, !(n <= .001) && (this._updaters.forEach(e => {
          let t = n;
          e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
        }), !this._fadeDisabled && this.disableFrameFade))) {
          const e = this._viewer.getPluginByType("FrameFade");
          e && (e.disable(BE.PluginType), this._fadeDisabled = !0);
        }
      }, this.defaultDriver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.animations = {}, this.enabled = e, this._postFrame = this._postFrame.bind(this);
    }
    async onAdded(e) {
      await super.onAdded(e), e.addEventListener("postFrame", this._postFrame);
    }
    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), super.onRemove(e);
    }
    animate(e) {
      const t = Xe(),
        r = {
          id: t,
          options: e,
          stop: () => {
            var e, r, n;
            (null === (e = this.animations[t]) || void 0 === e ? void 0 : e._stop) ? null === (n = null === (r = this.animations[t]) || void 0 === r ? void 0 : r._stop) || void 0 === n || n.call(r) : console.warn("Animation not started");
          }
        };
      return this.animations[t] = r, r.promise = new Promise((r, n) => {
        const i = {
            driver: this.defaultDriver,
            onComplete: () => {
              var t;
              null === (t = e.onComplete) || void 0 === t || t.call(e), r();
            },
            onStop: () => {
              var t;
              null === (t = e.onStop) || void 0 === t || t.call(e), r();
            },
            ...e
          },
          s = Ic(i);
        this.animations[t]._stop = s.stop, this.animations[t].options = i;
      }).then(() => (delete this.animations[t], t)), this.animations[t];
    }
    async animateAsync(e) {
      return this.animate(e).promise;
    }
  }
  BE.PluginType = "PopmotionPlugin";
  const RE = async e => xt(await (await fetch(e)).blob());
  async function LE(e, t = RE) {
    const r = e.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
    if (r) for (const n of r) {
      const r = await t(n);
      e = e.replace(n, r);
    }
    return e;
  }
  function OE(e, t, {
    width: r,
    height: n
  }, i = !0) {
    const s = `\n<svg viewBox="0 0 ${r} ${n}" xmlns="http://www.w3.org/2000/svg">\n    <style>\n    ${t}\n    </style>\n    <foreignObject x="0" y="0" width="100%" height="100%">\n        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">\n            ${e}\n        </div>\n    </foreignObject>\n</svg>\n    `;
    return i ? C(s) : s;
  }
  async function FE(e, t, r) {
    const n = OE(e, t, r);
    return await Jy(n, r);
  }
  async function UE(e, t, r) {
    const n = OE(e, t, r);
    return await Zy(n, r);
  }
  var NE,
    jE,
    zE = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  const GE = e => ({
    onChange: t => {
      t.last && e.onChange();
    }
  });
  let VE = NE = class {
    constructor() {
      this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.fontFamily = "", this.fontPath = "", this.maskText = !1, this.innerShadow = !1, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {};
    }
    set(e) {
      Object.assign(this, e);
    }
    reset() {
      const e = this.onChange;
      Object.assign(this, new NE()), this.onChange = e;
    }
    toJSON() {
      return {
        text: this.text,
        fontFamily: this.fontFamily,
        fontPath: this.fontPath,
        svgBackground: this.svgBackground,
        width: this.width,
        height: this.height,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        boxWidth: this.boxWidth,
        boxHeight: this.boxHeight,
        fontSize: this.fontSize,
        maskText: this.maskText,
        innerShadow: this.innerShadow,
        bgFillColor: this.bgFillColor,
        textColor: this.textColor
      };
    }
  };
  zE([nt("Text", GE)], VE.prototype, "text", void 0), zE([$e("Font Size", [2, 400], 1, GE)], VE.prototype, "fontSize", void 0), zE([$e("Width", [2, 4096], 1, GE)], VE.prototype, "width", void 0), zE([$e("Height", [2, 4096], 1, GE)], VE.prototype, "height", void 0), zE([$e("X Offset", [-1024, 1024], 1, GE)], VE.prototype, "xOffset", void 0), zE([$e("Y Offset", [-1024, 1024], 1, GE)], VE.prototype, "yOffset", void 0), zE([$e("V-Width", [2, 4096], 1, GE)], VE.prototype, "boxWidth", void 0), zE([$e("V-Height", [2, 4096], 1, GE)], VE.prototype, "boxHeight", void 0), zE([nt("Font", GE)], VE.prototype, "fontFamily", void 0), zE([nt("Font Url", GE)], VE.prototype, "fontPath", void 0), zE([Je("Mask Text", GE)], VE.prototype, "maskText", void 0), zE([Je("Inner Shadow", GE)], VE.prototype, "innerShadow", void 0), zE([it("Text Color", GE)], VE.prototype, "textColor", void 0), zE([it("BG Fill", GE)], VE.prototype, "bgFillColor", void 0), zE([it("SVG BG", GE)], VE.prototype, "svgBackground", void 0), VE = NE = zE([lt("Text SVG Options")], VE);
  const QE = {
      woff: "woff",
      woff2: "woff2",
      ttf: "truetype",
      otf: "opentype",
      eot: "embedded-opentype"
    },
    HE = e => ({
      hidden: () => {
        const t = e.getSelected();
        return !t || !t.userData[WE.PluginType];
      }
    });
  let WE = jE = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.getSelected = () => {
        var e, t;
        return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      }, this.options = new VE(), this.applyToMap = !0, this.applyToBumpMap = !1, this.applyToAlphaMap = !0, this.inverseAlphaMap = !1, this._lastMeta = void 0, this.fonts = {
        roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2"
      }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged;
    }
    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    _selectedObjectChanged() {
      var e, t, r, n, i, s;
      if (!this.enabled) return;
      const o = this.getSelected();
      if (!o) return void (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      const a = o.userData[jE.PluginType];
      if (!a) return this.options.reset(), this._lastMeta = void 0, void (null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0));
      this._lastMeta !== a && (this.options.set(a), this._lastMeta = a), null === (s = (i = this.uiConfig).uiRefresh) || void 0 === s || s.call(i, "postFrame", !0);
    }
    _paramsChanged() {
      if (!this.enabled) return;
      const e = this.getSelected();
      e && e.isMesh && e.userData[jE.PluginType] && this.updateText(e, this.options.toJSON());
    }
    async addTextToSelected() {
      var e;
      const t = this.getSelected();
      t && t.isMesh ? t.material ? (t.userData[jE.PluginType] || !t.material.map || (await (null === (e = this._viewer) || void 0 === e ? void 0 : e.confirm("Add Text: This mesh already has a texture. Adding text will replace the texture. Continue?")))) && (await this.addText(t)) : console.error("no material on mesh") : console.error("no mesh is selected");
    }
    async addText(e, t) {
      return this.updateText(e, Object.assign(this.options.toJSON(), t));
    }
    async updateText(e, t) {
      var r, n;
      if (!e.isMesh) return;
      if (!e.material) return void console.error("updateText: no material on mesh");
      let i = e.userData[jE.PluginType];
      i || (e.userData[jE.PluginType] = i = {}), Object.assign(i, t);
      const s = e.material;
      s.map && (s.map._isSimpleTextTexture && s.map.dispose(), s.map = void 0), s.alphaMap && (s.alphaMap._isSimpleTextTexture && s.alphaMap.dispose(), s.alphaMap = void 0), s.bumpMap && (s.bumpMap._isSimpleTextTexture && s.bumpMap.dispose(), s.bumpMap = void 0);
      const o = await this.makeTextSvg(i);
      this.applyToMap && (s.map = o), this.applyToAlphaMap && (s.alphaMap = o, s.transparent = !0), this.applyToBumpMap && (s.bumpMap = o), s.userData.inverseAlphaMap = this.inverseAlphaMap, s.setDirty(), s.needsUpdate = !0, null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0);
    }
    async makeTextSvg(e) {
      const t = e.fontFamily || "Arial",
        r = e.fontPath || this.fonts[t] || "";
      let i = e.style;
      if (r.length > 0) {
        const e = r.split("?")[0].split(".").pop() || "woff";
        i += "\n" + (r.length > 0 ? `\n            @font-face {\n                font-family: ${t};\n                src: url(${r}) format(${QE[e] || e});\n            }` : "");
      }
      let s = function ({
        text: e = "Custom Text",
        svgBackground: t = "#ffffff",
        xOffset: r = 0,
        yOffset: n = 0,
        width: i = 1024,
        height: s = 1024,
        boxWidth: o = 1024,
        boxHeight: a = 1024,
        fontFamily: l = "",
        fontSize: c = 32,
        maskText: u = !0,
        innerShadow: h = !0,
        bgFillColor: p = "#000000",
        textColor: d = "#ffffff",
        style: f = ""
      }) {
        return `\n<svg style="background-color:${t}" width="${i}" height="${s}" viewBox="0 0 ${o} ${a}"\n xmlns="http://www.w3.org/2000/svg"\n xmlns:xlink="http://www.w3.org/1999/xlink">\n     <defs>\n        <style>\n        ${f}\n        </style>\n    </defs>\n\n    <g style="overflow:hidden; text-anchor: middle; font-size: ${c}px; font-family: ${l || "Arial"}">\n        <defs>\n\n` + (u ? `\n<mask id="textMask">\n<text style="fill:white; font-size: ${c}px;" x="${r + o / 2}" y="${a / 2 + n + c / 4}" > ${e} </text>\n</mask>\n` : "") + "\n\n" + (h ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u ? '\n        <g mask="url(#textMask)">\n' : "") + `\n\n        <rect x="0" y="0" width="${o}" height="${a}" style="fill:${p}"/>\n        <text style="${h ? "filter: url(#innerShadow);" : ""} fill:${d};" x="${r + o / 2}" y="${a / 2 + n + c / 4}"> ${e} </text>\n\n` + (u ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n";
      }({
        ...e,
        fontFamily: t,
        style: i
      });
      s = await LE(s, async e => this._getAssetData(e)), s = C(s);
      const o = await this._viewer.getManager().importer.importSinglePath(s, {
        generateMipmaps: !1,
        minFilter: n.wem
      });
      return o._isSimpleTextTexture = !0, o.flipY = !1, o.needsUpdate = !0, o;
    }
    async _getAssetData(e) {
      var t, r;
      if (e.startsWith("http://www.w3.org")) return e;
      const n = null === (r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getManager()) || void 0 === r ? void 0 : r.importer;
      if (!n) throw new Error("no importer");
      this._assetLoadOptions = this._assetLoadOptions || {
        fileHandler: new b_(n.loadingManager),
        processImported: !1
      };
      try {
        return await n.importPath(e, this._assetLoadOptions);
      } catch (e) {
        return console.error(e), "";
      }
    }
  };
  WE.PluginType = "SimpleTextPlugin", zE([Ke(void 0, {
    params: HE
  })], WE.prototype, "options", void 0), zE([Je("Apply Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToMap", void 0), zE([Je("Apply Bump Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToBumpMap", void 0), zE([Je("Apply Alpha Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToAlphaMap", void 0), zE([Je("Invert Alpha Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "inverseAlphaMap", void 0), zE([rt("Add Text", e => ({
    hidden: () => !e.getSelected()
  }))], WE.prototype, "addTextToSelected", null), WE = jE = zE([lt("Simple Text")], WE);
  class qE {
    constructor(e) {
      this.top = 0, this.array = new Float32Array(e);
    }
    write(e) {
      this.array[this.top++] = e.x, this.array[this.top++] = e.y, this.array[this.top++] = e.z;
    }
  }
  class XE {
    constructor(e) {
      this.top = 0, this.array = new Float32Array(e);
    }
    write(e) {
      this.array[this.top++] = e.x, this.array[this.top++] = e.y;
    }
  }
  class YE {
    constructor(e) {
      this.plane = null, this.front = null, this.back = null, this.polygons = [], e && this.build(e);
    }
    clone() {
      const e = new YE();
      return e.plane = this.plane && this.plane.clone(), e.front = this.front && this.front.clone(), e.back = this.back && this.back.clone(), e.polygons = this.polygons.map(e => e.clone()), e;
    }
    invert() {
      for (let e = 0; e < this.polygons.length; e++) this.polygons[e].flip();
      this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();
      const e = this.front;
      this.front = this.back, this.back = e;
    }
    clipPolygons(e) {
      if (!this.plane) return e.slice();
      let t = new Array(),
        r = new Array();
      for (let n = 0; n < e.length; n++) this.plane.splitPolygon(e[n], t, r, t, r);
      return this.front && (t = this.front.clipPolygons(t)), r = this.back ? this.back.clipPolygons(r) : [], t.concat(r);
    }
    clipTo(e) {
      this.polygons = e.clipPolygons(this.polygons), this.front && this.front.clipTo(e), this.back && this.back.clipTo(e);
    }
    allPolygons() {
      let e = this.polygons.slice();
      return this.front && (e = e.concat(this.front.allPolygons())), this.back && (e = e.concat(this.back.allPolygons())), e;
    }
    build(e) {
      if (!e.length) return;
      this.plane || (this.plane = e[0].plane.clone());
      const t = [],
        r = [];
      for (let n = 0; n < e.length; n++) this.plane.splitPolygon(e[n], this.polygons, this.polygons, t, r);
      t.length && (this.front || (this.front = new YE()), this.front.build(t)), r.length && (this.back || (this.back = new YE()), this.back.build(r));
    }
  }
  class KE {
    constructor(e = 0, t = 0, r = 0) {
      this.x = e, this.y = t, this.z = r;
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    clone() {
      return new KE(this.x, this.y, this.z);
    }
    negate() {
      return this.x *= -1, this.y *= -1, this.z *= -1, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
    }
    times(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    dividedBy(e) {
      return this.x /= e, this.y /= e, this.z /= e, this;
    }
    lerp(e, t) {
      return this.add(new KE().copy(e).sub(this).times(t));
    }
    unit() {
      return this.dividedBy(this.length());
    }
    length() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
    }
    normalize() {
      return this.unit();
    }
    cross(e) {
      const t = this.clone(),
        r = t.x,
        n = t.y,
        i = t.z,
        s = e.x,
        o = e.y,
        a = e.z;
      return this.x = n * a - i * o, this.y = i * s - r * a, this.z = r * o - n * s, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    toVector3() {
      return new n.Pa4(this.x, this.y, this.z);
    }
  }
  class JE {
    constructor(e, t) {
      this.normal = e, this.w = t, this.normal = e, this.w = t;
    }
    clone() {
      return new JE(this.normal.clone(), this.w);
    }
    flip() {
      this.normal.negate(), this.w = -this.w;
    }
    splitPolygon(e, t, r, n, i) {
      let s = 0;
      const o = [];
      for (let t = 0; t < e.vertices.length; t++) {
        const r = this.normal.dot(e.vertices[t].pos) - this.w,
          n = r < -JE.EPSILON ? 2 : r > JE.EPSILON ? 1 : 0;
        s |= n, o.push(n);
      }
      switch (s) {
        case 0:
          (this.normal.dot(e.plane.normal) > 0 ? t : r).push(e);
          break;
        case 1:
          n.push(e);
          break;
        case 2:
          i.push(e);
          break;
        case 3:
          {
            const t = [],
              r = [];
            for (let n = 0; n < e.vertices.length; n++) {
              const i = (n + 1) % e.vertices.length,
                s = o[n],
                a = o[i],
                l = e.vertices[n],
                c = e.vertices[i];
              if (2 != s && t.push(l), 1 != s && r.push(2 != s ? l.clone() : l), 3 == (s | a)) {
                const e = (this.w - this.normal.dot(l.pos)) / this.normal.dot(new KE().copy(c.pos).sub(l.pos)),
                  n = l.interpolate(c, e);
                t.push(n), r.push(n.clone());
              }
            }
            t.length >= 3 && n.push(new ZE(t, e.shared)), r.length >= 3 && i.push(new ZE(r, e.shared));
            break;
          }
      }
    }
    static fromPoints(e, t, r) {
      const n = new KE().copy(t).sub(e).cross(new KE().copy(r).sub(e)).normalize();
      return new JE(n.clone(), n.dot(e));
    }
  }
  JE.EPSILON = 1e-5;
  class ZE {
    constructor(e, t) {
      this.vertices = e, this.shared = t, this.plane = JE.fromPoints(e[0].pos, e[1].pos, e[2].pos);
    }
    clone() {
      return new ZE(this.vertices.map(e => e.clone()), this.shared);
    }
    flip() {
      this.vertices.reverse().map(e => e.flip()), this.plane.flip();
    }
  }
  class $E {
    constructor(e, t, r, n) {
      this.pos = new KE().copy(e), this.normal = new KE().copy(t), this.uv = new KE().copy(r), this.uv.z = 0, n && (this.color = new KE().copy(n));
    }
    clone() {
      return new $E(this.pos, this.normal, this.uv, this.color);
    }
    flip() {
      this.normal.negate();
    }
    interpolate(e, t) {
      return new $E(this.pos.clone().lerp(e.pos, t), this.normal.clone().lerp(e.normal, t), this.uv.clone().lerp(e.uv, t), this.color && e.color && this.color.clone().lerp(e.color, t));
    }
  }
  class eS {
    constructor() {
      this.polygons = new Array();
    }
    static fromPolygons(e) {
      const t = new eS();
      return t.polygons = e, t;
    }
    static fromGeometry(e, t) {
      let r = [];
      const n = e.attributes.position,
        i = e.attributes.normal,
        s = e.attributes.uv,
        o = e.attributes.color,
        a = e.groups;
      let l;
      if (e.index) l = e.index.array;else {
        l = new Array(n.array.length / n.itemSize | 0);
        for (let e = 0; e < l.length; e++) l[e] = e;
      }
      const c = l.length / 3 | 0;
      r = new Array(c);
      for (let e = 0, c = 0, u = l.length; e < u; e += 3, c++) {
        const u = new Array(3);
        for (let t = 0; t < 3; t++) {
          const r = l[e + t],
            a = 3 * r,
            c = 2 * r,
            h = n.array[a],
            p = n.array[a + 1],
            d = n.array[a + 2],
            f = i.array[a],
            m = i.array[a + 1],
            _ = i.array[a + 2],
            g = null == s ? void 0 : s.array[c],
            v = null == s ? void 0 : s.array[c + 1];
          u[t] = new $E(new KE(h, p, d), new KE(f, m, _), new KE(g, v, 0), o && new KE(o.array[c], o.array[c + 1], o.array[c + 2]));
        }
        if (void 0 === t && a && a.length > 0) for (const t of a) e >= t.start && e < t.start + t.count && (r[c] = new ZE(u, t.materialIndex));else r[c] = new ZE(u, t);
      }
      return eS.fromPolygons(r.filter(e => !isNaN(e.plane.normal.x)));
    }
    static toGeometry(e, t) {
      let r = 0;
      const i = e.polygons;
      for (const e of i) r += e.vertices.length - 2;
      const s = new n.u9r(),
        o = new qE(3 * r * 3),
        a = new qE(3 * r * 3),
        l = new XE(2 * r * 3);
      let c;
      const u = [],
        h = [];
      for (const e of i) {
        const t = e.vertices,
          n = t.length;
        void 0 !== e.shared && (u[e.shared] || (u[e.shared] = [])), n && void 0 !== t[0].color && (c || (c = new qE(3 * r * 3)));
        for (let r = 3; r <= n; r++) (void 0 === e.shared ? h : u[e.shared]).push(o.top / 3, o.top / 3 + 1, o.top / 3 + 2), o.write(t[0].pos), o.write(t[r - 2].pos), o.write(t[r - 1].pos), a.write(t[0].normal), a.write(t[r - 2].normal), a.write(t[r - 1].normal), l && (l.write(t[0].uv), l.write(t[r - 2].uv), l.write(t[r - 1].uv)), c && (c.write(t[0].color), c.write(t[r - 2].color), c.write(t[r - 1].color));
      }
      s.setAttribute("position", new n.TlE(o.array, 3)), s.setAttribute("normal", new n.TlE(a.array, 3)), l && s.setAttribute("uv", new n.TlE(l.array, 2)), c && s.setAttribute("color", new n.TlE(c.array, 3));
      for (let e = 0; e < u.length; e++) void 0 === u[e] && (u[e] = []);
      if (u.length) {
        let e = [],
          t = 0;
        for (let r = 0; r < u.length; r++) s.addGroup(t, u[r].length, r), t += u[r].length, e = e.concat(u[r]);
        s.addGroup(t, h.length, u.length), e = e.concat(h), s.setIndex(e);
      }
      const p = new n.yGw().copy(t).invert();
      return s.applyMatrix4(p), s.computeBoundingSphere(), s.computeBoundingBox(), s;
    }
    static fromMesh(e, t) {
      const r = eS.fromGeometry(e.geometry, t),
        i = new n.Pa4(),
        s = new n.Vkp();
      s.getNormalMatrix(e.matrix);
      for (let t = 0; t < r.polygons.length; t++) {
        const n = r.polygons[t];
        for (let t = 0; t < n.vertices.length; t++) {
          const r = n.vertices[t];
          r.pos.copy(i.copy(r.pos.toVector3()).applyMatrix4(e.matrix)), r.normal.copy(i.copy(r.normal.toVector3()).applyMatrix3(s));
        }
      }
      return r;
    }
    static toMesh(e, t, r) {
      const i = eS.toGeometry(e, t),
        s = new n.Kj0(i, r);
      return s.matrix.copy(t), s.matrix.decompose(s.position, s.quaternion, s.scale), s.rotation.setFromQuaternion(s.quaternion), s.updateMatrixWorld(), s.castShadow = s.receiveShadow = !0, s;
    }
    static union(e, t) {
      const r = eS.fromMesh(e),
        n = eS.fromMesh(t);
      return eS.toMesh(r.union(n), e.matrix, e.material);
    }
    static subtract(e, t) {
      const r = eS.fromMesh(e),
        n = eS.fromMesh(t);
      return eS.toMesh(r.subtract(n), e.matrix, e.material);
    }
    static intersect(e, t) {
      const r = eS.fromMesh(e),
        n = eS.fromMesh(t);
      return eS.toMesh(r.intersect(n), e.matrix, e.material);
    }
    clone() {
      const e = new eS();
      return e.polygons = this.polygons.map(e => e.clone()).filter(e => Number.isFinite(e.plane.w)), e;
    }
    toPolygons() {
      return this.polygons;
    }
    union(e) {
      const t = new YE(this.clone().polygons),
        r = new YE(e.clone().polygons);
      return t.clipTo(r), r.clipTo(t), r.invert(), r.clipTo(t), r.invert(), t.build(r.allPolygons()), eS.fromPolygons(t.allPolygons());
    }
    subtract(e) {
      const t = new YE(this.clone().polygons),
        r = new YE(e.clone().polygons);
      return t.invert(), t.clipTo(r), r.clipTo(t), r.invert(), r.clipTo(t), r.invert(), t.build(r.allPolygons()), t.invert(), eS.fromPolygons(t.allPolygons());
    }
    intersect(e) {
      const t = new YE(this.clone().polygons),
        r = new YE(e.clone().polygons);
      return t.invert(), r.clipTo(t), r.invert(), t.clipTo(r), r.clipTo(t), t.build(r.allPolygons()), t.invert(), eS.fromPolygons(t.allPolygons());
    }
    inverse() {
      const e = this.clone();
      for (const t of e.polygons) t.flip();
      return e;
    }
    toMesh(e, t) {
      return eS.toMesh(this, e, t);
    }
    toGeometry(e) {
      return eS.toGeometry(this, e);
    }
  }
  var tS = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const rS = ["union", "subtract", "intersect"];
  class nS extends ro {
    constructor() {
      super(), this.enabled = !0, this.toJSON = void 0, this.dependencies = [Nc], this.rootMesh = new n.Kj0(), this.showResult = !1, this.csgSelectedEnabled = !1, this.csgSelectedOperation = "union", this._csgNeedsUpdate = !1, this._csgVisible = !1, this._sceneUpdate = this._sceneUpdate.bind(this), this._preFrame = this._preFrame.bind(this), this.makeSelectedCSGBrush = this.makeSelectedCSGBrush.bind(this), this.refreshCSG = this.refreshCSG.bind(this), this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this._updateSelectedProperties = this._updateSelectedProperties.bind(this), this.downloadObject = this.downloadObject.bind(this), this.exportObject = this.exportObject.bind(this);
    }
    async onAdded(e) {
      var t;
      await super.onAdded(e), this.rootObject = await e.createObject3D(), this.rootObject.modelObject.add(this.rootMesh), e.scene.addEventListener("sceneUpdate", this._sceneUpdate), e.addEventListener("preFrame", this._preFrame), null === (t = e.getPlugin(Nc)) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    async makeSelectedCSGBrush() {
      var e, t;
      const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
      r && r.geometry && (r.userData._isCSGMesh || (r.userData.csgBrush || (r.userData.csgBrush = {
        enabled: !0,
        operation: "union"
      }), this._selectedObjectChanged()));
    }
    refreshCSG() {
      this._sceneUpdate();
    }
    async downloadObject() {
      const e = await this.exportObject();
      e && yt(e, "csg." + e.ext);
    }
    async exportObject() {
      var e, t;
      const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("AssetExporterPlugin")) || void 0 === t ? void 0 : t.exporter;
      if (!r || !this.rootObject) return;
      const n = this.rootMesh.visible;
      this.rootMesh.visible = !0;
      const i = await r.exportObject(this.rootObject.modelObject, {});
      return this.rootMesh.visible = n, i;
    }
    _updateSelectedProperties() {
      var e, t;
      const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
      r && r.userData.csgBrush && (r.userData.csgBrush.enabled = this.csgSelectedEnabled, r.userData.csgBrush.operation = this.csgSelectedOperation);
    }
    _selectedObjectChanged() {
      var e, t, r, n, i, s, o, a;
      const l = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Nc)) || void 0 === t ? void 0 : t.getSelectedObject();
      l && (this.csgSelectedEnabled = null !== (n = null === (r = l.userData.csgBrush) || void 0 === r ? void 0 : r.enabled) && void 0 !== n && n, this.csgSelectedOperation = null !== (s = null === (i = l.userData.csgBrush) || void 0 === i ? void 0 : i.operation) && void 0 !== s ? s : "union"), null === (a = null === (o = this.uiConfig) || void 0 === o ? void 0 : o.uiRefresh) || void 0 === a || a.call(o, "postFrame", !0);
    }
    _preFrame() {
      var e, t, r;
      if (!this.rootObject) return;
      if (!this._csgNeedsUpdate && this._csgVisible === this.showResult) return;
      const n = this._findCSGMeshes();
      this._csgNeedsUpdate && (this._csgNeedsUpdate = !1, null === (e = this.rootObject) || void 0 === e || e.modelObject.updateMatrixWorld(!0), (null !== (t = this.rootMesh.userData.dispose) && void 0 !== t ? t : this.rootMesh.removeFromParent)(), this.rootMesh = this._buildCSGMesh(n)), this.rootMesh && !this.rootMesh.parent && (null === (r = this.rootObject) || void 0 === r || r.modelObject.add(this.rootMesh)), this.showResult ? (n.forEach(e => {
        e[0].visible = !1;
      }), this.rootObject.visible = !0, this._csgVisible = !0, this.rootObject.setDirty()) : (n.forEach(e => {
        e[0].visible = !0;
      }), this.rootObject.visible = !1, this._csgVisible = !1, this.rootObject.setDirty());
    }
    _findCSGMeshes() {
      var e;
      const t = [];
      return null === (e = this._viewer) || void 0 === e || e.scene.traverse(e => {
        var r;
        e.isMesh && e.geometry && (null === (r = e.userData.csgBrush) || void 0 === r ? void 0 : r.enabled) && t.push([e, e.userData.csgBrush.operation]);
      }), t;
    }
    _sceneUpdate(e) {
      var t, r;
      (null === (r = null === (t = null == e ? void 0 : e.object) || void 0 === t ? void 0 : t.userData) || void 0 === r ? void 0 : r._isCSGMesh) || (this._csgNeedsUpdate = !0);
    }
  }
  tS([Je("Show Result", e => ({
    onChange: () => {
      var t;
      return null === (t = e._viewer) || void 0 === t ? void 0 : t.setDirty();
    }
  }))], nS.prototype, "showResult", void 0), tS([rt("Make CSG Brush", e => ({
    hidden: () => {
      var t, r;
      const n = null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject();
      return !(null == n ? void 0 : n.userData) || !!n.userData.csgBrush || n.userData._isCSGMesh;
    }
  }))], nS.prototype, "makeSelectedCSGBrush", null), tS([Je("Enabled", e => ({
    hidden: () => {
      var t, r;
      const n = null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject();
      return !n || !n.userData.csgBrush;
    },
    onChange: e._updateSelectedProperties
  }))], nS.prototype, "csgSelectedEnabled", void 0), tS([tt("Operation", rS.map(e => ({
    label: e
  })), e => ({
    hidden: () => {
      var t, r;
      const n = null === (r = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === r ? void 0 : r.getSelectedObject();
      return !n || !n.userData.csgBrush;
    },
    onChange: e._updateSelectedProperties
  }))], nS.prototype, "csgSelectedOperation", void 0), tS([rt("Refresh CSG")], nS.prototype, "refreshCSG", null), tS([rt("Export Result", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("AssetExporterPlugin"));
    }
  }))], nS.prototype, "downloadObject", null);
  function iS(e, t) {
    let r = new eS();
    const i = e.map(e => e[0].material).flatMap(e => e);
    e.forEach(([e, t]) => {
      if (!rS.includes(t)) return void console.error(`Unknown operation ${t}`);
      e.updateMatrix(), e.updateMatrixWorld();
      const n = e.matrix;
      e.matrix = e.matrixWorld;
      let s = 0;
      s = Array.isArray(e.material) ? void 0 : i.indexOf(e.material), r = r[t](eS.fromMesh(e, s)), e.matrix = n;
    });
    const s = r.toMesh(null != t ? t : new n.yGw().identity(), i);
    return s.userData._isCSGMesh = !0, s.geometry.groups = s.geometry.groups.filter(e => e.count > 0), s;
  }
  let sS = class extends nS {
    _buildCSGMesh(e) {
      return iS(e);
    }
  };
  sS.PluginType = "CSGPluginBSP", sS = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  }([lt("CSG Plugin (BSP)")], sS);
  class oS {
    constructor() {
      this.min = 1 / 0, this.max = -1 / 0;
    }
    setFromPointsField(e, t) {
      let r = 1 / 0,
        n = -1 / 0;
      for (let i = 0, s = e.length; i < s; i++) {
        const s = e[i][t];
        r = s < r ? s : r, n = s > n ? s : n;
      }
      this.min = r, this.max = n;
    }
    setFromPoints(e, t) {
      let r = 1 / 0,
        n = -1 / 0;
      for (let i = 0, s = t.length; i < s; i++) {
        const s = t[i],
          o = e.dot(s);
        r = o < r ? o : r, n = o > n ? o : n;
      }
      this.min = r, this.max = n;
    }
    isSeparated(e) {
      return this.min > e.max || e.min > this.max;
    }
  }
  oS.prototype.setFromBox = function () {
    const e = new n.Pa4();
    return function (t, r) {
      const n = r.min,
        i = r.max;
      let s = 1 / 0,
        o = -1 / 0;
      for (let r = 0; r <= 1; r++) for (let a = 0; a <= 1; a++) for (let l = 0; l <= 1; l++) {
        e.x = n.x * r + i.x * (1 - r), e.y = n.y * a + i.y * (1 - a), e.z = n.z * l + i.z * (1 - l);
        const c = t.dot(e);
        s = Math.min(c, s), o = Math.max(c, o);
      }
      this.min = s, this.max = o;
    };
  }(), new oS();
  const aS = function () {
      const e = new n.Pa4(),
        t = new n.Pa4(),
        r = new n.Pa4();
      return function (n, i, s) {
        const o = n.start,
          a = e,
          l = i.start,
          c = t;
        r.subVectors(o, l), e.subVectors(n.end, i.start), t.subVectors(i.end, i.start);
        const u = r.dot(c),
          h = c.dot(a),
          p = c.dot(c),
          d = r.dot(a),
          f = a.dot(a) * p - h * h;
        let m, _;
        m = 0 !== f ? (u * h - d * p) / f : 0, _ = (u + m * h) / p, s.x = m, s.y = _;
      };
    }(),
    lS = function () {
      const e = new n.FM8(),
        t = new n.Pa4(),
        r = new n.Pa4();
      return function (n, i, s, o) {
        aS(n, i, e);
        let a = e.x,
          l = e.y;
        if (a >= 0 && a <= 1 && l >= 0 && l <= 1) return n.at(a, s), void i.at(l, o);
        if (a >= 0 && a <= 1) return l < 0 ? i.at(0, o) : i.at(1, o), void n.closestPointToPoint(o, !0, s);
        if (l >= 0 && l <= 1) return a < 0 ? n.at(0, s) : n.at(1, s), void i.closestPointToPoint(s, !0, o);
        {
          let e, c;
          e = a < 0 ? n.start : n.end, c = l < 0 ? i.start : i.end;
          const u = t,
            h = r;
          return n.closestPointToPoint(c, !0, t), i.closestPointToPoint(e, !0, r), u.distanceToSquared(c) <= h.distanceToSquared(e) ? (s.copy(u), void o.copy(c)) : (s.copy(e), void o.copy(h));
        }
      };
    }(),
    cS = function () {
      const e = new n.Pa4(),
        t = new n.Pa4(),
        r = new n.JOQ(),
        i = new n.Zzh();
      return function (n, s) {
        const {
            radius: o,
            center: a
          } = n,
          {
            a: l,
            b: c,
            c: u
          } = s;
        if (i.start = l, i.end = c, i.closestPointToPoint(a, !0, e).distanceTo(a) <= o) return !0;
        if (i.start = l, i.end = u, i.closestPointToPoint(a, !0, e).distanceTo(a) <= o) return !0;
        if (i.start = c, i.end = u, i.closestPointToPoint(a, !0, e).distanceTo(a) <= o) return !0;
        const h = s.getPlane(r);
        if (Math.abs(h.distanceToPoint(a)) <= o) {
          const e = h.projectPoint(a, t);
          if (s.containsPoint(e)) return !0;
        }
        return !1;
      };
    }();
  function uS(e) {
    return Math.abs(e) < 1e-15;
  }
  class hS extends n.CJI {
    constructor(...e) {
      super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new n.Pa4()), this.satBounds = new Array(4).fill().map(() => new oS()), this.points = [this.a, this.b, this.c], this.sphere = new n.aLr(), this.plane = new n.JOQ(), this.needsUpdate = !0;
    }
    intersectsSphere(e) {
      return cS(e, this);
    }
    update() {
      const e = this.a,
        t = this.b,
        r = this.c,
        n = this.points,
        i = this.satAxes,
        s = this.satBounds,
        o = i[0],
        a = s[0];
      this.getNormal(o), a.setFromPoints(o, n);
      const l = i[1],
        c = s[1];
      l.subVectors(e, t), c.setFromPoints(l, n);
      const u = i[2],
        h = s[2];
      u.subVectors(t, r), h.setFromPoints(u, n);
      const p = i[3],
        d = s[3];
      p.subVectors(r, e), d.setFromPoints(p, n), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, e), this.needsUpdate = !1;
    }
  }
  hS.prototype.closestPointToSegment = function () {
    const e = new n.Pa4(),
      t = new n.Pa4(),
      r = new n.Zzh();
    return function (n, i = null, s = null) {
      const {
          start: o,
          end: a
        } = n,
        l = this.points;
      let c,
        u = 1 / 0;
      for (let o = 0; o < 3; o++) {
        const a = (o + 1) % 3;
        r.start.copy(l[o]), r.end.copy(l[a]), lS(r, n, e, t), c = e.distanceToSquared(t), c < u && (u = c, i && i.copy(e), s && s.copy(t));
      }
      return this.closestPointToPoint(o, e), c = o.distanceToSquared(e), c < u && (u = c, i && i.copy(e), s && s.copy(o)), this.closestPointToPoint(a, e), c = a.distanceToSquared(e), c < u && (u = c, i && i.copy(e), s && s.copy(a)), Math.sqrt(u);
    };
  }(), hS.prototype.intersectsTriangle = function () {
    const e = new hS(),
      t = new Array(3),
      r = new Array(3),
      i = new oS(),
      s = new oS(),
      o = new n.Pa4(),
      a = new n.Pa4(),
      l = new n.Pa4(),
      c = new n.Pa4(),
      u = new n.Zzh(),
      h = new n.Zzh(),
      p = new n.Zzh();
    return function (n, d = null) {
      this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (e.copy(n), e.update(), n = e);
      const f = this.plane,
        m = n.plane;
      if (Math.abs(f.normal.dot(m.normal)) > 1 - 1e-10) {
        const e = this.satBounds,
          a = this.satAxes;
        r[0] = n.a, r[1] = n.b, r[2] = n.c;
        for (let t = 0; t < 4; t++) {
          const n = e[t],
            s = a[t];
          if (i.setFromPoints(s, r), n.isSeparated(i)) return !1;
        }
        const l = n.satBounds,
          c = n.satAxes;
        t[0] = this.a, t[1] = this.b, t[2] = this.c;
        for (let e = 0; e < 4; e++) {
          const r = l[e],
            n = c[e];
          if (i.setFromPoints(n, t), r.isSeparated(i)) return !1;
        }
        for (let e = 0; e < 4; e++) {
          const n = a[e];
          for (let e = 0; e < 4; e++) {
            const a = c[e];
            if (o.crossVectors(n, a), i.setFromPoints(o, t), s.setFromPoints(o, r), i.isSeparated(s)) return !1;
          }
        }
        return d && (console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), d.start.set(0, 0, 0), d.end.set(0, 0, 0)), !0;
      }
      {
        const e = this.points;
        let t = !1,
          r = 0;
        for (let n = 0; n < 3; n++) {
          const i = e[n],
            s = e[(n + 1) % 3];
          u.start.copy(i), u.end.copy(s), u.delta(a);
          const o = t ? h.start : h.end,
            l = uS(m.distanceToPoint(i));
          if (uS(m.normal.dot(a)) && l) {
            h.copy(u), r = 2;
            break;
          }
          if ((m.intersectLine(u, o) || l) && !uS(o.distanceTo(s))) {
            if (r++, t) break;
            t = !0;
          }
        }
        if (1 === r && this.containsPoint(h.start)) return d && (d.start.copy(h.start), d.end.copy(h.start)), !0;
        if (2 !== r) return !1;
        const i = n.points;
        let s = !1,
          o = 0;
        for (let e = 0; e < 3; e++) {
          const t = i[e],
            r = i[(e + 1) % 3];
          u.start.copy(t), u.end.copy(r), u.delta(l);
          const n = s ? p.start : p.end,
            a = uS(f.distanceToPoint(t));
          if (uS(f.normal.dot(l)) && a) {
            p.copy(u), o = 2;
            break;
          }
          if ((f.intersectLine(u, n) || a) && !uS(n.distanceTo(r))) {
            if (o++, s) break;
            s = !0;
          }
        }
        if (1 === o && this.containsPoint(p.start)) return d && (d.start.copy(p.start), d.end.copy(p.start)), !0;
        if (2 !== o) return !1;
        if (h.delta(a), p.delta(l), a.dot(l) < 0) {
          let e = p.start;
          p.start = p.end, p.end = e;
        }
        const _ = h.start.dot(a),
          g = h.end.dot(a),
          v = p.start.dot(a),
          A = p.end.dot(a),
          b = g < v,
          y = _ < A;
        return (_ === A || v === g || b !== y) && (d && (c.subVectors(h.start, p.start), c.dot(a) > 0 ? d.start.copy(h.start) : d.start.copy(p.start), c.subVectors(h.end, p.end), c.dot(a) < 0 ? d.end.copy(h.end) : d.end.copy(p.end)), !0);
      }
    };
  }(), hS.prototype.distanceToPoint = function () {
    const e = new n.Pa4();
    return function (t) {
      return this.closestPointToPoint(t, e), t.distanceTo(e);
    };
  }(), hS.prototype.distanceToTriangle = function () {
    const e = new n.Pa4(),
      t = new n.Pa4(),
      r = ["a", "b", "c"],
      i = new n.Zzh(),
      s = new n.Zzh();
    return function (n, o = null, a = null) {
      const l = o || a ? i : null;
      if (this.intersectsTriangle(n, l)) return (o || a) && (o && l.getCenter(o), a && l.getCenter(a)), 0;
      let c = 1 / 0;
      for (let t = 0; t < 3; t++) {
        let i;
        const s = r[t],
          l = n[s];
        this.closestPointToPoint(l, e), i = l.distanceToSquared(e), i < c && (c = i, o && o.copy(e), a && a.copy(l));
        const u = this[s];
        n.closestPointToPoint(u, e), i = u.distanceToSquared(e), i < c && (c = i, o && o.copy(u), a && a.copy(e));
      }
      for (let l = 0; l < 3; l++) {
        const u = r[l],
          h = r[(l + 1) % 3];
        i.set(this[u], this[h]);
        for (let l = 0; l < 3; l++) {
          const u = r[l],
            h = r[(l + 1) % 3];
          s.set(n[u], n[h]), lS(i, s, e, t);
          const p = e.distanceToSquared(t);
          p < c && (c = p, o && o.copy(e), a && a.copy(t));
        }
      }
      return Math.sqrt(c);
    };
  }();
  class pS {
    constructor() {
      this.intersectionSet = {}, this.ids = [];
    }
    add(e, t) {
      const {
        intersectionSet: r,
        ids: n
      } = this;
      r[e] || (r[e] = [], n.push(e)), r[e].push(t);
    }
  }
  const dS = new n.zHn(),
    fS = new n.yGw(),
    mS = new n.CJI(),
    _S = new n.Pa4(),
    gS = new n.Ltg(),
    vS = new n.Ltg(),
    AS = new n.Ltg(),
    bS = new n.Ltg(),
    yS = new n.Ltg(),
    xS = new n.Ltg(),
    wS = new n.Zzh(),
    ES = 1e-8;
  let SS = null;
  function CS(e) {
    SS = e;
  }
  function MS(e, t) {
    function r() {
      return Math.random() - .5;
    }
    dS.origin.copy(e.a).add(e.b).add(e.c).multiplyScalar(1 / 3), e.getNormal(dS.direction);
    let i = 0,
      s = 1 / 0;
    for (let e = 0; e < 3; e++) {
      dS.direction.x += r() * ES, dS.direction.y += r() * ES, dS.direction.z += r() * ES;
      const o = t.raycastFirst(dS, n.ehD);
      if (Boolean(o && dS.direction.dot(o.face.normal) > 0) && i++, null !== o && (s = Math.min(s, o.distance)), 0 === s || i / 3 > .5 || (e - i + 1) / 3 > .5) break;
    }
    return 0 === s ? 0 : i / 3 > .5 ? -1 : 1;
  }
  function TS(e, t, r, n, i, s, o = !1) {
    const a = r.attributes,
      l = r.index,
      c = 3 * e,
      u = l.getX(c + 0),
      h = l.getX(c + 1),
      p = l.getX(c + 2);
    for (const e in s) {
      const r = a[e],
        l = s[e];
      if (!(e in a)) throw new Error(`CSG Operations: Attribute ${e} not available on geometry.`);
      const c = r.itemSize;
      "position" === e ? (mS.a.fromBufferAttribute(r, u).applyMatrix4(n), mS.b.fromBufferAttribute(r, h).applyMatrix4(n), mS.c.fromBufferAttribute(r, p).applyMatrix4(n), DS(mS.a, mS.b, mS.c, t, 3, l, o)) : "normal" === e ? (mS.a.fromBufferAttribute(r, u).applyNormalMatrix(i), mS.b.fromBufferAttribute(r, h).applyNormalMatrix(i), mS.c.fromBufferAttribute(r, p).applyNormalMatrix(i), o && (mS.a.multiplyScalar(-1), mS.b.multiplyScalar(-1), mS.c.multiplyScalar(-1)), DS(mS.a, mS.b, mS.c, t, 3, l, o, !0)) : (gS.fromBufferAttribute(r, u), vS.fromBufferAttribute(r, h), AS.fromBufferAttribute(r, p), DS(gS, vS, AS, t, c, l, o));
    }
  }
  function IS(e, t, r, n, i, s, o, a = !1) {
    PS(e, n, i, s, o, a), PS(t, n, i, s, o, a), PS(r, n, i, s, o, a);
  }
  function kS(e, t, r = !1) {
    switch (e) {
      case 0:
        if (1 === t || 0 === t && r) return 1;
        break;
      case 1:
        if (r) {
          if (-1 === t) return 0;
        } else if (1 === t) return 1;
        break;
      case 3:
        if (-1 === t) return 0;
        if (1 === t) return 1;
      case 4:
        if (-1 === t || 0 === t && r) return 1;
        break;
      default:
        throw new Error(`Unrecognized CSG operation enum "${e}".`);
    }
    return 2;
  }
  function DS(e, t, r, n, i, s, o = !1, a = !1) {
    const l = e => {
      s.push(e.x), i > 1 && s.push(e.y), i > 2 && s.push(e.z), i > 3 && s.push(e.w);
    };
    bS.set(0, 0, 0, 0).addScaledVector(e, n.a.x).addScaledVector(t, n.a.y).addScaledVector(r, n.a.z), yS.set(0, 0, 0, 0).addScaledVector(e, n.b.x).addScaledVector(t, n.b.y).addScaledVector(r, n.b.z), xS.set(0, 0, 0, 0).addScaledVector(e, n.c.x).addScaledVector(t, n.c.y).addScaledVector(r, n.c.z), a && (bS.normalize(), yS.normalize(), xS.normalize()), l(bS), o ? (l(xS), l(yS)) : (l(yS), l(xS));
  }
  function PS(e, t, r, n, i, s = !1) {
    for (const o in i) {
      const a = t[o],
        l = i[o];
      if (!(o in t)) throw new Error(`CSG Operations: Attribute ${o} no available on geometry.`);
      const c = a.itemSize;
      "position" === o ? (_S.fromBufferAttribute(a, e).applyMatrix4(r), l.push(_S.x, _S.y, _S.z)) : "normal" === o ? (_S.fromBufferAttribute(a, e).applyNormalMatrix(n), s && _S.multiplyScalar(-1), l.push(_S.x, _S.y, _S.z)) : (l.push(a.getX(e)), c > 1 && l.push(a.getY(e)), c > 2 && l.push(a.getZ(e)), c > 3 && l.push(a.getW(e)));
    }
  }
  const BS = 1e-14,
    RS = 1e-7,
    LS = new n.Zzh(),
    OS = new n.Zzh(),
    FS = new n.Pa4(),
    US = new n.Pa4(),
    NS = new n.JOQ(),
    jS = new hS();
  function zS(e) {
    return e.a.distanceToSquared(e.b) < BS || e.a.distanceToSquared(e.c) < BS || e.b.distanceToSquared(e.c) < BS;
  }
  class GS extends n.CJI {
    constructor(...e) {
      super(...e), this.side = null, this.originalSide = null, this.coplanarCount = 0;
    }
    init() {
      this.side = null, this.originalSide = null, this.coplanarCount = 0;
    }
    initFrom(e) {
      this.side = e.side, this.originalSide = e.originalSide, this.coplanarCount = e.coplanarCount;
    }
    updateSide(e, t = null, r = -1) {
      if (null !== this.originalSide && null === this.side) return;
      FS.copy(this.a).add(this.b).add(this.c).multiplyScalar(1 / 3);
      const n = e.distanceToPoint(FS) < 0 ? -1 : 1;
      t && -1 !== r ? 1 === n && (this.coplanarCount++, 3 === this.coplanarCount && (this.side = 0)) : (null === this.originalSide && (this.originalSide = n, this.side = n), n !== this.side && (this.side = null));
    }
  }
  class VS {
    constructor() {
      this._pool = [], this._index = 0;
    }
    getTriangle() {
      this._index >= this._pool.length && this._pool.push(new GS());
      const e = this._pool[this._index++];
      return e.init(), e;
    }
    clear() {
      this._index = 0;
    }
    reset() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class QS {
    constructor() {
      this.trianglePool = new VS(), this.triangles = [], this.normal = new n.Pa4();
    }
    initialize(e) {
      const {
        triangles: t,
        trianglePool: r,
        normal: n
      } = this;
      if (t.length = 0, r.clear(), Array.isArray(e)) for (let i = 0, s = e.length; i < s; i++) {
        const s = e[i];
        if (0 === i) s.getNormal(n);else if (Math.abs(1 - s.getNormal(FS).dot(n)) > BS) throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
        const o = r.getTriangle();
        o.copy(s), t.push(o);
      } else {
        e.getNormal(n);
        const i = r.getTriangle();
        i.copy(e), t.push(i);
      }
    }
    splitByTriangle(e) {
      const {
        normal: t,
        triangles: r
      } = this;
      if (e.getPlane(NS), Math.abs(1 - Math.abs(NS.normal.dot(t))) < RS) {
        const n = [e.a, e.b, e.c];
        for (let r = 0; r < 3; r++) {
          const i = (r + 1) % 3,
            s = n[r],
            o = n[i];
          FS.subVectors(o, s).normalize(), US.crossVectors(t, FS), NS.setFromNormalAndCoplanarPoint(US, s), this.splitByPlane(NS, e, r);
        }
        for (let e = 0, t = r.length; e < t; e++) r[e].coplanarCount = 0;
      } else this.splitByPlane(NS, e);
    }
    splitByPlane(e, t = null, r = -1) {
      const {
        triangles: n,
        trianglePool: i
      } = this;
      let s = null;
      null !== t && (s = jS, s.copy(t), s.needsUpdate = !0);
      for (let t = 0, o = n.length; t < o; t++) {
        const a = n[t],
          {
            a: l,
            b: c,
            c: u
          } = a;
        if (s && (!s.intersectsTriangle(a, LS) || LS.distance() < 1e-5)) {
          a.updateSide(e, s, r), a.side = null;
          continue;
        }
        let h = 0,
          p = -1,
          d = 0,
          f = 0,
          m = !1;
        const _ = [l, c, u];
        for (let t = 0; t < 3; t++) {
          const r = (t + 1) % 3;
          LS.start.copy(_[t]), LS.end.copy(_[r]);
          const n = e.distanceToPoint(LS.start),
            i = e.distanceToPoint(LS.end);
          Math.abs(n) < BS ? f++ : n > 0 && d++, Math.abs(n) < RS && Math.abs(i) < RS && (m = !0);
          let s = !!e.intersectLine(LS, FS);
          !s && Math.abs(i) < BS && (FS.copy(LS.end), s = !0), !s || FS.distanceTo(LS.start) < BS || (FS.distanceTo(LS.end) < BS && (p = t), 0 === h ? OS.start.copy(FS) : OS.end.copy(FS), h++);
        }
        if (!m && f < 2 && 2 === h && OS.distance() > RS) {
          if (-1 !== p) {
            p = (p + 1) % 3;
            let l = 0;
            l === p && (l = (l + 1) % 3);
            let c = l + 1;
            c === p && (c = (c + 1) % 3);
            const u = i.getTriangle();
            u.a.copy(_[c]), u.b.copy(OS.end), u.c.copy(OS.start), zS(u) || (n.push(u), u.initFrom(a), u.updateSide(e, s, r)), a.a.copy(_[l]), a.b.copy(OS.start), a.c.copy(OS.end), zS(a) ? (n.splice(t, 1), t--, o--) : a.updateSide(e, s, r);
          } else {
            const l = _.findIndex(t => d >= 2 ? e.distanceToPoint(t) < 0 : e.distanceToPoint(t) > 0);
            if (0 === l) {
              let e = OS.start;
              OS.start = OS.end, OS.end = e;
            } else if (-1 === l) continue;
            const c = (l + 1) % 3,
              u = (l + 2) % 3,
              h = i.getTriangle(),
              p = i.getTriangle();
            _[c].distanceToSquared(OS.start) < _[u].distanceToSquared(OS.end) ? (h.a.copy(_[c]), h.b.copy(OS.start), h.c.copy(OS.end), p.a.copy(_[c]), p.b.copy(_[u]), p.c.copy(OS.start)) : (h.a.copy(_[u]), h.b.copy(OS.start), h.c.copy(OS.end), p.a.copy(_[c]), p.b.copy(_[u]), p.c.copy(OS.end)), a.a.copy(_[l]), a.b.copy(OS.end), a.c.copy(OS.start), zS(h) || (n.push(h), h.initFrom(a), h.updateSide(e, s, r)), zS(p) || (n.push(p), p.initFrom(a), p.updateSide(e, s, r)), zS(a) ? (n.splice(t, 1), t--, o--) : a.updateSide(e, s, r);
          }
        } else 3 === h && console.warn("TriangleClipper: Coplanar clip not handled");
      }
    }
    reset() {
      this.triangles.length = 0;
    }
  }
  function HS() {
    return "undefined" != typeof SharedArrayBuffer;
  }
  function WS(e) {
    if (e.buffer instanceof SharedArrayBuffer) return e;
    const t = e.constructor,
      r = e.buffer,
      n = new SharedArrayBuffer(r.byteLength),
      i = new Uint8Array(r);
    return new Uint8Array(n).set(i, 0), new t(n);
  }
  class qS {
    constructor(e, t = 500) {
      const r = HS() ? SharedArrayBuffer : ArrayBuffer;
      this.expansionFactor = 1.5, this.type = e, this.array = new e(new r(t * e.BYTES_PER_ELEMENT)), this.length = 0;
    }
    expand(e = null) {
      const {
        type: t,
        array: r,
        expansionFactor: n
      } = this;
      null === e && (e = ~~(r.length * n));
      const i = new t(e);
      i.set(r, 0), this.array = i;
    }
    push(...e) {
      let {
        array: t,
        length: r
      } = this;
      r + e.length > t.length && (this.expand(), t = this.array);
      for (let n = 0, i = e.length; n < i; n++) t[r + n] = e[n];
      this.length += e.length;
    }
    clear() {
      this.length = 0;
    }
  }
  class XS {
    constructor() {
      this.groupAttributes = [{}], this.groupCount = 0;
    }
    getType(e) {
      return this.groupAttributes[0][e].type;
    }
    getTotalLength(e) {
      const {
        groupCount: t,
        groupAttributes: r
      } = this;
      let n = 0;
      for (let i = 0; i < t; i++) n += r[i][e].length;
      return n;
    }
    getGroupSet(e = 0) {
      const {
        groupAttributes: t
      } = this;
      if (t[e]) return this.groupCount = Math.max(this.groupCount, e + 1), t[e];
      const r = t[0];
      for (this.groupCount = Math.max(this.groupCount, e + 1); e >= t.length;) {
        const e = {};
        t.push(e);
        for (const t in r) e[t] = new qS(r[t].type);
      }
      return t[e];
    }
    getGroupArray(e, t = 0) {
      const {
        groupAttributes: r
      } = this;
      if (!r[0][e]) throw new Error(`TypedAttributeData: Attribute with "${e}" has not been initialized`);
      return this.getGroupSet(t)[e];
    }
    initializeArray(e, t) {
      const {
          groupAttributes: r
        } = this,
        n = r[0][e];
      if (n) {
        if (n.type !== t) throw new Error(`TypedAttributeData: Array ${e} already initialized with a different type.`);
      } else for (let n = 0, i = r.length; n < i; n++) r[n][e] = new qS(t);
    }
    clear() {
      this.groupCount = 0;
      const {
        groupAttributes: e
      } = this;
      e.forEach(e => {
        for (const t in e) e[t].clear();
      });
    }
    delete(e) {
      this.groupAttributes.forEach(t => {
        delete t[e];
      });
    }
    reset() {
      this.groupAttributes = [];
    }
  }
  class YS {
    constructor(e) {
      this.triangle = new n.CJI().copy(e), this.intersects = {};
    }
    addTriangle(e, t) {
      this.intersects[e] = new n.CJI().copy(t);
    }
    getIntersectArray() {
      const e = [],
        {
          intersects: t
        } = this;
      for (const r in t) e.push(t[r]);
      return e;
    }
  }
  class KS {
    constructor() {
      this.data = {};
    }
    addTriangleIntersection(e, t, r, n) {
      const {
        data: i
      } = this;
      i[e] || (i[e] = new YS(t)), i[e].addTriangle(r, n);
    }
    getTrianglesAsArray(e = null) {
      const {
          data: t
        } = this,
        r = [];
      if (null !== e) e in t && r.push(t[e].triangle);else for (const e in t) r.push(t[e].triangle);
      return r;
    }
    getTriangleIndices() {
      return Object.keys(this.data).map(e => parseInt(e));
    }
    getIntersectionIndices(e) {
      const {
        data: t
      } = this;
      return t[e] ? Object.keys(t[e].intersects).map(e => parseInt(e)) : [];
    }
    getIntersectionsAsArray(e = null, t = null) {
      const {
          data: r
        } = this,
        n = new Set(),
        i = [],
        s = e => {
          if (r[e]) if (null !== t) r[e].intersects[t] && i.push(r[e].intersects[t]);else {
            const t = r[e].intersects;
            for (const e in t) n.has(e) || (n.add(e), i.push(t[e]));
          }
        };
      if (null !== e) s(e);else for (const e in r) s(e);
      return i;
    }
    reset() {
      this.data = {};
    }
  }
  class JS {
    constructor() {
      this.enabled = !1, this.triangleIntersectsA = new KS(), this.triangleIntersectsB = new KS(), this.intersectionEdges = [];
    }
    addIntersectingTriangles(e, t, r, n) {
      const {
        triangleIntersectsA: i,
        triangleIntersectsB: s
      } = this;
      i.addTriangleIntersection(e, t, r, n), s.addTriangleIntersection(r, n, e, t);
    }
    addEdge(e) {
      this.intersectionEdges.push(e.clone());
    }
    reset() {
      this.triangleIntersectsA.reset(), this.triangleIntersectsB.reset(), this.intersectionEdges = [];
    }
  }
  const ZS = new n.yGw(),
    $S = new n.Vkp(),
    eC = new n.CJI(),
    tC = new n.CJI(),
    rC = new n.CJI(),
    nC = new n.CJI();
  function iC(e) {
    for (const t of e) return t;
  }
  function sC(e, t, r, n, i, s, o, a = 0) {
    ZS.copy(t.matrixWorld).invert().multiply(e.matrixWorld), $S.getNormalMatrix(e.matrixWorld);
    const l = e.geometry.groupIndices,
      c = e.geometry.index,
      u = e.geometry.attributes.position,
      h = t.geometry.boundsTree,
      p = t.geometry.index,
      d = t.geometry.attributes.position,
      f = r.ids,
      m = r.intersectionSet;
    for (let t = 0, r = f.length; t < r; t++) {
      const r = f[t],
        _ = -1 === a ? 0 : l[r] + a,
        g = o.getGroupSet(_),
        v = 3 * r,
        A = c.getX(v + 0),
        b = c.getX(v + 1),
        y = c.getX(v + 2);
      eC.a.fromBufferAttribute(u, A).applyMatrix4(ZS), eC.b.fromBufferAttribute(u, b).applyMatrix4(ZS), eC.c.fromBufferAttribute(u, y).applyMatrix4(ZS), s.initialize(eC);
      const x = m[r];
      for (let e = 0, t = x.length; e < t; e++) {
        const t = 3 * x[e],
          r = p.getX(t + 0),
          n = p.getX(t + 1),
          i = p.getX(t + 2);
        tC.a.fromBufferAttribute(d, r), tC.b.fromBufferAttribute(d, n), tC.c.fromBufferAttribute(d, i), s.splitByTriangle(tC);
      }
      const w = s.triangles;
      for (let t = 0, s = w.length; t < s; t++) {
        const s = w[t],
          o = kS(n, MS(s, h), i);
        if (2 !== o) switch (eC.getBarycoord(s.a, nC.a), eC.getBarycoord(s.b, nC.b), eC.getBarycoord(s.c, nC.c), o) {
          case 1:
            TS(r, nC, e.geometry, e.matrixWorld, $S, g);
            break;
          case 0:
            TS(r, nC, e.geometry, e.matrixWorld, $S, g, !0);
        }
      }
    }
    return f.length;
  }
  function oC(e, t, r, n, i, s, o = 0) {
    ZS.copy(t.matrixWorld).invert().multiply(e.matrixWorld), $S.getNormalMatrix(e.matrixWorld);
    const a = t.geometry.boundsTree,
      l = e.geometry.groupIndices,
      c = e.geometry.index,
      u = e.geometry.attributes,
      h = u.position,
      p = [],
      d = e.geometry.halfEdges,
      f = new Set();
    for (let e = 0, t = c.count / 3; e < t; e++) e in r.intersectionSet || f.add(e);
    for (; f.size > 0;) {
      const t = iC(f);
      f.delete(t), p.push(t);
      const r = 3 * t,
        m = c.getX(r + 0),
        _ = c.getX(r + 1),
        g = c.getX(r + 2);
      rC.a.fromBufferAttribute(h, m).applyMatrix4(ZS), rC.b.fromBufferAttribute(h, _).applyMatrix4(ZS), rC.c.fromBufferAttribute(h, g).applyMatrix4(ZS);
      const v = kS(n, MS(rC, a), i);
      for (; p.length > 0;) {
        const t = p.pop(),
          r = -1 === o ? 0 : l[t] + o,
          n = s.getGroupSet(r);
        for (let e = 0; e < 3; e++) {
          const r = d.getSiblingTriangleIndex(t, e);
          -1 !== r && f.has(r) && (p.push(r), f.delete(r));
        }
        const a = 3 * t,
          h = c.getX(a + 0),
          m = c.getX(a + 1),
          _ = c.getX(a + 2);
        switch (v) {
          case 1:
            IS(h, m, _, u, e.matrixWorld, $S, n);
            break;
          case 0:
            IS(_, m, h, u, e.matrixWorld, $S, n, i);
        }
      }
    }
  }
  const aC = 1.25,
    lC = 65535,
    cC = Math.pow(2, -24);
  class uC {
    constructor() {}
  }
  function hC(e, t, r) {
    return r.min.x = t[e], r.min.y = t[e + 1], r.min.z = t[e + 2], r.max.x = t[e + 3], r.max.y = t[e + 4], r.max.z = t[e + 5], r;
  }
  function pC(e) {
    let t = -1,
      r = -1 / 0;
    for (let n = 0; n < 3; n++) {
      const i = e[n + 3] - e[n];
      i > r && (r = i, t = n);
    }
    return t;
  }
  function dC(e, t) {
    t.set(e);
  }
  function fC(e, t, r) {
    let n, i;
    for (let s = 0; s < 3; s++) {
      const o = s + 3;
      n = e[s], i = t[s], r[s] = n < i ? n : i, n = e[o], i = t[o], r[o] = n > i ? n : i;
    }
  }
  function mC(e, t, r) {
    for (let n = 0; n < 3; n++) {
      const i = t[e + 2 * n],
        s = t[e + 2 * n + 1],
        o = i - s,
        a = i + s;
      o < r[n] && (r[n] = o), a > r[n + 3] && (r[n + 3] = a);
    }
  }
  function _C(e) {
    const t = e[3] - e[0],
      r = e[4] - e[1],
      n = e[5] - e[2];
    return 2 * (t * r + r * n + n * t);
  }
  function gC(e, t, r, n, i = null) {
    let s = 1 / 0,
      o = 1 / 0,
      a = 1 / 0,
      l = -1 / 0,
      c = -1 / 0,
      u = -1 / 0,
      h = 1 / 0,
      p = 1 / 0,
      d = 1 / 0,
      f = -1 / 0,
      m = -1 / 0,
      _ = -1 / 0;
    const g = null !== i;
    for (let n = 6 * t, i = 6 * (t + r); n < i; n += 6) {
      const t = e[n + 0],
        r = e[n + 1],
        i = t - r,
        v = t + r;
      i < s && (s = i), v > l && (l = v), g && t < h && (h = t), g && t > f && (f = t);
      const A = e[n + 2],
        b = e[n + 3],
        y = A - b,
        x = A + b;
      y < o && (o = y), x > c && (c = x), g && A < p && (p = A), g && A > m && (m = A);
      const w = e[n + 4],
        E = e[n + 5],
        S = w - E,
        C = w + E;
      S < a && (a = S), C > u && (u = C), g && w < d && (d = w), g && w > _ && (_ = w);
    }
    n[0] = s, n[1] = o, n[2] = a, n[3] = l, n[4] = c, n[5] = u, g && (i[0] = h, i[1] = p, i[2] = d, i[3] = f, i[4] = m, i[5] = _);
  }
  const vC = (e, t) => e.candidate - t.candidate,
    AC = new Array(32).fill().map(() => ({
      count: 0,
      bounds: new Float32Array(6),
      rightCacheBounds: new Float32Array(6),
      leftCacheBounds: new Float32Array(6),
      candidate: 0
    })),
    bC = new Float32Array(6);
  class yC extends n.ZzF {
    constructor(...e) {
      super(...e), this.isOrientedBox = !0, this.matrix = new n.yGw(), this.invMatrix = new n.yGw(), this.points = new Array(8).fill().map(() => new n.Pa4()), this.satAxes = new Array(3).fill().map(() => new n.Pa4()), this.satBounds = new Array(3).fill().map(() => new oS()), this.alignedSatBounds = new Array(3).fill().map(() => new oS()), this.needsUpdate = !1;
    }
    set(e, t, r) {
      super.set(e, t), this.matrix.copy(r), this.needsUpdate = !0;
    }
    copy(e) {
      super.copy(e), this.matrix.copy(e.matrix), this.needsUpdate = !0;
    }
  }
  yC.prototype.update = function () {
    const e = this.matrix,
      t = this.min,
      r = this.max,
      n = this.points;
    for (let i = 0; i <= 1; i++) for (let s = 0; s <= 1; s++) for (let o = 0; o <= 1; o++) {
      const a = n[1 * i | 2 * s | 4 * o];
      a.x = i ? r.x : t.x, a.y = s ? r.y : t.y, a.z = o ? r.z : t.z, a.applyMatrix4(e);
    }
    const i = this.satBounds,
      s = this.satAxes,
      o = n[0];
    for (let e = 0; e < 3; e++) {
      const t = s[e],
        r = i[e],
        a = n[1 << e];
      t.subVectors(o, a), r.setFromPoints(t, n);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(n, "x"), a[1].setFromPointsField(n, "y"), a[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  }, yC.prototype.intersectsBox = function () {
    const e = new oS();
    return function (t) {
      this.needsUpdate && this.update();
      const r = t.min,
        n = t.max,
        i = this.satBounds,
        s = this.satAxes,
        o = this.alignedSatBounds;
      if (e.min = r.x, e.max = n.x, o[0].isSeparated(e)) return !1;
      if (e.min = r.y, e.max = n.y, o[1].isSeparated(e)) return !1;
      if (e.min = r.z, e.max = n.z, o[2].isSeparated(e)) return !1;
      for (let r = 0; r < 3; r++) {
        const n = s[r],
          o = i[r];
        if (e.setFromBox(n, t), o.isSeparated(e)) return !1;
      }
      return !0;
    };
  }(), yC.prototype.intersectsTriangle = function () {
    const e = new hS(),
      t = new Array(3),
      r = new oS(),
      i = new oS(),
      s = new n.Pa4();
    return function (n) {
      this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (e.copy(n), e.update(), n = e);
      const o = this.satBounds,
        a = this.satAxes;
      t[0] = n.a, t[1] = n.b, t[2] = n.c;
      for (let e = 0; e < 3; e++) {
        const n = o[e],
          i = a[e];
        if (r.setFromPoints(i, t), n.isSeparated(r)) return !1;
      }
      const l = n.satBounds,
        c = n.satAxes,
        u = this.points;
      for (let e = 0; e < 3; e++) {
        const t = l[e],
          n = c[e];
        if (r.setFromPoints(n, u), t.isSeparated(r)) return !1;
      }
      for (let e = 0; e < 3; e++) {
        const n = a[e];
        for (let e = 0; e < 4; e++) {
          const o = c[e];
          if (s.crossVectors(n, o), r.setFromPoints(s, t), i.setFromPoints(s, u), r.isSeparated(i)) return !1;
        }
      }
      return !0;
    };
  }(), yC.prototype.closestPointToPoint = function (e, t) {
    return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  }, yC.prototype.distanceToPoint = function () {
    const e = new n.Pa4();
    return function (t) {
      return this.closestPointToPoint(t, e), t.distanceTo(e);
    };
  }(), yC.prototype.distanceToBox = function () {
    const e = ["x", "y", "z"],
      t = new Array(12).fill().map(() => new n.Zzh()),
      r = new Array(12).fill().map(() => new n.Zzh()),
      i = new n.Pa4(),
      s = new n.Pa4();
    return function (n, o = 0, a = null, l = null) {
      if (this.needsUpdate && this.update(), this.intersectsBox(n)) return (a || l) && (n.getCenter(s), this.closestPointToPoint(s, i), n.closestPointToPoint(i, s), a && a.copy(i), l && l.copy(s)), 0;
      const c = o * o,
        u = n.min,
        h = n.max,
        p = this.points;
      let d = 1 / 0;
      for (let e = 0; e < 8; e++) {
        const t = p[e];
        s.copy(t).clamp(u, h);
        const r = t.distanceToSquared(s);
        if (r < d && (d = r, a && a.copy(t), l && l.copy(s), r < c)) return Math.sqrt(r);
      }
      let f = 0;
      for (let n = 0; n < 3; n++) for (let i = 0; i <= 1; i++) for (let s = 0; s <= 1; s++) {
        const o = (n + 1) % 3,
          a = (n + 2) % 3,
          l = 1 << n | i << o | s << a,
          c = p[i << o | s << a],
          d = p[l];
        t[f].set(c, d);
        const m = e[n],
          _ = e[o],
          g = e[a],
          v = r[f],
          A = v.start,
          b = v.end;
        A[m] = u[m], A[_] = i ? u[_] : h[_], A[g] = s ? u[g] : h[_], b[m] = h[m], b[_] = i ? u[_] : h[_], b[g] = s ? u[g] : h[_], f++;
      }
      for (let e = 0; e <= 1; e++) for (let t = 0; t <= 1; t++) for (let r = 0; r <= 1; r++) {
        s.x = e ? h.x : u.x, s.y = t ? h.y : u.y, s.z = r ? h.z : u.z, this.closestPointToPoint(s, i);
        const n = s.distanceToSquared(i);
        if (n < d && (d = n, a && a.copy(i), l && l.copy(s), n < c)) return Math.sqrt(n);
      }
      for (let e = 0; e < 12; e++) {
        const n = t[e];
        for (let e = 0; e < 12; e++) {
          const t = r[e];
          lS(n, t, i, s);
          const o = i.distanceToSquared(s);
          if (o < d && (d = o, a && a.copy(i), l && l.copy(s), o < c)) return Math.sqrt(o);
        }
      }
      return Math.sqrt(d);
    };
  }();
  const xC = new n.Pa4(),
    wC = new n.Pa4(),
    EC = new n.Pa4(),
    SC = new n.FM8(),
    CC = new n.FM8(),
    MC = new n.FM8(),
    TC = new n.Pa4();
  function IC(e, t, r, i, s) {
    const o = 3 * i,
      a = e.index.getX(o),
      l = e.index.getX(o + 1),
      c = e.index.getX(o + 2),
      u = function (e, t, r, i, s, o, a) {
        xC.fromBufferAttribute(t, i), wC.fromBufferAttribute(t, s), EC.fromBufferAttribute(t, o);
        const l = function (e, t, r, i, s, o) {
          let a;
          return a = o === n._Li ? e.intersectTriangle(i, r, t, !0, s) : e.intersectTriangle(t, r, i, o !== n.ehD, s), null === a ? null : {
            distance: e.origin.distanceTo(s),
            point: s.clone()
          };
        }(e, xC, wC, EC, TC, a);
        if (l) {
          r && (SC.fromBufferAttribute(r, i), CC.fromBufferAttribute(r, s), MC.fromBufferAttribute(r, o), l.uv = n.CJI.getUV(TC, xC, wC, EC, SC, CC, MC, new n.FM8()));
          const e = {
            a: i,
            b: s,
            c: o,
            normal: new n.Pa4(),
            materialIndex: 0
          };
          n.CJI.getNormal(xC, wC, EC, e.normal), l.face = e, l.faceIndex = i;
        }
        return l;
      }(r, e.attributes.position, e.attributes.uv, a, l, c, t);
    return u ? (u.faceIndex = i, s && s.push(u), u) : null;
  }
  function kC(e, t, r) {
    return null === e ? null : (e.point.applyMatrix4(t.matrixWorld), e.distance = e.point.distanceTo(r.ray.origin), e.object = t, e.distance < r.near || e.distance > r.far ? null : e);
  }
  function DC(e, t, r, n) {
    const i = e.a,
      s = e.b,
      o = e.c;
    let a = t,
      l = t + 1,
      c = t + 2;
    r && (a = r.getX(t), l = r.getX(t + 1), c = r.getX(t + 2)), i.x = n.getX(a), i.y = n.getY(a), i.z = n.getZ(a), s.x = n.getX(l), s.y = n.getY(l), s.z = n.getZ(l), o.x = n.getX(c), o.y = n.getY(c), o.z = n.getZ(c);
  }
  function PC(e, t, r, n, i, s, o) {
    const a = r.index,
      l = r.attributes.position;
    for (let r = e, c = t + e; r < c; r++) if (DC(o, 3 * r, a, l), o.needsUpdate = !0, n(o, r, i, s)) return !0;
    return !1;
  }
  class BC {
    constructor(e) {
      this._getNewPrimitive = e, this._primitives = [];
    }
    getPrimitive() {
      const e = this._primitives;
      return 0 === e.length ? this._getNewPrimitive() : e.pop();
    }
    releasePrimitive(e) {
      this._primitives.push(e);
    }
  }
  function RC(e, t) {
    return 65535 === t[e + 15];
  }
  function LC(e, t) {
    return t[e + 6];
  }
  function OC(e, t) {
    return t[e + 14];
  }
  function FC(e) {
    return e + 8;
  }
  function UC(e, t) {
    return t[e + 6];
  }
  const NC = new n.ZzF(),
    jC = new n.Pa4(),
    zC = ["x", "y", "z"];
  function GC(e, t, r, n, i) {
    let s = 2 * e,
      o = YC,
      a = KC,
      l = JC;
    if (RC(s, a)) !function (e, t, r, n, i, s) {
      for (let o = n, a = n + i; o < a; o++) IC(e, t, r, o, s);
    }(t, r, n, LC(e, l), OC(s, a), i);else {
      const s = FC(e);
      WC(s, o, n, jC) && GC(s, t, r, n, i);
      const a = UC(e, l);
      WC(a, o, n, jC) && GC(a, t, r, n, i);
    }
  }
  function VC(e, t, r, n) {
    let i = 2 * e,
      s = YC,
      o = KC,
      a = JC;
    if (RC(i, o)) return function (e, t, r, n, i) {
      let s = 1 / 0,
        o = null;
      for (let a = n, l = n + i; a < l; a++) {
        const n = IC(e, t, r, a);
        n && n.distance < s && (o = n, s = n.distance);
      }
      return o;
    }(t, r, n, LC(e, a), OC(i, o));
    {
      const i = function (e, t) {
          return t[e + 7];
        }(e, a),
        o = zC[i],
        l = n.direction[o] >= 0;
      let c, u;
      l ? (c = FC(e), u = UC(e, a)) : (c = UC(e, a), u = FC(e));
      const h = WC(c, s, n, jC) ? VC(c, t, r, n) : null;
      if (h) {
        const e = h.point[o];
        if (l ? e <= s[u + i] : e >= s[u + i + 3]) return h;
      }
      const p = WC(u, s, n, jC) ? VC(u, t, r, n) : null;
      return h && p ? h.distance <= p.distance ? h : p : h || p || null;
    }
  }
  const QC = function () {
      let e, t;
      const r = [],
        i = new BC(() => new n.ZzF());
      return function (...n) {
        e = i.getPrimitive(), t = i.getPrimitive(), r.push(e, t);
        const o = s(...n);
        i.releasePrimitive(e), i.releasePrimitive(t), r.pop(), r.pop();
        const a = r.length;
        return a > 0 && (t = r[a - 1], e = r[a - 2]), o;
      };
      function s(r, n, i, o, a = null, l = 0, c = 0) {
        function u(e) {
          let t = 2 * e,
            r = KC,
            n = JC;
          for (; !RC(t, r);) t = 2 * (e = FC(e));
          return LC(e, n);
        }
        function h(e) {
          let t = 2 * e,
            r = KC,
            n = JC;
          for (; !RC(t, r);) t = 2 * (e = UC(e, n));
          return LC(e, n) + OC(t, r);
        }
        let p = 2 * r,
          d = YC,
          f = KC,
          m = JC;
        if (RC(p, f)) {
          const t = LC(r, m),
            n = OC(p, f);
          return hC(r, d, e), o(t, n, !1, c, l + r, e);
        }
        {
          const p = FC(r),
            _ = UC(r, m);
          let g,
            v,
            A,
            b,
            y = p,
            x = _;
          if (a && (A = e, b = t, hC(y, d, A), hC(x, d, b), g = a(A), v = a(b), v < g)) {
            y = _, x = p;
            const e = g;
            g = v, v = e, A = b;
          }
          A || (A = e, hC(y, d, A));
          const w = i(A, RC(2 * y, f), g, c + 1, l + y);
          let E;
          if (2 === w) {
            const e = u(y);
            E = o(e, h(y) - e, !0, c + 1, l + y, A);
          } else E = w && s(y, n, i, o, a, l, c + 1);
          if (E) return !0;
          b = t, hC(x, d, b);
          const S = i(b, RC(2 * x, f), v, c + 1, l + x);
          let C;
          if (2 === S) {
            const e = u(x);
            C = o(e, h(x) - e, !0, c + 1, l + x, b);
          } else C = S && s(x, n, i, o, a, l, c + 1);
          return !!C;
        }
      }
    }(),
    HC = function () {
      const e = new hS(),
        t = new hS(),
        r = new n.yGw(),
        i = new yC(),
        s = new yC();
      return function n(o, a, l, c, u = null) {
        let h = 2 * o,
          p = YC,
          d = KC,
          f = JC;
        if (null === u && (l.boundingBox || l.computeBoundingBox(), i.set(l.boundingBox.min, l.boundingBox.max, c), u = i), !RC(h, d)) {
          const e = o + 8,
            t = f[o + 6];
          return hC(e, p, NC), u.intersectsBox(NC) && n(e, a, l, c, u) ? !0 : (hC(t, p, NC), !(!u.intersectsBox(NC) || !n(t, a, l, c, u)));
        }
        {
          const n = a,
            i = n.index,
            u = n.attributes.position,
            m = l.index,
            _ = l.attributes.position,
            g = LC(o, f),
            v = OC(h, d);
          if (r.copy(c).invert(), l.boundsTree) {
            hC(o, p, s), s.matrix.copy(r), s.needsUpdate = !0;
            const e = l.boundsTree.shapecast({
              intersectsBounds: e => s.intersectsBox(e),
              intersectsTriangle: e => {
                e.a.applyMatrix4(c), e.b.applyMatrix4(c), e.c.applyMatrix4(c), e.needsUpdate = !0;
                for (let r = 3 * g, n = 3 * (v + g); r < n; r += 3) if (DC(t, r, i, u), t.needsUpdate = !0, e.intersectsTriangle(t)) return !0;
                return !1;
              }
            });
            return e;
          }
          for (let n = 3 * g, s = v + 3 * g; n < s; n += 3) {
            DC(e, n, i, u), e.a.applyMatrix4(r), e.b.applyMatrix4(r), e.c.applyMatrix4(r), e.needsUpdate = !0;
            for (let r = 0, n = m.count; r < n; r += 3) if (DC(t, r, m, _), t.needsUpdate = !0, e.intersectsTriangle(t)) return !0;
          }
        }
      };
    }();
  function WC(e, t, r, n) {
    return hC(e, t, NC), r.intersectBox(NC, n);
  }
  const qC = [];
  let XC, YC, KC, JC;
  function ZC(e) {
    XC && qC.push(XC), XC = e, YC = new Float32Array(e), KC = new Uint16Array(e), JC = new Uint32Array(e);
  }
  function $C() {
    XC = null, YC = null, KC = null, JC = null, qC.length && ZC(qC.pop());
  }
  const eM = Symbol("skip tree generation"),
    tM = new n.ZzF(),
    rM = new n.ZzF(),
    nM = new n.yGw(),
    iM = new yC(),
    sM = new yC(),
    oM = new n.Pa4(),
    aM = new n.Pa4(),
    lM = new n.Pa4(),
    cM = new n.Pa4(),
    uM = new n.Pa4(),
    hM = new n.ZzF(),
    pM = new BC(() => new hS());
  class dM {
    static serialize(e, t = {}) {
      if (t.isBufferGeometry) return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), dM.serialize(arguments[0], {
        cloneBuffers: void 0 === arguments[2] || arguments[2]
      });
      t = {
        cloneBuffers: !0,
        ...t
      };
      const r = e.geometry,
        n = e._roots,
        i = r.getIndex();
      let s;
      return s = t.cloneBuffers ? {
        roots: n.map(e => e.slice()),
        index: i.array.slice()
      } : {
        roots: n,
        index: i.array
      }, s;
    }
    static deserialize(e, t, r = {}) {
      if ("boolean" == typeof r) return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), dM.deserialize(arguments[0], arguments[1], {
        setIndex: void 0 === arguments[2] || arguments[2]
      });
      r = {
        setIndex: !0,
        ...r
      };
      const {
          index: i,
          roots: s
        } = e,
        o = new dM(t, {
          ...r,
          [eM]: !0
        });
      if (o._roots = s, r.setIndex) {
        const r = t.getIndex();
        if (null === r) {
          const r = new n.TlE(e.index, 1, !1);
          t.setIndex(r);
        } else r.array !== i && (r.array.set(i), r.needsUpdate = !0);
      }
      return o;
    }
    constructor(e, t = {}) {
      if (!e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
      if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
      if ((t = Object.assign({
        strategy: 0,
        maxDepth: 40,
        maxLeafTris: 10,
        verbose: !0,
        useSharedArrayBuffer: !1,
        setBoundingBox: !0,
        onProgress: null,
        [eM]: !1
      }, t)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
      this._roots = null, t[eM] || (this._roots = function (e, t) {
        const r = function (e, t) {
          function r(e) {
            d && d(e / f);
          }
          function i(t, n, s, d = null, f = 0) {
            if (!m && f >= c && (m = !0, u && (console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), s <= h || f >= c) return r(n + s), t.offset = n, t.count = s, t;
            const _ = function (e, t, r, n, i, s) {
              let o = -1,
                a = 0;
              if (0 === s) o = pC(t), -1 !== o && (a = (t[o] + t[o + 3]) / 2);else if (1 === s) o = pC(e), -1 !== o && (a = function (e, t, r, n) {
                let i = 0;
                for (let s = t, o = t + r; s < o; s++) i += e[6 * s + 2 * n];
                return i / r;
              }(r, n, i, o));else if (2 === s) {
                const s = _C(e);
                let l = aC * i;
                const c = 6 * n,
                  u = 6 * (n + i);
                for (let e = 0; e < 3; e++) {
                  const n = t[e],
                    h = (t[e + 3] - n) / 32;
                  if (i < 8) {
                    const t = [...AC];
                    t.length = i;
                    let n = 0;
                    for (let i = c; i < u; i += 6, n++) {
                      const s = t[n];
                      s.candidate = r[i + 2 * e], s.count = 0;
                      const {
                        bounds: o,
                        leftCacheBounds: a,
                        rightCacheBounds: l
                      } = s;
                      for (let e = 0; e < 3; e++) l[e] = 1 / 0, l[e + 3] = -1 / 0, a[e] = 1 / 0, a[e + 3] = -1 / 0, o[e] = 1 / 0, o[e + 3] = -1 / 0;
                      mC(i, r, o);
                    }
                    t.sort(vC);
                    let h = i;
                    for (let e = 0; e < h; e++) {
                      const r = t[e];
                      for (; e + 1 < h && t[e + 1].candidate === r.candidate;) t.splice(e + 1, 1), h--;
                    }
                    for (let n = c; n < u; n += 6) {
                      const i = r[n + 2 * e];
                      for (let e = 0; e < h; e++) {
                        const s = t[e];
                        i >= s.candidate ? mC(n, r, s.rightCacheBounds) : (mC(n, r, s.leftCacheBounds), s.count++);
                      }
                    }
                    for (let r = 0; r < h; r++) {
                      const n = t[r],
                        c = n.count,
                        u = i - n.count,
                        h = n.leftCacheBounds,
                        p = n.rightCacheBounds;
                      let d = 0;
                      0 !== c && (d = _C(h) / s);
                      let f = 0;
                      0 !== u && (f = _C(p) / s);
                      const m = 1 + aC * (d * c + f * u);
                      m < l && (o = e, l = m, a = n.candidate);
                    }
                  } else {
                    for (let e = 0; e < 32; e++) {
                      const t = AC[e];
                      t.count = 0, t.candidate = n + h + e * h;
                      const r = t.bounds;
                      for (let e = 0; e < 3; e++) r[e] = 1 / 0, r[e + 3] = -1 / 0;
                    }
                    for (let t = c; t < u; t += 6) {
                      let i = ~~((r[t + 2 * e] - n) / h);
                      i >= 32 && (i = 31);
                      const s = AC[i];
                      s.count++, mC(t, r, s.bounds);
                    }
                    const t = AC[31];
                    dC(t.bounds, t.rightCacheBounds);
                    for (let e = 30; e >= 0; e--) {
                      const t = AC[e],
                        r = AC[e + 1];
                      fC(t.bounds, r.rightCacheBounds, t.rightCacheBounds);
                    }
                    let p = 0;
                    for (let t = 0; t < 31; t++) {
                      const r = AC[t],
                        n = r.count,
                        c = r.bounds,
                        u = AC[t + 1].rightCacheBounds;
                      0 !== n && (0 === p ? dC(c, bC) : fC(c, bC, bC)), p += n;
                      let h = 0,
                        d = 0;
                      0 !== p && (h = _C(bC) / s);
                      const f = i - p;
                      0 !== f && (d = _C(u) / s);
                      const m = 1 + aC * (h * p + d * f);
                      m < l && (o = e, l = m, a = r.candidate);
                    }
                  }
                }
              } else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);
              return {
                axis: o,
                pos: a
              };
            }(t.boundingData, d, a, n, s, p);
            if (-1 === _.axis) return r(n + s), t.offset = n, t.count = s, t;
            const g = function (e, t, r, n, i) {
              let s = r,
                o = r + n - 1;
              const a = i.pos,
                l = 2 * i.axis;
              for (;;) {
                for (; s <= o && t[6 * s + l] < a;) s++;
                for (; s <= o && t[6 * o + l] >= a;) o--;
                if (!(s < o)) return s;
                for (let r = 0; r < 3; r++) {
                  let n = e[3 * s + r];
                  e[3 * s + r] = e[3 * o + r], e[3 * o + r] = n;
                  let i = t[6 * s + 2 * r + 0];
                  t[6 * s + 2 * r + 0] = t[6 * o + 2 * r + 0], t[6 * o + 2 * r + 0] = i;
                  let a = t[6 * s + 2 * r + 1];
                  t[6 * s + 2 * r + 1] = t[6 * o + 2 * r + 1], t[6 * o + 2 * r + 1] = a;
                }
                s++, o--;
              }
            }(l, a, n, s, _);
            if (g === n || g === n + s) r(n + s), t.offset = n, t.count = s;else {
              t.splitAxis = _.axis;
              const e = new uC(),
                r = n,
                l = g - n;
              t.left = e, e.boundingData = new Float32Array(6), gC(a, r, l, e.boundingData, o), i(e, r, l, o, f + 1);
              const c = new uC(),
                u = g,
                h = s - l;
              t.right = c, c.boundingData = new Float32Array(6), gC(a, u, h, c.boundingData, o), i(c, u, h, o, f + 1);
            }
            return t;
          }
          !function (e, t) {
            if (!e.index) {
              const r = e.attributes.position.count,
                i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
              let s;
              s = r > 65535 ? new Uint32Array(new i(4 * r)) : new Uint16Array(new i(2 * r)), e.setIndex(new n.TlE(s, 1));
              for (let e = 0; e < r; e++) s[e] = e;
            }
          }(e, t);
          const s = new Float32Array(6),
            o = new Float32Array(6),
            a = function (e, t) {
              const r = e.attributes.position,
                n = r.array,
                i = e.index.array,
                s = i.length / 3,
                o = new Float32Array(6 * s),
                a = r.offset || 0;
              let l = 3;
              r.isInterleavedBufferAttribute && (l = r.data.stride);
              for (let e = 0; e < s; e++) {
                const r = 3 * e,
                  s = 6 * e,
                  c = i[r + 0] * l + a,
                  u = i[r + 1] * l + a,
                  h = i[r + 2] * l + a;
                for (let e = 0; e < 3; e++) {
                  const r = n[c + e],
                    i = n[u + e],
                    a = n[h + e];
                  let l = r;
                  i < l && (l = i), a < l && (l = a);
                  let p = r;
                  i > p && (p = i), a > p && (p = a);
                  const d = (p - l) / 2,
                    f = 2 * e;
                  o[s + f + 0] = l + d, o[s + f + 1] = d + (Math.abs(l) + d) * cC, l < t[e] && (t[e] = l), p > t[e + 3] && (t[e + 3] = p);
                }
              }
              return o;
            }(e, s),
            l = e.index.array,
            c = t.maxDepth,
            u = t.verbose,
            h = t.maxLeafTris,
            p = t.strategy,
            d = t.onProgress,
            f = e.index.count / 3;
          let m = !1;
          const _ = [],
            g = function (e) {
              if (!e.groups || !e.groups.length) return [{
                offset: 0,
                count: e.index.count / 3
              }];
              const t = [],
                r = new Set();
              for (const t of e.groups) r.add(t.start), r.add(t.start + t.count);
              const n = Array.from(r.values()).sort((e, t) => e - t);
              for (let e = 0; e < n.length - 1; e++) {
                const r = n[e],
                  i = n[e + 1];
                t.push({
                  offset: r / 3,
                  count: (i - r) / 3
                });
              }
              return t;
            }(e);
          if (1 === g.length) {
            const e = g[0],
              t = new uC();
            t.boundingData = s, function (e, t, r, n) {
              let i = 1 / 0,
                s = 1 / 0,
                o = 1 / 0,
                a = -1 / 0,
                l = -1 / 0,
                c = -1 / 0;
              for (let n = 6 * t, u = 6 * (t + r); n < u; n += 6) {
                const t = e[n + 0];
                t < i && (i = t), t > a && (a = t);
                const r = e[n + 2];
                r < s && (s = r), r > l && (l = r);
                const u = e[n + 4];
                u < o && (o = u), u > c && (c = u);
              }
              n[0] = i, n[1] = s, n[2] = o, n[3] = a, n[4] = l, n[5] = c;
            }(a, e.offset, e.count, o), i(t, e.offset, e.count, o), _.push(t);
          } else for (let e of g) {
            const t = new uC();
            t.boundingData = new Float32Array(6), gC(a, e.offset, e.count, t.boundingData, o), i(t, e.offset, e.count, o), _.push(t);
          }
          return _;
        }(e, t);
        let i, s, o;
        const a = [],
          l = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
        for (let e = 0; e < r.length; e++) {
          const t = r[e],
            n = new l(32 * c(t));
          i = new Float32Array(n), s = new Uint32Array(n), o = new Uint16Array(n), u(0, t), a.push(n);
        }
        return a;
        function c(e) {
          return e.count ? 1 : 1 + c(e.left) + c(e.right);
        }
        function u(e, t) {
          const r = e / 4,
            n = e / 2,
            a = !!t.count,
            l = t.boundingData;
          for (let e = 0; e < 6; e++) i[r + e] = l[e];
          if (a) {
            const i = t.offset,
              a = t.count;
            return s[r + 6] = i, o[n + 14] = a, o[n + 15] = lC, e + 32;
          }
          {
            const n = t.left,
              i = t.right,
              o = t.splitAxis;
            let a;
            if (a = u(e + 32, n), a / 4 > Math.pow(2, 32)) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return s[r + 6] = a / 4, a = u(a, i), s[r + 7] = o, a;
          }
        }
      }(e, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new n.ZzF()))), this.geometry = e;
    }
    refit(e = null) {
      e && Array.isArray(e) && (e = new Set(e));
      const t = this.geometry,
        r = t.index.array,
        n = t.attributes.position,
        i = n.array,
        s = n.offset || 0;
      let o,
        a,
        l,
        c,
        u = 3;
      n.isInterleavedBufferAttribute && (u = n.data.stride);
      let h = 0;
      const p = this._roots;
      for (let e = 0, t = p.length; e < t; e++) o = p[e], a = new Uint32Array(o), l = new Uint16Array(o), c = new Float32Array(o), d(0, h), h += o.byteLength;
      function d(t, n, o = !1) {
        const h = 2 * t;
        if (l[h + 15] === lC) {
          const e = a[t + 6];
          let n = 1 / 0,
            o = 1 / 0,
            p = 1 / 0,
            d = -1 / 0,
            f = -1 / 0,
            m = -1 / 0;
          for (let t = 3 * e, a = 3 * (e + l[h + 14]); t < a; t++) {
            const e = r[t] * u + s,
              a = i[e + 0],
              l = i[e + 1],
              c = i[e + 2];
            a < n && (n = a), a > d && (d = a), l < o && (o = l), l > f && (f = l), c < p && (p = c), c > m && (m = c);
          }
          return (c[t + 0] !== n || c[t + 1] !== o || c[t + 2] !== p || c[t + 3] !== d || c[t + 4] !== f || c[t + 5] !== m) && (c[t + 0] = n, c[t + 1] = o, c[t + 2] = p, c[t + 3] = d, c[t + 4] = f, c[t + 5] = m, !0);
        }
        {
          const r = t + 8,
            i = a[t + 6],
            s = r + n,
            l = i + n;
          let u = o,
            h = !1,
            p = !1;
          e ? u || (h = e.has(s), p = e.has(l), u = !h && !p) : (h = !0, p = !0);
          const f = u || p;
          let m = !1;
          (u || h) && (m = d(r, n, u));
          let _ = !1;
          f && (_ = d(i, n, u));
          const g = m || _;
          if (g) for (let e = 0; e < 3; e++) {
            const n = r + e,
              s = i + e,
              o = c[n],
              a = c[n + 3],
              l = c[s],
              u = c[s + 3];
            c[t + e] = o < l ? o : l, c[t + e + 3] = a > u ? a : u;
          }
          return g;
        }
      }
    }
    traverse(e, t = 0) {
      const r = this._roots[t],
        n = new Uint32Array(r),
        i = new Uint16Array(r);
      !function t(s, o = 0) {
        const a = 2 * s,
          l = i[a + 15] === lC;
        if (l) {
          const t = n[s + 6],
            c = i[a + 14];
          e(o, l, new Float32Array(r, 4 * s, 6), t, c);
        } else {
          const i = s + 8,
            a = n[s + 6],
            c = n[s + 7];
          e(o, l, new Float32Array(r, 4 * s, 6), c) || (t(i, o + 1), t(a, o + 1));
        }
      }(0);
    }
    raycast(e, t = n.Wl3) {
      const r = this._roots,
        i = this.geometry,
        s = [],
        o = t.isMaterial,
        a = Array.isArray(t),
        l = i.groups,
        c = o ? t.side : t;
      for (let n = 0, o = r.length; n < o; n++) {
        const o = a ? t[l[n].materialIndex].side : c,
          u = s.length;
        if (ZC(r[n]), GC(0, i, o, e, s), $C(), a) {
          const e = l[n].materialIndex;
          for (let t = u, r = s.length; t < r; t++) s[t].face.materialIndex = e;
        }
      }
      return s;
    }
    raycastFirst(e, t = n.Wl3) {
      const r = this._roots,
        i = this.geometry,
        s = t.isMaterial,
        o = Array.isArray(t);
      let a = null;
      const l = i.groups,
        c = s ? t.side : t;
      for (let n = 0, s = r.length; n < s; n++) {
        const s = o ? t[l[n].materialIndex].side : c;
        ZC(r[n]);
        const u = VC(0, i, s, e);
        $C(), null != u && (null == a || u.distance < a.distance) && (a = u, o && (u.face.materialIndex = l[n].materialIndex));
      }
      return a;
    }
    intersectsGeometry(e, t) {
      const r = this.geometry;
      let n = !1;
      for (const i of this._roots) if (ZC(i), n = HC(0, r, e, t), $C(), n) break;
      return n;
    }
    shapecast(e, t, r) {
      const n = this.geometry;
      if (e instanceof Function) {
        if (t) {
          const e = t;
          t = (t, r, n, i) => {
            const s = 3 * r;
            return e(t, s, s + 1, s + 2, n, i);
          };
        }
        e = {
          boundsTraverseOrder: r,
          intersectsBounds: e,
          intersectsTriangle: t,
          intersectsRange: null
        }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
      }
      const i = pM.getPrimitive();
      let {
        boundsTraverseOrder: s,
        intersectsBounds: o,
        intersectsRange: a,
        intersectsTriangle: l
      } = e;
      if (a && l) {
        const e = a;
        a = (t, r, s, o, a) => !!e(t, r, s, o, a) || PC(t, r, n, l, s, o, i);
      } else a || (a = l ? (e, t, r, s) => PC(e, t, n, l, r, s, i) : (e, t, r) => r);
      let c = !1,
        u = 0;
      for (const e of this._roots) {
        if (ZC(e), c = QC(0, n, o, a, s, u), $C(), c) break;
        u += e.byteLength;
      }
      return pM.releasePrimitive(i), c;
    }
    bvhcast(e, t, r) {
      let {
        intersectsRanges: n,
        intersectsTriangles: i
      } = r;
      const s = this.geometry.index,
        o = this.geometry.attributes.position,
        a = e.geometry.index,
        l = e.geometry.attributes.position;
      nM.copy(t).invert();
      const c = pM.getPrimitive(),
        u = pM.getPrimitive();
      if (i) {
        function p(e, r, n, h, p, d, f, m) {
          for (let _ = n, g = n + h; _ < g; _++) {
            DC(u, 3 * _, a, l), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
            for (let t = e, n = e + r; t < n; t++) if (DC(c, 3 * t, s, o), c.needsUpdate = !0, i(c, u, t, _, p, d, f, m)) return !0;
          }
          return !1;
        }
        if (n) {
          const d = n;
          n = function (e, t, r, n, i, s, o, a) {
            return !!d(e, t, r, n, i, s, o, a) || p(e, t, r, n, i, s, o, a);
          };
        } else n = p;
      }
      e.getBoundingBox(rM), rM.applyMatrix4(t);
      const h = this.shapecast({
        intersectsBounds: e => rM.intersectsBox(e),
        intersectsRange: (t, r, i, s, o, a) => (tM.copy(a), tM.applyMatrix4(nM), e.shapecast({
          intersectsBounds: e => tM.intersectsBox(e),
          intersectsRange: (e, i, a, l, c) => n(t, r, e, i, s, o, l, c)
        }))
      });
      return pM.releasePrimitive(c), pM.releasePrimitive(u), h;
    }
    intersectsBox(e, t) {
      return iM.set(e.min, e.max, t), iM.needsUpdate = !0, this.shapecast({
        intersectsBounds: e => iM.intersectsBox(e),
        intersectsTriangle: e => iM.intersectsTriangle(e)
      });
    }
    intersectsSphere(e) {
      return this.shapecast({
        intersectsBounds: t => e.intersectsBox(t),
        intersectsTriangle: t => t.intersectsSphere(e)
      });
    }
    closestPointToGeometry(e, t, r = {}, n = {}, i = 0, s = 1 / 0) {
      e.boundingBox || e.computeBoundingBox(), iM.set(e.boundingBox.min, e.boundingBox.max, t), iM.needsUpdate = !0;
      const o = this.geometry,
        a = o.attributes.position,
        l = o.index,
        c = e.attributes.position,
        u = e.index,
        h = pM.getPrimitive(),
        p = pM.getPrimitive();
      let d = aM,
        f = lM,
        m = null,
        _ = null;
      n && (m = cM, _ = uM);
      let g = 1 / 0,
        v = null,
        A = null;
      return nM.copy(t).invert(), sM.matrix.copy(nM), this.shapecast({
        boundsTraverseOrder: e => iM.distanceToBox(e),
        intersectsBounds: (e, t, r) => r < g && r < s && (t && (sM.min.copy(e.min), sM.max.copy(e.max), sM.needsUpdate = !0), !0),
        intersectsRange: (r, n) => {
          if (e.boundsTree) return e.boundsTree.shapecast({
            boundsTraverseOrder: e => sM.distanceToBox(e),
            intersectsBounds: (e, t, r) => r < g && r < s,
            intersectsRange: (e, s) => {
              for (let o = 3 * e, b = 3 * (e + s); o < b; o += 3) {
                DC(p, o, u, c), p.a.applyMatrix4(t), p.b.applyMatrix4(t), p.c.applyMatrix4(t), p.needsUpdate = !0;
                for (let e = 3 * r, t = 3 * (r + n); e < t; e += 3) {
                  DC(h, e, l, a), h.needsUpdate = !0;
                  const t = h.distanceToTriangle(p, d, m);
                  if (t < g && (f.copy(d), _ && _.copy(m), g = t, v = e / 3, A = o / 3), t < i) return !0;
                }
              }
            }
          });
          for (let e = 0, s = u ? u.count : c.count; e < s; e += 3) {
            DC(p, e, u, c), p.a.applyMatrix4(t), p.b.applyMatrix4(t), p.c.applyMatrix4(t), p.needsUpdate = !0;
            for (let t = 3 * r, s = 3 * (r + n); t < s; t += 3) {
              DC(h, t, l, a), h.needsUpdate = !0;
              const r = h.distanceToTriangle(p, d, m);
              if (r < g && (f.copy(d), _ && _.copy(m), g = r, v = t / 3, A = e / 3), r < i) return !0;
            }
          }
        }
      }), pM.releasePrimitive(h), pM.releasePrimitive(p), g === 1 / 0 ? null : (r.point ? r.point.copy(f) : r.point = f.clone(), r.distance = g, r.faceIndex = v, n && (n.point ? n.point.copy(_) : n.point = _.clone(), n.point.applyMatrix4(nM), f.applyMatrix4(nM), n.distance = f.sub(n.point).length(), n.faceIndex = A), r);
    }
    closestPointToPoint(e, t = {}, r = 0, n = 1 / 0) {
      const i = r * r,
        s = n * n;
      let o = 1 / 0,
        a = null;
      if (this.shapecast({
        boundsTraverseOrder: t => (oM.copy(e).clamp(t.min, t.max), oM.distanceToSquared(e)),
        intersectsBounds: (e, t, r) => r < o && r < s,
        intersectsTriangle: (t, r) => {
          t.closestPointToPoint(e, oM);
          const n = e.distanceToSquared(oM);
          return n < o && (aM.copy(oM), o = n, a = r), n < i;
        }
      }), o === 1 / 0) return null;
      const l = Math.sqrt(o);
      return t.point ? t.point.copy(aM) : t.point = aM.clone(), t.distance = l, t.faceIndex = a, t;
    }
    getBoundingBox(e) {
      return e.makeEmpty(), this._roots.forEach(t => {
        hC(0, new Float32Array(t), hM), e.union(hM);
      }), e;
    }
  }
  const fM = dM.prototype.raycast;
  dM.prototype.raycast = function (...e) {
    if (e[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');
      const [t, r, n, i] = e;
      return fM.call(this, n, t.material).forEach(e => {
        (e = kC(e, t, r)) && i.push(e);
      }), i;
    }
    return fM.apply(this, e);
  };
  const mM = dM.prototype.raycastFirst;
  dM.prototype.raycastFirst = function (...e) {
    if (e[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');
      const [t, r, n] = e;
      return kC(mM.call(this, n, t.material), t, r);
    }
    return mM.apply(this, e);
  };
  const _M = dM.prototype.closestPointToPoint;
  dM.prototype.closestPointToPoint = function (...e) {
    if (e[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'), e.unshift();
      const t = e[1],
        r = {};
      return e[1] = r, _M.apply(this, e), t && t.copy(r.point), r.distance;
    }
    return _M.apply(this, e);
  };
  const gM = dM.prototype.closestPointToGeometry;
  dM.prototype.closestPointToGeometry = function (...e) {
    const t = e[2],
      r = e[3];
    if (t && t.isVector3 || r && r.isVector3) {
      console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');
      const n = {},
        i = {},
        s = e[1];
      return e[2] = n, e[3] = i, gM.apply(this, e), t && t.copy(n.point), r && r.copy(i.point).applyMatrix4(s), n.distance;
    }
    return gM.apply(this, e);
  };
  const vM = dM.prototype.refit;
  dM.prototype.refit = function (...e) {
    const t = e[0],
      r = e[1];
    if (r && (r instanceof Set || Array.isArray(r))) {
      console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');
      const e = new Set();
      r.forEach(t => e.add(t)), t && t.forEach(t => e.add(t)), vM.call(this, e);
    } else vM.apply(this, e);
  }, ["intersectsGeometry", "shapecast", "intersectsBox", "intersectsSphere"].forEach(e => {
    const t = dM.prototype[e];
    dM.prototype[e] = function (...r) {
      return (null === r[0] || r[0].isMesh) && (r.shift(), console.warn(`MeshBVH: The function signature for "${e}" has changed and no longer takes Mesh. See docs for new signature.`)), t.apply(this, r);
    };
  });
  const AM = [new n.Pa4(), new n.Pa4(), new n.Pa4()];
  function bM(e) {
    return ~~(1e4 * e);
  }
  function yM(e) {
    return `${bM(e.x)},${bM(e.y)},${bM(e.z)}`;
  }
  class xM {
    constructor(e = null) {
      this.data = null, this.unmatchedEdges = null, this.matchedEdges = null, this.useDrawRange = !0, e && this.updateFrom(e);
    }
    getSiblingTriangleIndex(e, t) {
      const r = this.data[3 * e + t];
      return -1 === r ? -1 : ~~(r / 3);
    }
    getSiblingEdgeIndex(e, t) {
      const r = this.data[3 * e + t];
      return -1 === r ? -1 : r % 3;
    }
    updateFrom(e) {
      const t = new Map(),
        {
          attributes: r
        } = e,
        n = e.index,
        i = r.position;
      let s = n ? n.count / 3 : i.count / 3;
      const o = s;
      let a = 0;
      this.useDrawRange && (a = e.drawRange.start, e.drawRange.count !== 1 / 0 && (s = ~~(e.drawRange.count / 3)));
      let l = this.data;
      (!l || l.length < 3 * o) && (l = new Int32Array(3 * o)), l.fill(-1);
      let c = 0,
        u = 0;
      for (let e = 0; e < s; e++) {
        const r = 3 * e + a;
        for (let e = 0; e < 3; e++) {
          let t = r + e;
          n && (t = n.getX(t)), AM[e].fromBufferAttribute(i, t);
        }
        for (let e = 0; e < 3; e++) {
          const n = (e + 1) % 3,
            i = AM[e],
            s = AM[n],
            o = yM(i),
            a = yM(s),
            h = `${a}_${o}`;
          if (t.has(h)) {
            const n = t.get(h);
            l[r + e] = n, l[n] = r + e, t.delete(h), c--, u++;
          } else {
            const n = `${o}_${a}`;
            t.set(n, r + e), c++;
          }
        }
      }
      this.matchedEdges = u, this.unmatchedEdges = c, this.data = l;
    }
  }
  class wM extends n.Kj0 {
    constructor(...e) {
      super(...e), this.isBrush = !0, this._previousMatrix = new n.yGw(), this._previousMatrix.elements.fill(0);
    }
    markUpdated() {
      this._previousMatrix.copy(this.matrix);
    }
    isDirty() {
      const {
          matrix: e,
          _previousMatrix: t
        } = this,
        r = e.elements,
        n = t.elements;
      for (let e = 0; e < 16; e++) if (r[e] !== n[e]) return !0;
      return !1;
    }
    prepareGeometry() {
      const e = this.geometry,
        t = e.attributes;
      if (HS()) for (const e in t) {
        const r = t[e];
        if (r.isInterleavedBufferAttribute) throw new Error("Brush: InterleavedBufferAttributes are not supported.");
        r.array = WS(r.array);
      }
      if (e.boundsTree || (e.boundsTree = new dM(e, {
        maxLeafTris: 3
      }), e.halfEdges && e.halfEdges.updateFrom(e)), e.halfEdges || (e.halfEdges = new xM(e)), !e.groupIndices) {
        const t = e.index.count / 3,
          r = new Uint16Array(t),
          n = e.groups;
        for (let e = 0, t = n.length; e < t; e++) {
          const {
            start: t,
            count: i
          } = n[e];
          for (let n = t / 3, s = (t + i) / 3; n < s; n++) r[n] = e;
        }
        e.groupIndices = r;
      }
    }
    disposeCacheData() {
      const {
        geometry: e
      } = this;
      e.halfEdges = null, e.boundsTree = null, e.groupIndices = null;
    }
  }
  function EM(e, t) {
    let r = t;
    return Array.isArray(t) || (r = [], e.forEach(e => {
      r[e.materialIndex] = t;
    })), r;
  }
  class SM {
    constructor() {
      this.triangleSplitter = new QS(), this.attributeData = new XS(), this.attributes = ["position", "uv", "normal"], this.useGroups = !0, this.debug = new JS();
    }
    evaluate(e, t, r, i = new wM()) {
      e.prepareGeometry(), t.prepareGeometry();
      const {
          triangleSplitter: s,
          attributeData: o,
          attributes: a,
          useGroups: l,
          debug: c
        } = this,
        u = i.geometry,
        h = e.geometry.attributes;
      for (let e = 0, t = a.length; e < t; e++) {
        const t = a[e],
          r = h[t];
        o.initializeArray(t, r.array.constructor);
      }
      for (const e in o.attributes) a.includes(e) || o.delete(e);
      for (const e in u.attributes) a.includes(e) || (u.deleteAttribute(e), u.dispose());
      o.clear(), c.enabled && (c.reset(), CS(c)), function (e, t, r, n, i, s) {
        const {
            useGroups: o = !0
          } = s,
          {
            aIntersections: a,
            bIntersections: l
          } = function (e, t) {
            const r = new pS(),
              n = new pS();
            return fS.copy(e.matrixWorld).invert().multiply(t.matrixWorld), e.geometry.boundsTree.bvhcast(t.geometry.boundsTree, fS, {
              intersectsTriangles: (e, t, i, s) => (e.intersectsTriangle(t, wS) && wS.distance() > 1e-5 && (r.add(i, s), n.add(s, i), SS && (SS.addEdge(wS), SS.addIntersectingTriangles(i, e, s, t))), !1)
            }), {
              aIntersections: r,
              bIntersections: n
            };
          }(e, t);
        let c;
        c = o ? 0 : -1, oC(e, t, a, r, !1, i, c), sC(e, t, a, r, !1, n, i, c), c = o ? e.geometry.groups.length || 1 : -1, oC(t, e, l, r, !0, i, c), sC(t, e, l, r, !0, n, i, c);
      }(e, t, r, s, o, {
        useGroups: l
      }), c.enabled && CS(null);
      const p = l && 0 !== e.geometry.groups.length ? e.geometry.groups.map(e => ({
          ...e
        })) : [{
          start: 0,
          count: 1 / 0,
          materialIndex: 0
        }],
        d = l && 0 !== t.geometry.groups.length ? t.geometry.groups.map(e => ({
          ...e
        })) : [{
          start: 0,
          count: 1 / 0,
          materialIndex: 0
        }],
        f = EM(p, e.material),
        m = EM(d, t.material);
      d.forEach(e => {
        e.materialIndex += f.length;
      }), function (e, t, r, i) {
        let s = !1,
          o = -1;
        const a = i.groupCount,
          l = e.attributes,
          c = i.groupAttributes[0];
        for (const r in c) {
          const u = i.getTotalLength(r, a),
            h = c[r].type;
          let p = l[r];
          if (!p || p.array.length < u) {
            const i = t.attributes[r];
            p = new n.TlE(new h(u), i.itemSize, i.normalized), e.setAttribute(r, p), s = !0;
          }
          let d = 0;
          for (let e = 0; e < a; e++) {
            const {
                array: t,
                type: n,
                length: s
              } = i.groupAttributes[e][r],
              o = new n(t.buffer, 0, s);
            p.array.set(o, d), d += o.length;
          }
          p.needsUpdate = !0, o = u / p.itemSize;
        }
        e.setDrawRange(0, o), e.clearGroups();
        let u = 0;
        for (let t = 0; t < a; t++) {
          const n = i.getGroupArray("position", t).length / 3;
          if (0 !== n) {
            const i = r[t];
            e.addGroup(u, n, i.materialIndex), u += n;
          }
        }
        if (e.index) {
          const t = e.index.array;
          if (t.length < o) e.index = null, s = !0;else for (let e = 0, r = t.length; e < r; e++) t[e] = e;
        }
        e.boundsTree = null, s && e.dispose();
      }(u, e.geometry, [...p, ...d], o);
      const _ = u.groups;
      if (l) {
        const e = new Map(),
          t = [...f, ...m];
        let r = 0;
        for (let n = 0, i = t.length; n < i; n++) Boolean(_.find(e => e.materialIndex === n)) ? (e.set(n, r), r++) : t[n] = null;
        for (let t = 0, r = _.length; t < r; t++) {
          const r = _[t];
          r.materialIndex = e.get(r.materialIndex);
        }
        i.material = t.filter(e => e);
      }
      return i;
    }
    evaluateHierarchy(e, t = new wM()) {
      e.updateMatrixWorld(!0);
      const r = (e, t) => {
          const n = e.children;
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            i.isOperationGroup ? r(i, t) : t(i);
          }
        },
        n = e => {
          const t = e.children;
          let i = !1;
          for (let e = 0, r = t.length; e < r; e++) {
            const r = t[e];
            i = n(r) || i;
          }
          const s = e.isDirty();
          if (s && e.markUpdated(), i && !e.isOperationGroup) {
            let t;
            return r(e, r => {
              t = t ? this.evaluate(t, r, r.operation) : this.evaluate(e, r, r.operation);
            }), e._cachedGeometry = t.geometry, e._cachedMaterials = t.material, !0;
          }
          return i || s;
        };
      return n(e), t.geometry = e._cachedGeometry, t.material = e._cachedMaterials, t;
    }
    reset() {
      this.triangleSplitter.reset();
    }
  }
  const CM = {
    union: 0,
    subtract: 1,
    intersect: 4,
    difference: 3
  };
  function MM(e, t) {
    const r = new SM();
    r.useGroups = !0, r.attributes = ["position", "normal", "uv"], e.forEach(e => {
      for (const t of [...r.attributes]) e[0].geometry.getAttribute(t) || r.attributes.splice(r.attributes.indexOf(t), 1);
    });
    let i = new wM(new n._12(.01, .01, 2, 2));
    e.forEach(([e, t]) => {
      if (!Object.keys(CM).includes(t)) return void console.error(`Unknown operation ${t}`);
      e.updateMatrix(), e.updateMatrixWorld();
      const n = new wM();
      n.geometry = e.geometry, n.material = e.material, e.matrixWorld.decompose(n.position, n.quaternion, n.scale), n.updateMatrix(), n.updateMatrixWorld(), i = r.evaluate(i, n, CM[t]);
    });
    const s = i;
    return s.userData._isCSGMesh = !0, s;
  }
  let TM = class extends nS {
    _buildCSGMesh(e) {
      return MM(e);
    }
  };
  TM.PluginType = "CSGPluginBVH", TM = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  }([lt("CSG Plugin (BVH)")], TM);
  var IM = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const kM = new n.Pa4(0, 0, 1),
    DM = new n.USm(),
    PM = new n._fP(),
    BM = new n._fP(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)),
    RM = new n._fP(),
    LM = {
      type: "change"
    };
  let OM = class extends r {
    constructor(e) {
      super(), this.enabled = !1, this.lastOrder = "XYZ", this.dampingFactor = .05, this.lastQuaternion = new n._fP(), this.onDeviceOrientationChangeEvent = e => {
        this.deviceOrientation = e;
      }, this.onScreenOrientationChangeEvent = () => {
        this.screenOrientation = screen.orientation;
      }, this._initQuaternion = new n._fP(), this._initQuaternionInvert = new n._fP(), this._initQuaternionDest = new n._fP(), this._lastTime = -1, !1 === window.isSecureContext && console.error("DeviceOrientationControls2: DeviceOrientationEvent is only available in secure contexts (https)"), this.object = e, this.lastOrder = this.object.rotation.order, this.object.rotation.reorder("YXZ"), this.connect();
    }
    connect() {
      this.onScreenOrientationChangeEvent(), void 0 !== window.DeviceOrientationEvent && "function" == typeof window.DeviceOrientationEvent.requestPermission ? window.DeviceOrientationEvent.requestPermission().then(e => {
        "granted" == e && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent));
      }).catch(e => {
        console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", e);
      }) : (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent)), this.enabled = !0, this._initQuaternion.copy(this.object.quaternion), this._initQuaternionInvert.copy(this.object.quaternion).invert();
    }
    disconnect() {
      window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._initQuaternion.identity(), this._initQuaternionInvert.identity(), this._initQuaternionDest = new n._fP(), this.object.rotation.reorder(this.lastOrder), this.lastOrder = "XYZ", this.enabled = !1;
    }
    update() {
      if (!this.enabled) return;
      const e = this.deviceOrientation;
      if (e) {
        const t = null !== e.alpha ? n.M8C.degToRad(e.alpha) : 0,
          r = null !== e.beta ? n.M8C.degToRad(e.beta) : 0,
          i = null !== e.gamma ? n.M8C.degToRad(e.gamma) : 0,
          s = this.screenOrientation ? n.M8C.degToRad(this.screenOrientation.angle) : 0;
        this.setObjectQuaternion(t, r, i, s), 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > 1e-6 && (this.lastQuaternion.copy(this.object.quaternion), this.dispatchEvent(LM));
      }
    }
    dispose() {
      this.disconnect();
    }
    setObjectQuaternion(e, t, r, n) {
      const i = Dt() / 1e3;
      DM.set(t, e, -r, "YXZ"), RM.setFromEuler(DM), RM.multiply(BM), RM.multiply(PM.setFromAxisAngle(kM, -n)), this._initQuaternionDest.__init || (this._initQuaternionDest.copy(RM).invert(), this._initQuaternionDest.__init = !0), RM.premultiply(this._initQuaternionDest), this.object.quaternion.slerp(RM, this.dampingFactor / (Math.min(1, i - this._lastTime) / (1 / 60))), this._lastTime = i;
    }
  };
  IM([Ce(), $e("Damping", [0, 1], .01)], OM.prototype, "dampingFactor", void 0), OM = IM([lt("Device Orientation Controls")], OM);
  class FM extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.toJSON = void 0, this._cameraChanged = e => {
        var t, r, n, i;
        null === (r = null === (t = e.lastCamera) || void 0 === t ? void 0 : t.removeControlsCtor) || void 0 === r || r.call(t, this.controlsKey), null === (i = null === (n = e.camera) || void 0 === n ? void 0 : n.setControlsCtor) || void 0 === i || i.call(n, this.controlsKey, this._controlsCtor);
      };
    }
    async onAdded(e) {
      await super.onAdded(e), this._cameraChanged({
        camera: e.scene.activeCamera
      }), e.scene.addEventListener("activeCameraChange", this._cameraChanged);
    }
    async onRemove(e) {
      return this._cameraChanged({
        lastCamera: e.scene.activeCamera
      }), e.scene.removeEventListener("activeCameraChange", this._cameraChanged), super.onRemove(e);
    }
  }
  class UM extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "deviceOrientation", this._controlsCtor = (e, t) => new OM(e);
    }
  }
  UM.PluginType = "DeviceOrientationControlsPlugin";
  var NM = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const jM = new n.Pa4(),
    zM = new n.$V(),
    GM = new n.Pa4(),
    VM = {
      type: "change"
    };
  let QM = class extends r {
    constructor(e, t) {
      super(), this.enabled = !0, this.enableKeys = !0, this.movementSpeed = 1, this.lookSpeed = .005, this.lookVertical = !0, this.autoForward = !1, this.activeLook = !0, this.heightSpeed = !1, this.heightCoef = 1, this.heightMin = 0, this.heightMax = 1, this.constrainVertical = !1, this.verticalMin = 0, this.verticalMax = Math.PI, this.mouseDragOn = !1, this.autoSpeedFactor = 0, this.mouseX = 0, this.mouseY = 0, this.moveForward = !1, this.moveBackward = !1, this.moveLeft = !1, this.moveRight = !1, this.moveUp = !1, this.moveDown = !1, this.viewHalfX = 0, this.viewHalfY = 0, this.lat = 0, this.lon = 0, this.targetPosition = new n.Pa4(), this._lastTime = -1, this.object = e, this.domElement = t, this.onMouseMove = this.onMouseMove.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("mousemove", this.onMouseMove), this.domElement.addEventListener("mousedown", this.onMouseDown), this.domElement.addEventListener("mouseup", this.onMouseUp), window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp), this.handleResize(), this.setOrientation();
    }
    setOrientation() {
      const e = this.object.quaternion;
      jM.set(0, 0, -1).applyQuaternion(e), zM.setFromVector3(jM), this.lat = 90 - n.M8C.radToDeg(zM.phi), this.lon = n.M8C.radToDeg(zM.theta);
    }
    handleResize() {
      this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, this.viewHalfY = this.domElement.offsetHeight / 2);
    }
    onMouseDown(e) {
      if (this.domElement !== document && this.domElement.focus(), this.activeLook) switch (e.button) {
        case 0:
          this.moveForward = !0;
          break;
        case 2:
          this.moveBackward = !0;
      }
      this.mouseDragOn = !0;
    }
    onMouseUp(e) {
      if (this.activeLook) switch (e.button) {
        case 0:
          this.moveForward = !1;
          break;
        case 2:
          this.moveBackward = !1;
      }
      this.mouseDragOn = !1;
    }
    onMouseMove(e) {
      this.domElement === document ? (this.mouseX = e.pageX - this.viewHalfX, this.mouseY = e.pageY - this.viewHalfY) : (this.mouseX = e.pageX - this.domElement.offsetLeft - this.viewHalfX, this.mouseY = e.pageY - this.domElement.offsetTop - this.viewHalfY);
    }
    onKeyDown(e) {
      if (this.enableKeys) switch (e.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = !0;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = !0;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = !0;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = !0;
          break;
        case "KeyR":
          this.moveUp = !0;
          break;
        case "KeyF":
          this.moveDown = !0;
      }
    }
    onKeyUp(e) {
      if (this.enableKeys) switch (e.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = !1;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = !1;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = !1;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = !1;
          break;
        case "KeyR":
          this.moveUp = !1;
          break;
        case "KeyF":
          this.moveDown = !1;
      }
    }
    lookAt(e, t, r) {
      return e.isVector3 ? GM.copy(e) : void 0 === t || void 0 === r ? console.error("FirstPersonControls2.lookAt: y and z parameters are required") : GM.set(e, t, r), this.object.lookAt(GM), this.setOrientation(), this;
    }
    update() {
      const e = Dt(),
        t = (this._lastTime < 0 ? 16 : Math.min(e - this._lastTime, 1e3)) / 1e3;
      if (this._lastTime = e, !this.enabled) return;
      if (this.heightSpeed) {
        const e = n.M8C.clamp(this.object.position.y, this.heightMin, this.heightMax) - this.heightMin;
        this.autoSpeedFactor = t * (e * this.heightCoef);
      } else this.autoSpeedFactor = 0;
      const r = t * this.movementSpeed;
      (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(r + this.autoSpeedFactor)), this.moveBackward && this.object.translateZ(r), this.moveLeft && this.object.translateX(-r), this.moveRight && this.object.translateX(r), this.moveUp && this.object.translateY(r), this.moveDown && this.object.translateY(-r);
      let i = t * this.lookSpeed;
      this.activeLook || (i = 0);
      let s = 1;
      this.constrainVertical && (s = Math.PI / (this.verticalMax - this.verticalMin)), this.lon -= this.mouseX * i, this.lookVertical && (this.lat -= this.mouseY * i * s), this.lat = Math.max(-85, Math.min(85, this.lat));
      let o = n.M8C.degToRad(90 - this.lat);
      const a = n.M8C.degToRad(this.lon);
      this.constrainVertical && (o = n.M8C.mapLinear(o, 0, Math.PI, this.verticalMin, this.verticalMax));
      const l = this.object.position;
      this.targetPosition.setFromSphericalCoords(1, o, a).add(l), this.object.lookAt(this.targetPosition), this.dispatchEvent(VM);
    }
    dispose() {
      this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("mousedown", this.onMouseDown), this.domElement.removeEventListener("mousemove", this.onMouseMove), this.domElement.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
    }
    onContextMenu(e) {
      this.enableKeys && e.preventDefault();
    }
  };
  NM([Ce(), Je()], QM.prototype, "enabled", void 0), NM([Ce(), Je()], QM.prototype, "enableKeys", void 0), NM([Ce(), nt()], QM.prototype, "movementSpeed", void 0), NM([Ce(), nt()], QM.prototype, "lookSpeed", void 0), NM([Ce(), Je()], QM.prototype, "lookVertical", void 0), NM([Ce(), Je()], QM.prototype, "autoForward", void 0), NM([Ce(), Je()], QM.prototype, "activeLook", void 0), NM([Ce(), Je()], QM.prototype, "heightSpeed", void 0), NM([Ce(), nt()], QM.prototype, "heightCoef", void 0), NM([Ce(), nt()], QM.prototype, "heightMin", void 0), NM([Ce(), nt()], QM.prototype, "heightMax", void 0), NM([Ce(), Je()], QM.prototype, "constrainVertical", void 0), NM([Ce(), nt()], QM.prototype, "verticalMin", void 0), NM([Ce(), nt()], QM.prototype, "verticalMax", void 0), NM([Ce(), Je()], QM.prototype, "mouseDragOn", void 0), QM = NM([lt("First Person Controls")], QM);
  class HM extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "firstPerson", this._controlsCtor = (e, t) => new QM(e, t);
    }
  }
  HM.PluginType = "FirstPersonControlsPlugin";
  var WM = function (e, t, r, n) {
    var i,
      s = arguments.length,
      o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
    return s > 3 && o && Object.defineProperty(t, r, o), o;
  };
  const qM = new n.USm(0, 0, 0, "YXZ"),
    XM = new n.Pa4(),
    YM = {
      type: "change"
    },
    KM = {
      type: "lock"
    },
    JM = {
      type: "unlock"
    },
    ZM = Math.PI / 2;
  let $M = class extends r {
    constructor(e, t) {
      super(), this.isLocked = !1, this.enabled = !0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, this.autoLockOnClick = !0, this._movementX = 0, this._movementY = 0, this._forwardDirection = new n.Pa4(0, 0, -1), this.domElement = t, this.object = e, this.onElementClick = this.onElementClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onPointerlockChange = this.onPointerlockChange.bind(this), this.onPointerlockError = this.onPointerlockError.bind(this), this.connect();
    }
    onElementClick(e) {
      this.isLocked || this.autoLockOnClick && (e.preventDefault(), this.lock());
    }
    onMouseMove(e) {
      this.isLocked && (this._movementX += e.movementX || e.mozMovementX || e.webkitMovementX || 0, this._movementY += e.movementY || e.mozMovementY || e.webkitMovementY || 0);
    }
    onPointerlockChange() {
      this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(KM), this.isLocked = !0) : (this.dispatchEvent(JM), this.isLocked = !1);
    }
    onPointerlockError() {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }
    connect() {
      this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.addEventListener("click", this.onElementClick);
    }
    disconnect() {
      this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.removeEventListener("click", this.onElementClick);
    }
    dispose() {
      this.disconnect();
    }
    getDirection(e) {
      return e.copy(this._forwardDirection).applyQuaternion(this.object.quaternion);
    }
    moveForward(e) {
      XM.setFromMatrixColumn(this.object.matrix, 0), XM.crossVectors(this.object.up, XM), this.object.position.addScaledVector(XM, e);
    }
    moveRight(e) {
      XM.setFromMatrixColumn(this.object.matrix, 0), this.object.position.addScaledVector(XM, e);
    }
    lock() {
      this.domElement.requestPointerLock();
    }
    unlock() {
      this.domElement.ownerDocument.exitPointerLock();
    }
    update() {
      qM.setFromQuaternion(this.object.quaternion), qM.y -= .002 * this._movementX * this.pointerSpeed, qM.x -= .002 * this._movementY * this.pointerSpeed, this._movementX = 0, this._movementY = 0, qM.x = Math.max(ZM - this.maxPolarAngle, Math.min(ZM - this.minPolarAngle, qM.x)), this.object.quaternion.setFromEuler(qM), this.dispatchEvent(YM);
    }
  };
  WM([Je(), Ce()], $M.prototype, "enabled", void 0), WM([nt(), Ce()], $M.prototype, "minPolarAngle", void 0), WM([nt(), Ce()], $M.prototype, "maxPolarAngle", void 0), WM([nt(), Ce()], $M.prototype, "pointerSpeed", void 0), WM([Je(), Ce()], $M.prototype, "autoLockOnClick", void 0), $M = WM([lt("Pointer Lock Controls")], $M);
  class eT extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "pointerLock", this._controlsCtor = (e, t) => new $M(e, t.ownerDocument ? t : t.documentElement);
    }
  }
  eT.PluginType = "PointerLockControlsPlugin";
  var tT = __webpackgi_require__(819);
  class rT {
    static _initialize() {
      this._inited = !0, Mt(E`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", e => {
        this.Element && !this.Element.contains(e.target) && this.Remove();
      });
    }
    static Create(e, t, r) {
      this._inited || this._initialize(), this.Element && this.Remove();
      const n = St({
        id: "customContextMenu",
        addToBody: !1
      });
      n.style.top = r + "px", n.style.left = t + "px";
      for (const [t, r] of Object.entries(e)) {
        const e = St({
          classList: ["customContextMenuItems"],
          addToBody: !1,
          innerHTML: t
        });
        n.appendChild(e), e.onclick = r;
      }
      return this.Element = n, n;
    }
    static Remove() {
      var e;
      null === (e = this.Element) || void 0 === e || e.remove(), this.Element = void 0;
    }
  }
  rT.Element = void 0, rT._inited = !1;
  var nT = __webpackgi_require__(665);
  const iT = (e, t, r) => {
      var n, i, s;
      const o = e.controller_,
        a = null === (i = null === (n = o.parent) || void 0 === n ? void 0 : n.children) || void 0 === i ? void 0 : i.indexOf(o),
        l = ((e, t) => t.controller_.rackController.rack === e.controller_.parent)(e, t);
      return !(l && a === r || (void 0 !== a && a >= 0 && (null === (s = o.parent) || void 0 === s || s.remove(e)), t.add(e, r), 0));
    },
    sT = (e, t, r, n) => {
      var i, s, o, a, l;
      let c = t.uiRef;
      const u = null == c ? void 0 : c.expanded;
      if (c || (c = e.addFolder({
        title: ""
      }), c.on("fold", e => {
        var r, n, i;
        let s = c.expanded;
        _(t, "expanded", s, !0), s = null !== (r = A(t.expanded)) && void 0 !== r ? r : s, s !== c.expanded && (c.expanded = s), null === (n = t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0), s && (null === (i = t.onExpand) || void 0 === i || i.call(t, t));
      })), !c) return c;
      c.expanded = null !== (s = null !== (i = A(t.expanded)) && void 0 !== i ? i : u) && void 0 !== s && s;
      const h = (null !== (o = t.children) && void 0 !== o ? o : []).map(e => e && A(e)).flat(2).filter(e => e);
      let p = 0;
      for (const e of h) {
        let t = e.uiRef;
        t && t.controller_.viewProps.get("disposed") && (e.uiRef = void 0), t = e.uiRef, t || (r.appendUiObject({
          uiConfig: e
        }, c), t = e.uiRef), t && iT(t, c, p++) && r.appendUiObject({
          uiConfig: e
        }, c);
      }
      let d = c.children;
      for (; d.length > p;) {
        const e = d[d.length - 1];
        c.remove(e), d = c.children;
      }
      c.controller_.props.set("title", null !== (a = A(t.label)) && void 0 !== a ? a : "");
      const f = c.controller_.view.containerElement,
        m = A(t.domChildren, []);
      if (void 0 !== (null == m ? void 0 : m.length)) {
        const e = [];
        for (let t = 0; t < f.children.length; t++) {
          const r = f.children[t];
          (null === (l = r.dataset) || void 0 === l ? void 0 : l.tpCustomDOM) && e.push(r);
        }
        for (const t of e) f.removeChild(t);
        for (const e of m) e.parentElement !== f && (f.appendChild(e), e.dataset.tpCustomDOM = "true");
        c.controller_.foldable.cleanUpTransition();
      }
      return c;
    },
    oT = (e, t, r, n) => {
      var i, s;
      const [o, a] = null !== (i = t.property) && void 0 !== i ? i : [void 0, void 0],
        l = null !== (s = A(t.label)) && void 0 !== s ? s : a;
      let c = t.uiRef;
      return c || (c = e.addButton({
        title: ""
      }), c.on("click", async () => {
        var e;
        const n = [];
        t.prompt && n.push(await r.prompt(...t.prompt));
        const i = null !== (e = o && a ? o[a] : void 0) && void 0 !== e ? e : t.value;
        if ("function" == typeof i) {
          const e = () => {
            r.removeEventListener("postFrame", e), i(...n);
          };
          r.addEventListener("postFrame", e);
        } else console.warn("Invalid action type for button");
      })), c && (c.title = null != l ? l : "click me"), c;
    },
    aT = (e, t, r, n) => {
      var i;
      const s = Object.fromEntries((null !== (i = A(t.children)) && void 0 !== i ? i : []).map(e => A(e)).flat(2).filter(e => e).map(e => {
        var t;
        const r = A(e.label);
        return [r, null !== (t = e.value) && void 0 !== t ? t : r];
      }));
      return hT(e, t, r, {
        options: s,
        ...(null != n ? n : {})
      });
    },
    lT = (e, t, r, n) => {
      var i, s;
      const o = A(t.bounds),
        a = (null !== (i = null == o ? void 0 : o.length) && void 0 !== i ? i : 0) >= 2 ? o[1] : 1,
        l = (null !== (s = null == o ? void 0 : o.length) && void 0 !== s ? s : 0) >= 1 ? o[0] : 0,
        c = t.stepSize || void 0;
      return hT(e, t, r, {
        min: l,
        max: a,
        step: c,
        ...(null != n ? n : {})
      });
    },
    cT = (e, t, r, i) => {
      var s, o, a;
      const l = A(t.bounds);
      if (!l || l.length < 1) return hT(e, t, r, {
        ...(null != i ? i : {})
      });
      const c = (null !== (s = l.length) && void 0 !== s ? s : 0) >= 2 ? l[1] : 1,
        u = (null !== (o = l.length) && void 0 !== o ? o : 0) >= 1 ? l[0] : 0,
        h = {
          min: u,
          max: c,
          step: null !== (a = t.stepSize) && void 0 !== a ? a : (c - u) / 100
        },
        p = {
          x: h,
          y: h
        };
      "vec3" !== t.type && "vec4" !== t.type || (p.z = h), "vec4" === t.type && (p.w = h);
      const d = t.property;
      if (void 0 === t.value && d && d[0] && "object" == typeof d[0] && d[0][d[1]] && Array.isArray(d[0][d[1]])) {
        const [e, r] = d,
          i = e[r],
          s = i.length,
          o = new (2 === s ? n.FM8 : 3 === s ? n.Pa4 : n.Ltg)().fromArray(i);
        t.value = o, t.property = void 0, t.onChange = [() => {
          e[r] = o.toArray();
        }, ...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = r);
      }
      return hT(e, t, r, {
        ...p,
        ...(null != i ? i : {})
      });
    },
    uT = (e, t, r, n) => {
      var i;
      const s = t.property;
      if (void 0 === t.value && s && "object" == typeof s[0] && (null === (i = s[0][s[1]]) || void 0 === i ? void 0 : i.isColor)) {
        const [e, r] = s,
          n = new Ae().set(e[r]).convertSRGBToLinear();
        Object.defineProperty(t, "value", {
          get: () => {
            const t = e[r];
            return t ? n.set(t).convertLinearToSRGB().getHex() : 0;
          },
          set: t => {
            const i = e[r];
            n.setHex(t).convertSRGBToLinear(), i.isColor ? i.copy(n) : "number" == typeof i ? e[r] = n.getHex() : "string" == typeof i && (e[r] = "#" + n.getHexString()), "function" == typeof (null == e ? void 0 : e.setDirty) && e.setDirty();
          }
        }), t.property = void 0, t.onChange = [...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = r);
      }
      return (n = null != n ? n : {}).view = "color", A(t.inlinePicker) && (n.picker = "inline"), hT(e, t, r, n);
    },
    hT = (e, t, r, n) => {
      var i;
      let s = A(t.property);
      if ((t.getValue || t.setValue) && s && console.error("specify either property or value, or getValue and setValue", t), s) t.value && console.warn("Both property and value are defined, value will be ignored", t);else if (void 0 === t.value && (t.getValue || t.setValue) && (Object.defineProperty(t, "value", {
        get: () => {
          var e;
          return null === (e = t.getValue) || void 0 === e ? void 0 : e.call(t);
        },
        set: e => {
          var r;
          return null === (r = t.setValue) || void 0 === r ? void 0 : r.call(t, e);
        }
      }), s = [t, "value"]), s || void 0 === t.value || (s = [t, "value"]), !s) return void console.error("cannot determine property", t);
      n = null != n ? n : {};
      const o = {
        label: null !== (i = A(t.label)) && void 0 !== i ? i : s[1],
        ...n
      };
      let a = t.uiRef;
      if (!a && "object" == typeof s[0] && s[0]) {
        const [r, n] = s;
        try {
          a = t.isMonitor ? e.addMonitor(r, n, o) : e.addInput(r, n, o).on("change", e => {
            [t.onChange].flat().forEach(t => "function" == typeof t && (null == t ? void 0 : t(e))), "function" == typeof (null == r ? void 0 : r.setDirty) && r.setDirty(e);
          });
        } catch (e) {
          if (!e.message.startsWith("No matching controller for")) throw e;
          a = void 0;
        }
      }
      if (a) {
        for (const [e, t] of Object.entries(o)) {
          const r = a.controller_.props.value(e);
          void 0 !== r && r.rawValue !== t && a.controller_.props.set(e, t);
        }
        "slider" === t.type && (void 0 !== o.min && a.controller_.valueController.sliderController.props.set("minValue", o.min), void 0 !== o.max && a.controller_.valueController.sliderController.props.set("maxValue", o.max)), a.refresh();
      }
      return a;
    };
  class pT extends r {
    constructor(e = !1, t = !1, r = !1, n = !0, i = document.body) {
      super(), this._refreshQueue = {
        preRender: [],
        postRender: [],
        preFrame: [],
        postFrame: []
      }, this._lastModeTime = {
        preRender: 0,
        postRender: 0,
        preFrame: 0,
        postFrame: 0
      }, this._typeGenerators = {
        folder: sT,
        input: hT,
        slider: lT,
        dropdown: aT,
        checkbox: hT,
        color: uT,
        vec: cT,
        vec2: cT,
        vec3: cT,
        vec4: cT,
        button: oT,
        monitor: (e, t, r, n) => (t.isMonitor = !0, hT(e, t, r, n)),
        dummy: (e, t, r, n) => hT(e, t, r, n)
      }, this.alert = async e => alert(e), this.confirm = async e => confirm(e), this.prompt = async (e, t, r = !0) => prompt(e, t), this._expand = e, this._limitedOptions = r;
      const s = this._createUiContainer();
      i.appendChild(s), this._pane = new nT.Pane({
        title: "Configuration",
        container: s
      }), this._pane.expanded = this._expand, n && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), setTimeout(() => {
        this.dispatchEvent({
          type: "postFrame"
        });
      }, 32));
    }
    refreshQueue(e) {
      const t = this._refreshQueue[e],
        r = [],
        n = Dt(),
        i = n - this._lastModeTime[e];
      t.forEach(e => {
        e[2] > .001 ? (e[2] -= i, r.push(e)) : this._refreshUiObject(e[0], e[1], e[2]);
      }), this._refreshQueue[e] = r, this._lastModeTime[e] = n;
    }
    addToRefreshQueue(e, t) {
      var r;
      const n = null === (r = t[0]) || void 0 === r ? void 0 : r.uiConfig,
        i = null == n ? void 0 : n.uuid,
        s = this._refreshQueue[e],
        o = s.find(e => e[3] === i);
      o ? o[2] = Math.max(o[2], t[2]) : s.push([...t, i]), this._refreshQueue[e] = s;
    }
    dispose() {
      var e;
      null === (e = this._pane) || void 0 === e || e.dispose(), this._pane = void 0;
    }
    appendUiObject(e, t) {
      e && this._appendUiObject(e, t);
    }
    _appendUiObject(e, t) {
      var r, n, i, s;
      const {
        uiConfig: o
      } = null != e ? e : {};
      if (o && (!this._limitedOptions || o.limitedUi) && (t = null != t ? t : this._pane, o.type)) {
        o.uuid || (o.uuid = Xe()), o.uiRef && o.uiRefType !== o.type && (console.log("Removing UI object because of type mismatch", o.uiRef), this.removeUiConfig(o));
        const a = null === (n = (r = this._typeGenerators)[o.type]) || void 0 === n ? void 0 : n.call(r, t, o, this);
        a && (a.hidden = null !== (i = A(o.hidden)) && void 0 !== i && i, a.disabled = null !== (s = A(o.disabled)) && void 0 !== s && s), o.uiRef = a, o.uiRefType = a ? o.type : void 0, o.uiRefresh = (r = "postFrame", n = !1, i = 0) => {
          var s;
          return this._uiObjectRefresh(r, null !== (s = null == e ? void 0 : e.uiConfig) && void 0 !== s ? s : o, t, n, i);
        };
      }
    }
    removeUiObject(e) {
      this.removeUiConfig(null == e ? void 0 : e.uiConfig);
    }
    removeUiConfig(e) {
      var t, r;
      e && e.uiRef && (null === (r = (t = e.uiRef).dispose) || void 0 === r || r.call(t), e.uiRef = void 0, e.uiRefType = void 0, e.uiRefresh = void 0);
    }
    _uiObjectRefresh(e, t, r, n, i) {
      (n ? dT(t, r) : [{
        uiConfig: t,
        parentFolder: r
      }]).forEach(t => {
        const r = [{
          uiConfig: t.uiConfig
        }, t.parentFolder, i];
        "immediate" === e ? this._refreshUiObject(...r) : this.addToRefreshQueue(e, r);
      });
    }
    _refreshUiObject(e, t, r = 0) {
      this._appendUiObject(e, t), r > 1e-4 && console.error("no support for immediate delay");
    }
    _createUiContainer() {
      const e = St({
        id: "tweakpaneUiContainer",
        addToBody: !1
      });
      return Mt(E`
          :root{
            --tweakpane-ui-container-width: 300px;
          }
          @media only screen and (min-width: 1500px) {
            :root{
              --tweakpane-ui-container-width: 300px;
            }
          }
          @media only screen and (min-width: 2500px) {
            :root{
              --tweakpane-ui-container-width: 500px;
            }
          }
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: var(--tweakpane-ui-container-width);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
          }
        `), e;
    }
  }
  function dT(e, t, r) {
    var n;
    return r = null != r ? r : [], e ? (r.push({
      uiConfig: e,
      parentFolder: t
    }), null === (n = e.children) || void 0 === n || n.forEach(t => r = dT(t, e.uiRef, r)), r) : r;
  }
  class fT {
    constructor() {
      fT.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    set(e, t, r, n, i, s, o, a, l) {
      const c = this.elements;
      return c[0] = e, c[1] = n, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = r, c[7] = s, c[8] = l, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements,
        r = e.elements;
      return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
    }
    extractBasis(e, t, r) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const r = e.elements,
        n = t.elements,
        i = this.elements,
        s = r[0],
        o = r[3],
        a = r[6],
        l = r[1],
        c = r[4],
        u = r[7],
        h = r[2],
        p = r[5],
        d = r[8],
        f = n[0],
        m = n[3],
        _ = n[6],
        g = n[1],
        v = n[4],
        A = n[7],
        b = n[2],
        y = n[5],
        x = n[8];
      return i[0] = s * f + o * g + a * b, i[3] = s * m + o * v + a * y, i[6] = s * _ + o * A + a * x, i[1] = l * f + c * g + u * b, i[4] = l * m + c * v + u * y, i[7] = l * _ + c * A + u * x, i[2] = h * f + p * g + d * b, i[5] = h * m + p * v + d * y, i[8] = h * _ + p * A + d * x, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        n = e[2],
        i = e[3],
        s = e[4],
        o = e[5],
        a = e[6],
        l = e[7],
        c = e[8];
      return t * s * c - t * o * l - r * i * c + r * o * a + n * i * l - n * s * a;
    }
    invert() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        n = e[2],
        i = e[3],
        s = e[4],
        o = e[5],
        a = e[6],
        l = e[7],
        c = e[8],
        u = c * s - o * l,
        h = o * a - c * i,
        p = l * i - s * a,
        d = t * u + r * h + n * p;
      if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / d;
      return e[0] = u * f, e[1] = (n * l - c * r) * f, e[2] = (o * r - n * s) * f, e[3] = h * f, e[4] = (c * t - n * a) * f, e[5] = (n * i - o * t) * f, e[6] = p * f, e[7] = (r * a - l * t) * f, e[8] = (s * t - r * i) * f, this;
    }
    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }
    setUvTransform(e, t, r, n, i, s, o) {
      const a = Math.cos(i),
        l = Math.sin(i);
      return this.set(r * a, r * l, -r * (a * s + l * o) + s + e, -n * l, n * a, -n * (-l * s + a * o) + o + t, 0, 0, 1), this;
    }
    scale(e, t) {
      const r = this.elements;
      return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
    }
    rotate(e) {
      const t = Math.cos(e),
        r = Math.sin(e),
        n = this.elements,
        i = n[0],
        s = n[3],
        o = n[6],
        a = n[1],
        l = n[4],
        c = n[7];
      return n[0] = t * i + r * a, n[3] = t * s + r * l, n[6] = t * o + r * c, n[1] = -r * i + t * a, n[4] = -r * s + t * l, n[7] = -r * o + t * c, this;
    }
    translate(e, t) {
      const r = this.elements;
      return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
    }
    equals(e) {
      const t = this.elements,
        r = e.elements;
      for (let e = 0; e < 9; e++) if (t[e] !== r[e]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const r = this.elements;
      return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  function mT(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e);
  }
  let _T;
  Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
  class gT {
    constructor(e = null) {
      this.isSource = !0, this.uuid = $(), this.data = e, this.version = 0;
    }
    set needsUpdate(e) {
      !0 === e && this.version++;
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
      const r = {
          uuid: this.uuid,
          url: ""
        },
        n = this.data;
      if (null !== n) {
        let e;
        if (Array.isArray(n)) {
          e = [];
          for (let t = 0, r = n.length; t < r; t++) n[t].isDataTexture ? e.push(vT(n[t].image)) : e.push(vT(n[t]));
        } else e = vT(n);
        r.url = e;
      }
      return t || (e.images[this.uuid] = r), r;
    }
  }
  function vT(e) {
    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return class {
      static getDataURL(e, t = !1) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let r;
        if (e instanceof HTMLCanvasElement) r = e;else {
          void 0 === _T && (_T = mT("canvas")), _T.width = e.width, _T.height = e.height;
          const t = _T.getContext("2d");
          e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), r = _T;
        }
        return !t && (r.width > 2048 || r.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), r.toDataURL("image/jpeg", .6)) : r.toDataURL("image/png");
      }
      static sRGBToLinear(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
          const t = mT("canvas");
          t.width = e.width, t.height = e.height;
          const r = t.getContext("2d");
          r.drawImage(e, 0, 0, e.width, e.height);
          const n = r.getImageData(0, 0, e.width, e.height),
            i = n.data;
          for (let e = 0; e < i.length; e++) i[e] = 255 * ce(i[e] / 255);
          return r.putImageData(n, 0, 0), t;
        }
        if (e.data) {
          const t = e.data.slice(0);
          for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * ce(t[e] / 255)) : t[e] = ce(t[e]);
          return {
            data: t,
            width: e.width,
            height: e.height
          };
        }
        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
      }
    }.getDataURL(e);
    if (e.data) {
      let t = [];
      try {
        t = Array.from(e.data);
      } catch (r) {
        r.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(r), t = e.data;
      }
      return {
        data: t,
        width: e.width,
        height: e.height,
        type: e.data.constructor.name
      };
    }
    return console.warn("THREE.Texture: Unable to serialize Texture."), {};
  }
  let AT = 0;
  class bT extends class {
    addEventListener(e, t) {
      void 0 === this._listeners && (this._listeners = {});
      const r = this._listeners;
      void 0 === r[e] && (r[e] = []), -1 === r[e].indexOf(t) && r[e].push(t);
    }
    hasEventListener(e, t) {
      if (void 0 === this._listeners) return !1;
      const r = this._listeners;
      return void 0 !== r[e] && -1 !== r[e].indexOf(t);
    }
    removeEventListener(e, t) {
      if (void 0 === this._listeners) return;
      const r = this._listeners[e];
      if (void 0 !== r) {
        const e = r.indexOf(t);
        -1 !== e && r.splice(e, 1);
      }
    }
    dispatchEvent(e) {
      if (void 0 === this._listeners) return;
      const t = this._listeners[e.type];
      if (void 0 !== t) {
        e.target = this;
        const r = t.slice(0);
        for (let t = 0, n = r.length; t < n; t++) r[t].call(this, e);
        e.target = null;
      }
    }
  } {
    constructor(e = bT.DEFAULT_IMAGE, t = bT.DEFAULT_MAPPING, r = 1001, n = 1001, i = oe, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) {
      super(), this.isTexture = !0, Object.defineProperty(this, "id", {
        value: AT++
      }), this.uuid = $(), this.name = "", this.source = new gT(e), this.mipmaps = [], this.mapping = t, this.wrapS = r, this.wrapT = n, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new I(0, 0), this.repeat = new I(1, 1), this.center = new I(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new fT(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
    }
    get image() {
      return this.source.data;
    }
    set image(e) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
      const r = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    transformUv(e) {
      if (300 !== this.mapping) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;
        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;
        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      !0 === e && (this.version++, this.source.needsUpdate = !0);
    }
  }
  bT.DEFAULT_IMAGE = null, bT.DEFAULT_MAPPING = 300;
  var yT = __webpackgi_require__(898),
    xT = {};
  yT.Z && yT.Z.locals && (xT.locals = yT.Z.locals);
  var wT,
    ET = 0,
    ST = {};
  ST.styleTagTransform = cp(), ST.setAttributes = sp(), ST.insert = function (e, t) {
    (t.target || document.head).appendChild(e);
  }, ST.domAPI = np(), ST.insertStyleElement = ap(), xT.use = function (e) {
    return ST.options = e || {}, ET++ || (wT = tp()(yT.Z, ST)), xT;
  }, xT.unuse = function () {
    ET > 0 && ! --ET && (wT(), wT = null);
  };
  var CT = xT;
  class MT extends pT {
    constructor(e = !1, t = !1, r = !1, n = document.body) {
      super(e, t, r, !1), this.dependencies = [to], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = e => {
        this.dispatchEvent(e), this.refreshQueue("postFrame");
      }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this.alert = async e => this._viewer ? this._viewer.alert(e) : super.alert(e), this.confirm = async e => this._viewer ? this._viewer.confirm(e) : super.confirm(e), this.prompt = async (e, t, r = !0) => this._viewer ? this._viewer.prompt(e, t, r) : super.prompt(e, t, r), this._pane.registerPlugin(tT), CT.use({
        target: n
      });
    }
    async onAdded(e) {
      this._viewer = e, this._typeGenerators.image = (e => (t, r, i, s) => {
        const o = r.property,
          a = "placeholder";
        if (void 0 === r.value && o && "object" == typeof o[0]) {
          const [t, i] = o,
            s = Ky("Render Target"),
            l = Ky("Data Texture"),
            c = Ky("CUBE Texture"),
            u = Ky("Compressed Texture"),
            h = {},
            p = {};
          Object.defineProperty(r, "value", {
            get: () => {
              var e;
              let r,
                n = t[i];
              if ((null == n ? void 0 : n.get) && (n = n.get()), !n) return a;
              if (n.isRenderTargetTexture && !n.image.tp_src && (n.image.tp_src = s), n.isDataTexture && !n.image.tp_src && (n.image.tp_src = l), n.isCompressedTexture && !n.image.tp_src && (n.image.tp_src = u), n.isTexture ? (n.image && (n.image instanceof ImageBitmap || n.image instanceof HTMLImageElement || n.image instanceof HTMLVideoElement) && !n.image.tp_src && (n.image.tp_src = It(n.image, 160)), n.image && (r = n.image.tp_src_uuid, r = r ? h[r] : void 0, r || (r = n.image.tp_src || n.image.src))) : "string" == typeof n ? r = n : n.domainMin ? (r = n.texture, n.texture.image && !n.texture.image.tp_src && (n.texture.image.tp_src = c), n.texture.image && (r = n.texture.image.tp_src_uuid, r = r ? h[r] : void 0, r || (r = n.texture.image.tp_src || n.texture.image.src))) : n && console.error("unknown value", n), r || (r = a), n.image && !n.image.tp_src_uuid) {
                const e = Xe();
                n.image.tp_src_uuid = e, p[r] = e;
              }
              return "string" == typeof r && (r = null !== (e = h[r]) && void 0 !== e ? e : r), r;
            },
            set: s => {
              var o, l, c, u, d, f, m, _, g, v, A;
              const b = t[i],
                y = e => {
                  var r;
                  t[i] = e, (null == e ? void 0 : e.isTexture) && (e.flipY = e.isDataTexture ? e.flipY : null === (r = null == b ? void 0 : b.flipY) || void 0 === r || r);
                };
              if ("string" == typeof s) return void ("string" == typeof b && y(s));
              if (!s) return void (r.value = a);
              if (s.isPlaceholder) return void (b && (y("string" == typeof b ? "" : null), "function" == typeof (null == t ? void 0 : t.setDirty) && t.setDirty()));
              let x = s.tp_src_uuid;
              if (x || (x = null !== (o = s.src) && void 0 !== o ? o : s.tp_src, x = null !== (l = p[x]) && void 0 !== l ? l : x, delete p[x], s.tp_src_uuid = x), x && (h[x] = s), "string" != typeof b) {
                if (!((null == b ? void 0 : b.image) === s || (null === (c = null == b ? void 0 : b.image) || void 0 === c ? void 0 : c.src) === s.src || (null === (u = null == b ? void 0 : b.image) || void 0 === u ? void 0 : u.tp_src) === s.tp_src && null != s.tp_src || (null === (d = null == b ? void 0 : b.image) || void 0 === d ? void 0 : d.tp_src) === s.src && null != s.src || (null === (f = null == b ? void 0 : b.image) || void 0 === f ? void 0 : f.src) === s.tp_src && null != s.tp_src)) if (s instanceof File) {
                  const n = null == e ? void 0 : e.getPlugin(to);
                  if (!n) throw "Viewer or AssetManagerPlugin not found";
                  null === (m = n.importer) || void 0 === m || m.importSingle({
                    file: s,
                    path: s.src
                  }).then(e => {
                    var n, i, o, a;
                    if (e) {
                      e.isDataTexture && (e.needsUpdate = !0);
                      const l = null === (o = null === (i = null === (n = s.src) || void 0 === n ? void 0 : n.split("?")) || void 0 === i ? void 0 : i[0]) || void 0 === o ? void 0 : o.split(".").pop();
                      e.userData && (e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(l) ? "jpeg" : "png"))), y(e), [r.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null == t ? void 0 : t.setDirty) && t.setDirty(), null === (a = r.uiRefresh) || void 0 === a || a.call(r, "postFrame", !1);
                    }
                  });
                } else {
                  const e = new bT(s);
                  e.assetType = "texture", e.needsUpdate = !0;
                  const o = null === (v = null === (g = null === (_ = s.src) || void 0 === _ ? void 0 : _.split("?")) || void 0 === g ? void 0 : g[0]) || void 0 === v ? void 0 : v.split(".").pop();
                  e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o) ? "jpeg" : "png")), y(e);
                  const a = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(i);
                  e.encoding = a ? n.rnI : n.knz, e.wrapS = n.rpg, e.wrapT = n.rpg, [r.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null == t ? void 0 : t.setDirty) && t.setDirty(), null === (A = r.uiRefresh) || void 0 === A || A.call(r, "postFrame", !1);
                }
              } else y(x);
            }
          }), r.property = void 0, void 0 === r.label && (r.label = i);
        }
        return (s = null != s ? s : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp", ".cube"], void 0 === s.imageFit && (s.imageFit = "contain"), void 0 === s.clickCallback && (s.clickCallback = (t, s) => {
          var l;
          const c = null == t ? void 0 : t.target,
            u = null == c ? void 0 : c.getBoundingClientRect();
          if (!u) return void s.click();
          const h = r.uiRef.controller_.valueController.value.rawValue,
            p = h === a || (null == h ? void 0 : h.isPlaceholder) ? {} : {
              "remove image": () => {
                var e;
                r.uiRef.controller_.valueController.value.setRawValue("");
                const [t, n] = o || [r, "value"],
                  i = "string" == typeof t[n];
                t[n] = i ? "" : null, [r.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null == t ? void 0 : t.setDirty) && t.setDirty(), null === (e = r.uiRefresh) || void 0 === e || e.call(r, "postFrame", !1), rT.Remove();
              },
              "download image": () => {
                var e, t, n;
                const [i, s] = o || [r, "value"];
                let a = null !== (t = null === (e = i[s]) || void 0 === e ? void 0 : e.image) && void 0 !== t ? t : r.uiRef.controller_.valueController.value.rawValue;
                a && (a instanceof ImageBitmap || a instanceof HTMLImageElement || a instanceof HTMLVideoElement) && !a.src && (a = It(a));
                const l = document.createElement("a");
                document.body.appendChild(l), l.style.display = "none", l.href = null !== (n = null == a ? void 0 : a.src) && void 0 !== n ? n : a, l.download = "image.png", l.click(), document.body.removeChild(l), rT.Remove();
              }
            },
            d = rT.Create({
              ...p,
              "set/replace image": () => {
                s.click(), rT.Remove();
              },
              "from url": async () => {
                var t, s;
                let a = "";
                if (a && (a.startsWith("http") || a.startsWith("data:image")) || (a = ""), a = await i.prompt("Load texture: Enter Image/Texture URL", a, !0), !a || !a.startsWith("http") && !a.startsWith("data:image")) return null !== a && (await i.alert("Loading Image: Invalid URL")), void rT.Remove();
                const [l, c] = o || [r, "value"],
                  u = l[c];
                if ("string" == typeof u) l[c] = a, [r.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null == l ? void 0 : l.setDirty) && l.setDirty(), null === (t = r.uiRefresh) || void 0 === t || t.call(r, "postFrame", !1);else {
                  const t = null == e ? void 0 : e.getPlugin(to);
                  if (!t) throw "Viewer or AssetManagerPlugin not found";
                  null === (s = t.importer) || void 0 === s || s.importSinglePath(a).then(e => {
                    var t;
                    if (e) {
                      e.isDataTexture ? e.needsUpdate = !0 : e && void 0 !== (null == u ? void 0 : u.flipY) && (e.flipY = u.flipY), l[c] = e;
                      const i = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(c);
                      e.encoding = i ? n.rnI : n.knz, [r.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null == l ? void 0 : l.setDirty) && l.setDirty(), null === (t = r.uiRefresh) || void 0 === t || t.call(r, "postFrame", !1);
                    }
                  });
                }
                rT.Remove();
              },
              cancel: () => {
                rT.Remove();
              }
            }, 2, u.height + 8);
          null === (l = c.parentElement) || void 0 === l || l.appendChild(d), u.y > .7 * document.body.clientHeight && (d.style.top = "auto", d.style.bottom = u.height + 8 + "px");
        }), s.view = "input-image", hT(t, r, i, s);
      })(this._viewer), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame), e.addEventListener("postFrame", this._postFrame);
    }
    async onDispose(e) {
      this.dispose();
    }
    async onRemove(e) {
      this._viewer = void 0, e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), e.removeEventListener("preFrame", this._preFrame), e.removeEventListener("postFrame", this._postFrame), this.dispose();
    }
    setupPluginUi(e) {
      var t;
      const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(e);
      if (!r) return void console.warn("plugin not found:", e);
      this._plugins.push(r), r.uiConfig && (r.uiConfig.limitedUi = !0), r.uiConfig && void 0 === r.uiConfig.hidden && (r.uiConfig.hidden = !1), this._appendUiObject(r);
      const n = r.uiConfig;
      if ((null == n ? void 0 : n.uiRef) && r.toJSON) {
        const e = n.uiRef.controller_.view.element,
          t = St({
            innerHTML: "&#8942;",
            classList: ["pluginOptionsButton"],
            elementTag: "button"
          });
        t.onclick = t => {
          const n = {};
          "function" == typeof r.toJSON && (n["download preset"] = async () => {
            var e, t;
            const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(to)) || void 0 === t ? void 0 : t.exportPluginPreset(r);
            await yt(new Blob([JSON.stringify(n, null, 2)], {
              type: "application/json"
            }), "preset." + r.constructor.PluginType + ".json"), rT.Remove();
          }), "function" == typeof r.fromJSON && (n["upload preset"] = async () => {
            var e, t;
            rT.Remove();
            const n = await Et(!1, !1);
            if (0 === n.length) return;
            const i = n[0],
              s = await i.text(),
              o = JSON.parse(s);
            await (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(to)) || void 0 === t ? void 0 : t.importPluginPreset(o, r));
          });
          const i = rT.Create(n, e.clientWidth - 120, 12);
          e.append(i), t.preventDefault();
        }, e.appendChild(t);
      }
      return n;
    }
    setupPlugins(...e) {
      e.forEach(e => this.setupPluginUi(e));
    }
    refreshPluginsEnabled() {
      this._plugins.forEach(e => {
        var t;
        const r = e.uiConfig;
        r && (!0 !== A(r.hidden) ? null === (t = r.uiRefresh) || void 0 === t || t.call(r, "postFrame", !0) : r.uiRef && (r.uiRef.hidden = !0));
      });
    }
  }
  MT.PluginType = "TweakpaneUi";
  class TT extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.toJSON = void 0, this.bgUIConfig = {
        label: "Color",
        type: "color",
        inlinePicker: !0,
        onChange: () => {
          if (!this._viewer) return;
          const e = new Ae(this.bgUIConfig.value || 16777215).convertSRGBToLinear();
          this._viewer.setBackground(e.getHex());
        },
        expanded: !0,
        limitedUi: !0
      }, this.uiConfig = {
        label: "Background / Environment",
        type: "folder",
        expanded: !1,
        limitedUi: !0,
        children: [this.bgUIConfig, {
          label: "Image",
          property: [this, "sceneBackground"],
          type: "image",
          limitedUi: !0
        }, {
          label: "EnvMap BG",
          type: "checkbox",
          property: [this, "envmapBg"]
        }, () => ({
          type: "slider",
          label: "BG Intensity",
          property: [this._viewer, "backgroundIntensity"],
          bounds: [0, 16]
        }), {
          label: "Set Transparent BG",
          type: "button",
          hidden: () => !this._viewer || this._viewer.useRgbm,
          value: () => {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setBackground(null);
          }
        }, {
          label: "Environment",
          property: [this, "sceneEnvironment"],
          type: "image",
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Rotation",
          property: [this, "sceneEnvironmentRotation"],
          bounds: [0, 2 * Math.PI],
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Intensity",
          property: [this, "sceneEnvironmentIntensity"],
          bounds: [0, 4],
          limitedUi: !0
        }]
      };
    }
    get sceneBackground() {
      var e;
      const t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground();
      return t && (t.isTexture || "texture" === t.assetType) ? t : null;
    }
    set sceneBackground(e) {
      var t, r;
      e ? null === (t = this._viewer) || void 0 === t || t.setBackground(e) : null === (r = this._viewer) || void 0 === r || r.setBackground(this.bgUIConfig.value);
    }
    get sceneEnvironment() {
      var e;
      return null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment();
    }
    set sceneEnvironment(e) {
      var t;
      null === (t = this._viewer) || void 0 === t || t.scene.setEnvironment(e);
    }
    get sceneEnvironmentRotation() {
      var e, t, r;
      return null !== (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || void 0 === t ? void 0 : t.rotation) && void 0 !== r ? r : 0;
    }
    set sceneEnvironmentRotation(e) {
      var t, r;
      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.getEnvironment();
      n && (n.rotation = e, null === (r = this._viewer) || void 0 === r || r.scene.setDirty());
    }
    get sceneEnvironmentIntensity() {
      var e, t;
      return null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.envMapIntensity) && void 0 !== t ? t : 1;
    }
    set sceneEnvironmentIntensity(e) {
      var t;
      (null === (t = this._viewer) || void 0 === t ? void 0 : t.scene) && (this._viewer.scene.envMapIntensity = e);
    }
    get envmapBg() {
      var e;
      return (null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0)) === vo;
    }
    set envmapBg(e) {
      if (this._viewer) if (e) {
        const e = this._viewer.getBackground(!0);
        e && e !== vo && (this.lastBgVal = e), this._viewer.setBackground(vo);
      } else this._viewer.getBackground() === this._viewer.scene.getEnvironment() && this._viewer.setBackground(this.lastBgVal || this.bgUIConfig.value);
    }
    async onAdded(e) {
      var t;
      await super.onAdded(e);
      const r = e.getBackground();
      this.bgUIConfig.value = "string" == typeof r && r !== vo || "number" == typeof r || (null === (t = r) || void 0 === t ? void 0 : t.isColor) ? "#" + new Ae(r).getHexString() : "#000000", this.lastBgVal = r;
    }
  }
  TT.PluginType = "SimpleBackgroundEnvUiPlugin1";
  class IT extends ro {
    constructor() {
      super(), this.enabled = !0, this.toJSON = void 0, this._uiConfig = {
        type: "folder",
        label: "Scene Objects",
        children: [],
        onExpand: () => {
          var e, t;
          null === (t = (e = this._uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
        }
      }, this._clearSceneButton = {
        type: "button",
        label: "Clear Scene",
        value: () => {
          var e;
          null === (e = this._viewer) || void 0 === e || e.scene.disposeSceneModels();
        }
      }, this._sceneUpdate = this._sceneUpdate.bind(this);
    }
    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e);
    }
    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }
    get uiConfig() {
      var e, t, r;
      return this._viewer ? (this._uiConfig.children = [this._clearSceneButton], this._uiConfig.children.push(...(null !== (r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.modelRoot.modelObject.children) || void 0 === t ? void 0 : t.map(e => "light" === e.assetType ? null : e.uiConfig).filter(e => null != e)) && void 0 !== r ? r : [])), this._uiConfig) : this._uiConfig;
    }
    _sceneUpdate() {
      var e, t;
      null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
    }
  }
  IT.PluginType = "SimpleUi";
  var kT = __webpackgi_require__(1),
    DT = __webpackgi_require__.n(kT)();
  class PT extends ro {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = St({
        innerHTML: "",
        id: "tpHierarchyContainer",
        addToBody: !1
      }), this._uiConfig = {
        type: "folder",
        label: "Hierarchy",
        children: []
      }, this._buildData = (e, t) => (e.push({
        text: t.name || "unnamed",
        id: t.uuid,
        children: t.children.reduce(this._buildData, [])
      }), e), this._findVisible = (e, t) => t.visible ? (t.children.length < 1 ? e.push(t.uuid) : e.push(...t.children.reduce(this._findVisible, [])), e) : e, this._setVisible = e => {
        var t, r, n;
        const i = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
        if (!i || null == e) return;
        const s = new Set();
        i.traverse(t => {
          t !== i && (t.visible = e.includes(t.uuid), t.visible && t.traverseAncestors(e => s.add(e)));
        }), s.forEach(e => e.visible = !0), null === (n = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene) || void 0 === n || n.setDirty({
          sceneUpdate: !0,
          fromHierarchyPlugin: !0,
          updateGround: !1
        });
      }, this.enabled = e, this.reset = this.reset.bind(this), Mt(E`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: #e9e9ed;
  margin-top: 0;
}
`);
    }
    reset(e) {
      var t;
      if (null == e ? void 0 : e.fromHierarchyPlugin) return;
      if (!(null == e ? void 0 : e.hierarchyChanged)) return;
      for (; this.hierarchyDiv.firstChild;) this.hierarchyDiv.firstChild.remove();
      const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
      if (!r) return;
      const n = r.children.reduce(this._buildData, []),
        i = r.children.reduce(this._findVisible, []);
      let s = !1;
      return new Promise((e, t) => {
        this.treeView = new DT(this.hierarchyDiv, {
          closeDepth: 1,
          data: n,
          loaded: function () {
            this.values = i, e();
          },
          onChange: () => {
            s ? Dc(200).then(() => {
              this.treeView && this._setVisible(this.treeView.values);
            }) : s = !0;
          },
          onItemLabelClick: e => {
            var t;
            const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot.modelObject.getObjectByProperty("uuid", e);
            n && r.visible && n.dispatchEvent({
              type: "select",
              value: n,
              ui: !0
            });
          }
        });
      });
    }
    async onAdded(e) {
      await super.onAdded(e), this.reset(), e.scene.addEventListener("sceneUpdate", this.reset);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e);
    }
    async onDispose(e) {
      return super.onDispose(e);
    }
    get uiConfig() {
      return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig;
    }
  }
  PT.PluginType = "HierarchyUiPlugin";
  class BT extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = !0, this.uiConfig = {
        type: "folder",
        label: "Lights",
        children: [{
          type: "button",
          label: "Add Directional Light",
          value: () => {
            if (!this._viewer) return;
            const e = new Ws();
            e.position.set(0, 0, 0), e.target.position.set(0, 0, -1).normalize(), e.intensity = 2, e.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e);
          }
        }],
        limitedUi: !0
      }, this.dependencies = [to], this._sceneUpdate = e => {
        var t, r, n;
        if (!e.hierarchyChanged) return;
        const i = [];
        null === (t = this._viewer) || void 0 === t || t.traverseSceneObjects(e => {
          if (!e.lightObject) return;
          const t = e.uiConfig;
          t && !i.includes(t) && i.push(t);
        }), [...this.uiConfig.children].forEach(e => {
          var t;
          "button" === (null === (t = e) || void 0 === t ? void 0 : t.type) || i.includes(e) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e), 1);
        }), i.forEach(e => {
          this.uiConfig.children.includes(e) || this.uiConfig.children.push(e);
        }), null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0);
      };
    }
    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e);
    }
  }
  BT.PluginType = "SimpleLightsUi";
  class RT extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = !0, this.uiConfig = {
        type: "folder",
        label: "Cameras (Loaded)",
        children: [{
          type: "button",
          label: "Add Camera",
          hidden: !0
        }],
        limitedUi: !0
      }, this.dependencies = [to], this._sceneUpdate = e => {
        var t, r, n;
        if (!e.hierarchyChanged) return;
        const i = [];
        null === (t = this._viewer) || void 0 === t || t.traverseSceneObjects(e => {
          if (!e.cameraObject) return;
          const t = e.uiConfig;
          t && !i.includes(t) && i.push(t);
        }), [...this.uiConfig.children].forEach(e => {
          var t;
          "button" === (null === (t = e) || void 0 === t ? void 0 : t.type) || i.includes(e) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e), 1);
        }), i.forEach(e => {
          this.uiConfig.children.includes(e) || this.uiConfig.children.push(e);
        }), null === (n = (r = this.uiConfig).uiRefresh) || void 0 === n || n.call(r, "postFrame", !0);
      };
    }
    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e);
    }
  }
  RT.PluginType = "SimpleSceneCamerasUi";
  var LT,
    OT = function (e, t, r, n) {
      var i,
        s = arguments.length,
        o = s < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
      return s > 3 && o && Object.defineProperty(t, r, o), o;
    };
  let FT = LT = class extends ro {
    constructor() {
      super(), this.enabled = !0, this.width = 0, this.height = 0, this.scale = 1, this._sizeChanged = this._sizeChanged.bind(this), this._refresh = this._refresh.bind(this);
    }
    refreshSize() {
      this._sizeChanged();
    }
    _sizeChanged() {
      var e;
      if (!this._viewer) return;
      const t = {
          width: Math.round(this.width),
          height: Math.round(this.height)
        },
        r = this._viewer.container.getBoundingClientRect();
      t.width >= r.width && delete t.width, t.height >= r.height && delete t.height, null === (e = this._viewer) || void 0 === e || e.setSize(t), this._viewer.renderer.displayCanvasScaling = this.scale;
    }
    async onAdded(e) {
      await super.onAdded(e);
      const t = e.canvas.clientWidth,
        r = e.canvas.clientHeight,
        n = e.renderer.displayCanvasScaling;
      this.width = t, this.height = r, this.scale = n, e.renderer.addEventListener("resize", this._refresh), this.addEventListener("deserialize", this._sizeChanged), this._refresh();
    }
    async onRemove(e) {
      return this.removeEventListener("deserialize", this._sizeChanged), e.renderer.removeEventListener("resize", this._refresh), super.onRemove(e);
    }
    _refresh() {
      var e, t;
      null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
    }
  };
  FT.PluginType = "RendererParamsUiPlugin", OT([Ce(), M(LT.prototype._sizeChanged), $e("Width", void 0, 1, e => ({
    bounds: () => {
      var t;
      return [10, (null === (t = e._viewer) || void 0 === t ? void 0 : t.container.getBoundingClientRect().width) || 1024];
    }
  }))], FT.prototype, "width", void 0), OT([Ce(), M(LT.prototype._sizeChanged), $e("Height", void 0, 1, e => ({
    bounds: () => {
      var t;
      return [10, (null === (t = e._viewer) || void 0 === t ? void 0 : t.container.getBoundingClientRect().height) || 1024];
    }
  }))], FT.prototype, "height", void 0), OT([Ce(), M(LT.prototype._sizeChanged), $e("Scale", [.25, 4], .25, {
    limitedUi: !0
  })], FT.prototype, "scale", void 0), FT = LT = OT([lt("Renderer")], FT);
  class UT extends ro {
    constructor() {
      super(), this.enabled = !0, this.serializeWithViewer = !1, this._refresh = this._refresh.bind(this);
    }
    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("activeCameraChange", this._refresh), e.scene.addEventListener("sceneUpdate", this._refresh);
    }
    async onRemove(e) {
      return e.scene.removeEventListener("activeCameraChange", this._refresh), e.scene.removeEventListener("sceneUpdate", this._refresh), super.onRemove(e);
    }
    toJSON(e) {
      var t;
      const r = super.toJSON(e);
      return r.activeCamera = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera.toJSON(), r;
    }
    fromJSON(e, t) {
      var r;
      return e.activeCamera && (null === (r = this._viewer) || void 0 === r || r.scene.activeCamera.fromJSON(e.activeCamera), delete (e = {
        ...e
      }).activeCamera), super.fromJSON(e, t);
    }
    _refresh() {
      var e, t;
      this._viewer && (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
    }
    get uiConfig() {
      var e;
      return (null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera.uiConfig) || {};
    }
  }
  UT.PluginType = "CameraUiPlugin";
  let NT = {
    create: e => {
      let t = "button" + (e.type ? " " + e.type : ""),
        r = GT.createDiv(t, e.text);
      return r.addEventListener("click", e.onClick), r;
    }
  };
  var jT = NT;
  let zT = {
    createElement: (e, t, r, n) => {
      let i = document.createElement(e);
      if (t && (i.className = t), r && (i.innerHTML = r), n) for (let e in n) i.setAttribute(e, n[e]);
      return i;
    },
    createDiv: (e, t, r) => zT.createElement("div", e, t, r),
    createDomTree: e => {
      if (!e || !e.hasOwnProperty("dom")) return e;
      let t = e.dom;
      if (e.children) for (let r in e.children) e.children[r] && t.appendChild(zT.createDomTree(e.children[r]));
      return t;
    },
    removeElement: e => {
      null != e && e.parentNode.removeChild(e);
    },
    appendToBody: e => {
      document.body.appendChild(e);
    },
    makeIconHTML: e => {
      let t = "";
      return "ok" == e && (t = "#tick"), "error" == e && (t = "#cancel"), "info" == e && (t = "#info-button"), "caution" == e && (t = "#danger"), "min" == e && (t = "#line"), "close" == e && (t = "#close"), `<svg class="icon ${e}"><use xlink:href="${t}" /></svg>`;
    },
    makeNftContent: e => {
      let t = null;
      if (e.type) {
        let r = null;
        r = "string" == typeof e.content ? zT.createDiv("inner-content", e.content) : zT.createDomTree({
          dom: zT.createDiv("inner-content"),
          children: [e.content]
        }), t = "text" == e.type ? zT.createDomTree({
          dom: zT.createDiv("content text"),
          children: [r]
        }) : zT.createDomTree({
          dom: zT.createDiv("content"),
          children: [zT.createDiv("state", zT.makeIconHTML(e.type)), r]
        });
      } else "string" == typeof e.content && (t = zT.createDiv("content", e.content));
      return t;
    },
    standardizeButtons: (e, t) => {
      let r = [];
      if (void 0 === t.buttons) return "caution" != t.type && "info" != t.type || r.push({
        key: 27,
        text: "Cancel",
        onClick: e.close.bind(e, "cancel")
      }), r.push({
        key: 13,
        text: "OK",
        type: "main",
        onClick: e.close.bind(e, "ok")
      }), r;
      r = t.buttons, r.constructor !== Array && (r = [r]);
      for (let t in r) !r[t].onClick && (r[t].onClick = e.close.bind(e, r[t].id));
      return r;
    },
    makeButtons: e => {
      let t = [];
      if (e) for (let r in e) t.push(jT.create({
        text: e[r].text ? e[r].text : "OK",
        type: e[r].normal ? null : "main",
        onClick: e[r].onClick
      }));
      return zT.createDomTree({
        dom: zT.createDiv("button-wrapper"),
        children: t
      });
    },
    bindButtonKeyEvents: e => {
      let t = t => {
        for (let r in e) if (e[r].key === t.keyCode) return void e[r].onClick();
      };
      return window.addEventListener("keydown", t), t;
    },
    unbindButtonKeyEvents: e => {
      window.removeEventListener("keydown", e);
    }
  };
  var GT = zT,
    VT = __webpackgi_require__(476);
  var QT = {
    "wwise-overlay-in-1": {
      opacity: "0"
    },
    "wwise-overlay-in-2": {
      opacity: "1"
    },
    "wwise-overlay-out-1": {
      opacity: "0"
    },
    "wwise-pop-in-1": {
      transform: "scale(0.5, 0.5)",
      "margin-top": "50px",
      opacity: ".5"
    },
    "wwise-pop-in-2": {
      transform: "scale(1, 1)",
      "margin-top": "0",
      opacity: "1"
    },
    "wwise-pop-in-3": {
      transform: "scale(1.05, 1.05)"
    },
    "wwise-pop-in-4": {
      transform: "scale(1, 1)"
    },
    "wwise-pop-out-1": {
      transform: "scale(0.25, 0.25)",
      "margin-top": "50px",
      opacity: "0"
    },
    "wwise-flip-in-1": {
      transform: "rotateX(60deg) scaleX(.5)",
      opacity: ".2"
    },
    "wwise-flip-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-flip-out-1": {
      transform: "rotateX(60deg) scaleX(.5)",
      opacity: "0"
    },
    "wwise-top-in-1": {
      transform: "translateY(-30vh)",
      opacity: ".5"
    },
    "wwise-top-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-top-out-1": {
      transform: "translateY(-30vh)",
      opacity: "0"
    },
    "wwise-bottom-in-1": {
      transform: "translateY(30vh)",
      opacity: ".5"
    },
    "wwise-bottom-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-bottom-out-1": {
      transform: "translateY(30vh)",
      opacity: "0"
    },
    "wwise-left-in-1": {
      transform: "translateX(-30vw)",
      opacity: ".5"
    },
    "wwise-left-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-left-out-1": {
      transform: "translateX(-30vw)",
      opacity: "0"
    },
    "wwise-right-in-1": {
      transform: "translateX(30vw)",
      opacity: ".5"
    },
    "wwise-right-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-right-out-1": {
      transform: "translateX(30vw)",
      opacity: "0"
    },
    "wwise-min-in-1": {
      "margin-top": "0",
      transform: "rotateX(-60deg) scale(0.2, 1.8) translateY(80vh)",
      opacity: ".2"
    },
    "wwise-min-in-2": {
      transform: "none",
      opacity: "1"
    },
    "wwise-min-out-1": {
      "margin-top": "30vh",
      transform: "rotateX(-60deg) scale(0.05, 2) translateY(30vh)",
      opacity: "0"
    }
  };
  let HT = {};
  HT.overlay_in = [new VT.Frame(QT["wwise-overlay-in-1"], 0), new VT.Frame(QT["wwise-overlay-in-2"], 400)], HT.overlay_out = [new VT.Frame(QT["wwise-overlay-out-1"], 300)], HT.pop_in = [new VT.Frame(QT["wwise-pop-in-1"], 0), new VT.Frame(QT["wwise-pop-in-2"], {
    duration: 200,
    "timing-function": "ease-in"
  }), new VT.Frame(QT["wwise-pop-in-3"], {
    duration: 100,
    "timing-function": "linear"
  }), new VT.Frame(QT["wwise-pop-in-4"], {
    duration: 100,
    "timing-function": "linear"
  })], HT.pop_out = [new VT.Frame(QT["wwise-pop-out-1"], {
    duration: 250,
    "timing-function": "ease-in"
  })], HT.flip_in = [new VT.Frame(QT["wwise-flip-in-1"], 0), new VT.Frame(QT["wwise-flip-in-2"], 500)], HT.flip_out = [new VT.Frame(QT["wwise-flip-out-1"], 400)], HT.min_in = [new VT.Frame(QT["wwise-min-in-1"], 0), new VT.Frame(QT["wwise-min-in-2"], 350)], HT.min_out = [new VT.Frame(QT["wwise-min-out-1"], 400)];
  let WT = ["top", "bottom", "left", "right"];
  for (let e in WT) {
    let t = WT[e];
    HT[t + "_in"] = [new VT.Frame(QT["wwise-" + t + "-in-1"], 0), new VT.Frame(QT["wwise-" + t + "-in-2"], {
      duration: 400,
      "timing-function": "ease-out"
    })], HT[t + "_out"] = [new VT.Frame(QT["wwise-" + t + "-out-1"], {
      duration: 400,
      "timing-function": "ease-in"
    })];
  }
  var qT = HT;
  let XT = {
    animation: "pop",
    topbar: {
      showClose: !0,
      showMin: !1
    },
    keepOverlay: !1,
    position: "center",
    overlay: !1,
    clickOverlayToClose: !0,
    removeBackground: !1,
    noRadius: !1,
    zIndex: null
  };
  class YT {
    static create(e, t) {
      let r = e.getElementsByClassName("title")[0];
      r && (r = r.innerHTML);
      let n = e.getElementsByClassName("content")[0];
      return n && (n = n.innerHTML), GT.removeElement(e), t.title = r, t.content = n, new YT(t);
    }
    constructor(e) {
      this.options = JSON.parse(JSON.stringify(XT));
      for (let t in e) null != e[t] && (this.options[t] = e[t]);
      let t = this.options.position;
      if (-1 == t.indexOf(" ") && ("left" == t || "right" == t ? t += " center" : t = "top" == t || "bottom" == t ? "center " + t : t + " " + t), this.options.position = t, this.options.overlay) {
        let e = document.getElementsByClassName("wwise-overlay");
        e.length ? (this.overlay = e[0], this.hasOverlay = !0) : (this.overlay = GT.createDiv("wwise-overlay"), this.options.zIndex && (this.overlay.style.zIndex = this.options.zIndex)), this.overlayClickHandler = this.close.bind(this, void 0);
      } else this.options.clickOverlayToClose = !1;
      let r = "content";
      if (this.options.topbar) {
        let e = [];
        this.options.topbar.showMin && (e.push(GT.createDiv(null, GT.makeIconHTML("min"))), e[e.length - 1].addEventListener("click", this.min.bind(this))), this.options.topbar.showClose && (e.push(GT.createDiv(null, GT.makeIconHTML("close"))), e[e.length - 1].addEventListener("click", this.close.bind(this, void 0)));
        let t = null;
        t = "string" == typeof this.options.title ? GT.createDiv("title", this.options.title) : GT.createDomTree({
          dom: GT.createDiv("title"),
          children: [this.options.title]
        }), this.topbar = GT.createDomTree({
          dom: GT.createDiv("topbar"),
          children: [{
            dom: GT.createDiv("control"),
            children: e.map(e => ({
              dom: e
            }))
          }, {
            dom: t
          }, {
            dom: GT.createDiv("clear")
          }]
        });
      } else r += " no-topbar";
      "string" == typeof this.options.content ? this.content = GT.createDomTree({
        dom: GT.createDiv(r, this.options.content)
      }) : this.content = GT.createDomTree({
        dom: GT.createDiv(r),
        children: [this.options.content]
      }), this.options.removeBackground && (this.content.style.background = "initial"), this.window = GT.createDomTree({
        dom: GT.createDiv("wwise" + (this.options.noRadius ? " no-radius" : "")),
        children: [this.topbar, this.content]
      });
      let n = GT.createDiv("wwise-wrapper");
      this.options.zIndex && (n.style.zIndex = this.options.zIndex), this.wrapper = GT.createDomTree({
        dom: n,
        children: [this.window]
      }), this.dom = GT.createDomTree({
        dom: GT.createDiv(),
        children: [this.wrapper]
      });
      let i = this.options.position.split(" "),
        s = -50,
        o = -50;
      if ("left" == i[0] ? (s = 0, this.wrapper.classList.add("left")) : "right" == i[0] ? (s = -100, this.wrapper.classList.add("right")) : "center" == i[0] ? this.wrapper.classList.add("h-center") : this.wrapper.style.left = i[0], "top" == i[1] ? (o = 0, this.wrapper.classList.add("top")) : "bottom" == i[1] ? (o = -100, this.wrapper.classList.add("bottom")) : "center" == i[1] ? this.wrapper.classList.add("v-center") : this.wrapper.style.top = t[1], this.window.style.transform = `translate(${s}%, ${o}%)`, this.options.style) for (let e in this.options.style) this.window.style[e] = this.options.style[e];
      this.options.margin && (this.wrapper.style.margin = this.options.margin), this.options.draggable && this.draggable();
    }
    open(e) {
      if (this.opened) return;
      this.promise = new Promise(e => {
        this.promiseResolve = e;
      }), this.appendDoms(), this.opened = !0, this.options.clickOverlayToClose && (this.overlay.addEventListener("click", this.overlayClickHandler), this.overlay.addEventListener("touchstart", this.overlayClickHandler));
      let t = e ? "min" : this.options.animation;
      if (t) {
        "min" != t && "flip" != t || this.dom.classList.add("wwise-perspective");
        let e = [new VT.Queue(this.wrapper, qT[t + "_in"], {
          instant: !0,
          applyOnEnd: !0
        }).getPromise()];
        return this.options.overlay && !this.hasOverlay && e.push(new VT.Queue(this.overlay, qT.overlay_in, {
          instant: !0,
          applyOnEnd: !0
        }).getPromise()), Promise.all(e).then(() => {
          this.dom.classList.remove("wwise-perspective");
        });
      }
      return Promise.resolve();
    }
    close(e) {
      if (!this.opened) return;
      this.opened = !1;
      let t = e ? "min" : this.options.animation;
      if (this.overlay && (this.overlay.removeEventListener("click", this.overlayClickHandler), this.overlay.removeEventListener("touchstart", this.overlayClickHandler)), t) {
        "min" != t && "flip" != t || this.dom.classList.add("wwise-perspective");
        let e = [new VT.Queue(this.wrapper, qT[t + "_out"], {
          instant: !0,
          applyOnEnd: !0
        }).getPromise()];
        return this.options.overlay && !this.options.keepOverlay && e.push(new VT.Queue(this.overlay, qT.overlay_out, {
          instant: !0,
          applyOnEnd: !0
        }).getPromise()), Promise.all(e).then(() => {
          this.removeDoms(), this.dom.classList.remove("wwise-perspective"), this.promiseResolve();
        });
      }
      return this.removeDoms(), this.promiseResolve(), Promise.resolve();
    }
    min() {
      return this.close(!0);
    }
    resume() {
      return this.open(!0);
    }
    getPromise() {
      return this.promise;
    }
    appendDoms() {
      this.options.overlay && !this.hasOverlay && (GT.appendToBody(this.overlay), document.body.classList.add("wwise-no-scroll"), this.overlay.addEventListener("touchstart", e => {
        e.preventDefault();
      })), GT.appendToBody(this.dom);
    }
    removeDoms() {
      GT.removeElement(this.dom), !this.options.keepOverlay && this.overlay && (GT.removeElement(this.overlay), document.body.classList.remove("wwise-no-scroll"));
    }
    draggable(e = !0) {
      this.topbar && (e ? (this.draggableMouseMoveHandler = this.handleDraggableMouseMove.bind(this), this.draggableMouseDownHandler = this.handleDraggableMouseDown.bind(this), this.draggableMouseUpHandler = this.handleDraggableMouseUp.bind(this), this.draggableMouseOutHandler = this.handleDraggableMouseOut.bind(this), window.addEventListener("mousemove", this.draggableMouseMoveHandler), window.addEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.addEventListener("mousedown", this.draggableMouseDownHandler), window.addEventListener("mouseup", this.draggableMouseUpHandler)) : (window.removeEventListener("mousemove", this.draggableMouseMoveHandler), window.removeEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.removeEventListener("mousedown", this.draggableMouseDownHandler), window.removeEventListener("mouseup", this.draggableMouseUpHandler)));
    }
    handleDraggableMouseMove(e) {
      if (this.inDragging) {
        let t = {
            x: e.clientX - this.dragPrev.x,
            y: e.clientY - this.dragPrev.y
          },
          r = window.getComputedStyle(this.wrapper),
          n = this.options.draggable,
          i = parseFloat(r.left),
          s = parseFloat(r.top);
        if (-1 != r.left.indexOf("%")) {
          i = r.left, i = i.substr(0, i.length - 1), i = parseInt(i);
          let e = window,
            t = document,
            n = t.documentElement,
            s = t.getElementsByTagName("body")[0];
          i = i * (e.innerWidth || n.clientWidth || s.clientWidth) / 100;
        }
        if (-1 != r.top.indexOf("%")) {
          s = r.top, s = s.substr(0, s.length - 1), s = parseInt(s);
          let e = window,
            t = document,
            n = t.documentElement,
            i = t.getElementsByTagName("body")[0];
          s = s * (e.innerHeight || n.clientHeight || i.clientHeight) / 100;
        }
        1 != n && "horizontal" != n || (this.wrapper.style.left = i + t.x + "px"), 1 != n && "vertical" != n || (this.wrapper.style.top = s + t.y + "px"), this.dragPrev = {
          x: e.clientX,
          y: e.clientY
        };
      }
    }
    handleDraggableMouseDown(e) {
      this.inDragging = !0, this.dragPrev = {
        x: e.clientX,
        y: e.clientY
      };
    }
    handleDraggableMouseUp(e) {
      this.inDragging = !1;
    }
    handleDraggableMouseOut(e) {
      let t = e.relatedTarget;
      t && "HTML" != t.nodeName || (this.inDragging = !1);
    }
  }
  var KT = YT,
    JT = class {
      constructor(e) {
        let t = this.options = e;
        !t.type && (t.type = "ok");
        let r = {
          topbar: !1
        };
        r.content = this.constructContent({
          type: t.type,
          title: t.title,
          text: t.text,
          content: t.content,
          buttons: t.buttons
        }), r.overlay = !0, r.keepOverlay = t.keepOverlay, r.clickOverlayToClose = !1, r.animation = t.animation, r.zIndex = t.zIndex, this.wwise = new KT(r);
      }
      constructContent(e) {
        let t = GT.createDiv("modal"),
          r = GT.createDomTree({
            dom: GT.createDiv("main " + e.type),
            children: [GT.createDiv(null, GT.makeIconHTML(e.type)), GT.createDiv("title", e.title), GT.createDiv("text", e.text)]
          });
        this.buttonArr = GT.standardizeButtons(this, e);
        let n = GT.makeButtons(this.buttonArr),
          i = null;
        e.content && (i = "string" == typeof e.content ? GT.createDiv(null, e.content) : e.content);
        let s = null;
        return n.innerHTML && (s = GT.createDomTree({
          dom: GT.createDiv("operation " + e.type),
          children: [n]
        })), i || s || r.classList.add("no-op"), GT.createDomTree({
          dom: t,
          children: [r, i, s]
        });
      }
      open() {
        if (this.wwise.opened) return;
        let e = this.wwise.open();
        return this.value = void 0, this.promise = new Promise(e => {
          this.promiseResolve = e;
        }), this.wwise.getPromise().then(this.handlePromiseResolve.bind(this)), this.keyHandler = GT.bindButtonKeyEvents(this.buttonArr), this.options.closeAfter && window.setTimeout(() => {
          this.close("timer");
        }, this.options.closeAfter), e;
      }
      close(e) {
        if (this.wwise.opened) return this.value = e, GT.unbindButtonKeyEvents(this.keyHandler), this.wwise.close();
      }
      getPromise() {
        return this.promise;
      }
      handlePromiseResolve() {
        this.promiseResolve(this.value);
      }
    };
  let ZT = {
      showCancel: !1,
      okText: "OK",
      cancelText: "Cancel",
      placeholder: "",
      validator: null
    },
    $T = {
      type: "info",
      keepOverlay: !1,
      title: "Input",
      text: "",
      zIndex: null
    };
  var eI = __webpackgi_require__(513),
    tI = {};
  eI.Z && eI.Z.locals && (tI.locals = eI.Z.locals);
  var rI,
    nI = 0,
    iI = {};
  iI.styleTagTransform = cp(), iI.setAttributes = sp(), iI.insert = function (e, t) {
    (t.target || document.head).appendChild(e);
  }, iI.domAPI = np(), iI.insertStyleElement = ap(), tI.use = function (e) {
    return iI.options = e || {}, nI++ || (rI = tp()(eI.Z, iI)), tI;
  }, tI.unuse = function () {
    nI > 0 && ! --nI && (rI(), rI = null);
  };
  var sI = tI;
  class oI extends ro {
    constructor() {
      super(...arguments), this.enabled = !0, this.toJSON = void 0, this._previousMappings = {};
    }
    async onAdded(e) {
      await super.onAdded(e), this._previousMappings = {
        alert: e.alert,
        confirm: e.confirm,
        prompt: e.prompt
      }, GT.appendToBody = t => {
        e.container.appendChild(t);
      }, GT.makeIconHTML = e => "", sI.use({
        target: e.container
      }), e.alert = async e => {
        const t = null == e ? void 0 : e.split(":")[0],
          r = new JT({
            type: "info",
            title: null != t ? t : "&ndsp;",
            text: (null == e ? void 0 : e.replace(t + ":", "")) || "",
            buttons: [{
              key: 13,
              text: "OK",
              type: "main",
              id: "ok"
            }],
            animation: "overlay"
          });
        return r.open(), r.getPromise();
      }, e.confirm = async e => {
        const t = null == e ? void 0 : e.split(":")[0],
          r = new JT({
            type: "info",
            title: null != t ? t : "&ndsp;",
            text: (null == e ? void 0 : e.replace(t || "", "").replace(":", "")) || "",
            buttons: [{
              id: "no",
              key: 27,
              text: "No",
              normal: !0
            }, {
              id: "yes",
              key: 13,
              text: "Yes"
            }],
            animation: "overlay"
          });
        return r.open(), "yes" === (await r.getPromise());
      }, e.prompt = async (e, t, r = !0) => {
        const n = null == e ? void 0 : e.split(":")[0],
          i = new class {
            constructor(e) {
              this.options = JSON.parse(JSON.stringify(ZT));
              for (let t in e) null != e[t] && (this.options[t] = e[t]);
              let t = this.options,
                r = JSON.parse(JSON.stringify($T));
              for (let e in r) t.hasOwnProperty(e) && (r[e] = t[e]);
              let n = [];
              t.showCancel && n.push({
                key: 27,
                text: t.cancelText,
                normal: !0,
                onClick: this.handleCancel.bind(this)
              }), n.push({
                key: 13,
                text: t.okText,
                onClick: this.handleOk.bind(this)
              }), r.buttons = n, this.input = GT.createElement("input", "input", null, {
                placeholder: t.placeholder
              }), this.error = GT.createDiv("error"), r.content = GT.createDomTree({
                dom: GT.createDiv("input-wrapper"),
                children: [this.input, this.error]
              }), this.modal = new JT(r);
            }
            handleCancel() {
              this.close().then(this.promiseReject.bind(this));
            }
            handleOk() {
              this.options.validator ? this.options.validator(this.input.value).then(() => {
                this.close().then(this.promiseResolve.bind(this, this.input.value));
              }, e => {
                this.error.innerText = e;
              }) : this.close().then(this.promiseResolve.bind(this, this.input.value));
            }
            open() {
              if (this.modal.wwise.opened) return;
              let e = this.modal.open();
              return this.input.value = "", this.error.innerText = "", this.input.focus(), this.promise = new Promise((e, t) => {
                this.promiseResolve = e, this.promiseReject = t;
              }), e;
            }
            close() {
              if (this.modal.wwise.opened) return this.modal.close();
            }
            getPromise() {
              return this.promise;
            }
          }({
            type: "info",
            title: null != n ? n : "&ndsp;",
            placeholder: null != t ? t : "",
            showCancel: r,
            animation: "overlay",
            text: (null == e ? void 0 : e.replace(n || "", "").replace(":", "")) || ""
          });
        return i.open(), await i.getPromise().catch(async () => null);
      };
    }
    async onRemove(e) {
      return e.alert = this._previousMappings.alert, e.confirm = this._previousMappings.confirm, e.prompt = this._previousMappings.prompt, super.onRemove(e);
    }
  }
  oI.PluginType = "WindowiseDialogPlugin";
  var aI = Yx({
      defaultModifiers: [Zx, nw, ow, aw]
    }),
    lI = __webpackgi_require__(388),
    cI = __webpackgi_require__.n(lI);
  function uI(e) {
    const t = [];
    e.traverse(e => {
      e.geometry && t.push(e);
    });
    const r = {},
      n = {};
    t.forEach(e => {
      var t;
      if (!r[e.geometry.uuid]) {
        const t = e.geometry.toJSON().data,
          n = t ? cI()({
            a: t.attributes || {},
            b: t.index || []
          }) : "";
        r[e.geometry.uuid] = n;
      }
      const i = r[e.geometry.uuid],
        s = null !== (t = n[i]) && void 0 !== t ? t : n[i] = [];
      s.includes(e) || s.push(e);
    }), Object.values(n).forEach(e => {
      if (e.length < 2) return;
      const t = e[0].geometry;
      e.forEach((e, r) => {
        r < 1 || (e.geometry.dispose(), e.geometry = t);
      });
    });
  }
  const hI = new n.Pa4(),
    pI = new n.Pa4(),
    dI = new n.Pa4(),
    fI = new n.Pa4(),
    mI = new n.Pa4(),
    _I = new n.Pa4();
  let gI = 1;
  const vI = new n.Pa4(0, 1, 0);
  class AI extends pt {
    constructor(e, t) {
      super(e, t), this.targetOffset = new n.Pa4(0, 0, 0);
      const r = this.update;
      this.update = () => this._update(r);
    }
    _update(e) {
      this.target.add(this.targetOffset), hI.copy(this.object.position).sub(this.target), gI = hI.length(), _I.copy(this.target);
      const t = e();
      return _I.sub(this.target), hI.copy(this.object.position).sub(this.target), gI /= hI.length(), this.target.add(_I), this.object.position.copy(this.target).add(hI), hI.normalize(), pI.crossVectors(vI, hI).normalize(), dI.crossVectors(hI, pI).normalize(), fI.crossVectors(pI, dI).normalize().negate(), pI.length() > .1 && this.object.up.crossVectors(hI.clone().normalize(), pI), this.enablePan && (mI.set(0, 0, 0).addScaledVector(pI, _I.x).addScaledVector(dI, _I.y).addScaledVector(fI, _I.z), this.targetOffset.add(mI), this.targetOffset.multiplyScalar(1 / gI)), mI.set(0, 0, 0).addScaledVector(pI, -this.targetOffset.x).addScaledVector(dI, -this.targetOffset.y).addScaledVector(fI, -this.targetOffset.z), this.object.lookAt(mI.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t;
    }
  }
  class bI extends ja {
    constructor() {
      super(), this.boundingScaleMultiplier = 1.2, this._initGeometry(new n.cJO(1, 0));
    }
  }
  function yI(e, t) {
    var r, n;
    const i = Array.from((null !== (r = e.access) && void 0 !== r ? r : "").split(".")),
      s = i.pop();
    let o = null !== (n = e.targetObject) && void 0 !== n ? n : t;
    if (!s || 0 === s.length) return {
      key: void 0,
      tar: o
    };
    if (o = g(i, o), o && !(s in o)) throw console.error("invalid key", s, o, t, e), "";
    return {
      key: s,
      tar: o
    };
  }
  function xI(e, t, r, n) {
    const {
      key: i,
      tar: s
    } = yI(e, t);
    return i && s ? Pc(s, i, () => {
      var t;
      r && (null === (t = e.updater) || void 0 === t ? void 0 : t.length) && e.updater.forEach(e => r[e]()), null == n || n();
    }) : r => console.warn("Unable to set ", r, i, s, e, t);
  }
  async function wI(e, t, r) {
    var n, i, s, o;
    const {
        key: a,
        tar: l
      } = yI(t, e),
      c = t.animSet ? [EI(l, t.animSet, r, null !== (n = t.animSetParallel) && void 0 !== n && n)] : [];
    if (a && l) {
      const e = null !== (o = t.updater) && void 0 !== o ? o : [],
        n = async () => Rc(l, a, {
          ...t,
          onUpdate: n => {
            var i;
            null === (i = t.onUpdate) || void 0 === i || i.call(t, n), e.forEach(e => {
              var t;
              return null === (t = r[e]) || void 0 === t ? void 0 : t.call(r);
            });
          }
        });
      t.delay ? c.push(Dc(t.delay).then(n)) : c.push(n());
    } else (t.duration || t.delay) && c.push(Dc((null !== (i = t.delay) && void 0 !== i ? i : 0) + (null !== (s = t.duration) && void 0 !== s ? s : 0)));
    return 1 === c.length ? c[0] : Promise.all(c);
  }
  async function EI(e, t, r, n = !1) {
    if (n) return Promise.all(t.map(async t => wI(e, t, r)));
    for (const n of t) await wI(e, n, r);
  }
  function SI(e, t, r, n) {
    var i, s, o, a, l, c, u;
    if (!e) return;
    t || (t = []);
    const h = null != n ? n : {},
      p = e;
    for (let e = 0, d = t.length; e < d; e++) {
      const d = t[e];
      if (d.uiRef) {
        const t = null !== (l = null == p ? void 0 : p.indexOf(d.uiRef)) && void 0 !== l ? l : -1;
        t !== e && (t >= 0 && (null == p || p.splice(t, 1)), null == p || p.splice(e, 0, d.uiRef));
      } else {
        d.uiRef = {
          type: "folder",
          label: null !== (i = d.name) && void 0 !== i ? i : "Animation " + e,
          children: []
        };
        const t = [{
          type: "button",
          label: "animate",
          value: () => {
            wI(r, d, h).then(() => {
              var e;
              return console.log((null === (e = d.uiRef) || void 0 === e ? void 0 : e.label) + " finished");
            });
          }
        }];
        void 0 !== d.access && t.push({
          type: "input",
          property: [d, "access"]
        }), void 0 !== d.from && t.push({
          type: null !== (s = d.uiObjectType) && void 0 !== s ? s : "input",
          property: [d, "from"],
          onChange: () => {
            var e;
            xI(d, r)(d.from), null === (e = d.updater) || void 0 === e || e.forEach(e => e in h && h[e]());
          }
        }), void 0 !== d.to && t.push({
          type: null !== (o = d.uiObjectType) && void 0 !== o ? o : "input",
          property: [d, "to"],
          onChange: () => {
            var e;
            xI(d, r)(d.to), null === (e = d.updater) || void 0 === e || e.forEach(e => e in h && h[e]());
          }
        }), void 0 !== d.duration && t.push({
          type: "input",
          property: [d, "duration"]
        }), d.animSet && (d.animSetParallel || (d.animSetParallel = !1), t.push({
          type: "input",
          label: "run parallel",
          property: [d, "animSetParallel"]
        })), d.animSet && t.push({
          type: "folder",
          label: "AnimSet",
          expanded: !1,
          children: [],
          animSetContainer: !0
        }), null === (a = d.uiRef.children) || void 0 === a || a.push(...t), null == p || p.splice(e, 0, d.uiRef);
      }
      const f = null === (c = d.uiRef.children) || void 0 === c ? void 0 : c.map(e => A(e)).flat(2).find(e => null == e ? void 0 : e.animSetContainer);
      d.animSet && f && SI(f.children, d.animSet, null !== (u = d.targetObject) && void 0 !== u ? u : r, n);
    }
  }
  function CI(e, t) {
    return t ? e * (1e3 / t) : 0;
  }
  function MI(e) {
    var t,
      r = e.from,
      n = void 0 === r ? 0 : r,
      i = e.velocity,
      s = void 0 === i ? 0 : i,
      o = e.min,
      a = e.max,
      l = e.power,
      c = void 0 === l ? .8 : l,
      u = e.timeConstant,
      h = void 0 === u ? 750 : u,
      p = e.bounceStiffness,
      d = void 0 === p ? 500 : p,
      f = e.bounceDamping,
      m = void 0 === f ? 10 : f,
      _ = e.restDelta,
      g = void 0 === _ ? 1 : _,
      v = e.modifyTarget,
      A = e.driver,
      b = e.onUpdate,
      y = e.onComplete;
    function x(e) {
      return void 0 !== o && e < o || void 0 !== a && e > a;
    }
    function w(e) {
      return void 0 === o ? a : void 0 === a || Math.abs(o - e) < Math.abs(a - e) ? o : a;
    }
    function E(e) {
      null == t || t.stop(), t = Ic(al(al({}, e), {
        driver: A,
        onUpdate: function (t) {
          var r;
          null == b || b(t), null === (r = e.onUpdate) || void 0 === r || r.call(e, t);
        },
        onComplete: y
      }));
    }
    function S(e) {
      E(al({
        type: "spring",
        stiffness: d,
        damping: m,
        restDelta: g
      }, e));
    }
    if (x(n)) S({
      from: n,
      velocity: s,
      to: w(n)
    });else {
      var C = c * s + n;
      void 0 !== v && (C = v(C));
      var M,
        T,
        I = w(C),
        k = I === o ? -1 : 1;
      E({
        type: "decay",
        from: n,
        velocity: s,
        timeConstant: h,
        power: c,
        restDelta: g,
        modifyTarget: v,
        onUpdate: x(C) ? function (e) {
          M = T, T = e, s = CI(e - M, Sc().delta), (1 === k && e > I || -1 === k && e < I) && S({
            from: e,
            to: I,
            velocity: s
          });
        } : void 0
      });
    }
    return {
      stop: function () {
        return null == t ? void 0 : t.stop();
      }
    };
  }
  var TI = function (e) {
      return 180 * e / Math.PI;
    },
    II = function (e, t) {
      return void 0 === t && (t = Kl), TI(Math.atan2(t.y - e.y, t.x - e.x));
    },
    kI = function (e, t) {
      var r = !0;
      return void 0 === t && (t = e, r = !1), function (n) {
        return r ? n - e + t : (e = n, r = !0, t);
      };
    },
    DI = function (e) {
      return e;
    },
    PI = function (e) {
      return void 0 === e && (e = DI), function (t, r, n) {
        var i = r - n,
          s = -(0 - t + 1) * (0 - e(Math.abs(i)));
        return i <= 0 ? r + s : r - s;
      };
    },
    BI = PI(),
    RI = PI(Math.sqrt),
    LI = function (e) {
      return e * Math.PI / 180;
    },
    OI = function (e) {
      return e.hasOwnProperty("x") && e.hasOwnProperty("y");
    },
    FI = function (e) {
      return OI(e) && e.hasOwnProperty("z");
    },
    UI = function (e, t) {
      return Math.abs(e - t);
    };
  function NI(e, t) {
    if (Jl(e) && Jl(t)) return UI(e, t);
    if (OI(e) && OI(t)) {
      var r = UI(e.x, t.x),
        n = UI(e.y, t.y),
        i = FI(e) && FI(t) ? UI(e.z, t.z) : 0;
      return Math.sqrt(Math.pow(r, 2) + Math.pow(n, 2) + Math.pow(i, 2));
    }
  }
  var jI = function (e, t, r) {
      return t = LI(t), {
        x: r * Math.cos(t) + e.x,
        y: r * Math.sin(t) + e.y
      };
    },
    zI = function (e, t) {
      return void 0 === t && (t = 2), t = Math.pow(10, t), Math.round(e * t) / t;
    },
    GI = function (e, t, r, n) {
      return void 0 === n && (n = 0), zI(e + r * (t - e) / Math.max(n, r));
    },
    VI = function (e) {
      void 0 === e && (e = 50);
      var t = 0,
        r = 0;
      return function (n) {
        var i = Sc().timestamp,
          s = i !== r ? i - r : 0,
          o = s ? GI(t, n, s, e) : t;
        return r = i, t = o, o;
      };
    },
    QI = function (e) {
      if ("number" == typeof e) return function (t) {
        return Math.round(t / e) * e;
      };
      var t = 0,
        r = e.length;
      return function (n) {
        var i = Math.abs(e[0] - n);
        for (t = 1; t < r; t++) {
          var s = e[t],
            o = Math.abs(s - n);
          if (0 === o) return s;
          if (o > i) return e[t - 1];
          if (t === r - 1) return s;
          i = o;
        }
      };
    };
  function HI(e, t) {
    return e / (1e3 / t);
  }
  var WI = function (e, t, r) {
      var n = t - e;
      return ((r - e) % n + n) % n + e;
    },
    qI = function (e, t) {
      return 1 - 3 * t + 3 * e;
    },
    XI = function (e, t) {
      return 3 * t - 6 * e;
    },
    YI = function (e) {
      return 3 * e;
    },
    KI = function (e, t, r) {
      return ((qI(t, r) * e + XI(t, r)) * e + YI(t)) * e;
    },
    JI = function (e, t, r) {
      return 3 * qI(t, r) * e * e + 2 * XI(t, r) * e + YI(t);
    },
    ZI = .1;
  function $I(e, t, r, n) {
    if (e === t && r === n) return qa;
    for (var i = new Float32Array(11), s = 0; s < 11; ++s) i[s] = KI(s * ZI, e, r);
    return function (s) {
      return 0 === s || 1 === s ? s : KI(function (t) {
        for (var n = 0, s = 1; 10 !== s && i[s] <= t; ++s) n += ZI;
        --s;
        var o = n + (t - i[s]) / (i[s + 1] - i[s]) * ZI,
          a = JI(o, e, r);
        return a >= .001 ? function (e, t, r, n) {
          for (var i = 0; i < 8; ++i) {
            var s = JI(t, r, n);
            if (0 === s) return t;
            t -= (KI(t, r, n) - e) / s;
          }
          return t;
        }(t, o, e, r) : 0 === a ? o : function (e, t, r, n, i) {
          var s,
            o,
            a = 0;
          do {
            (s = KI(o = t + (r - t) / 2, n, i) - e) > 0 ? r = o : t = o;
          } while (Math.abs(s) > 1e-7 && ++a < 10);
          return o;
        }(t, n, n + ZI, e, r);
      }(s), t, n);
    };
  }
  var ek = function (e, t) {
    return void 0 === t && (t = "end"), function (r) {
      var n = (r = "end" === t ? Math.min(r, .999) : Math.max(r, .001)) * e,
        i = "end" === t ? Math.floor(n) : Math.ceil(n);
      return cl(0, 1, i / e);
    };
  };
  async function tk(e, {
    debug: t = !1,
    ground: r = !0,
    bloom: n = !0,
    depthTonemap: i = !1,
    importPopup: s = !0,
    caching: o = !0
  }) {
    const a = new go(e);
    a.enabled = !1, t && (await a.addPlugin(Yc)), await a.addPlugin(to, void 0, void 0, {
      storage: o && window.caches ? await window.caches.open("webgi-cache-storage") : void 0
    }), await a.addPlugin(tg), await a.addPlugin(Vb), s && (await a.addPlugin(vp)), await a.addPlugin(oI), await a.addPlugin(m_), await a.addPlugin(qm), await a.addPlugin(Zm), await a.addPlugin(t_), await a.addPlugin(ym), await a.addPlugin(v_), await a.addPlugin($m), await a.addPlugin(wo), await a.addPlugin(Nc, za, !1, !0), await Wp(a, {
      ground: r,
      bloom: n,
      depthTonemap: i
    }), await a.addPlugin(CE, !1), await a.addPlugin(wE, !1), await a.addPlugin(Ob, !1), await a.addPlugin(Nb, !1), await a.addPlugin(UM), await a.addPlugin(HM), await a.addPlugin(eT), await a.addPlugin(vy, !1), await a.addPlugin(bE), await a.addPlugin(DE), await a.addPlugin(WE), await a.addPlugin(dE), await a.addPlugin(ME), await a.addPlugin(mE), await a.addPlugin(Ny), await a.addPlugin($u), await a.addPlugin(PT), await a.addPlugin(IT), await a.addPlugin(BT), await a.addPlugin(RT), await a.addPlugin(FT), await a.addPlugin(UT), await a.addPlugin(TT);
    const l = await a.addPlugin(new MT(!Pt()));
    return a.renderer.refreshPipeline(), a.scene.addEventListener("textureAdded", e => {
      e.texture && a.scene.setEnvironment(e.texture);
    }), l.setupPluginUi(yo), l.setupPluginUi(FT), l.setupPluginUi(UT), l.setupPluginUi(wo), l.setupPluginUi(TT), l.setupPluginUi(tg), l.setupPluginUi(Wc), l.setupPluginUi(hh), l.setupPluginUi(ME), l.setupPluginUi(dE), l.setupPluginUi(PT), l.setupPluginUi(mE), l.setupPluginUi(Gc), l.setupPluginUi(Nc), r && l.setupPluginUi(_u), l.setupPluginUi(No), l.setupPluginUi(nh), l.setupPluginUi(Ny), l.setupPluginUi(Ip), l.setupPluginUi(zp), l.setupPluginUi(Hp), l.setupPluginUi(Bp), l.setupPluginUi(Fp), l.setupPluginUi(bh), l.setupPluginUi(Qo), l.setupPluginUi(Ob), l.setupPluginUi(Nb), l.setupPluginUi(IT), l.setupPluginUi(bE), l.setupPluginUi(DE), l.setupPluginUi(To), l.setupPluginUi(BT), l.setupPluginUi(RT), l.setupPluginUi(Cu), l.setupPluginUi(Du), n && l.setupPluginUi(bu), l.setupPluginUi($u), l.setupPluginUi(xu), l.setupPluginUi(Ku), l.setupPluginUi(fh), l.setupPluginUi(CE), l.setupPluginUi(WE), l.setupPluginUi(Oc), l.setupPluginUi(Xu), l.setupPluginUi(Jh), l.setupPluginUi(Fu), l.setupPluginUi(wE), l.setupPluginUi(vp), l.setupPluginUi($h), l.setupPluginUi(vy), a.enabled = !0, a;
  }
}();
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__.LY2,
  __webpackgi_exports__AMaterialManager = __webpackgi_exports__.HRj,
  __webpackgi_exports__ARPlacementBox = __webpackgi_exports__.li4,
  __webpackgi_exports__ARPlugin = __webpackgi_exports__.FO5,
  __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__.Nlh,
  __webpackgi_exports__AViewerPlugin = __webpackgi_exports__.QvI,
  __webpackgi_exports__AddBlendPass = __webpackgi_exports__.JHp,
  __webpackgi_exports__AddEquation = __webpackgi_exports__.bGH,
  __webpackgi_exports__AddOperation = __webpackgi_exports__.NDo,
  __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__.gSk,
  __webpackgi_exports__AdditiveBlending = __webpackgi_exports__.WMw,
  __webpackgi_exports__AlphaFormat = __webpackgi_exports__.OTo,
  __webpackgi_exports__AlwaysDepth = __webpackgi_exports__.Se2,
  __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__.cum,
  __webpackgi_exports__AmbientLight = __webpackgi_exports__.Mig,
  __webpackgi_exports__AmbientLight2 = __webpackgi_exports__.B$7,
  __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__.i_9,
  __webpackgi_exports__AnimationClip = __webpackgi_exports__.m7l,
  __webpackgi_exports__AnimationLoader = __webpackgi_exports__.sYA,
  __webpackgi_exports__AnimationMixer = __webpackgi_exports__.Xcj,
  __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__.mzJ,
  __webpackgi_exports__AnimationUtils = __webpackgi_exports__.ZZA,
  __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__.$Ph,
  __webpackgi_exports__ArcCurve = __webpackgi_exports__.T__,
  __webpackgi_exports__ArrayCamera = __webpackgi_exports__.HkE,
  __webpackgi_exports__ArrowHelper = __webpackgi_exports__.tGC,
  __webpackgi_exports__AssetExporter = __webpackgi_exports__.g1S,
  __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__.I$C,
  __webpackgi_exports__AssetImporter = __webpackgi_exports__.QIH,
  __webpackgi_exports__AssetManagerBasicPopupPlugin = __webpackgi_exports__._JE,
  __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__.ksm,
  __webpackgi_exports__AsyncCompress = __webpackgi_exports__.jl_,
  __webpackgi_exports__AsyncDecompress = __webpackgi_exports__.b7R,
  __webpackgi_exports__AsyncDeflate = __webpackgi_exports__.BDV,
  __webpackgi_exports__AsyncGunzip = __webpackgi_exports__.Ea_,
  __webpackgi_exports__AsyncGzip = __webpackgi_exports__.qff,
  __webpackgi_exports__AsyncInflate = __webpackgi_exports__.tmC,
  __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__.BON,
  __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__.P40,
  __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__.wLL,
  __webpackgi_exports__AsyncZlib = __webpackgi_exports__.iHO,
  __webpackgi_exports__Audio = __webpackgi_exports__.BbS,
  __webpackgi_exports__AudioAnalyser = __webpackgi_exports__.kqm,
  __webpackgi_exports__AudioContext = __webpackgi_exports__.Hmr,
  __webpackgi_exports__AudioListener = __webpackgi_exports__.SJI,
  __webpackgi_exports__AudioLoader = __webpackgi_exports__.mTL,
  __webpackgi_exports__AxesHelper = __webpackgi_exports__.y8_,
  __webpackgi_exports__BackSide = __webpackgi_exports__._Li,
  __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__.g56,
  __webpackgi_exports__BaseRenderer = __webpackgi_exports__.bj3,
  __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__.z81,
  __webpackgi_exports__BasicShadowMap = __webpackgi_exports__._MY,
  __webpackgi_exports__BlobLoader = __webpackgi_exports__.yEv,
  __webpackgi_exports__BloomPlugin = __webpackgi_exports__.dFZ,
  __webpackgi_exports__Bone = __webpackgi_exports__.N$j,
  __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__._YM,
  __webpackgi_exports__Box2 = __webpackgi_exports__.TUj,
  __webpackgi_exports__Box3 = __webpackgi_exports__.ZzF,
  __webpackgi_exports__Box3B = __webpackgi_exports__.qzb,
  __webpackgi_exports__Box3Helper = __webpackgi_exports__.GQ,
  __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__.nvb,
  __webpackgi_exports__BoxGeometry = __webpackgi_exports__.DvJ,
  __webpackgi_exports__BoxHelper = __webpackgi_exports__.fQA,
  __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__.cPz,
  __webpackgi_exports__BufferAttribute = __webpackgi_exports__.TlE,
  __webpackgi_exports__BufferGeometry = __webpackgi_exports__.u9r,
  __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__.s4_,
  __webpackgi_exports__ByteType = __webpackgi_exports__.T95,
  __webpackgi_exports__CSGPluginBSP = __webpackgi_exports__.F5w,
  __webpackgi_exports__CSGPluginBVH = __webpackgi_exports__.NlP,
  __webpackgi_exports__CSGPluginBase = __webpackgi_exports__.$8Z,
  __webpackgi_exports__CSS3DRendererPlugin = __webpackgi_exports__.YYN,
  __webpackgi_exports__Cache = __webpackgi_exports__.CtF,
  __webpackgi_exports__Camera = __webpackgi_exports__.V1s,
  __webpackgi_exports__CameraController = __webpackgi_exports__.jOv,
  __webpackgi_exports__CameraHelper = __webpackgi_exports__.Rki,
  __webpackgi_exports__CameraUiPlugin = __webpackgi_exports__.pzV,
  __webpackgi_exports__CameraView = __webpackgi_exports__.itZ,
  __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__.qKx,
  __webpackgi_exports__CanvasRecorder = __webpackgi_exports__.vlJ,
  __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__.nPO,
  __webpackgi_exports__CanvasSnipper = __webpackgi_exports__.zcQ,
  __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__.GH1,
  __webpackgi_exports__CanvasTexture = __webpackgi_exports__.ROQ,
  __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__.YN5,
  __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__.BVQ,
  __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__.YT8,
  __webpackgi_exports__ChromaticAberrationPlugin = __webpackgi_exports__._DE,
  __webpackgi_exports__CineonToneMapping = __webpackgi_exports__.YGz,
  __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__.trn,
  __webpackgi_exports__CircleGeometry = __webpackgi_exports__.zf8,
  __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__.uWy,
  __webpackgi_exports__ClearcoatTintPlugin = __webpackgi_exports__.wYQ,
  __webpackgi_exports__Clock = __webpackgi_exports__.SUY,
  __webpackgi_exports__Color = __webpackgi_exports__.Ilk,
  __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__.R2R,
  __webpackgi_exports__ColorManagement = __webpackgi_exports__.epp,
  __webpackgi_exports__CombinedPostPlugin = __webpackgi_exports__.xmJ,
  __webpackgi_exports__Compress = __webpackgi_exports__.GD$,
  __webpackgi_exports__CompressedTexture = __webpackgi_exports__.EB7,
  __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__.DqL,
  __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__._3,
  __webpackgi_exports__ConeGeometry = __webpackgi_exports__.b_z,
  __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__.OCn,
  __webpackgi_exports__CubeCamera = __webpackgi_exports__._am,
  __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__.kB7,
  __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__.fY$,
  __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__.vxC,
  __webpackgi_exports__CubeTexture = __webpackgi_exports__.BtG,
  __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__.cBK,
  __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__.g8_,
  __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__.AXT,
  __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__.yj7,
  __webpackgi_exports__CubicInterpolant = __webpackgi_exports__.dYG,
  __webpackgi_exports__CullFaceBack = __webpackgi_exports__.tm_,
  __webpackgi_exports__CullFaceFront = __webpackgi_exports__.S2y,
  __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__.B02,
  __webpackgi_exports__CullFaceNone = __webpackgi_exports__.PeU,
  __webpackgi_exports__Curve = __webpackgi_exports__.Hyl,
  __webpackgi_exports__CurvePath = __webpackgi_exports__.Wqd,
  __webpackgi_exports__CustomBlending = __webpackgi_exports__.Xaj,
  __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__.DUb,
  __webpackgi_exports__CustomToneMapping = __webpackgi_exports__.dZ3,
  __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__.m_w,
  __webpackgi_exports__CylinderGeometry = __webpackgi_exports__.fHI,
  __webpackgi_exports__Cylindrical = __webpackgi_exports__.LBq,
  __webpackgi_exports__DECAY_MILLISECONDS = __webpackgi_exports__.dHf,
  __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__.Qww,
  __webpackgi_exports__Damper = __webpackgi_exports__.CGV,
  __webpackgi_exports__Data3DTexture = __webpackgi_exports__.JUT,
  __webpackgi_exports__DataArrayTexture = __webpackgi_exports__.p3g,
  __webpackgi_exports__DataTexture = __webpackgi_exports__.IEO,
  __webpackgi_exports__DataTexture2DArray = __webpackgi_exports__.CN8,
  __webpackgi_exports__DataTexture3D = __webpackgi_exports__.zob,
  __webpackgi_exports__DataTextureLoader = __webpackgi_exports__.yxD,
  __webpackgi_exports__DataUrlLoader = __webpackgi_exports__.CUS,
  __webpackgi_exports__DataUtils = __webpackgi_exports__.A5E,
  __webpackgi_exports__DebugPlugin = __webpackgi_exports__.zqG,
  __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__.PfX,
  __webpackgi_exports__Decompress = __webpackgi_exports__.Q1o,
  __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__.jfJ,
  __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__.T_J,
  __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__.tEQ,
  __webpackgi_exports__Deflate = __webpackgi_exports__.gb4,
  __webpackgi_exports__DepthFormat = __webpackgi_exports__.qkB,
  __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__.cvk,
  __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__.HWo,
  __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__.brP,
  __webpackgi_exports__DepthTexture = __webpackgi_exports__.$YQ,
  __webpackgi_exports__DeviceOrientationControls2 = __webpackgi_exports__.X8d,
  __webpackgi_exports__DeviceOrientationControlsPlugin = __webpackgi_exports__.Zdt,
  __webpackgi_exports__DiamondMaterial = __webpackgi_exports__.yNB,
  __webpackgi_exports__DiamondPlugin = __webpackgi_exports__.h7x,
  __webpackgi_exports__DirectionalLight = __webpackgi_exports__.Ox3,
  __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__.qtn,
  __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__.cBI,
  __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__.cU9,
  __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__.DT1,
  __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__.Kgo,
  __webpackgi_exports__DoubleSide = __webpackgi_exports__.ehD,
  __webpackgi_exports__Dropzone = __webpackgi_exports__.fhJ,
  __webpackgi_exports__DropzonePlugin = __webpackgi_exports__.y1s,
  __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__.fSK,
  __webpackgi_exports__DstColorFactor = __webpackgi_exports__.Vdb,
  __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__.l8J,
  __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__.dj0,
  __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__.QM0,
  __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__.OIS,
  __webpackgi_exports__EasingFunctions = __webpackgi_exports__.q8b,
  __webpackgi_exports__EdgesGeometry = __webpackgi_exports__.TOt,
  __webpackgi_exports__EffectComposer2 = __webpackgi_exports__.xaN,
  __webpackgi_exports__EllipseCurve = __webpackgi_exports__.Ny0,
  __webpackgi_exports__EllipseCurve3D = __webpackgi_exports__.NeD,
  __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__.Zof,
  __webpackgi_exports__EqualDepth = __webpackgi_exports__.eD,
  __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__.jwo,
  __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__.dSO,
  __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__.Bf4,
  __webpackgi_exports__Euler = __webpackgi_exports__.USm,
  __webpackgi_exports__EventDispatcher = __webpackgi_exports__.pBf,
  __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__.$Vf,
  __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__.O7d,
  __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__.ksq,
  __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__.gXf,
  __webpackgi_exports__FileLoader = __webpackgi_exports__.hH6,
  __webpackgi_exports__FilmicGrainPlugin = __webpackgi_exports__.kpi,
  __webpackgi_exports__FirstPersonControls2 = __webpackgi_exports__.DwZ,
  __webpackgi_exports__FirstPersonControlsPlugin = __webpackgi_exports__.kN3,
  __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__.e62,
  __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__.a$l,
  __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__.OM3,
  __webpackgi_exports__FloatType = __webpackgi_exports__.VzW,
  __webpackgi_exports__Fog = __webpackgi_exports__.ybr,
  __webpackgi_exports__FogExp2 = __webpackgi_exports__.yo9,
  __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__.$Bt,
  __webpackgi_exports__FramebufferTexture = __webpackgi_exports__.Wzm,
  __webpackgi_exports__FrontSide = __webpackgi_exports__.Wl3,
  __webpackgi_exports__Frustum = __webpackgi_exports__.iWj,
  __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__.DNz,
  __webpackgi_exports__GBufferPlugin = __webpackgi_exports__.m1M,
  __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__.ylh,
  __webpackgi_exports__GLSL1 = __webpackgi_exports__.v9Y,
  __webpackgi_exports__GLSL3 = __webpackgi_exports__.LSk,
  __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__.LHE,
  __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__.KE0,
  __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__.KCF,
  __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__.a4n,
  __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__.zIH,
  __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__.Hfk,
  __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__.png,
  __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName = __webpackgi_exports__.tAj,
  __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__.Eb_,
  __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__.BT2,
  __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__._8p,
  __webpackgi_exports__GammaCorrectionExtension = __webpackgi_exports__.V5Z,
  __webpackgi_exports__GammaCorrectionPlugin = __webpackgi_exports__.s5b,
  __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__.hkn,
  __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__.GFY,
  __webpackgi_exports__GreaterDepth = __webpackgi_exports__.w$m,
  __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__.ksN,
  __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__.j4z,
  __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__.OAl,
  __webpackgi_exports__GridHelper = __webpackgi_exports__.VLJ,
  __webpackgi_exports__GroundPlugin = __webpackgi_exports__.C73,
  __webpackgi_exports__Group = __webpackgi_exports__.ZAu,
  __webpackgi_exports__Gunzip = __webpackgi_exports__.ibP,
  __webpackgi_exports__Gzip = __webpackgi_exports__._fI,
  __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__.hUN,
  __webpackgi_exports__HalfFloatType = __webpackgi_exports__.cLu,
  __webpackgi_exports__HemisphereLight = __webpackgi_exports__.vmT,
  __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__.Qpg,
  __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__.So8,
  __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__.eOv,
  __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__.Wjw,
  __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__.cJO,
  __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__.QRU,
  __webpackgi_exports__ImageLoader = __webpackgi_exports__.S3k,
  __webpackgi_exports__ImageUtils = __webpackgi_exports__.PpQ,
  __webpackgi_exports__ImmediateRenderObject = __webpackgi_exports__.AHu,
  __webpackgi_exports__Importer = __webpackgi_exports__.q_9,
  __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__.ZRs,
  __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__.oqc,
  __webpackgi_exports__Inflate = __webpackgi_exports__.T_x,
  __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__.lb7,
  __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__.L5s,
  __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__.$TI,
  __webpackgi_exports__InstancedMesh = __webpackgi_exports__.SPe,
  __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__.aVm,
  __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__.j87,
  __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__.RNb,
  __webpackgi_exports__IntType = __webpackgi_exports__.Kz5,
  __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__.vpT,
  __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__.kB5,
  __webpackgi_exports__Interpolant = __webpackgi_exports__._C8,
  __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__.Syv,
  __webpackgi_exports__InterpolateLinear = __webpackgi_exports__.NMF,
  __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__.pIN,
  __webpackgi_exports__InvertStencilOp = __webpackgi_exports__.eMJ,
  __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__.rN7,
  __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__.iUp,
  __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__.GFd,
  __webpackgi_exports__KeepStencilOp = __webpackgi_exports__.x5V,
  __webpackgi_exports__KeyframeTrack = __webpackgi_exports__.tUh,
  __webpackgi_exports__LOD = __webpackgi_exports__.z8B,
  __webpackgi_exports__LUTPlugin = __webpackgi_exports__.vcl,
  __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__.GZb,
  __webpackgi_exports__LatheGeometry = __webpackgi_exports__.p7y,
  __webpackgi_exports__Layers = __webpackgi_exports__.S9g,
  __webpackgi_exports__LessDepth = __webpackgi_exports__.Zr5,
  __webpackgi_exports__LessEqualDepth = __webpackgi_exports__.vCF,
  __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__.yt0,
  __webpackgi_exports__LessStencilFunc = __webpackgi_exports__.uXU,
  __webpackgi_exports__Light = __webpackgi_exports__._kC,
  __webpackgi_exports__LightProbe = __webpackgi_exports__.lk7,
  __webpackgi_exports__LightsUiPlugin = __webpackgi_exports__.USc,
  __webpackgi_exports__Line = __webpackgi_exports__.x12,
  __webpackgi_exports__Line3 = __webpackgi_exports__.Zzh,
  __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__.nls,
  __webpackgi_exports__LineCurve = __webpackgi_exports__.g_z,
  __webpackgi_exports__LineCurve3 = __webpackgi_exports__.U7,
  __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__.FT0,
  __webpackgi_exports__LineLoop = __webpackgi_exports__.blk,
  __webpackgi_exports__LineSegments = __webpackgi_exports__.ejS,
  __webpackgi_exports__LinearEncoding = __webpackgi_exports__.rnI,
  __webpackgi_exports__LinearFilter = __webpackgi_exports__.wem,
  __webpackgi_exports__LinearInterpolant = __webpackgi_exports__.lfu,
  __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__.FDw,
  __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__.lRj,
  __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__.D1R,
  __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__.qyh,
  __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__.GUF,
  __webpackgi_exports__LinearToneMapping = __webpackgi_exports__.EoG,
  __webpackgi_exports__Loader = __webpackgi_exports__.aNw,
  __webpackgi_exports__LoaderUtils = __webpackgi_exports__.Zp0,
  __webpackgi_exports__LoadingManager = __webpackgi_exports__.lLk,
  __webpackgi_exports__LoopOnce = __webpackgi_exports__.jAl,
  __webpackgi_exports__LoopPingPong = __webpackgi_exports__.uEv,
  __webpackgi_exports__LoopRepeat = __webpackgi_exports__.YKA,
  __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__.cRx,
  __webpackgi_exports__LuminanceFormat = __webpackgi_exports__.Y8D,
  __webpackgi_exports__MOUSE = __webpackgi_exports__.RsA,
  __webpackgi_exports__MTLLoader2 = __webpackgi_exports__.Y0m,
  __webpackgi_exports__Material = __webpackgi_exports__.F5T,
  __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__.EDU,
  __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__.z$Q,
  __webpackgi_exports__MaterialExtender = __webpackgi_exports__.KA8,
  __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__.XUj,
  __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__.Me$,
  __webpackgi_exports__MaterialLoader = __webpackgi_exports__.u7G,
  __webpackgi_exports__MaterialManager = __webpackgi_exports__.PEk,
  __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__.BG4,
  __webpackgi_exports__MathUtils = __webpackgi_exports__.M8C,
  __webpackgi_exports__Matrix3 = __webpackgi_exports__.Vkp,
  __webpackgi_exports__Matrix4 = __webpackgi_exports__.yGw,
  __webpackgi_exports__MaxEquation = __webpackgi_exports__.Sm8,
  __webpackgi_exports__Mesh = __webpackgi_exports__.Kj0,
  __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__.vBJ,
  __webpackgi_exports__MeshBasicMaterial2 = __webpackgi_exports__.QfV,
  __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__.lRF,
  __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__.Lun,
  __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__.YBo,
  __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__.kaV,
  __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__.RSm,
  __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__.xoR,
  __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__.EJi,
  __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__.Wid,
  __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__.iuj,
  __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__.IKL,
  __webpackgi_exports__MinEquation = __webpackgi_exports__.r_,
  __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__.OoA,
  __webpackgi_exports__MixOperation = __webpackgi_exports__.qhX,
  __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__.qPT,
  __webpackgi_exports__MultiplyBlending = __webpackgi_exports__.M5h,
  __webpackgi_exports__MultiplyOperation = __webpackgi_exports__.Ns1,
  __webpackgi_exports__NearestFilter = __webpackgi_exports__.TyD,
  __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__.vZf,
  __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__.HTd,
  __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__.aH4,
  __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__.YLQ,
  __webpackgi_exports__NeverDepth = __webpackgi_exports__.BVF,
  __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__.MyG,
  __webpackgi_exports__NoBlending = __webpackgi_exports__.jFi,
  __webpackgi_exports__NoColorSpace = __webpackgi_exports__.aCh,
  __webpackgi_exports__NoToneMapping = __webpackgi_exports__.uL9,
  __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__.TNj,
  __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__.IFH,
  __webpackgi_exports__NormalBlending = __webpackgi_exports__.bdR,
  __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__.kM_,
  __webpackgi_exports__NotEqualDepth = __webpackgi_exports__.M6v,
  __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__.RvT,
  __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__.dUE,
  __webpackgi_exports__OBJLoader2 = __webpackgi_exports__.oe_,
  __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__.BuN,
  __webpackgi_exports__Object3D = __webpackgi_exports__.Tme,
  __webpackgi_exports__Object3DModel = __webpackgi_exports__.N9P,
  __webpackgi_exports__ObjectLoader = __webpackgi_exports__.Gql,
  __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__.$XY,
  __webpackgi_exports__ObjectPicker = __webpackgi_exports__.O9d,
  __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__.zEO,
  __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__.qfx,
  __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__.PA7,
  __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__.REq,
  __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__.pQR,
  __webpackgi_exports__OneFactor = __webpackgi_exports__.ghN,
  __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__.Hy8,
  __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__.Wpd,
  __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__.LgZ,
  __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__.iWC,
  __webpackgi_exports__OrbitControls2 = __webpackgi_exports__.mqn,
  __webpackgi_exports__OrbitControls3 = __webpackgi_exports__.SKe,
  __webpackgi_exports__OrthographicCamera = __webpackgi_exports__.iKG,
  __webpackgi_exports__PCFShadowMap = __webpackgi_exports__._iA,
  __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__.ntZ,
  __webpackgi_exports__PMREMGenerator = __webpackgi_exports__.anP,
  __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__.X2e,
  __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__.FCo,
  __webpackgi_exports__Path = __webpackgi_exports__.y$t,
  __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__.cPb,
  __webpackgi_exports__PickingPlugin = __webpackgi_exports__.lmx,
  __webpackgi_exports__Plane = __webpackgi_exports__.JOQ,
  __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__.BKK,
  __webpackgi_exports__PlaneGeometry = __webpackgi_exports__._12,
  __webpackgi_exports__PlaneHelper = __webpackgi_exports__.tJx,
  __webpackgi_exports__PointLight = __webpackgi_exports__.cek,
  __webpackgi_exports__PointLight2 = __webpackgi_exports__.qD0,
  __webpackgi_exports__PointLightHelper = __webpackgi_exports__.xG9,
  __webpackgi_exports__PointerLockControls2 = __webpackgi_exports__.wI8,
  __webpackgi_exports__PointerLockControlsPlugin = __webpackgi_exports__.Sgv,
  __webpackgi_exports__Points = __webpackgi_exports__.woe,
  __webpackgi_exports__PointsMaterial = __webpackgi_exports__.UY4,
  __webpackgi_exports__PolarGridHelper = __webpackgi_exports__.aq0,
  __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__.ujx,
  __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__.Uol,
  __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__.JiH,
  __webpackgi_exports__PositionalAudio = __webpackgi_exports__.VYz,
  __webpackgi_exports__PresetLibraryPlugin = __webpackgi_exports__._Pm,
  __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__.EsW,
  __webpackgi_exports__PropertyBinding = __webpackgi_exports__.iUV,
  __webpackgi_exports__PropertyMixer = __webpackgi_exports__.tf,
  __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__.ZQ6,
  __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__.mXe,
  __webpackgi_exports__Quaternion = __webpackgi_exports__._fP,
  __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__.iLg,
  __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__.zbs,
  __webpackgi_exports__REVISION = __webpackgi_exports__.UZH,
  __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__.mSO,
  __webpackgi_exports__RGBAFormat = __webpackgi_exports__.wk1,
  __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__.E2K,
  __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__.FUD,
  __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__.pKu,
  __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__.GG6,
  __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__.Gih,
  __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__.iiP,
  __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__.SvJ,
  __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__.ptH,
  __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__.jZA,
  __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__.y2t,
  __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__.gi4,
  __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__.Djp,
  __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__.BG$,
  __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__.NYV,
  __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__.xJs,
  __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__.bsb,
  __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__.ekQ,
  __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__.CaW,
  __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__.eaV,
  __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__.BFQ,
  __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__.v3W,
  __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__.ILR,
  __webpackgi_exports__RGBFormat = __webpackgi_exports__.UCm,
  __webpackgi_exports__RGBM16Encoding = __webpackgi_exports__.Inb,
  __webpackgi_exports__RGBM16Encoding_ = __webpackgi_exports__.U1$,
  __webpackgi_exports__RGBM7Encoding = __webpackgi_exports__.LgE,
  __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__.fto,
  __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__.l0P,
  __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__.vCx,
  __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__._AM,
  __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__.wuA,
  __webpackgi_exports__RGFormat = __webpackgi_exports__.av9,
  __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__.CtA,
  __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__.BvQ,
  __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__.FZJ,
  __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__.FIo,
  __webpackgi_exports__Ray = __webpackgi_exports__.zHn,
  __webpackgi_exports__Raycaster = __webpackgi_exports__.iMs,
  __webpackgi_exports__RectAreaLight = __webpackgi_exports__.T_f,
  __webpackgi_exports__RedFormat = __webpackgi_exports__.hEm,
  __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__.D9w,
  __webpackgi_exports__Reflector2 = __webpackgi_exports__.sHH,
  __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__.CdI,
  __webpackgi_exports__RendererUiPlugin = __webpackgi_exports__.rkc,
  __webpackgi_exports__RepeatWrapping = __webpackgi_exports__.rpg,
  __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__.ce8,
  __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__.rOj,
  __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__.P6m,
  __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__.JA6,
  __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__.V4E,
  __webpackgi_exports__RingGeometry = __webpackgi_exports__.o8S,
  __webpackgi_exports__RootScene = __webpackgi_exports__.flB,
  __webpackgi_exports__SETTLING_TIME = __webpackgi_exports__.DUH,
  __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__.KI_,
  __webpackgi_exports__SSAOPlugin = __webpackgi_exports__.iLN,
  __webpackgi_exports__SSContactShadows = __webpackgi_exports__.jsw,
  __webpackgi_exports__SSGIPlugin = __webpackgi_exports__.srG,
  __webpackgi_exports__SSRPlugin = __webpackgi_exports__.i6Z,
  __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__.vfv,
  __webpackgi_exports__Scene = __webpackgi_exports__.xsS,
  __webpackgi_exports__SceneCamerasUiPlugin = __webpackgi_exports__.or,
  __webpackgi_exports__SceneLoopPlugin = __webpackgi_exports__.EQj,
  __webpackgi_exports__SelectionWidget = __webpackgi_exports__.ov0,
  __webpackgi_exports__ShaderChunk = __webpackgi_exports__.WdD,
  __webpackgi_exports__ShaderLib = __webpackgi_exports__.Vj0,
  __webpackgi_exports__ShaderMaterial = __webpackgi_exports__.jyz,
  __webpackgi_exports__ShaderMaterial2 = __webpackgi_exports__.mTM,
  __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__.Mn1,
  __webpackgi_exports__ShaderPass2 = __webpackgi_exports__.Hlq,
  __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__.Fi7,
  __webpackgi_exports__ShadowMaterial = __webpackgi_exports__.Tn7,
  __webpackgi_exports__Shape = __webpackgi_exports__.bnF,
  __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__.HW6,
  __webpackgi_exports__ShapeGeometry = __webpackgi_exports__.oa8,
  __webpackgi_exports__ShapePath = __webpackgi_exports__.T_1,
  __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__.zHJ,
  __webpackgi_exports__ShapeUtils = __webpackgi_exports__.iDF,
  __webpackgi_exports__ShortType = __webpackgi_exports__.iAb,
  __webpackgi_exports__SimpleAssetList = __webpackgi_exports__.d4E,
  __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__.lBg,
  __webpackgi_exports__SimpleDataSource = __webpackgi_exports__.JeJ,
  __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__.FKY,
  __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__.zlZ,
  __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__.vkg,
  __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__.brh,
  __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__.kZK,
  __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__.puG,
  __webpackgi_exports__Skeleton = __webpackgi_exports__.OdW,
  __webpackgi_exports__SkeletonHelper = __webpackgi_exports__._YX,
  __webpackgi_exports__SkinnedMesh = __webpackgi_exports__.TUv,
  __webpackgi_exports__Source = __webpackgi_exports__.Hw6,
  __webpackgi_exports__Sphere = __webpackgi_exports__.aLr,
  __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__.Aip,
  __webpackgi_exports__SphereGeometry = __webpackgi_exports__.xo$,
  __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__.bIn,
  __webpackgi_exports__Spherical = __webpackgi_exports__.$V,
  __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__.lDi,
  __webpackgi_exports__SplineCurve = __webpackgi_exports__.gti,
  __webpackgi_exports__SpotLight = __webpackgi_exports__.PMe,
  __webpackgi_exports__SpotLight2 = __webpackgi_exports__.iwP,
  __webpackgi_exports__SpotLightHelper = __webpackgi_exports__.FvO,
  __webpackgi_exports__Sprite = __webpackgi_exports__.jyi,
  __webpackgi_exports__SpriteMaterial = __webpackgi_exports__.xeV,
  __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__.k74,
  __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__.RlZ,
  __webpackgi_exports__SrcColorFactor = __webpackgi_exports__.KhW,
  __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__.HgB,
  __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__.W2J,
  __webpackgi_exports__StaticReadUsage = __webpackgi_exports__.JWc,
  __webpackgi_exports__StereoCamera = __webpackgi_exports__.u37,
  __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__.Z6B,
  __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__.QZ1,
  __webpackgi_exports__StreamReadUsage = __webpackgi_exports__.Ir4,
  __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__.NwF,
  __webpackgi_exports__SubtractEquation = __webpackgi_exports__.Wbm,
  __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__.N4l,
  __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__.ej9,
  __webpackgi_exports__TOUCH = __webpackgi_exports__.QmN,
  __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__.IOt,
  __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__.NOD,
  __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__.L5g,
  __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__.H$k,
  __webpackgi_exports__TextSVGOptions = __webpackgi_exports__.cuP,
  __webpackgi_exports__Texture = __webpackgi_exports__.xEZ,
  __webpackgi_exports__TextureLoader = __webpackgi_exports__.dpR,
  __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__.wOD,
  __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__.KNb,
  __webpackgi_exports__TonemapPlugin = __webpackgi_exports__.IiN,
  __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__.Cne,
  __webpackgi_exports__TorusGeometry = __webpackgi_exports__.XvJ,
  __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__.XZw,
  __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__.FE5,
  __webpackgi_exports__TransformControls2 = __webpackgi_exports__.lVp,
  __webpackgi_exports__Triangle = __webpackgi_exports__.CJI,
  __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__.z$h,
  __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__.UlW,
  __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__.WwZ,
  __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__.Lcc,
  __webpackgi_exports__TubeGeometry = __webpackgi_exports__.WXh,
  __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__.Vjr,
  __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__.LuM,
  __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__.LP5,
  __webpackgi_exports__UVMapping = __webpackgi_exports__.xfE,
  __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__.qlB,
  __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__.lCJ,
  __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__.WTc,
  __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__.rAo,
  __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__.LZj,
  __webpackgi_exports__Uniform = __webpackgi_exports__.xWb,
  __webpackgi_exports__UniformsGroup = __webpackgi_exports__.gH0,
  __webpackgi_exports__UniformsLib = __webpackgi_exports__.rBU,
  __webpackgi_exports__UniformsUtils = __webpackgi_exports__.rDY,
  __webpackgi_exports__UnsignedByteType = __webpackgi_exports__.ywz,
  __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__.wJv,
  __webpackgi_exports__UnsignedIntType = __webpackgi_exports__.JQ4,
  __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__.k0A,
  __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__.irR,
  __webpackgi_exports__UnsignedShortType = __webpackgi_exports__.LsT,
  __webpackgi_exports__Unzip = __webpackgi_exports__.q5h,
  __webpackgi_exports__UnzipInflate = __webpackgi_exports__.TKh,
  __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__.tyg,
  __webpackgi_exports__Unzlib = __webpackgi_exports__.Ro5,
  __webpackgi_exports__VSMShadowMap = __webpackgi_exports__.dwk,
  __webpackgi_exports__Vector2 = __webpackgi_exports__.FM8,
  __webpackgi_exports__Vector3 = __webpackgi_exports__.Pa4,
  __webpackgi_exports__Vector4 = __webpackgi_exports__.Ltg,
  __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__.yC1,
  __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__.lHq,
  __webpackgi_exports__VideoTexture = __webpackgi_exports__.fO1,
  __webpackgi_exports__ViewerApp = __webpackgi_exports__.oMA,
  __webpackgi_exports__ViewerState = __webpackgi_exports__.JzW,
  __webpackgi_exports__VignettePlugin = __webpackgi_exports__.QEt,
  __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__.b5g,
  __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__.Ywn,
  __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__.GVz,
  __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__.oAp,
  __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__.kFz,
  __webpackgi_exports__WebGLMultisampleRenderTarget = __webpackgi_exports__.p7A,
  __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__.dd2,
  __webpackgi_exports__WebGLRenderer = __webpackgi_exports__.CP7,
  __webpackgi_exports__WebGLUtils = __webpackgi_exports__.fQK,
  __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__.Wd$,
  __webpackgi_exports__WindowiseDialogPlugin = __webpackgi_exports__.t1_,
  __webpackgi_exports__WireframeGeometry = __webpackgi_exports__.Uk6,
  __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__._sL,
  __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__.Pnf,
  __webpackgi_exports__ZeroFactor = __webpackgi_exports__.c8b,
  __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__._lf,
  __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__.ad5,
  __webpackgi_exports__Zip = __webpackgi_exports__.sZV,
  __webpackgi_exports__ZipDeflate = __webpackgi_exports__.TfA,
  __webpackgi_exports__ZipLoader = __webpackgi_exports__.sKX,
  __webpackgi_exports__ZipPassThrough = __webpackgi_exports__.UdM,
  __webpackgi_exports__Zlib = __webpackgi_exports__.P0y,
  __webpackgi_exports___SRGBAFormat = __webpackgi_exports__.L_r,
  __webpackgi_exports__addBasePlugins = __webpackgi_exports__.Bve,
  __webpackgi_exports__addDracoLoader = __webpackgi_exports__.UeO,
  __webpackgi_exports__addGLTFExporter = __webpackgi_exports__.$nx,
  __webpackgi_exports__addGLTFLoader = __webpackgi_exports__.Bk6,
  __webpackgi_exports__addRGBELoader = __webpackgi_exports__.y4l,
  __webpackgi_exports__addZipLoader = __webpackgi_exports__.pQ0,
  __webpackgi_exports__afterMain = __webpackgi_exports__.wXW,
  __webpackgi_exports__afterRead = __webpackgi_exports__.r5x,
  __webpackgi_exports__afterWrite = __webpackgi_exports__.MSI,
  __webpackgi_exports__angle = __webpackgi_exports__.EUu,
  __webpackgi_exports__animate = __webpackgi_exports__.jtH,
  __webpackgi_exports__animateAsync = __webpackgi_exports__.T0T,
  __webpackgi_exports__animateObject = __webpackgi_exports__.gAb,
  __webpackgi_exports__animatePromise = __webpackgi_exports__.iwT,
  __webpackgi_exports__animateSet = __webpackgi_exports__.je_,
  __webpackgi_exports__animateTarget = __webpackgi_exports__.wBP,
  __webpackgi_exports__anticipate = __webpackgi_exports__.LU2,
  __webpackgi_exports__applyOffset = __webpackgi_exports__.wQL,
  __webpackgi_exports__applyStyles = __webpackgi_exports__.Zs7,
  __webpackgi_exports__arrow = __webpackgi_exports__.x7s,
  __webpackgi_exports__attract = __webpackgi_exports__.Mnd,
  __webpackgi_exports__attractExpo = __webpackgi_exports__.A0_,
  __webpackgi_exports__auto = __webpackgi_exports__.d73,
  __webpackgi_exports__autoCenterObject3D = __webpackgi_exports__.HCD,
  __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__.RG9,
  __webpackgi_exports__backIn = __webpackgi_exports__.G2P,
  __webpackgi_exports__backInOut = __webpackgi_exports__.XLf,
  __webpackgi_exports__backOut = __webpackgi_exports__.CGN,
  __webpackgi_exports__basePlacements = __webpackgi_exports__.mvg,
  __webpackgi_exports__basicMaterialPropList = __webpackgi_exports__.Hiy,
  __webpackgi_exports__beforeMain = __webpackgi_exports__.XMc,
  __webpackgi_exports__beforeRead = __webpackgi_exports__.N7M,
  __webpackgi_exports__beforeWrite = __webpackgi_exports__.iv,
  __webpackgi_exports__blobToDataURL = __webpackgi_exports__.n55,
  __webpackgi_exports__bottom = __webpackgi_exports__.IaC,
  __webpackgi_exports__bounceIn = __webpackgi_exports__.h9t,
  __webpackgi_exports__bounceInOut = __webpackgi_exports__.yDW,
  __webpackgi_exports__bounceOut = __webpackgi_exports__.gJv,
  __webpackgi_exports__buildCSGMeshBSP = __webpackgi_exports__.l$g,
  __webpackgi_exports__buildCSGMeshBVH = __webpackgi_exports__.vQi,
  __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__.$MY,
  __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__.wJl,
  __webpackgi_exports__circIn = __webpackgi_exports__.Z7Y,
  __webpackgi_exports__circInOut = __webpackgi_exports__.X7D,
  __webpackgi_exports__circOut = __webpackgi_exports__.BnX,
  __webpackgi_exports__clamp = __webpackgi_exports__.uZ5,
  __webpackgi_exports__clippingParents = __webpackgi_exports__.zVI,
  __webpackgi_exports__combineDofShader = __webpackgi_exports__.DpF,
  __webpackgi_exports__compress = __webpackgi_exports__.nNb,
  __webpackgi_exports__compressSync = __webpackgi_exports__.cqZ,
  __webpackgi_exports__computeAverageGeometryNormal = __webpackgi_exports__.pKN,
  __webpackgi_exports__computeEigenVectors = __webpackgi_exports__.d_$,
  __webpackgi_exports__computeGeometryCenter = __webpackgi_exports__.DdI,
  __webpackgi_exports__computeGeometrySize = __webpackgi_exports__.rrX,
  __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__.KlC,
  __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__.KVn,
  __webpackgi_exports__computeStyles = __webpackgi_exports__.oau,
  __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__.aw9,
  __webpackgi_exports__copyObject3DUserData = __webpackgi_exports__.Aap,
  __webpackgi_exports__copyProps = __webpackgi_exports__.Dxg,
  __webpackgi_exports__copyTextureUserData = __webpackgi_exports__.MjT,
  __webpackgi_exports__createAnticipate = __webpackgi_exports__.F7Q,
  __webpackgi_exports__createAttractor = __webpackgi_exports__.IFq,
  __webpackgi_exports__createBackIn = __webpackgi_exports__.IJl,
  __webpackgi_exports__createCanvasElement = __webpackgi_exports__.O5A,
  __webpackgi_exports__createDiv = __webpackgi_exports__.wCn,
  __webpackgi_exports__createExpoIn = __webpackgi_exports__.gGT,
  __webpackgi_exports__createIFrameCSS3DObject = __webpackgi_exports__.pEc,
  __webpackgi_exports__createImage = __webpackgi_exports__.Bi6,
  __webpackgi_exports__createPopper = __webpackgi_exports__.fi_,
  __webpackgi_exports__createPopperBase = __webpackgi_exports__.TT,
  __webpackgi_exports__createPopperLite = __webpackgi_exports__.q2Z,
  __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__.NyK,
  __webpackgi_exports__createScriptFromURL = __webpackgi_exports__.bgu,
  __webpackgi_exports__createStyles = __webpackgi_exports__.kcS,
  __webpackgi_exports__csgOperations = __webpackgi_exports__.rRN,
  __webpackgi_exports__css = __webpackgi_exports__.ivY,
  __webpackgi_exports__cubicBezier = __webpackgi_exports__._s1,
  __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__._HO,
  __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__.tpL,
  __webpackgi_exports__decay = __webpackgi_exports__.DMK,
  __webpackgi_exports__decompress = __webpackgi_exports__.LjN,
  __webpackgi_exports__decompressSync = __webpackgi_exports__.iFs,
  __webpackgi_exports__deepAccessObject = __webpackgi_exports__.qTg,
  __webpackgi_exports__deflate = __webpackgi_exports__.Wtl,
  __webpackgi_exports__deflateSync = __webpackgi_exports__.DmK,
  __webpackgi_exports__degreesToRadians = __webpackgi_exports__.Htt,
  __webpackgi_exports__deserializeObject = __webpackgi_exports__.Hx7,
  __webpackgi_exports__deserializers = __webpackgi_exports__.imt,
  __webpackgi_exports__detectOverflow = __webpackgi_exports__.US6,
  __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__.vZs,
  __webpackgi_exports__distance = __webpackgi_exports__.TE$,
  __webpackgi_exports__downloadBlob = __webpackgi_exports__.lmu,
  __webpackgi_exports__downloadFile = __webpackgi_exports__.SvO,
  __webpackgi_exports__easeIn = __webpackgi_exports__.YQY,
  __webpackgi_exports__easeInOut = __webpackgi_exports__.mZN,
  __webpackgi_exports__easeOut = __webpackgi_exports__.VvG,
  __webpackgi_exports__embedUrlRefs = __webpackgi_exports__.omp,
  __webpackgi_exports__end = __webpackgi_exports__.utz,
  __webpackgi_exports__envMapBackground = __webpackgi_exports__.TFV,
  __webpackgi_exports__escapeRegExp = __webpackgi_exports__.hrz,
  __webpackgi_exports__eventListeners = __webpackgi_exports__.JKM,
  __webpackgi_exports__extractAnimationKey = __webpackgi_exports__.jZf,
  __webpackgi_exports__flattenUiConfig = __webpackgi_exports__.RjL,
  __webpackgi_exports__flip = __webpackgi_exports__.RRI,
  __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__.RUq,
  __webpackgi_exports__generateUiConfig = __webpackgi_exports__._t4,
  __webpackgi_exports__generateUiFolder = __webpackgi_exports__.YHh,
  __webpackgi_exports__getEncodingComponents = __webpackgi_exports__.R8g,
  __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__.Bbl,
  __webpackgi_exports__getKeyByValue = __webpackgi_exports__.V9r,
  __webpackgi_exports__getOrCall = __webpackgi_exports__.PZ2,
  __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__.w7A,
  __webpackgi_exports__getTexelDecoding = __webpackgi_exports__.N6S,
  __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__.Uxp,
  __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__.tAz,
  __webpackgi_exports__getTexelEncoding = __webpackgi_exports__.R$F,
  __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__.N33,
  __webpackgi_exports__getTextureDataType = __webpackgi_exports__.gw2,
  __webpackgi_exports__getTextureEncodingFromMap = __webpackgi_exports__.KlU,
  __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__.wo6,
  __webpackgi_exports__glsl = __webpackgi_exports__.H4P,
  __webpackgi_exports__gunzip = __webpackgi_exports__.swA,
  __webpackgi_exports__gunzipSync = __webpackgi_exports__._Z3,
  __webpackgi_exports__gzip = __webpackgi_exports__.ivc,
  __webpackgi_exports__gzipSync = __webpackgi_exports__.rZ1,
  __webpackgi_exports__hide = __webpackgi_exports__.CpZ,
  __webpackgi_exports__html = __webpackgi_exports__.dyc,
  __webpackgi_exports__htmlToCanvas = __webpackgi_exports__.MxZ,
  __webpackgi_exports__htmlToPng = __webpackgi_exports__.btp,
  __webpackgi_exports__htmlToSvg = __webpackgi_exports__.mXy,
  __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__.Ej0,
  __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__.ep4,
  __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__.DQP,
  __webpackgi_exports__iTextureIgnoredUserData = __webpackgi_exports__.VNr,
  __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__.V7q,
  __webpackgi_exports__imageToCanvas = __webpackgi_exports__.zEk,
  __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__.qfq,
  __webpackgi_exports__includesAll = __webpackgi_exports__.piB,
  __webpackgi_exports__inertia = __webpackgi_exports__.IIc,
  __webpackgi_exports__inflate = __webpackgi_exports__.rrF,
  __webpackgi_exports__inflateSync = __webpackgi_exports__.naq,
  __webpackgi_exports__interpolate = __webpackgi_exports__.sXR,
  __webpackgi_exports__isAnimatableType = __webpackgi_exports__.p5I,
  __webpackgi_exports__isPoint = __webpackgi_exports__.wps,
  __webpackgi_exports__isPoint3D = __webpackgi_exports__.wuo,
  __webpackgi_exports__isPropertyWritable = __webpackgi_exports__.GpE,
  __webpackgi_exports__keyframes = __webpackgi_exports__.F4b,
  __webpackgi_exports__left = __webpackgi_exports__.t$v,
  __webpackgi_exports__lerpAngle = __webpackgi_exports__.tdn,
  __webpackgi_exports__lerpAngle2 = __webpackgi_exports__.Y9t,
  __webpackgi_exports__linear = __webpackgi_exports__.GEo,
  __webpackgi_exports__main = __webpackgi_exports__.DH3,
  __webpackgi_exports__makeColorSvg = __webpackgi_exports__.uxM,
  __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__.zH3,
  __webpackgi_exports__makeFilter = __webpackgi_exports__.MLs,
  __webpackgi_exports__makeSamplerUi = __webpackgi_exports__.xXG,
  __webpackgi_exports__makeSetterFor = __webpackgi_exports__.YM4,
  __webpackgi_exports__makeSetterForAnimObject = __webpackgi_exports__.B3r,
  __webpackgi_exports__makeTextSvg = __webpackgi_exports__.iAx,
  __webpackgi_exports__matDefine = __webpackgi_exports__.lDn,
  __webpackgi_exports__mirrorEasing = __webpackgi_exports__.oaQ,
  __webpackgi_exports__mix = __webpackgi_exports__.CD7,
  __webpackgi_exports__mixColor = __webpackgi_exports__.Rc0,
  __webpackgi_exports__mixComplex = __webpackgi_exports__.iPG,
  __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__.TIc,
  __webpackgi_exports__modifierPhases = __webpackgi_exports__.xsC,
  __webpackgi_exports__now = __webpackgi_exports__.zOc,
  __webpackgi_exports__offset = __webpackgi_exports__.r46,
  __webpackgi_exports__onChange = __webpackgi_exports__.z2C,
  __webpackgi_exports__parseFileExtension = __webpackgi_exports__._X$,
  __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__._yn,
  __webpackgi_exports__pathJoin = __webpackgi_exports__.Dyg,
  __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__.cUc,
  __webpackgi_exports__pipe = __webpackgi_exports__.zGw,
  __webpackgi_exports__placements = __webpackgi_exports__.Ctq,
  __webpackgi_exports__pointFromVector = __webpackgi_exports__.$ch,
  __webpackgi_exports__popper = __webpackgi_exports__.k5b,
  __webpackgi_exports__popperGenerator = __webpackgi_exports__.kZl,
  __webpackgi_exports__popperOffsets = __webpackgi_exports__.OCg,
  __webpackgi_exports__preventOverflow = __webpackgi_exports__.YjH,
  __webpackgi_exports__processViewer = __webpackgi_exports__.Ui8,
  __webpackgi_exports__progress = __webpackgi_exports__.YD2,
  __webpackgi_exports__radiansToDegrees = __webpackgi_exports__.vi9,
  __webpackgi_exports__read = __webpackgi_exports__.ij3,
  __webpackgi_exports__reference = __webpackgi_exports__.YPW,
  __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__.Bg1,
  __webpackgi_exports__replaceAll = __webpackgi_exports__.kon,
  __webpackgi_exports__reverseEasing = __webpackgi_exports__.M3g,
  __webpackgi_exports__right = __webpackgi_exports__.F2z,
  __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__.pJF,
  __webpackgi_exports__sRGBEncoding = __webpackgi_exports__.knz,
  __webpackgi_exports__safeSetProperty = __webpackgi_exports__.Ejo,
  __webpackgi_exports__serializable = __webpackgi_exports__.BgY,
  __webpackgi_exports__serialize = __webpackgi_exports__.qCG,
  __webpackgi_exports__serializeObject = __webpackgi_exports__.HD9,
  __webpackgi_exports__serializers = __webpackgi_exports__.fEB,
  __webpackgi_exports__setMeshGeometry = __webpackgi_exports__.Udc,
  __webpackgi_exports__setMeshMaterial = __webpackgi_exports__.ZQg,
  __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__.ofC,
  __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__.yRy,
  __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__._NL,
  __webpackgi_exports__setupIModel = __webpackgi_exports__.LCA,
  __webpackgi_exports__setupObject3dModel = __webpackgi_exports__.j1w,
  __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__.i8J,
  __webpackgi_exports__shaderReplaceString = __webpackgi_exports__.p7C,
  __webpackgi_exports__slerp = __webpackgi_exports__.ZAS,
  __webpackgi_exports__smooth = __webpackgi_exports__.ipH,
  __webpackgi_exports__smoothFrame = __webpackgi_exports__.$TF,
  __webpackgi_exports__snap = __webpackgi_exports__.uZI,
  __webpackgi_exports__snapObject = __webpackgi_exports__.VWG,
  __webpackgi_exports__sphericalFromObject = __webpackgi_exports__.pQ7,
  __webpackgi_exports__spring = __webpackgi_exports__.STw,
  __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__.jc8,
  __webpackgi_exports__start = __webpackgi_exports__.BL_,
  __webpackgi_exports__steps = __webpackgi_exports__.S6,
  __webpackgi_exports__strFromU8 = __webpackgi_exports__.T8U,
  __webpackgi_exports__strToU8 = __webpackgi_exports__.TD6,
  __webpackgi_exports__svgToCanvas = __webpackgi_exports__.akS,
  __webpackgi_exports__svgToPng = __webpackgi_exports__.QKE,
  __webpackgi_exports__svgUrl = __webpackgi_exports__.dKx,
  __webpackgi_exports__syncAnimSetUi = __webpackgi_exports__.OvX,
  __webpackgi_exports__timeout = __webpackgi_exports__.VsW,
  __webpackgi_exports__toDecimal = __webpackgi_exports__.YMc,
  __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__.aPg,
  __webpackgi_exports__toTitleCase = __webpackgi_exports__.LFn,
  __webpackgi_exports__top = __webpackgi_exports__.wey,
  __webpackgi_exports__uiButton = __webpackgi_exports__.MaE,
  __webpackgi_exports__uiColor = __webpackgi_exports__.s4x,
  __webpackgi_exports__uiConfig = __webpackgi_exports__.FJA,
  __webpackgi_exports__uiDropdown = __webpackgi_exports__.vIA,
  __webpackgi_exports__uiFolder = __webpackgi_exports__.Spv,
  __webpackgi_exports__uiImage = __webpackgi_exports__.w8l,
  __webpackgi_exports__uiInput = __webpackgi_exports__.riG,
  __webpackgi_exports__uiMonitor = __webpackgi_exports__.Kbh,
  __webpackgi_exports__uiSlider = __webpackgi_exports__.t8K,
  __webpackgi_exports__uiToggle = __webpackgi_exports__.Q7n,
  __webpackgi_exports__uiVector = __webpackgi_exports__.KGF,
  __webpackgi_exports__uniform = __webpackgi_exports__.e5,
  __webpackgi_exports__unzip = __webpackgi_exports__.Rik,
  __webpackgi_exports__unzipSync = __webpackgi_exports__.GZo,
  __webpackgi_exports__unzlib = __webpackgi_exports__.Bds,
  __webpackgi_exports__unzlibSync = __webpackgi_exports__.HTu,
  __webpackgi_exports__uploadFile = __webpackgi_exports__.cTq,
  __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__.X_Y,
  __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__.dA8,
  __webpackgi_exports__variationPlacements = __webpackgi_exports__.bwS,
  __webpackgi_exports__velocityPerFrame = __webpackgi_exports__.Lks,
  __webpackgi_exports__velocityPerSecond = __webpackgi_exports__.Rvq,
  __webpackgi_exports__verifyPermission = __webpackgi_exports__.P4F,
  __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__.Pd0,
  __webpackgi_exports__viewport = __webpackgi_exports__.Pjo,
  __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__.Tum,
  __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__.dRH,
  __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__.RX0,
  __webpackgi_exports__wrap = __webpackgi_exports__.reQ,
  __webpackgi_exports__write = __webpackgi_exports__.cWm,
  __webpackgi_exports__writeFile = __webpackgi_exports__.NC9,
  __webpackgi_exports__zip = __webpackgi_exports__.$Re,
  __webpackgi_exports__zipSync = __webpackgi_exports__.Xo9,
  __webpackgi_exports__zlib = __webpackgi_exports__.LNO,
  __webpackgi_exports__zlibSync = __webpackgi_exports__.iZP;
exports.zlibSync = __webpackgi_exports__zlibSync;
exports.zlib = __webpackgi_exports__zlib;
exports.zipSync = __webpackgi_exports__zipSync;
exports.zip = __webpackgi_exports__zip;
exports.writeFile = __webpackgi_exports__writeFile;
exports.write = __webpackgi_exports__write;
exports.wrap = __webpackgi_exports__wrap;
exports.webgiObject3DExtrasExtension = __webpackgi_exports__webgiObject3DExtrasExtension;
exports.webgiMaterialExtrasExtension = __webpackgi_exports__webgiMaterialExtrasExtension;
exports.webgiLightExtrasExtension = __webpackgi_exports__webgiLightExtrasExtension;
exports.viewport = __webpackgi_exports__viewport;
exports.viewerGLTFExtension = __webpackgi_exports__viewerGLTFExtension;
exports.verifyPermission = __webpackgi_exports__verifyPermission;
exports.velocityPerSecond = __webpackgi_exports__velocityPerSecond;
exports.velocityPerFrame = __webpackgi_exports__velocityPerFrame;
exports.variationPlacements = __webpackgi_exports__variationPlacements;
exports.vRGBMToLinear = __webpackgi_exports__vRGBMToLinear;
exports.vLinearToRGBM = __webpackgi_exports__vLinearToRGBM;
exports.uploadFile = __webpackgi_exports__uploadFile;
exports.unzlibSync = __webpackgi_exports__unzlibSync;
exports.unzlib = __webpackgi_exports__unzlib;
exports.unzipSync = __webpackgi_exports__unzipSync;
exports.unzip = __webpackgi_exports__unzip;
exports.uniform = __webpackgi_exports__uniform;
exports.uiVector = __webpackgi_exports__uiVector;
exports.uiToggle = __webpackgi_exports__uiToggle;
exports.uiSlider = __webpackgi_exports__uiSlider;
exports.uiMonitor = __webpackgi_exports__uiMonitor;
exports.uiInput = __webpackgi_exports__uiInput;
exports.uiImage = __webpackgi_exports__uiImage;
exports.uiFolder = __webpackgi_exports__uiFolder;
exports.uiDropdown = __webpackgi_exports__uiDropdown;
exports.uiConfig = __webpackgi_exports__uiConfig;
exports.uiColor = __webpackgi_exports__uiColor;
exports.uiButton = __webpackgi_exports__uiButton;
exports.top = __webpackgi_exports__top;
exports.toTitleCase = __webpackgi_exports__toTitleCase;
exports.toIndexedGeometry = __webpackgi_exports__toIndexedGeometry;
exports.toDecimal = __webpackgi_exports__toDecimal;
exports.timeout = __webpackgi_exports__timeout;
exports.syncAnimSetUi = __webpackgi_exports__syncAnimSetUi;
exports.svgUrl = __webpackgi_exports__svgUrl;
exports.svgToPng = __webpackgi_exports__svgToPng;
exports.svgToCanvas = __webpackgi_exports__svgToCanvas;
exports.strToU8 = __webpackgi_exports__strToU8;
exports.strFromU8 = __webpackgi_exports__strFromU8;
exports.steps = __webpackgi_exports__steps;
exports.start = __webpackgi_exports__start;
exports.standardMaterialPropList = __webpackgi_exports__standardMaterialPropList;
exports.spring = __webpackgi_exports__spring;
exports.sphericalFromObject = __webpackgi_exports__sphericalFromObject;
exports.snapObject = __webpackgi_exports__snapObject;
exports.snap = __webpackgi_exports__snap;
exports.smoothFrame = __webpackgi_exports__smoothFrame;
exports.smooth = __webpackgi_exports__smooth;
exports.slerp = __webpackgi_exports__slerp;
exports.shaderReplaceString = __webpackgi_exports__shaderReplaceString;
exports.setupSandboxWebGiEditor = __webpackgi_exports__setupSandboxWebGiEditor;
exports.setupObject3dModel = __webpackgi_exports__setupObject3dModel;
exports.setupIModel = __webpackgi_exports__setupIModel;
exports.setupCoreWebGiViewer = __webpackgi_exports__setupCoreWebGiViewer;
exports.setUrlQueryParam = __webpackgi_exports__setUrlQueryParam;
exports.setThreeRendererMode = __webpackgi_exports__setThreeRendererMode;
exports.setMeshMaterial = __webpackgi_exports__setMeshMaterial;
exports.setMeshGeometry = __webpackgi_exports__setMeshGeometry;
exports.serializers = __webpackgi_exports__serializers;
exports.serializeObject = __webpackgi_exports__serializeObject;
exports.serialize = __webpackgi_exports__serialize;
exports.serializable = __webpackgi_exports__serializable;
exports.safeSetProperty = __webpackgi_exports__safeSetProperty;
exports.sRGBEncoding = __webpackgi_exports__sRGBEncoding;
exports.rotateDuplicatedMesh = __webpackgi_exports__rotateDuplicatedMesh;
exports.right = __webpackgi_exports__right;
exports.reverseEasing = __webpackgi_exports__reverseEasing;
exports.replaceAll = __webpackgi_exports__replaceAll;
exports.removeDuplicateGeometries = __webpackgi_exports__removeDuplicateGeometries;
exports.reference = __webpackgi_exports__reference;
exports.read = __webpackgi_exports__read;
exports.radiansToDegrees = __webpackgi_exports__radiansToDegrees;
exports.progress = __webpackgi_exports__progress;
exports.processViewer = __webpackgi_exports__processViewer;
exports.preventOverflow = __webpackgi_exports__preventOverflow;
exports.popperOffsets = __webpackgi_exports__popperOffsets;
exports.popperGenerator = __webpackgi_exports__popperGenerator;
exports.popper = __webpackgi_exports__popper;
exports.pointFromVector = __webpackgi_exports__pointFromVector;
exports.placements = __webpackgi_exports__placements;
exports.pipe = __webpackgi_exports__pipe;
exports.physicalMaterialPropList = __webpackgi_exports__physicalMaterialPropList;
exports.pathJoin = __webpackgi_exports__pathJoin;
exports.patchShaderEncodingSupport = __webpackgi_exports__patchShaderEncodingSupport;
exports.parseFileExtension = __webpackgi_exports__parseFileExtension;
exports.onChange = __webpackgi_exports__onChange;
exports.offset = __webpackgi_exports__offset;
exports.now = __webpackgi_exports__now;
exports.modifierPhases = __webpackgi_exports__modifierPhases;
exports.mobileAndTabletCheck = __webpackgi_exports__mobileAndTabletCheck;
exports.mixComplex = __webpackgi_exports__mixComplex;
exports.mixColor = __webpackgi_exports__mixColor;
exports.mix = __webpackgi_exports__mix;
exports.mirrorEasing = __webpackgi_exports__mirrorEasing;
exports.matDefine = __webpackgi_exports__matDefine;
exports.makeTextSvg = __webpackgi_exports__makeTextSvg;
exports.makeSetterForAnimObject = __webpackgi_exports__makeSetterForAnimObject;
exports.makeSetterFor = __webpackgi_exports__makeSetterFor;
exports.makeSamplerUi = __webpackgi_exports__makeSamplerUi;
exports.makeFilter = __webpackgi_exports__makeFilter;
exports.makeColorSvgCircle = __webpackgi_exports__makeColorSvgCircle;
exports.makeColorSvg = __webpackgi_exports__makeColorSvg;
exports.main = __webpackgi_exports__main;
exports.linear = __webpackgi_exports__linear;
exports.lerpAngle2 = __webpackgi_exports__lerpAngle2;
exports.lerpAngle = __webpackgi_exports__lerpAngle;
exports.left = __webpackgi_exports__left;
exports.keyframes = __webpackgi_exports__keyframes;
exports.isPropertyWritable = __webpackgi_exports__isPropertyWritable;
exports.isPoint3D = __webpackgi_exports__isPoint3D;
exports.isPoint = __webpackgi_exports__isPoint;
exports.isAnimatableType = __webpackgi_exports__isAnimatableType;
exports.interpolate = __webpackgi_exports__interpolate;
exports.inflateSync = __webpackgi_exports__inflateSync;
exports.inflate = __webpackgi_exports__inflate;
exports.inertia = __webpackgi_exports__inertia;
exports.includesAll = __webpackgi_exports__includesAll;
exports.imageUrlToImageData = __webpackgi_exports__imageUrlToImageData;
exports.imageToCanvas = __webpackgi_exports__imageToCanvas;
exports.imageBitmapToBase64 = __webpackgi_exports__imageBitmapToBase64;
exports.iTextureIgnoredUserData = __webpackgi_exports__iTextureIgnoredUserData;
exports.iModelIgnoredUserData = __webpackgi_exports__iModelIgnoredUserData;
exports.iMaterialIgnoredUserData = __webpackgi_exports__iMaterialIgnoredUserData;
exports.iGeometryIgnoredUserData = __webpackgi_exports__iGeometryIgnoredUserData;
exports.htmlToSvg = __webpackgi_exports__htmlToSvg;
exports.htmlToPng = __webpackgi_exports__htmlToPng;
exports.htmlToCanvas = __webpackgi_exports__htmlToCanvas;
exports.html = __webpackgi_exports__html;
exports.hide = __webpackgi_exports__hide;
exports.gzipSync = __webpackgi_exports__gzipSync;
exports.gzip = __webpackgi_exports__gzip;
exports.gunzipSync = __webpackgi_exports__gunzipSync;
exports.gunzip = __webpackgi_exports__gunzip;
exports.glsl = __webpackgi_exports__glsl;
exports.getUrlQueryParam = __webpackgi_exports__getUrlQueryParam;
exports.getTextureEncodingFromMap = __webpackgi_exports__getTextureEncodingFromMap;
exports.getTextureDataType = __webpackgi_exports__getTextureDataType;
exports.getTexelEncodingFunction = __webpackgi_exports__getTexelEncodingFunction;
exports.getTexelEncoding = __webpackgi_exports__getTexelEncoding;
exports.getTexelDecodingFunction = __webpackgi_exports__getTexelDecodingFunction;
exports.getTexelDecoding2 = __webpackgi_exports__getTexelDecoding2;
exports.getTexelDecoding = __webpackgi_exports__getTexelDecoding;
exports.getPropertyDescriptor = __webpackgi_exports__getPropertyDescriptor;
exports.getOrCall = __webpackgi_exports__getOrCall;
exports.getKeyByValue = __webpackgi_exports__getKeyByValue;
exports.getFilenameFromPath = __webpackgi_exports__getFilenameFromPath;
exports.getEncodingComponents = __webpackgi_exports__getEncodingComponents;
exports.generateUiFolder = __webpackgi_exports__generateUiFolder;
exports.generateUiConfig = __webpackgi_exports__generateUiConfig;
exports.fontFormatExtensionMap = __webpackgi_exports__fontFormatExtensionMap;
exports.flip = __webpackgi_exports__flip;
exports.flattenUiConfig = __webpackgi_exports__flattenUiConfig;
exports.extractAnimationKey = __webpackgi_exports__extractAnimationKey;
exports.eventListeners = __webpackgi_exports__eventListeners;
exports.escapeRegExp = __webpackgi_exports__escapeRegExp;
exports.envMapBackground = __webpackgi_exports__envMapBackground;
exports.end = __webpackgi_exports__end;
exports.embedUrlRefs = __webpackgi_exports__embedUrlRefs;
exports.easeOut = __webpackgi_exports__easeOut;
exports.easeInOut = __webpackgi_exports__easeInOut;
exports.easeIn = __webpackgi_exports__easeIn;
exports.downloadFile = __webpackgi_exports__downloadFile;
exports.downloadBlob = __webpackgi_exports__downloadBlob;
exports.distance = __webpackgi_exports__distance;
exports.diamondMaterialPropList = __webpackgi_exports__diamondMaterialPropList;
exports.detectOverflow = __webpackgi_exports__detectOverflow;
exports.deserializers = __webpackgi_exports__deserializers;
exports.deserializeObject = __webpackgi_exports__deserializeObject;
exports.degreesToRadians = __webpackgi_exports__degreesToRadians;
exports.deflateSync = __webpackgi_exports__deflateSync;
exports.deflate = __webpackgi_exports__deflate;
exports.deepAccessObject = __webpackgi_exports__deepAccessObject;
exports.decompressSync = __webpackgi_exports__decompressSync;
exports.decompress = __webpackgi_exports__decompress;
exports.decay = __webpackgi_exports__decay;
exports.dataTextureFromVec4 = __webpackgi_exports__dataTextureFromVec4;
exports.dataTextureFromColor = __webpackgi_exports__dataTextureFromColor;
exports.cubicBezier = __webpackgi_exports__cubicBezier;
exports.css = __webpackgi_exports__css;
exports.csgOperations = __webpackgi_exports__csgOperations;
exports.createStyles = __webpackgi_exports__createStyles;
exports.createScriptFromURL = __webpackgi_exports__createScriptFromURL;
exports.createRenderTargetKey = __webpackgi_exports__createRenderTargetKey;
exports.createPopperLite = __webpackgi_exports__createPopperLite;
exports.createPopperBase = __webpackgi_exports__createPopperBase;
exports.createPopper = __webpackgi_exports__createPopper;
exports.createImage = __webpackgi_exports__createImage;
exports.createIFrameCSS3DObject = __webpackgi_exports__createIFrameCSS3DObject;
exports.createExpoIn = __webpackgi_exports__createExpoIn;
exports.createDiv = __webpackgi_exports__createDiv;
exports.createCanvasElement = __webpackgi_exports__createCanvasElement;
exports.createBackIn = __webpackgi_exports__createBackIn;
exports.createAttractor = __webpackgi_exports__createAttractor;
exports.createAnticipate = __webpackgi_exports__createAnticipate;
exports.copyTextureUserData = __webpackgi_exports__copyTextureUserData;
exports.copyProps = __webpackgi_exports__copyProps;
exports.copyObject3DUserData = __webpackgi_exports__copyObject3DUserData;
exports.copyMaterialUserData = __webpackgi_exports__copyMaterialUserData;
exports.computeStyles = __webpackgi_exports__computeStyles;
exports.computeScreenSpaceBoundingBox = __webpackgi_exports__computeScreenSpaceBoundingBox;
exports.computeOffsetMatrix = __webpackgi_exports__computeOffsetMatrix;
exports.computeGeometrySize = __webpackgi_exports__computeGeometrySize;
exports.computeGeometryCenter = __webpackgi_exports__computeGeometryCenter;
exports.computeEigenVectors = __webpackgi_exports__computeEigenVectors;
exports.computeAverageGeometryNormal = __webpackgi_exports__computeAverageGeometryNormal;
exports.compressSync = __webpackgi_exports__compressSync;
exports.compress = __webpackgi_exports__compress;
exports.combineDofShader = __webpackgi_exports__combineDofShader;
exports.clippingParents = __webpackgi_exports__clippingParents;
exports.clamp = __webpackgi_exports__clamp;
exports.circOut = __webpackgi_exports__circOut;
exports.circInOut = __webpackgi_exports__circInOut;
exports.circIn = __webpackgi_exports__circIn;
exports.cRGBMToLinear = __webpackgi_exports__cRGBMToLinear;
exports.cLinearToRGBM = __webpackgi_exports__cLinearToRGBM;
exports.buildCSGMeshBVH = __webpackgi_exports__buildCSGMeshBVH;
exports.buildCSGMeshBSP = __webpackgi_exports__buildCSGMeshBSP;
exports.bounceOut = __webpackgi_exports__bounceOut;
exports.bounceInOut = __webpackgi_exports__bounceInOut;
exports.bounceIn = __webpackgi_exports__bounceIn;
exports.bottom = __webpackgi_exports__bottom;
exports.blobToDataURL = __webpackgi_exports__blobToDataURL;
exports.beforeWrite = __webpackgi_exports__beforeWrite;
exports.beforeRead = __webpackgi_exports__beforeRead;
exports.beforeMain = __webpackgi_exports__beforeMain;
exports.basicMaterialPropList = __webpackgi_exports__basicMaterialPropList;
exports.basePlacements = __webpackgi_exports__basePlacements;
exports.backOut = __webpackgi_exports__backOut;
exports.backInOut = __webpackgi_exports__backInOut;
exports.backIn = __webpackgi_exports__backIn;
exports.autoScaleObject3D = __webpackgi_exports__autoScaleObject3D;
exports.autoCenterObject3D = __webpackgi_exports__autoCenterObject3D;
exports.auto = __webpackgi_exports__auto;
exports.attractExpo = __webpackgi_exports__attractExpo;
exports.attract = __webpackgi_exports__attract;
exports.arrow = __webpackgi_exports__arrow;
exports.applyStyles = __webpackgi_exports__applyStyles;
exports.applyOffset = __webpackgi_exports__applyOffset;
exports.anticipate = __webpackgi_exports__anticipate;
exports.animateTarget = __webpackgi_exports__animateTarget;
exports.animateSet = __webpackgi_exports__animateSet;
exports.animatePromise = __webpackgi_exports__animatePromise;
exports.animateObject = __webpackgi_exports__animateObject;
exports.animateAsync = __webpackgi_exports__animateAsync;
exports.animate = __webpackgi_exports__animate;
exports.angle = __webpackgi_exports__angle;
exports.afterWrite = __webpackgi_exports__afterWrite;
exports.afterRead = __webpackgi_exports__afterRead;
exports.afterMain = __webpackgi_exports__afterMain;
exports.addZipLoader = __webpackgi_exports__addZipLoader;
exports.addRGBELoader = __webpackgi_exports__addRGBELoader;
exports.addGLTFLoader = __webpackgi_exports__addGLTFLoader;
exports.addGLTFExporter = __webpackgi_exports__addGLTFExporter;
exports.addDracoLoader = __webpackgi_exports__addDracoLoader;
exports.addBasePlugins = __webpackgi_exports__addBasePlugins;
exports._SRGBAFormat = __webpackgi_exports___SRGBAFormat;
exports.Zlib = __webpackgi_exports__Zlib;
exports.ZipPassThrough = __webpackgi_exports__ZipPassThrough;
exports.ZipLoader = __webpackgi_exports__ZipLoader;
exports.ZipDeflate = __webpackgi_exports__ZipDeflate;
exports.Zip = __webpackgi_exports__Zip;
exports.ZeroStencilOp = __webpackgi_exports__ZeroStencilOp;
exports.ZeroSlopeEnding = __webpackgi_exports__ZeroSlopeEnding;
exports.ZeroFactor = __webpackgi_exports__ZeroFactor;
exports.ZeroCurvatureEnding = __webpackgi_exports__ZeroCurvatureEnding;
exports.WrapAroundEnding = __webpackgi_exports__WrapAroundEnding;
exports.WireframeGeometry = __webpackgi_exports__WireframeGeometry;
exports.WindowiseDialogPlugin = __webpackgi_exports__WindowiseDialogPlugin;
exports.WebGiViewerElement = __webpackgi_exports__WebGiViewerElement;
exports.WebGLUtils = __webpackgi_exports__WebGLUtils;
exports.WebGLRenderer = __webpackgi_exports__WebGLRenderer;
exports.WebGLRenderTarget = __webpackgi_exports__WebGLRenderTarget;
exports.WebGLMultisampleRenderTarget = __webpackgi_exports__WebGLMultisampleRenderTarget;
exports.WebGLMultipleRenderTargets = __webpackgi_exports__WebGLMultipleRenderTargets;
exports.WebGLCubeRenderTarget = __webpackgi_exports__WebGLCubeRenderTarget;
exports.WebGLArrayRenderTarget = __webpackgi_exports__WebGLArrayRenderTarget;
exports.WebGL3DRenderTarget = __webpackgi_exports__WebGL3DRenderTarget;
exports.WebGL1Renderer = __webpackgi_exports__WebGL1Renderer;
exports.VignettePlugin = __webpackgi_exports__VignettePlugin;
exports.ViewerState = __webpackgi_exports__ViewerState;
exports.ViewerApp = __webpackgi_exports__ViewerApp;
exports.VideoTexture = __webpackgi_exports__VideoTexture;
exports.VelocityBufferPlugin = __webpackgi_exports__VelocityBufferPlugin;
exports.VectorKeyframeTrack = __webpackgi_exports__VectorKeyframeTrack;
exports.Vector4 = __webpackgi_exports__Vector4;
exports.Vector3 = __webpackgi_exports__Vector3;
exports.Vector2 = __webpackgi_exports__Vector2;
exports.VSMShadowMap = __webpackgi_exports__VSMShadowMap;
exports.Unzlib = __webpackgi_exports__Unzlib;
exports.UnzipPassThrough = __webpackgi_exports__UnzipPassThrough;
exports.UnzipInflate = __webpackgi_exports__UnzipInflate;
exports.Unzip = __webpackgi_exports__Unzip;
exports.UnsignedShortType = __webpackgi_exports__UnsignedShortType;
exports.UnsignedShort5551Type = __webpackgi_exports__UnsignedShort5551Type;
exports.UnsignedShort4444Type = __webpackgi_exports__UnsignedShort4444Type;
exports.UnsignedIntType = __webpackgi_exports__UnsignedIntType;
exports.UnsignedInt248Type = __webpackgi_exports__UnsignedInt248Type;
exports.UnsignedByteType = __webpackgi_exports__UnsignedByteType;
exports.UniformsUtils = __webpackgi_exports__UniformsUtils;
exports.UniformsLib = __webpackgi_exports__UniformsLib;
exports.UniformsGroup = __webpackgi_exports__UniformsGroup;
exports.Uniform = __webpackgi_exports__Uniform;
exports.Uncharted2Tonemapping = __webpackgi_exports__Uncharted2Tonemapping;
exports.Uint8ClampedBufferAttribute = __webpackgi_exports__Uint8ClampedBufferAttribute;
exports.Uint8BufferAttribute = __webpackgi_exports__Uint8BufferAttribute;
exports.Uint32BufferAttribute = __webpackgi_exports__Uint32BufferAttribute;
exports.Uint16BufferAttribute = __webpackgi_exports__Uint16BufferAttribute;
exports.UVMapping = __webpackgi_exports__UVMapping;
exports.TweakpaneWrapper = __webpackgi_exports__TweakpaneWrapper;
exports.TweakpaneUiPlugin = __webpackgi_exports__TweakpaneUiPlugin;
exports.TubeShapeGeometry = __webpackgi_exports__TubeShapeGeometry;
exports.TubeGeometry = __webpackgi_exports__TubeGeometry;
exports.TubeBufferGeometry = __webpackgi_exports__TubeBufferGeometry;
exports.TrianglesDrawMode = __webpackgi_exports__TrianglesDrawMode;
exports.TriangleStripDrawMode = __webpackgi_exports__TriangleStripDrawMode;
exports.TriangleFanDrawMode = __webpackgi_exports__TriangleFanDrawMode;
exports.Triangle = __webpackgi_exports__Triangle;
exports.TransformControls2 = __webpackgi_exports__TransformControls2;
exports.TorusKnotGeometry = __webpackgi_exports__TorusKnotGeometry;
exports.TorusKnotBufferGeometry = __webpackgi_exports__TorusKnotBufferGeometry;
exports.TorusGeometry = __webpackgi_exports__TorusGeometry;
exports.TorusBufferGeometry = __webpackgi_exports__TorusBufferGeometry;
exports.TonemapPlugin = __webpackgi_exports__TonemapPlugin;
exports.ThreeMaterialLoader = __webpackgi_exports__ThreeMaterialLoader;
exports.ThinFilmLayerPlugin = __webpackgi_exports__ThinFilmLayerPlugin;
exports.TextureLoader = __webpackgi_exports__TextureLoader;
exports.Texture = __webpackgi_exports__Texture;
exports.TextSVGOptions = __webpackgi_exports__TextSVGOptions;
exports.TetrahedronGeometry = __webpackgi_exports__TetrahedronGeometry;
exports.TetrahedronBufferGeometry = __webpackgi_exports__TetrahedronBufferGeometry;
exports.TemporalAAPlugin = __webpackgi_exports__TemporalAAPlugin;
exports.TangentSpaceNormalMap = __webpackgi_exports__TangentSpaceNormalMap;
exports.TOUCH = __webpackgi_exports__TOUCH;
exports.SwitchNodePlugin = __webpackgi_exports__SwitchNodePlugin;
exports.SubtractiveBlending = __webpackgi_exports__SubtractiveBlending;
exports.SubtractEquation = __webpackgi_exports__SubtractEquation;
exports.StringKeyframeTrack = __webpackgi_exports__StringKeyframeTrack;
exports.StreamReadUsage = __webpackgi_exports__StreamReadUsage;
exports.StreamDrawUsage = __webpackgi_exports__StreamDrawUsage;
exports.StreamCopyUsage = __webpackgi_exports__StreamCopyUsage;
exports.StereoCamera = __webpackgi_exports__StereoCamera;
exports.StaticReadUsage = __webpackgi_exports__StaticReadUsage;
exports.StaticDrawUsage = __webpackgi_exports__StaticDrawUsage;
exports.StaticCopyUsage = __webpackgi_exports__StaticCopyUsage;
exports.SrcColorFactor = __webpackgi_exports__SrcColorFactor;
exports.SrcAlphaSaturateFactor = __webpackgi_exports__SrcAlphaSaturateFactor;
exports.SrcAlphaFactor = __webpackgi_exports__SrcAlphaFactor;
exports.SpriteMaterial = __webpackgi_exports__SpriteMaterial;
exports.Sprite = __webpackgi_exports__Sprite;
exports.SpotLightHelper = __webpackgi_exports__SpotLightHelper;
exports.SpotLight2 = __webpackgi_exports__SpotLight2;
exports.SpotLight = __webpackgi_exports__SpotLight;
exports.SplineCurve = __webpackgi_exports__SplineCurve;
exports.SphericalHarmonics3 = __webpackgi_exports__SphericalHarmonics3;
exports.Spherical = __webpackgi_exports__Spherical;
exports.SphereSelectionWidget = __webpackgi_exports__SphereSelectionWidget;
exports.SphereGeometry = __webpackgi_exports__SphereGeometry;
exports.SphereBufferGeometry = __webpackgi_exports__SphereBufferGeometry;
exports.Sphere = __webpackgi_exports__Sphere;
exports.Source = __webpackgi_exports__Source;
exports.SkinnedMesh = __webpackgi_exports__SkinnedMesh;
exports.SkeletonHelper = __webpackgi_exports__SkeletonHelper;
exports.Skeleton = __webpackgi_exports__Skeleton;
exports.SimpleViewerUi = __webpackgi_exports__SimpleViewerUi;
exports.SimpleTextPlugin = __webpackgi_exports__SimpleTextPlugin;
exports.SimpleTextExporter = __webpackgi_exports__SimpleTextExporter;
exports.SimpleJSONLoader = __webpackgi_exports__SimpleJSONLoader;
exports.SimpleJSONExporter = __webpackgi_exports__SimpleJSONExporter;
exports.SimpleEventDispatcher = __webpackgi_exports__SimpleEventDispatcher;
exports.SimpleDataSource = __webpackgi_exports__SimpleDataSource;
exports.SimpleBackgroundEnvUiPlugin = __webpackgi_exports__SimpleBackgroundEnvUiPlugin;
exports.SimpleAssetList = __webpackgi_exports__SimpleAssetList;
exports.ShortType = __webpackgi_exports__ShortType;
exports.ShapeUtils = __webpackgi_exports__ShapeUtils;
exports.ShapeTubeExtrudePlugin = __webpackgi_exports__ShapeTubeExtrudePlugin;
exports.ShapePath = __webpackgi_exports__ShapePath;
exports.ShapeGeometry = __webpackgi_exports__ShapeGeometry;
exports.ShapeBufferGeometry = __webpackgi_exports__ShapeBufferGeometry;
exports.Shape = __webpackgi_exports__Shape;
exports.ShadowMaterial = __webpackgi_exports__ShadowMaterial;
exports.ShadowMapBaker = __webpackgi_exports__ShadowMapBaker;
exports.ShaderPass2 = __webpackgi_exports__ShaderPass2;
exports.ShaderMaterialEncodingSupport = __webpackgi_exports__ShaderMaterialEncodingSupport;
exports.ShaderMaterial2 = __webpackgi_exports__ShaderMaterial2;
exports.ShaderMaterial = __webpackgi_exports__ShaderMaterial;
exports.ShaderLib = __webpackgi_exports__ShaderLib;
exports.ShaderChunk = __webpackgi_exports__ShaderChunk;
exports.SelectionWidget = __webpackgi_exports__SelectionWidget;
exports.SceneLoopPlugin = __webpackgi_exports__SceneLoopPlugin;
exports.SceneCamerasUiPlugin = __webpackgi_exports__SceneCamerasUiPlugin;
exports.Scene = __webpackgi_exports__Scene;
exports.STLLoadPlugin = __webpackgi_exports__STLLoadPlugin;
exports.SSRPlugin = __webpackgi_exports__SSRPlugin;
exports.SSGIPlugin = __webpackgi_exports__SSGIPlugin;
exports.SSContactShadows = __webpackgi_exports__SSContactShadows;
exports.SSAOPlugin = __webpackgi_exports__SSAOPlugin;
exports.SRGBColorSpace = __webpackgi_exports__SRGBColorSpace;
exports.SETTLING_TIME = __webpackgi_exports__SETTLING_TIME;
exports.RootScene = __webpackgi_exports__RootScene;
exports.RingGeometry = __webpackgi_exports__RingGeometry;
exports.RingBufferGeometry = __webpackgi_exports__RingBufferGeometry;
exports.Rhino3dmLoader2 = __webpackgi_exports__Rhino3dmLoader2;
exports.Rhino3dmLoadPlugin = __webpackgi_exports__Rhino3dmLoadPlugin;
exports.ReverseSubtractEquation = __webpackgi_exports__ReverseSubtractEquation;
exports.ReplaceStencilOp = __webpackgi_exports__ReplaceStencilOp;
exports.RepeatWrapping = __webpackgi_exports__RepeatWrapping;
exports.RendererUiPlugin = __webpackgi_exports__RendererUiPlugin;
exports.ReinhardToneMapping = __webpackgi_exports__ReinhardToneMapping;
exports.Reflector2 = __webpackgi_exports__Reflector2;
exports.RedIntegerFormat = __webpackgi_exports__RedIntegerFormat;
exports.RedFormat = __webpackgi_exports__RedFormat;
exports.RectAreaLight = __webpackgi_exports__RectAreaLight;
exports.Raycaster = __webpackgi_exports__Raycaster;
exports.Ray = __webpackgi_exports__Ray;
exports.RawShaderMaterial = __webpackgi_exports__RawShaderMaterial;
exports.RandomizedDirectionalLightPlugin = __webpackgi_exports__RandomizedDirectionalLightPlugin;
exports.RandomizedDirectionalLight = __webpackgi_exports__RandomizedDirectionalLight;
exports.RGIntegerFormat = __webpackgi_exports__RGIntegerFormat;
exports.RGFormat = __webpackgi_exports__RGFormat;
exports.RGB_S3TC_DXT1_Format = __webpackgi_exports__RGB_S3TC_DXT1_Format;
exports.RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__RGB_PVRTC_4BPPV1_Format;
exports.RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__RGB_PVRTC_2BPPV1_Format;
exports.RGB_ETC2_Format = __webpackgi_exports__RGB_ETC2_Format;
exports.RGB_ETC1_Format = __webpackgi_exports__RGB_ETC1_Format;
exports.RGBM7Encoding = __webpackgi_exports__RGBM7Encoding;
exports.RGBM16Encoding_ = __webpackgi_exports__RGBM16Encoding_;
exports.RGBM16Encoding = __webpackgi_exports__RGBM16Encoding;
exports.RGBFormat = __webpackgi_exports__RGBFormat;
exports.RGBA_S3TC_DXT5_Format = __webpackgi_exports__RGBA_S3TC_DXT5_Format;
exports.RGBA_S3TC_DXT3_Format = __webpackgi_exports__RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT1_Format = __webpackgi_exports__RGBA_S3TC_DXT1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format;
exports.RGBA_ETC2_EAC_Format = __webpackgi_exports__RGBA_ETC2_EAC_Format;
exports.RGBA_BPTC_Format = __webpackgi_exports__RGBA_BPTC_Format;
exports.RGBA_ASTC_8x8_Format = __webpackgi_exports__RGBA_ASTC_8x8_Format;
exports.RGBA_ASTC_8x6_Format = __webpackgi_exports__RGBA_ASTC_8x6_Format;
exports.RGBA_ASTC_8x5_Format = __webpackgi_exports__RGBA_ASTC_8x5_Format;
exports.RGBA_ASTC_6x6_Format = __webpackgi_exports__RGBA_ASTC_6x6_Format;
exports.RGBA_ASTC_6x5_Format = __webpackgi_exports__RGBA_ASTC_6x5_Format;
exports.RGBA_ASTC_5x5_Format = __webpackgi_exports__RGBA_ASTC_5x5_Format;
exports.RGBA_ASTC_5x4_Format = __webpackgi_exports__RGBA_ASTC_5x4_Format;
exports.RGBA_ASTC_4x4_Format = __webpackgi_exports__RGBA_ASTC_4x4_Format;
exports.RGBA_ASTC_12x12_Format = __webpackgi_exports__RGBA_ASTC_12x12_Format;
exports.RGBA_ASTC_12x10_Format = __webpackgi_exports__RGBA_ASTC_12x10_Format;
exports.RGBA_ASTC_10x8_Format = __webpackgi_exports__RGBA_ASTC_10x8_Format;
exports.RGBA_ASTC_10x6_Format = __webpackgi_exports__RGBA_ASTC_10x6_Format;
exports.RGBA_ASTC_10x5_Format = __webpackgi_exports__RGBA_ASTC_10x5_Format;
exports.RGBA_ASTC_10x10_Format = __webpackgi_exports__RGBA_ASTC_10x10_Format;
exports.RGBAIntegerFormat = __webpackgi_exports__RGBAIntegerFormat;
exports.RGBAFormat = __webpackgi_exports__RGBAFormat;
exports.RGBADepthPacking = __webpackgi_exports__RGBADepthPacking;
exports.REVISION = __webpackgi_exports__REVISION;
exports.QuaternionLinearInterpolant = __webpackgi_exports__QuaternionLinearInterpolant;
exports.QuaternionKeyframeTrack = __webpackgi_exports__QuaternionKeyframeTrack;
exports.Quaternion = __webpackgi_exports__Quaternion;
exports.QuadraticBezierCurve3 = __webpackgi_exports__QuadraticBezierCurve3;
exports.QuadraticBezierCurve = __webpackgi_exports__QuadraticBezierCurve;
exports.PropertyMixer = __webpackgi_exports__PropertyMixer;
exports.PropertyBinding = __webpackgi_exports__PropertyBinding;
exports.ProgressivePlugin = __webpackgi_exports__ProgressivePlugin;
exports.PresetLibraryPlugin = __webpackgi_exports__PresetLibraryPlugin;
exports.PositionalAudio = __webpackgi_exports__PositionalAudio;
exports.PopmotionPlugin = __webpackgi_exports__PopmotionPlugin;
exports.PolyhedronGeometry = __webpackgi_exports__PolyhedronGeometry;
exports.PolyhedronBufferGeometry = __webpackgi_exports__PolyhedronBufferGeometry;
exports.PolarGridHelper = __webpackgi_exports__PolarGridHelper;
exports.PointsMaterial = __webpackgi_exports__PointsMaterial;
exports.Points = __webpackgi_exports__Points;
exports.PointerLockControlsPlugin = __webpackgi_exports__PointerLockControlsPlugin;
exports.PointerLockControls2 = __webpackgi_exports__PointerLockControls2;
exports.PointLightHelper = __webpackgi_exports__PointLightHelper;
exports.PointLight2 = __webpackgi_exports__PointLight2;
exports.PointLight = __webpackgi_exports__PointLight;
exports.PlaneHelper = __webpackgi_exports__PlaneHelper;
exports.PlaneGeometry = __webpackgi_exports__PlaneGeometry;
exports.PlaneBufferGeometry = __webpackgi_exports__PlaneBufferGeometry;
exports.Plane = __webpackgi_exports__Plane;
exports.PickingPlugin = __webpackgi_exports__PickingPlugin;
exports.PerspectiveCamera = __webpackgi_exports__PerspectiveCamera;
exports.Path = __webpackgi_exports__Path;
exports.ParallaxMappingPlugin = __webpackgi_exports__ParallaxMappingPlugin;
exports.PMREMGeneratorPlugin = __webpackgi_exports__PMREMGeneratorPlugin;
exports.PMREMGenerator = __webpackgi_exports__PMREMGenerator;
exports.PCFSoftShadowMap = __webpackgi_exports__PCFSoftShadowMap;
exports.PCFShadowMap = __webpackgi_exports__PCFShadowMap;
exports.OrthographicCamera = __webpackgi_exports__OrthographicCamera;
exports.OrbitControls3 = __webpackgi_exports__OrbitControls3;
exports.OrbitControls2 = __webpackgi_exports__OrbitControls2;
exports.OneMinusSrcColorFactor = __webpackgi_exports__OneMinusSrcColorFactor;
exports.OneMinusSrcAlphaFactor = __webpackgi_exports__OneMinusSrcAlphaFactor;
exports.OneMinusDstColorFactor = __webpackgi_exports__OneMinusDstColorFactor;
exports.OneMinusDstAlphaFactor = __webpackgi_exports__OneMinusDstAlphaFactor;
exports.OneFactor = __webpackgi_exports__OneFactor;
exports.OctahedronGeometry = __webpackgi_exports__OctahedronGeometry;
exports.OctahedronBufferGeometry = __webpackgi_exports__OctahedronBufferGeometry;
exports.ObjectSpaceNormalMap = __webpackgi_exports__ObjectSpaceNormalMap;
exports.ObjectRotationPlugin = __webpackgi_exports__ObjectRotationPlugin;
exports.ObjectProcessorMap = __webpackgi_exports__ObjectProcessorMap;
exports.ObjectPicker = __webpackgi_exports__ObjectPicker;
exports.ObjectLoader2 = __webpackgi_exports__ObjectLoader2;
exports.ObjectLoader = __webpackgi_exports__ObjectLoader;
exports.Object3DModel = __webpackgi_exports__Object3DModel;
exports.Object3D = __webpackgi_exports__Object3D;
exports.ObjMtlLoadPlugin = __webpackgi_exports__ObjMtlLoadPlugin;
exports.OBJLoader2 = __webpackgi_exports__OBJLoader2;
exports.NumberKeyframeTrack = __webpackgi_exports__NumberKeyframeTrack;
exports.NotEqualStencilFunc = __webpackgi_exports__NotEqualStencilFunc;
exports.NotEqualDepth = __webpackgi_exports__NotEqualDepth;
exports.NormalCaptureMaterial = __webpackgi_exports__NormalCaptureMaterial;
exports.NormalBlending = __webpackgi_exports__NormalBlending;
exports.NormalAnimationBlendMode = __webpackgi_exports__NormalAnimationBlendMode;
exports.NoiseBumpMaterialPlugin = __webpackgi_exports__NoiseBumpMaterialPlugin;
exports.NoToneMapping = __webpackgi_exports__NoToneMapping;
exports.NoColorSpace = __webpackgi_exports__NoColorSpace;
exports.NoBlending = __webpackgi_exports__NoBlending;
exports.NeverStencilFunc = __webpackgi_exports__NeverStencilFunc;
exports.NeverDepth = __webpackgi_exports__NeverDepth;
exports.NearestMipmapNearestFilter = __webpackgi_exports__NearestMipmapNearestFilter;
exports.NearestMipmapLinearFilter = __webpackgi_exports__NearestMipmapLinearFilter;
exports.NearestMipMapNearestFilter = __webpackgi_exports__NearestMipMapNearestFilter;
exports.NearestMipMapLinearFilter = __webpackgi_exports__NearestMipMapLinearFilter;
exports.NearestFilter = __webpackgi_exports__NearestFilter;
exports.MultiplyOperation = __webpackgi_exports__MultiplyOperation;
exports.MultiplyBlending = __webpackgi_exports__MultiplyBlending;
exports.MultiFilterPlugin = __webpackgi_exports__MultiFilterPlugin;
exports.MixOperation = __webpackgi_exports__MixOperation;
exports.MirroredRepeatWrapping = __webpackgi_exports__MirroredRepeatWrapping;
exports.MinEquation = __webpackgi_exports__MinEquation;
exports.MeshToonMaterial = __webpackgi_exports__MeshToonMaterial;
exports.MeshStandardMaterial2 = __webpackgi_exports__MeshStandardMaterial2;
exports.MeshStandardMaterial = __webpackgi_exports__MeshStandardMaterial;
exports.MeshPhysicalMaterial = __webpackgi_exports__MeshPhysicalMaterial;
exports.MeshPhongMaterial = __webpackgi_exports__MeshPhongMaterial;
exports.MeshNormalMaterial = __webpackgi_exports__MeshNormalMaterial;
exports.MeshMatcapMaterial = __webpackgi_exports__MeshMatcapMaterial;
exports.MeshLambertMaterial = __webpackgi_exports__MeshLambertMaterial;
exports.MeshDistanceMaterial = __webpackgi_exports__MeshDistanceMaterial;
exports.MeshDepthMaterial = __webpackgi_exports__MeshDepthMaterial;
exports.MeshBasicMaterial2 = __webpackgi_exports__MeshBasicMaterial2;
exports.MeshBasicMaterial = __webpackgi_exports__MeshBasicMaterial;
exports.Mesh = __webpackgi_exports__Mesh;
exports.MaxEquation = __webpackgi_exports__MaxEquation;
exports.Matrix4 = __webpackgi_exports__Matrix4;
exports.Matrix3 = __webpackgi_exports__Matrix3;
exports.MathUtils = __webpackgi_exports__MathUtils;
exports.MaterialPreviewGenerator = __webpackgi_exports__MaterialPreviewGenerator;
exports.MaterialManager = __webpackgi_exports__MaterialManager;
exports.MaterialLoader = __webpackgi_exports__MaterialLoader;
exports.MaterialLibraryPlugin = __webpackgi_exports__MaterialLibraryPlugin;
exports.MaterialLibraryBasePlugin = __webpackgi_exports__MaterialLibraryBasePlugin;
exports.MaterialExtender = __webpackgi_exports__MaterialExtender;
exports.MaterialConfiguratorPlugin = __webpackgi_exports__MaterialConfiguratorPlugin;
exports.MaterialConfiguratorBasePlugin = __webpackgi_exports__MaterialConfiguratorBasePlugin;
exports.Material = __webpackgi_exports__Material;
exports.MTLLoader2 = __webpackgi_exports__MTLLoader2;
exports.MOUSE = __webpackgi_exports__MOUSE;
exports.LuminanceFormat = __webpackgi_exports__LuminanceFormat;
exports.LuminanceAlphaFormat = __webpackgi_exports__LuminanceAlphaFormat;
exports.LoopRepeat = __webpackgi_exports__LoopRepeat;
exports.LoopPingPong = __webpackgi_exports__LoopPingPong;
exports.LoopOnce = __webpackgi_exports__LoopOnce;
exports.LoadingManager = __webpackgi_exports__LoadingManager;
exports.LoaderUtils = __webpackgi_exports__LoaderUtils;
exports.Loader = __webpackgi_exports__Loader;
exports.LinearToneMapping = __webpackgi_exports__LinearToneMapping;
exports.LinearSRGBColorSpace = __webpackgi_exports__LinearSRGBColorSpace;
exports.LinearMipmapNearestFilter = __webpackgi_exports__LinearMipmapNearestFilter;
exports.LinearMipmapLinearFilter = __webpackgi_exports__LinearMipmapLinearFilter;
exports.LinearMipMapNearestFilter = __webpackgi_exports__LinearMipMapNearestFilter;
exports.LinearMipMapLinearFilter = __webpackgi_exports__LinearMipMapLinearFilter;
exports.LinearInterpolant = __webpackgi_exports__LinearInterpolant;
exports.LinearFilter = __webpackgi_exports__LinearFilter;
exports.LinearEncoding = __webpackgi_exports__LinearEncoding;
exports.LineSegments = __webpackgi_exports__LineSegments;
exports.LineLoop = __webpackgi_exports__LineLoop;
exports.LineDashedMaterial = __webpackgi_exports__LineDashedMaterial;
exports.LineCurve3 = __webpackgi_exports__LineCurve3;
exports.LineCurve = __webpackgi_exports__LineCurve;
exports.LineBasicMaterial = __webpackgi_exports__LineBasicMaterial;
exports.Line3 = __webpackgi_exports__Line3;
exports.Line = __webpackgi_exports__Line;
exports.LightsUiPlugin = __webpackgi_exports__LightsUiPlugin;
exports.LightProbe = __webpackgi_exports__LightProbe;
exports.Light = __webpackgi_exports__Light;
exports.LessStencilFunc = __webpackgi_exports__LessStencilFunc;
exports.LessEqualStencilFunc = __webpackgi_exports__LessEqualStencilFunc;
exports.LessEqualDepth = __webpackgi_exports__LessEqualDepth;
exports.LessDepth = __webpackgi_exports__LessDepth;
exports.Layers = __webpackgi_exports__Layers;
exports.LatheGeometry = __webpackgi_exports__LatheGeometry;
exports.LatheBufferGeometry = __webpackgi_exports__LatheBufferGeometry;
exports.LUTPlugin = __webpackgi_exports__LUTPlugin;
exports.LOD = __webpackgi_exports__LOD;
exports.KeyframeTrack = __webpackgi_exports__KeyframeTrack;
exports.KeepStencilOp = __webpackgi_exports__KeepStencilOp;
exports.KTXLoadPlugin = __webpackgi_exports__KTXLoadPlugin;
exports.KTX2LoadPlugin = __webpackgi_exports__KTX2LoadPlugin;
exports.KHR_TEXTURE_BASISU = __webpackgi_exports__KHR_TEXTURE_BASISU;
exports.InvertStencilOp = __webpackgi_exports__InvertStencilOp;
exports.InterpolateSmooth = __webpackgi_exports__InterpolateSmooth;
exports.InterpolateLinear = __webpackgi_exports__InterpolateLinear;
exports.InterpolateDiscrete = __webpackgi_exports__InterpolateDiscrete;
exports.Interpolant = __webpackgi_exports__Interpolant;
exports.InterleavedBufferAttribute = __webpackgi_exports__InterleavedBufferAttribute;
exports.InterleavedBuffer = __webpackgi_exports__InterleavedBuffer;
exports.IntType = __webpackgi_exports__IntType;
exports.Int8BufferAttribute = __webpackgi_exports__Int8BufferAttribute;
exports.Int32BufferAttribute = __webpackgi_exports__Int32BufferAttribute;
exports.Int16BufferAttribute = __webpackgi_exports__Int16BufferAttribute;
exports.InstancedMesh = __webpackgi_exports__InstancedMesh;
exports.InstancedInterleavedBuffer = __webpackgi_exports__InstancedInterleavedBuffer;
exports.InstancedBufferGeometry = __webpackgi_exports__InstancedBufferGeometry;
exports.InstancedBufferAttribute = __webpackgi_exports__InstancedBufferAttribute;
exports.Inflate = __webpackgi_exports__Inflate;
exports.IncrementWrapStencilOp = __webpackgi_exports__IncrementWrapStencilOp;
exports.IncrementStencilOp = __webpackgi_exports__IncrementStencilOp;
exports.Importer = __webpackgi_exports__Importer;
exports.ImmediateRenderObject = __webpackgi_exports__ImmediateRenderObject;
exports.ImageUtils = __webpackgi_exports__ImageUtils;
exports.ImageLoader = __webpackgi_exports__ImageLoader;
exports.ImageBitmapLoader = __webpackgi_exports__ImageBitmapLoader;
exports.IcosahedronGeometry = __webpackgi_exports__IcosahedronGeometry;
exports.IcosahedronBufferGeometry = __webpackgi_exports__IcosahedronBufferGeometry;
exports.HierarchyUiPlugin = __webpackgi_exports__HierarchyUiPlugin;
exports.HemisphereLightProbe = __webpackgi_exports__HemisphereLightProbe;
exports.HemisphereLightHelper = __webpackgi_exports__HemisphereLightHelper;
exports.HemisphereLight = __webpackgi_exports__HemisphereLight;
exports.HalfFloatType = __webpackgi_exports__HalfFloatType;
exports.HDRiGroundPlugin = __webpackgi_exports__HDRiGroundPlugin;
exports.Gzip = __webpackgi_exports__Gzip;
exports.Gunzip = __webpackgi_exports__Gunzip;
exports.Group = __webpackgi_exports__Group;
exports.GroundPlugin = __webpackgi_exports__GroundPlugin;
exports.GridHelper = __webpackgi_exports__GridHelper;
exports.GreaterStencilFunc = __webpackgi_exports__GreaterStencilFunc;
exports.GreaterEqualStencilFunc = __webpackgi_exports__GreaterEqualStencilFunc;
exports.GreaterEqualDepth = __webpackgi_exports__GreaterEqualDepth;
exports.GreaterDepth = __webpackgi_exports__GreaterDepth;
exports.GenericFilterPlugin = __webpackgi_exports__GenericFilterPlugin;
exports.GenericBlendTexturePass = __webpackgi_exports__GenericBlendTexturePass;
exports.GammaCorrectionPlugin = __webpackgi_exports__GammaCorrectionPlugin;
exports.GammaCorrectionExtension = __webpackgi_exports__GammaCorrectionExtension;
exports.GLTFWriter2 = __webpackgi_exports__GLTFWriter2;
exports.GLTFMeshOptPlugin = __webpackgi_exports__GLTFMeshOptPlugin;
exports.GLTFMaterialsLightMapExtensionName = __webpackgi_exports__GLTFMaterialsLightMapExtensionName;
exports.GLTFMaterialsDisplacementMapExtensionName = __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName;
exports.GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__GLTFMaterialsBumpMapExtensionName;
exports.GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName;
exports.GLTFLoader2 = __webpackgi_exports__GLTFLoader2;
exports.GLTFExporter2 = __webpackgi_exports__GLTFExporter2;
exports.GLTFDracoExporter = __webpackgi_exports__GLTFDracoExporter;
exports.GLTFDracoExportPlugin = __webpackgi_exports__GLTFDracoExportPlugin;
exports.GLTFAnimationPlugin = __webpackgi_exports__GLTFAnimationPlugin;
exports.GLSL3 = __webpackgi_exports__GLSL3;
exports.GLSL1 = __webpackgi_exports__GLSL1;
exports.GLBufferAttribute = __webpackgi_exports__GLBufferAttribute;
exports.GBufferPlugin = __webpackgi_exports__GBufferPlugin;
exports.FullScreenPlugin = __webpackgi_exports__FullScreenPlugin;
exports.Frustum = __webpackgi_exports__Frustum;
exports.FrontSide = __webpackgi_exports__FrontSide;
exports.FramebufferTexture = __webpackgi_exports__FramebufferTexture;
exports.FrameFadePlugin = __webpackgi_exports__FrameFadePlugin;
exports.FogExp2 = __webpackgi_exports__FogExp2;
exports.Fog = __webpackgi_exports__Fog;
exports.FloatType = __webpackgi_exports__FloatType;
exports.Float64BufferAttribute = __webpackgi_exports__Float64BufferAttribute;
exports.Float32BufferAttribute = __webpackgi_exports__Float32BufferAttribute;
exports.Float16BufferAttribute = __webpackgi_exports__Float16BufferAttribute;
exports.FirstPersonControlsPlugin = __webpackgi_exports__FirstPersonControlsPlugin;
exports.FirstPersonControls2 = __webpackgi_exports__FirstPersonControls2;
exports.FilmicGrainPlugin = __webpackgi_exports__FilmicGrainPlugin;
exports.FileLoader = __webpackgi_exports__FileLoader;
exports.FSShadowMaterial = __webpackgi_exports__FSShadowMaterial;
exports.FBXLoadPlugin = __webpackgi_exports__FBXLoadPlugin;
exports.ExtrudeGeometry = __webpackgi_exports__ExtrudeGeometry;
exports.ExtrudeBufferGeometry = __webpackgi_exports__ExtrudeBufferGeometry;
exports.EventDispatcher = __webpackgi_exports__EventDispatcher;
exports.Euler = __webpackgi_exports__Euler;
exports.EquirectangularRefractionMapping = __webpackgi_exports__EquirectangularRefractionMapping;
exports.EquirectangularReflectionMapping = __webpackgi_exports__EquirectangularReflectionMapping;
exports.EqualStencilFunc = __webpackgi_exports__EqualStencilFunc;
exports.EqualDepth = __webpackgi_exports__EqualDepth;
exports.EncodeUTF8 = __webpackgi_exports__EncodeUTF8;
exports.EllipseCurve3D = __webpackgi_exports__EllipseCurve3D;
exports.EllipseCurve = __webpackgi_exports__EllipseCurve;
exports.EffectComposer2 = __webpackgi_exports__EffectComposer2;
exports.EdgesGeometry = __webpackgi_exports__EdgesGeometry;
exports.EasingFunctions = __webpackgi_exports__EasingFunctions;
exports.EXRLoadPlugin = __webpackgi_exports__EXRLoadPlugin;
exports.DynamicReadUsage = __webpackgi_exports__DynamicReadUsage;
exports.DynamicDrawUsage = __webpackgi_exports__DynamicDrawUsage;
exports.DynamicCopyUsage = __webpackgi_exports__DynamicCopyUsage;
exports.DstColorFactor = __webpackgi_exports__DstColorFactor;
exports.DstAlphaFactor = __webpackgi_exports__DstAlphaFactor;
exports.DropzonePlugin = __webpackgi_exports__DropzonePlugin;
exports.Dropzone = __webpackgi_exports__Dropzone;
exports.DoubleSide = __webpackgi_exports__DoubleSide;
exports.DodecahedronGeometry = __webpackgi_exports__DodecahedronGeometry;
exports.DodecahedronBufferGeometry = __webpackgi_exports__DodecahedronBufferGeometry;
exports.DiscreteInterpolant = __webpackgi_exports__DiscreteInterpolant;
exports.DirectionalLightHelper = __webpackgi_exports__DirectionalLightHelper;
exports.DirectionalLight2 = __webpackgi_exports__DirectionalLight2;
exports.DirectionalLight = __webpackgi_exports__DirectionalLight;
exports.DiamondPlugin = __webpackgi_exports__DiamondPlugin;
exports.DiamondMaterial = __webpackgi_exports__DiamondMaterial;
exports.DeviceOrientationControlsPlugin = __webpackgi_exports__DeviceOrientationControlsPlugin;
exports.DeviceOrientationControls2 = __webpackgi_exports__DeviceOrientationControls2;
exports.DepthTexture = __webpackgi_exports__DepthTexture;
exports.DepthStencilFormat = __webpackgi_exports__DepthStencilFormat;
exports.DepthOfFieldPlugin = __webpackgi_exports__DepthOfFieldPlugin;
exports.DepthOfFieldPass = __webpackgi_exports__DepthOfFieldPass;
exports.DepthFormat = __webpackgi_exports__DepthFormat;
exports.Deflate = __webpackgi_exports__Deflate;
exports.DefaultLoadingManager = __webpackgi_exports__DefaultLoadingManager;
exports.DecrementWrapStencilOp = __webpackgi_exports__DecrementWrapStencilOp;
exports.DecrementStencilOp = __webpackgi_exports__DecrementStencilOp;
exports.Decompress = __webpackgi_exports__Decompress;
exports.DecodeUTF8 = __webpackgi_exports__DecodeUTF8;
exports.DebugPlugin = __webpackgi_exports__DebugPlugin;
exports.DataUtils = __webpackgi_exports__DataUtils;
exports.DataUrlLoader = __webpackgi_exports__DataUrlLoader;
exports.DataTextureLoader = __webpackgi_exports__DataTextureLoader;
exports.DataTexture3D = __webpackgi_exports__DataTexture3D;
exports.DataTexture2DArray = __webpackgi_exports__DataTexture2DArray;
exports.DataTexture = __webpackgi_exports__DataTexture;
exports.DataArrayTexture = __webpackgi_exports__DataArrayTexture;
exports.Data3DTexture = __webpackgi_exports__Data3DTexture;
exports.Damper = __webpackgi_exports__Damper;
exports.DRACOLoader2 = __webpackgi_exports__DRACOLoader2;
exports.DECAY_MILLISECONDS = __webpackgi_exports__DECAY_MILLISECONDS;
exports.Cylindrical = __webpackgi_exports__Cylindrical;
exports.CylinderGeometry = __webpackgi_exports__CylinderGeometry;
exports.CylinderBufferGeometry = __webpackgi_exports__CylinderBufferGeometry;
exports.CustomToneMapping = __webpackgi_exports__CustomToneMapping;
exports.CustomBumpMapPlugin = __webpackgi_exports__CustomBumpMapPlugin;
exports.CustomBlending = __webpackgi_exports__CustomBlending;
exports.CurvePath = __webpackgi_exports__CurvePath;
exports.Curve = __webpackgi_exports__Curve;
exports.CullFaceNone = __webpackgi_exports__CullFaceNone;
exports.CullFaceFrontBack = __webpackgi_exports__CullFaceFrontBack;
exports.CullFaceFront = __webpackgi_exports__CullFaceFront;
exports.CullFaceBack = __webpackgi_exports__CullFaceBack;
exports.CubicInterpolant = __webpackgi_exports__CubicInterpolant;
exports.CubicBezierCurve3 = __webpackgi_exports__CubicBezierCurve3;
exports.CubicBezierCurve = __webpackgi_exports__CubicBezierCurve;
exports.CubeUVReflectionMapping = __webpackgi_exports__CubeUVReflectionMapping;
exports.CubeTextureLoader = __webpackgi_exports__CubeTextureLoader;
exports.CubeTexture = __webpackgi_exports__CubeTexture;
exports.CubeRefractionMapping = __webpackgi_exports__CubeRefractionMapping;
exports.CubeReflectionMapping = __webpackgi_exports__CubeReflectionMapping;
exports.CubeNormalsCaptureHelper = __webpackgi_exports__CubeNormalsCaptureHelper;
exports.CubeCamera = __webpackgi_exports__CubeCamera;
exports.ContactShadowGroundPlugin = __webpackgi_exports__ContactShadowGroundPlugin;
exports.ConeGeometry = __webpackgi_exports__ConeGeometry;
exports.ConeBufferGeometry = __webpackgi_exports__ConeBufferGeometry;
exports.CompressedTextureLoader = __webpackgi_exports__CompressedTextureLoader;
exports.CompressedTexture = __webpackgi_exports__CompressedTexture;
exports.Compress = __webpackgi_exports__Compress;
exports.CombinedPostPlugin = __webpackgi_exports__CombinedPostPlugin;
exports.ColorManagement = __webpackgi_exports__ColorManagement;
exports.ColorKeyframeTrack = __webpackgi_exports__ColorKeyframeTrack;
exports.Color = __webpackgi_exports__Color;
exports.Clock = __webpackgi_exports__Clock;
exports.ClearcoatTintPlugin = __webpackgi_exports__ClearcoatTintPlugin;
exports.ClampToEdgeWrapping = __webpackgi_exports__ClampToEdgeWrapping;
exports.CircleGeometry = __webpackgi_exports__CircleGeometry;
exports.CircleBufferGeometry = __webpackgi_exports__CircleBufferGeometry;
exports.CineonToneMapping = __webpackgi_exports__CineonToneMapping;
exports.ChromaticAberrationPlugin = __webpackgi_exports__ChromaticAberrationPlugin;
exports.CatmullRomCurve3 = __webpackgi_exports__CatmullRomCurve3;
exports.CapsuleGeometry = __webpackgi_exports__CapsuleGeometry;
exports.CapsuleBufferGeometry = __webpackgi_exports__CapsuleBufferGeometry;
exports.CanvasTexture = __webpackgi_exports__CanvasTexture;
exports.CanvasSnipperPlugin = __webpackgi_exports__CanvasSnipperPlugin;
exports.CanvasSnipper = __webpackgi_exports__CanvasSnipper;
exports.CanvasRecorderPlugin = __webpackgi_exports__CanvasRecorderPlugin;
exports.CanvasRecorder = __webpackgi_exports__CanvasRecorder;
exports.CameraViewPlugin = __webpackgi_exports__CameraViewPlugin;
exports.CameraView = __webpackgi_exports__CameraView;
exports.CameraUiPlugin = __webpackgi_exports__CameraUiPlugin;
exports.CameraHelper = __webpackgi_exports__CameraHelper;
exports.CameraController = __webpackgi_exports__CameraController;
exports.Camera = __webpackgi_exports__Camera;
exports.Cache = __webpackgi_exports__Cache;
exports.CSS3DRendererPlugin = __webpackgi_exports__CSS3DRendererPlugin;
exports.CSGPluginBase = __webpackgi_exports__CSGPluginBase;
exports.CSGPluginBVH = __webpackgi_exports__CSGPluginBVH;
exports.CSGPluginBSP = __webpackgi_exports__CSGPluginBSP;
exports.ByteType = __webpackgi_exports__ByteType;
exports.BufferGeometryLoader = __webpackgi_exports__BufferGeometryLoader;
exports.BufferGeometry = __webpackgi_exports__BufferGeometry;
exports.BufferAttribute = __webpackgi_exports__BufferAttribute;
exports.BoxSelectionWidget = __webpackgi_exports__BoxSelectionWidget;
exports.BoxHelper = __webpackgi_exports__BoxHelper;
exports.BoxGeometry = __webpackgi_exports__BoxGeometry;
exports.BoxBufferGeometry = __webpackgi_exports__BoxBufferGeometry;
exports.Box3Helper = __webpackgi_exports__Box3Helper;
exports.Box3B = __webpackgi_exports__Box3B;
exports.Box3 = __webpackgi_exports__Box3;
exports.Box2 = __webpackgi_exports__Box2;
exports.BooleanKeyframeTrack = __webpackgi_exports__BooleanKeyframeTrack;
exports.Bone = __webpackgi_exports__Bone;
exports.BloomPlugin = __webpackgi_exports__BloomPlugin;
exports.BlobLoader = __webpackgi_exports__BlobLoader;
exports.BasicShadowMap = __webpackgi_exports__BasicShadowMap;
exports.BasicDepthPacking = __webpackgi_exports__BasicDepthPacking;
exports.BaseRenderer = __webpackgi_exports__BaseRenderer;
exports.BaseGroundPlugin = __webpackgi_exports__BaseGroundPlugin;
exports.BackSide = __webpackgi_exports__BackSide;
exports.AxesHelper = __webpackgi_exports__AxesHelper;
exports.AudioLoader = __webpackgi_exports__AudioLoader;
exports.AudioListener = __webpackgi_exports__AudioListener;
exports.AudioContext = __webpackgi_exports__AudioContext;
exports.AudioAnalyser = __webpackgi_exports__AudioAnalyser;
exports.Audio = __webpackgi_exports__Audio;
exports.AsyncZlib = __webpackgi_exports__AsyncZlib;
exports.AsyncZipDeflate = __webpackgi_exports__AsyncZipDeflate;
exports.AsyncUnzlib = __webpackgi_exports__AsyncUnzlib;
exports.AsyncUnzipInflate = __webpackgi_exports__AsyncUnzipInflate;
exports.AsyncInflate = __webpackgi_exports__AsyncInflate;
exports.AsyncGzip = __webpackgi_exports__AsyncGzip;
exports.AsyncGunzip = __webpackgi_exports__AsyncGunzip;
exports.AsyncDeflate = __webpackgi_exports__AsyncDeflate;
exports.AsyncDecompress = __webpackgi_exports__AsyncDecompress;
exports.AsyncCompress = __webpackgi_exports__AsyncCompress;
exports.AssetManagerPlugin = __webpackgi_exports__AssetManagerPlugin;
exports.AssetManagerBasicPopupPlugin = __webpackgi_exports__AssetManagerBasicPopupPlugin;
exports.AssetImporter = __webpackgi_exports__AssetImporter;
exports.AssetExporterPlugin = __webpackgi_exports__AssetExporterPlugin;
exports.AssetExporter = __webpackgi_exports__AssetExporter;
exports.ArrowHelper = __webpackgi_exports__ArrowHelper;
exports.ArrayCamera = __webpackgi_exports__ArrayCamera;
exports.ArcCurve = __webpackgi_exports__ArcCurve;
exports.AnisotropyPlugin = __webpackgi_exports__AnisotropyPlugin;
exports.AnimationUtils = __webpackgi_exports__AnimationUtils;
exports.AnimationObjectGroup = __webpackgi_exports__AnimationObjectGroup;
exports.AnimationMixer = __webpackgi_exports__AnimationMixer;
exports.AnimationLoader = __webpackgi_exports__AnimationLoader;
exports.AnimationClip = __webpackgi_exports__AnimationClip;
exports.AmbientLightProbe = __webpackgi_exports__AmbientLightProbe;
exports.AmbientLight2 = __webpackgi_exports__AmbientLight2;
exports.AmbientLight = __webpackgi_exports__AmbientLight;
exports.AlwaysStencilFunc = __webpackgi_exports__AlwaysStencilFunc;
exports.AlwaysDepth = __webpackgi_exports__AlwaysDepth;
exports.AlphaFormat = __webpackgi_exports__AlphaFormat;
exports.AdditiveBlending = __webpackgi_exports__AdditiveBlending;
exports.AdditiveAnimationBlendMode = __webpackgi_exports__AdditiveAnimationBlendMode;
exports.AddOperation = __webpackgi_exports__AddOperation;
exports.AddEquation = __webpackgi_exports__AddEquation;
exports.AddBlendPass = __webpackgi_exports__AddBlendPass;
exports.AViewerPlugin = __webpackgi_exports__AViewerPlugin;
exports.ARTouchInputHelper = __webpackgi_exports__ARTouchInputHelper;
exports.ARPlugin = __webpackgi_exports__ARPlugin;
exports.ARPlacementBox = __webpackgi_exports__ARPlacementBox;
exports.AMaterialManager = __webpackgi_exports__AMaterialManager;
exports.ACESFilmicToneMapping = __webpackgi_exports__ACESFilmicToneMapping;
},{"buffer":"node_modules/buffer/index.js"}],"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;
function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }
  return bundleURL;
}
function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
    if (matches) {
      return getBaseURL(matches[0]);
    }
  }
  return '/';
}
function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');
function updateLink(link) {
  var newLink = link.cloneNode();
  newLink.onload = function () {
    link.remove();
  };
  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
  if (cssTimeout) {
    return;
  }
  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }
    cssTimeout = null;
  }, 50);
}
module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"src/styles.css":[function(require,module,exports) {
var reloadCSS = require('_css_loader');
module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js"}],"node_modules/gsap/gsap-core.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapYoyo = exports.wrap = exports.unitize = exports.toArray = exports.splitColor = exports.snap = exports.shuffle = exports.selector = exports.random = exports.pipe = exports.normalize = exports.mapRange = exports.interpolate = exports.gsap = exports.getUnit = exports.distribute = exports.default = exports.clamp = exports._ticker = exports._sortPropTweensByPriority = exports._setDefaults = exports._roundModifier = exports._round = exports._replaceRandom = exports._renderComplexString = exports._removeLinkedListItem = exports._relExp = exports._plugins = exports._parseRelative = exports._numWithUnitExp = exports._numExp = exports._missingPlugin = exports._isUndefined = exports._isString = exports._getSetter = exports._getProperty = exports._getCache = exports._forEachName = exports._config = exports._colorStringFilter = exports._colorExp = exports._checkPlugin = exports.TweenMax = exports.TweenLite = exports.Tween = exports.TimelineMax = exports.TimelineLite = exports.Timeline = exports.Strong = exports.SteppedEase = exports.Sine = exports.Quint = exports.Quart = exports.Quad = exports.PropTween = exports.Power4 = exports.Power3 = exports.Power2 = exports.Power1 = exports.Power0 = exports.Linear = exports.GSCache = exports.Expo = exports.Elastic = exports.Cubic = exports.Circ = exports.Bounce = exports.Back = exports.Animation = void 0;
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/*!
 * GSAP 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  },
  _defaults = {
    duration: .5,
    overwrite: false,
    delay: 0
  },
  _suppressOverwrites,
  _reverting,
  _context,
  _bigNum = 1e8,
  _tinyNum = 1 / _bigNum,
  _2PI = Math.PI * 2,
  _HALF_PI = _2PI / 4,
  _gsID = 0,
  _sqrt = Math.sqrt,
  _cos = Math.cos,
  _sin = Math.sin,
  _isString = function _isString(value) {
    return typeof value === "string";
  },
  _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
  _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
  _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
  _isObject = function _isObject(value) {
    return typeof value === "object";
  },
  _isNotFalse = function _isNotFalse(value) {
    return value !== false;
  },
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _isFuncOrString = function _isFuncOrString(value) {
    return _isFunction(value) || _isString(value);
  },
  _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
  // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
  _isArray = Array.isArray,
  _strictNumExp = /(?:-?\.?\d|\.)+/gi,
  //only numbers (including negatives and decimals) but NOT relative values.
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
  _relExp = /[+-]=-?[.\d]+/,
  _delimitedValueExp = /[^,'"\[\]\s]+/gi,
  // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
  _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  _globalTimeline,
  _win,
  _coreInitted,
  _doc,
  _globals = {},
  _installScope = {},
  _coreReady,
  _install = function _install(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  },
  _missingPlugin = function _missingPlugin(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  },
  _warn = function _warn(message, suppress) {
    return !suppress && console.warn(message);
  },
  _addGlobal = function _addGlobal(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  },
  _emptyFunc = function _emptyFunc() {
    return 0;
  },
  _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  },
  _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  },
  _revertConfig = {
    suppressEvents: true
  },
  _reservedProps = {},
  _lazyTweens = [],
  _lazyLookup = {},
  _lastRenderedFrame,
  _plugins = {},
  _effects = {},
  _nextGCFrame = 30,
  _harnessPlugins = [],
  _callbackNames = "",
  _harness = function _harness(targets) {
    var target = targets[0],
      harnessPlugin,
      i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {}
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  },
  _getCache = function _getCache(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  },
  _getProperty = function _getProperty(target, property, v) {
    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  },
  _forEachName = function _forEachName(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  },
  //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
  _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
  _roundPrecise = function _roundPrecise(value) {
    return Math.round(value * 10000000) / 10000000 || 0;
  },
  // increased precision mostly for timing values.
  _parseRelative = function _parseRelative(start, value) {
    var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  },
  _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
    var l = toFind.length,
      i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
    return i < l;
  },
  _lazyRender = function _lazyRender() {
    var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  },
  _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
  },
  _numericIfPossible = function _numericIfPossible(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  },
  _passThrough = function _passThrough(p) {
    return p;
  },
  _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }
    return obj;
  },
  _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
    return function (obj, defaults) {
      for (var p in defaults) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
      }
    };
  },
  _merge = function _merge(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  },
  _mergeDeep = function _mergeDeep(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  },
  _copyExcluding = function _copyExcluding(obj, excluding) {
    var copy = {},
      p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  },
  _inheritDefaults = function _inheritDefaults(vars) {
    var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  },
  _arraysMatch = function _arraysMatch(a1, a2) {
    var i = a1.length,
      match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {}
    return i < 0;
  },
  _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp],
      t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  },
  _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev,
      next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
  },
  _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
    child._act = 0;
  },
  _uncache = function _uncache(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  },
  _recacheAncestors = function _recacheAncestors(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  },
  _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  },
  _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
  },
  _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  },
  // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
  _animationCycle = function _animationCycle(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  },
  _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  },
  _setEnd = function _setEnd(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  },
  _alignPlayhead = function _alignPlayhead(animation, totalTime) {
    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
    }

    return animation;
  },
  /*
  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
  	let cycleDuration = duration + repeatDelay,
  		time = _round(clampedTotalTime % cycleDuration);
  	if (time > duration) {
  		time = duration;
  	}
  	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
  },
  */
  _postAddChecks = function _postAddChecks(timeline, child) {
    var t;
    if (child._time || child._initted && !child._dur) {
      //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
      t = _parentToChildTotalTime(timeline.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.

    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
      //in case any of the ancestors had completed but should now be enabled...
      if (timeline._dur < timeline.duration()) {
        t = timeline;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

          t = t._dp;
        }
      }
      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
    }
  },
  _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline._recent = child);
    skipChecks || _postAddChecks(timeline, child);
    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

    return timeline;
  },
  _scrollTrigger = function _scrollTrigger(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  },
  _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  },
  _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
  },
  // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
  _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  },
  _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
      repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;
    if (repeatDelay && tween._repeat) {
      // in case there's a zero-duration tween that has a repeat with a repeatDelay
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        // if iteration changed
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  },
  _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  },
  _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  },
  _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  },
  _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  },
  _parsePosition = function _parsePosition(animation, position, percentAnimation) {
    var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
      i,
      offset,
      isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  },
  _createTweenType = function _createTweenType(type, params, timeline) {
    var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline;
    if (type) {
      irVars = vars;
      parent = timeline;
      while (parent && !("immediateRender" in irVars)) {
        // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
    }

    return new Tween(params[0], vars, params[varsIndex + 1]);
  },
  _conditionalReturn = function _conditionalReturn(value, func) {
    return value || value === 0 ? func(value) : func;
  },
  _clamp = function _clamp(min, max, value) {
    return value < min ? min : value > max ? max : value;
  },
  getUnit = function getUnit(value, v) {
    return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  },
  // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
  clamp = function clamp(min, max, value) {
    return _conditionalReturn(value, function (v) {
      return _clamp(min, max, v);
    });
  },
  _slice = [].slice,
  _isArrayLike = function _isArrayLike(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  },
  _flatten = function _flatten(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function (value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  },
  //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  toArray = function toArray(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  },
  selector = function selector(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function (v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  },
  shuffle = function shuffle(a) {
    return a.sort(function () {
      return .5 - Math.random();
    });
  },
  // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
  //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
  distribute = function distribute(v) {
    if (_isFunction(v)) {
      return v;
    }
    var vars = _isObject(v) ? v : {
        each: v
      },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
      ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: .5,
        edges: .5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function (i, target, a) {
      var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
          wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0; //unit

        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
    };
  },
  _roundModifier = function _roundModifier(v) {
    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

    return function (raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
    };
  },
  snap = function snap(snapTo, value) {
    var isArray = _isArray(snapTo),
      radius,
      is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function (raw) {
      var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  },
  random = function random(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  },
  pipe = function pipe() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function (value) {
      return functions.reduce(function (v, f) {
        return f(v);
      }, value);
    };
  },
  unitize = function unitize(func, unit) {
    return function (value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  },
  normalize = function normalize(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  },
  _wrapArray = function _wrapArray(a, wrapper, value) {
    return _conditionalReturn(value, function (index) {
      return a[~~wrapper(index)];
    });
  },
  wrap = function wrap(min, max, value) {
    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
      return (range + (value - min) % range) % range + min;
    });
  },
  wrapYoyo = function wrapYoyo(min, max, value) {
    var range = max - min,
      total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
      value = (total + (value - min) % total) % total || 0;
      return min + (value > range ? total - value : value);
    });
  },
  _replaceRandom = function _replaceRandom(value) {
    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
    var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  },
  mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin,
      outRange = outMax - outMin;
    return _conditionalReturn(value, function (value) {
      return outMin + ((value - inMin) / inRange * outRange || 0);
    });
  },
  interpolate = function interpolate(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function (p) {
      return (1 - p) * start + p * end;
    };
    if (!func) {
      var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
        }

        l--;
        func = function func(p) {
          p *= l;
          var i = Math.min(il, ~~p);
          return interpolators[i](p - i);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func(p) {
          return _renderPropTweens(p, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  },
  _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
    //used for nextLabel() and previousLabel()
    var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  },
  _callback = function _callback(animation, type, executeLazyFirst) {
    var v = animation.vars,
      callback = v[type],
      prevContext = _context,
      context = animation._ctx,
      params,
      scope,
      result;
    if (!callback) {
      return;
    }
    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

    context && (_context = context);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  },
  _interrupt = function _interrupt(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  },
  _quickTween,
  _createPlugin = function _createPlugin(config) {
    config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

    var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
      instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
      statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
    _wake();
    if (config !== Plugin) {
      if (_plugins[name]) {
        return;
      }
      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods

      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods

      _plugins[Plugin.prop = name] = Plugin;
      if (config.targetTest) {
        _harnessPlugins.push(Plugin);
        _reservedProps[name] = 1;
      }
      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
    }

    _addGlobal(name, Plugin);
    config.register && config.register(gsap, Plugin, PropTween);
  },
  /*
   * --------------------------------------------------------------------------------------
   * COLORS
   * --------------------------------------------------------------------------------------
   */
  _255 = 255,
  _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  },
  // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
  // let ctx = _doc.createElement("canvas").getContext("2d");
  // _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
  _hue = function _hue(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
  },
  splitColor = function splitColor(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;
    if (!a) {
      if (v.substr(-1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          //for shorthand like #9F0 or #9F0F (could have alpha)
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }
        if (v.length === 9) {
          // hex with alpha, like #fd5e53ff
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);
        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= .5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1); //cast as number

          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = ~~(h + .5);
      a[1] = ~~(s * 100 + .5);
      a[2] = ~~(l * 100 + .5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  },
  _colorOrderData = function _colorOrderData(v) {
    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
    var values = [],
      c = [],
      i = -1;
    v.split(_colorExp).forEach(function (v) {
      var a = v.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  },
  _formatColors = function _formatColors(s, toHSL, orderMatchData) {
    var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function (color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  },
  _colorExp = function () {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
      p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  }(),
  _hslExp = /hsl[a]?\(/,
  _colorStringFilter = function _colorStringFilter(a) {
    var combined = a.join(" "),
      toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

      return true;
    }
  },
  /*
   * --------------------------------------------------------------------------------------
   * TICKER
   * --------------------------------------------------------------------------------------
   */
  _tickerActive,
  _ticker = function () {
    var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
        var elapsed = _getTime() - _lastUpdate,
          manual = v === true,
          overlap,
          dispatch,
          time,
          frame;
        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1000;
          _self.time = time = time / 1000;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

        if (dispatch) {
          for (_i = 0; _i < _listeners.length; _i++) {
            // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
            _listeners[_i](time, _delta, frame, v);
          }
        }
      };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1000 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _raf = _win.requestAnimationFrame;
          }
          _id && _self.sleep();
          _req = _raf || function (f) {
            return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited

        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1000 / (_fps || 240);
        _nextTime = _self.time * 1000 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function (t, d, f, v) {
          callback(t, d, f, v);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
      },
      _listeners: _listeners
    };
    return _self;
  }(),
  _wake = function _wake() {
    return !_tickerActive && _ticker.wake();
  },
  //also ensures the core classes are initialized.

  /*
  * -------------------------------------------------
  * EASING
  * -------------------------------------------------
  */
  _easeMap = {},
  _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
  _quotesExp = /["']/g,
  _parseObjectInString = function _parseObjectInString(value) {
    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
    var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;
    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  },
  _valueInParentheses = function _valueInParentheses(value) {
    var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  },
  _configEaseFromString = function _configEaseFromString(name) {
    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
    var split = (name + "").split("("),
      ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  },
  _invertEase = function _invertEase(ease) {
    return function (p) {
      return 1 - ease(1 - p);
    };
  },
  // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
  _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
    var child = timeline._first,
      ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  },
  _parseEase = function _parseEase(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  },
  _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut(p) {
        return 1 - easeIn(1 - p);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut(p) {
        return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }
    var ease = {
        easeIn: easeIn,
        easeOut: easeOut,
        easeInOut: easeInOut
      },
      lowercaseName;
    _forEachName(names, function (name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });
    return ease;
  },
  _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
    return function (p) {
      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
    };
  },
  _configElastic = function _configElastic(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
      p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2; //precalculate to optimize

    ease.config = function (amplitude, period) {
      return _configElastic(type, amplitude, period);
    };
    return ease;
  },
  _configBack = function _configBack(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
    ease.config = function (overshoot) {
      return _configBack(type, overshoot);
    };
    return ease;
  }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };
exports._ticker = _ticker;
exports._colorStringFilter = _colorStringFilter;
exports._colorExp = _colorExp;
exports.splitColor = splitColor;
exports.interpolate = interpolate;
exports.mapRange = mapRange;
exports._replaceRandom = _replaceRandom;
exports.wrapYoyo = wrapYoyo;
exports.wrap = wrap;
exports.normalize = normalize;
exports.unitize = unitize;
exports.pipe = pipe;
exports.random = random;
exports.snap = snap;
exports._roundModifier = _roundModifier;
exports.distribute = distribute;
exports.shuffle = shuffle;
exports.selector = selector;
exports.toArray = toArray;
exports.clamp = clamp;
exports.getUnit = getUnit;
exports._removeLinkedListItem = _removeLinkedListItem;
exports._setDefaults = _setDefaults;
exports._parseRelative = _parseRelative;
exports._round = _round;
exports._forEachName = _forEachName;
exports._getProperty = _getProperty;
exports._getCache = _getCache;
exports._plugins = _plugins;
exports._missingPlugin = _missingPlugin;
exports._relExp = _relExp;
exports._numWithUnitExp = _numWithUnitExp;
exports._numExp = _numExp;
exports._isUndefined = _isUndefined;
exports._isString = _isString;
exports._config = _config;
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;
  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
(function (n, c) {
  var n1 = 1 / c,
    n2 = 2 * n1,
    n3 = 2.5 * n1,
    easeOut = function easeOut(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
    };
  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);
_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});
_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});
_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }
    var p1 = 1 / steps,
      p2 = steps + (immediateStart ? 0 : 1),
      p3 = immediateStart ? 1 : 0,
      max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */

var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */
exports.GSCache = GSCache;
var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;
    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }
    this._ts = 1;
    _setDuration(this, +vars.duration, 1, 1);
    this.data = vars.data;
    if (_context) {
      this._ctx = _context;
      _context.data.push(this);
    }
    _tickerActive || _ticker.wake();
  }
  var _proto = Animation.prototype;
  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }
    return this._delay;
  };
  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };
  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }
    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };
  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();
    if (!arguments.length) {
      return this._tTime;
    }
    var parent = this._dp;
    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);
      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }
        parent = parent.parent;
      }
      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }
    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}
    }

    return this;
  };
  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };
  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };
  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }
    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);
    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.

    return _recacheAncestors(this);
  };
  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }
    if (this._ps !== value) {
      this._ps = value;
      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();
        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };
  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }
    return this._start;
  };
  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };
  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };
  _proto.revert = function revert(config) {
    if (config === void 0) {
      config = _revertConfig;
    }
    var prevIsReverting = _reverting;
    _reverting = config;
    if (this._initted || this._startAt) {
      this.timeline && this.timeline.revert(config);
      this.totalTime(-0.01, config.suppressEvents);
    }
    this.data !== "nested" && config.kill !== false && this.kill();
    _reverting = prevIsReverting;
    return this;
  };
  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
      time = arguments.length ? rawTime : animation.rawTime();
    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }
    return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). "_sat" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }
    return this._repeat === -2 ? Infinity : this._repeat;
  };
  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;
      _onUpdateTotalDuration(this);
      return time ? this.time(time) : this;
    }
    return this._rDelay;
  };
  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }
    return this._yoyo;
  };
  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };
  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };
  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };
  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };
  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };
  _proto.resume = function resume() {
    return this.paused(false);
  };
  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }
    return this._rts < 0;
  };
  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };
  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
      start = this._start,
      rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };
  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;
    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }
      return this;
    }
    return vars[type];
  };
  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
        _resolve = function _resolve() {
          var _then = self.then;
          self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

          _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
          resolve(f);
          self.then = _then;
        };
      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };
  _proto.kill = function kill() {
    _interrupt(this);
  };
  return Animation;
}();
exports.Animation = Animation;
_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */

var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);
  function Timeline(vars, position) {
    var _this;
    if (vars === void 0) {
      vars = {};
    }
    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }
  var _proto2 = Timeline.prototype;
  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);
    return this;
  };
  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);
    return this;
  };
  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);
    return this;
  };
  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };
  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };
  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
      tDur = this._dirty ? this.totalDuration() : this._tDur,
      dur = this._dur,
      tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
      // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
      crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
      time,
      child,
      next,
      iteration,
      cycleDuration,
      prevPaused,
      pauseTween,
      timeScale,
      prevStart,
      prevIteration,
      yoyo,
      isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }
      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;
      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }
      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */

        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
            doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }
          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;
          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }
          this._lock = 0;
          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.

          _propagateYoyoEase(this, isYoyo);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }
      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }
      if (time >= prevTime && totalTime >= 0) {
        child = this._first;
        while (child) {
          next = child._next;
          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }
          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;
          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }
          child = next;
        }
      }
      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }
    return this;
  };
  _proto2.add = function add(child, position) {
    var _this2 = this;
    _isNumber(position) || (position = _parsePosition(this, position, child));
    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }
      if (_isString(child)) {
        return this.addLabel(child, position);
      }
      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }
    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }
    if (tweens === void 0) {
      tweens = true;
    }
    if (timelines === void 0) {
      timelines = true;
    }
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }
    var a = [],
      child = this._first;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }
      child = child._next;
    }
    return a;
  };
  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
      i = animations.length;
    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };
  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }
    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }
    _removeLinkedListItem(this, child);
    if (child === this._recent) {
      this._recent = this._last;
    }
    return _uncache(this);
  };
  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }
    this._forcing = 1;
    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }
    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
    this._forcing = 0;
    return this;
  };
  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };
  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };
  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };
  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);
    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }
      child = child._next;
    }
  };
  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
      i = tweens.length;
    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }
    return this;
  };
  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
      parsedTargets = toArray(targets),
      child = this._first,
      isGlobalTime = _isNumber(onlyActive),
      // a number is interpreted as a global time. If the animation spans
      children;
    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }
      child = child._next;
    }
    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};
    var tl = this,
      endTime = _parsePosition(tl, position),
      _vars = vars,
      startAt = _vars.startAt,
      _onStart = _vars.onStart,
      onStartParams = _vars.onStartParams,
      immediateRender = _vars.immediateRender,
      initted,
      tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
        }
      }, vars));
    return immediateRender ? tween.render(0) : tween;
  };
  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };
  _proto2.recent = function recent() {
    return this._recent;
  };
  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };
  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };
  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };
  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }
    var child = this._first,
      labels = this.labels,
      p;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }
      child = child._next;
    }
    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }
    return _uncache(this);
  };
  _proto2.invalidate = function invalidate(soft) {
    var child = this._first;
    this._lock = 0;
    while (child) {
      child.invalidate(soft);
      child = child._next;
    }
    return _Animation.prototype.invalidate.call(this, soft);
  };
  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }
    var child = this._first,
      next;
    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }
    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };
  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
      self = this,
      child = self._last,
      prevStart = _bigNum,
      prev,
      start,
      parent;
    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }
    if (self._dirty) {
      parent = self.parent;
      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;
        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }
        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;
          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }
          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }
        child._end > max && child._ts && (max = child._end);
        child = prev;
      }
      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
      self._dirty = 0;
    }
    return self._tDur;
  };
  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
      _lastRenderedFrame = _ticker.frame;
    }
    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }
        child || _ticker.sleep();
      }
    }
  };
  return Timeline;
}(Animation);
exports.TimelineLite = exports.TimelineMax = exports.Timeline = Timeline;
_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings

    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

    return pt;
  },
  _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          // to avoid isNaN, like if someone passes in a value like "!= whatever"
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        // fun fact: any number multiplied by "" is evaluated as the number 0!
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  },
  //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
  _processVars = function _processVars(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {},
      p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  },
  _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  },
  _overwritingTween,
  //store a reference temporarily so we can avoid overwriting itself.
  _forceAllPropTweens,
  _initTween = function _initTween(tween, time, tTime) {
    var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

    if (!tl || keyframes && !vars.stagger) {
      //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.

        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
        // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate,
          onUpdateParams: onUpdateParams,
          callbackScope: callbackScope,
          stagger: 0
        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);

        tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.

        tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween

        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.
            time && (tween._zTime = time);
            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          }
        }
      } else if (runBackwards && dur) {
        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
        if (!prevStartAt) {
          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender: immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0; // don't allow it to get put back into root timeline!

          tween._startAt._sat = tween; // used in globalTime()

          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function (name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!

          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
    }

    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

    keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
  },
  _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      rootPT,
      lookup,
      i;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;
      while (i--) {
        pt = lookup[i][property];
        if (pt && pt.d && pt.d._pt) {
          // it's a plugin, so find the nested PropTween
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
            pt = pt._next;
          }
        }
        if (!pt) {
          // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
          // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
          _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return 1;
        }
        ptCache.push(pt);
      }
    }
    i = ptCache.length;
    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
    }
  },
  _addAliasesToVars = function _addAliasesToVars(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  },
  // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
  _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;
    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

      obj.forEach(function (value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  },
  _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  },
  _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  _staggerPropsToSkip = {};
exports._checkPlugin = _checkPlugin;
_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */

var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);
  function Tween(targets, vars, position, skipInherit) {
    var _this3;
    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }
    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
      duration = _this3$vars.duration,
      delay = _this3$vars.delay,
      immediateRender = _this3$vars.immediateRender,
      stagger = _this3$vars.stagger,
      overwrite = _this3$vars.overwrite,
      keyframes = _this3$vars.keyframes,
      defaults = _this3$vars.defaults,
      scrollTrigger = _this3$vars.scrollTrigger,
      yoyoEase = _this3$vars.yoyoEase,
      parent = vars.parent || _globalTimeline,
      parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
      tl,
      i,
      copy,
      l,
      p,
      curTarget,
      staggerFunc,
      staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;
    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;
      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);
        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }
        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }
          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }
        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));
        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
          a,
          kf,
          v;
        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
        } else {
          copy = {};
          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }
          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;
            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }
          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);
      _globalTimeline.killTweensOf(parsedTargets);
      _overwritingTween = 0;
    }
    _addToTimeline(parent, _assertThisInitialized(_this3), position);
    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);
    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative
    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }
  var _proto3 = Tween.prototype;
  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
      tDur = this._tDur,
      dur = this._dur,
      isNegative = totalTime < 0,
      tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
      time,
      pt,
      iteration,
      cycleDuration,
      prevIteration,
      isYoyo,
      ratio,
      timeline,
      yoyoEase;
    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;
      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        isYoyo = this._yoyo && iteration & 1;
        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }
        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }
      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }
        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }
        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._tTime = tTime;
      this._time = time;
      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }
      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }
      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }
      pt = this._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }
      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }
    return this;
  };
  _proto3.targets = function targets() {
    return this._targets;
  };
  _proto3.invalidate = function invalidate(soft) {
    // "soft" gives us a way to clear out everything EXCEPT the recorded pre-"from" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the "from" values would persist and then on the next render, the from() tweens would initialize and the current value would match the "from" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.
    (!soft || !this.vars.runBackwards) && (this._startAt = 0);
    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate(soft);
    return _Animation2.prototype.invalidate.call(this, soft);
  };
  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
      ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}

    _alignPlayhead(this, 0);
    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };
  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }
    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }
    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }
    var parsedTargets = this._targets,
      killingTargets = targets ? toArray(targets) : parsedTargets,
      propTweenLookup = this._ptLookup,
      firstPT = this._pt,
      overwrittenProps,
      curLookup,
      curOverwriteProps,
      props,
      p,
      pt,
      i;
    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }
    overwrittenProps = this._op = this._op || [];
    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};
        _forEachName(vars, function (name) {
          return p[name] = 1;
        });
        vars = p;
      }
      vars = _addAliasesToVars(parsedTargets, vars);
    }
    i = parsedTargets.length;
    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];
        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }
        for (p in props) {
          pt = curLookup && curLookup[p];
          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }
            delete curLookup[p];
          }
          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }
    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };
  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };
  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };
  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };
  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };
  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };
  return Tween;
}(Animation);
exports.TweenLite = exports.TweenMax = exports.Tween = Tween;
_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.

_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
      params = _slice.call(arguments, 0);
    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */

var _setterPlain = function _setterPlain(target, property, value) {
    return target[property] = value;
  },
  _setterFunc = function _setterFunc(target, property, value) {
    return target[property](value);
  },
  _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
    return target[property](data.fp, value);
  },
  _setterAttribute = function _setterAttribute(target, property, value) {
    return target.setAttribute(property, value);
  },
  _getSetter = function _getSetter(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  },
  _renderPlain = function _renderPlain(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
  },
  _renderBoolean = function _renderBoolean(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  },
  _renderComplexString = function _renderComplexString(ratio, data) {
    var pt = data._pt,
      s = "";
    if (!ratio && data.b) {
      //b = beginning string
      s = data.b;
    } else if (ratio === 1 && data.e) {
      //e = ending string
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

        pt = pt._next;
      }
      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
    }

    data.set(data.t, data.p, s, data);
  },
  _renderPropTweens = function _renderPropTweens(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  },
  _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
    var pt = this._pt,
      next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  },
  _killPropTweensOf = function _killPropTweensOf(property) {
    var pt = this._pt,
      hasNonDependentRemaining,
      next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  },
  _setterWithModifier = function _setterWithModifier(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  },
  _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
    var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)
exports._sortPropTweensByPriority = _sortPropTweensByPriority;
exports._renderComplexString = _renderComplexString;
exports._getSetter = _getSetter;
var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;
    if (next) {
      next._prev = this;
    }
  }
  var _proto4 = PropTween.prototype;
  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };
  return PropTween;
}(); //Initialization tasks
exports.PropTween = PropTween;
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
var _media = [],
  _listeners = {},
  _emptyArray = [],
  _lastMediaTime = 0,
  _dispatch = function _dispatch(type) {
    return (_listeners[type] || _emptyArray).map(function (f) {
      return f();
    });
  },
  _onMediaChange = function _onMediaChange() {
    var time = Date.now(),
      matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function (c) {
        var queries = c.queries,
          conditions = c.conditions,
          match,
          p,
          anyMatch,
          toggled;
        for (p in queries) {
          match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

          match && (anyMatch = 1);
          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function (c) {
        return c.onMatch(c);
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
var Context = /*#__PURE__*/function () {
  function Context(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = []; // returned/cleanup functions

    this.isReverted = false;
    func && this.add(func);
  }
  var _proto5 = Context.prototype;
  _proto5.add = function add(name, func, scope) {
    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.
    // if (name && _isFunction(name.revert)) {
    // 	this.data.push(name);
    // 	return (name._ctx = this);
    // }
    if (_isFunction(name)) {
      scope = func;
      func = name;
      name = _isFunction;
    }
    var self = this,
      f = function f() {
        var prev = _context,
          prevSelector = self.selector,
          result;
        prev && prev !== self && prev.data.push(self);
        scope && (self.selector = selector(scope));
        _context = self;
        result = func.apply(self, arguments);
        _isFunction(result) && self._r.push(result);
        _context = prev;
        self.selector = prevSelector;
        self.isReverted = false;
        return result;
      };
    self.last = f;
    return name === _isFunction ? f(self) : name ? self[name] = f : f;
  };
  _proto5.ignore = function ignore(func) {
    var prev = _context;
    _context = null;
    func(this);
    _context = prev;
  };
  _proto5.getTweens = function getTweens() {
    var a = [];
    this.data.forEach(function (e) {
      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
    });
    return a;
  };
  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };
  _proto5.kill = function kill(revert, matchMedia) {
    var _this4 = this;
    if (revert) {
      var tweens = this.getTweens();
      this.data.forEach(function (t) {
        // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.
        if (t.data === "isFlip") {
          t.revert();
          t.getChildren(true, true, false).forEach(function (tween) {
            return tweens.splice(tweens.indexOf(tween), 1);
          });
        }
      }); // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort

      tweens.map(function (t) {
        return {
          g: t.globalTime(0),
          t: t
        };
      }).sort(function (a, b) {
        return b.g - a.g || -1;
      }).forEach(function (o) {
        return o.t.revert(revert);
      }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

      this.data.forEach(function (e) {
        return !(e instanceof Animation) && e.revert && e.revert(revert);
      });
      this._r.forEach(function (f) {
        return f(revert, _this4);
      });
      this.isReverted = true;
    } else {
      this.data.forEach(function (e) {
        return e.kill && e.kill();
      });
    }
    this.clear();
    if (matchMedia) {
      var i = _media.indexOf(this);
      !!~i && _media.splice(i, 1);
    }
  };
  _proto5.revert = function revert(config) {
    this.kill(config || {});
  };
  return Context;
}();
var MatchMedia = /*#__PURE__*/function () {
  function MatchMedia(scope) {
    this.contexts = [];
    this.scope = scope;
  }
  var _proto6 = MatchMedia.prototype;
  _proto6.add = function add(conditions, func, scope) {
    _isObject(conditions) || (conditions = {
      matches: conditions
    });
    var context = new Context(0, scope || this.scope),
      cond = context.conditions = {},
      mq,
      p,
      active;
    this.contexts.push(context);
    func = context.add("onMatch", func);
    context.queries = conditions;
    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win.matchMedia(conditions[p]);
        if (mq) {
          _media.indexOf(context) < 0 && _media.push(context);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }
    active && func(context);
    return this;
  } // refresh() {
  // 	let time = _lastMediaTime,
  // 		media = _media;
  // 	_lastMediaTime = -1;
  // 	_media = this.contexts;
  // 	_onMediaChange();
  // 	_lastMediaTime = time;
  // 	_media = media;
  // }
  ;

  _proto6.revert = function revert(config) {
    this.kill(config || {});
  };
  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function (c) {
      return c.kill(revert, true);
    });
  };
  return MatchMedia;
}();
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
      format = unit ? _passThrough : _numericIfPossible;
    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);
    if (target.length > 1) {
      var setters = target.map(function (t) {
          return gsap.quickSetter(t, property, unit);
        }),
        l = setters.length;
      return function (value) {
        var i = l;
        while (i--) {
          setters[i](value);
        }
      };
    }
    target = target[0] || {};
    var Plugin = _plugins[property],
      cache = _getCache(target),
      p = cache.harness && (cache.harness.aliases || {})[property] || property,
      // in case it's an alias, like "rotate" for "rotation".
      setter = Plugin ? function (value) {
        var p = new Plugin();
        _quickTween._pt = 0;
        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p.render(1, p);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;
    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
      func = function func(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
      effect = _ref3.effect,
      plugins = _ref3.plugins,
      defaults = _ref3.defaults,
      extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });
    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };
    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }
    var tl = new Timeline(vars),
      child,
      next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
    _globalTimeline.remove(tl);
    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;
    while (child) {
      next = child._next;
      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }
      child = next;
    }
    _addToTimeline(_globalTimeline, tl, 0);
    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function (c) {
      var cond = c.conditions,
        found,
        p;
      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }
      found && c.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a = _listeners[type],
      i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting;
    },
    context: function context(toAdd) {
      if (toAdd && _context) {
        _context.data.push(toAdd);
        toAdd._ctx = _context;
      }
      return _context;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  },
  _addModifiers = function _addModifiers(tween, modifiers) {
    var targets = tween._targets,
      p,
      i,
      pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            // is a plugin
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  },
  _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
    return {
      name: name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init(target, vars, tween) {
        tween._onInit = function (tween) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function (name) {
              return temp[name] = 1;
            }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.

            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween, vars);
        };
      }
    };
  }; //register core plugins

var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;
    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v; // record the beginning value so we can revert()

      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;
    while (pt) {
      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;
    while (i--) {
      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.
exports.default = exports.gsap = gsap;
Tween.version = Timeline.version = gsap.version = "3.11.4";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
  Power1 = _easeMap.Power1,
  Power2 = _easeMap.Power2,
  Power3 = _easeMap.Power3,
  Power4 = _easeMap.Power4,
  Linear = _easeMap.Linear,
  Quad = _easeMap.Quad,
  Cubic = _easeMap.Cubic,
  Quart = _easeMap.Quart,
  Quint = _easeMap.Quint,
  Strong = _easeMap.Strong,
  Elastic = _easeMap.Elastic,
  Back = _easeMap.Back,
  SteppedEase = _easeMap.SteppedEase,
  Bounce = _easeMap.Bounce,
  Sine = _easeMap.Sine,
  Expo = _easeMap.Expo,
  Circ = _easeMap.Circ;
exports.Circ = Circ;
exports.Expo = Expo;
exports.Sine = Sine;
exports.Bounce = Bounce;
exports.SteppedEase = SteppedEase;
exports.Back = Back;
exports.Elastic = Elastic;
exports.Strong = Strong;
exports.Quint = Quint;
exports.Quart = Quart;
exports.Cubic = Cubic;
exports.Quad = Quad;
exports.Linear = Linear;
exports.Power4 = Power4;
exports.Power3 = Power3;
exports.Power2 = Power2;
exports.Power1 = Power1;
exports.Power0 = Power0;
},{}],"node_modules/gsap/CSSPlugin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.checkPrefix = exports._getBBox = exports._createElement = exports.CSSPlugin = void 0;
var _gsapCore = require("./gsap-core.js");
/*!
 * CSSPlugin 3.11.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */

var _win,
  _doc,
  _docElement,
  _pluginInitted,
  _tempDiv,
  _tempDivStyler,
  _recentSetterPlugin,
  _reverting,
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _transformProps = {},
  _RAD2DEG = 180 / Math.PI,
  _DEG2RAD = Math.PI / 180,
  _atan2 = Math.atan2,
  _bigNum = 1e8,
  _capsExp = /([A-Z])/g,
  _horizontalExp = /(left|right|width|margin|padding|x)/i,
  _complexExp = /[\s,\(]\S/,
  _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  },
  _renderCSSProp = function _renderCSSProp(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
  _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
  _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
  //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
  },
  _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  },
  _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  },
  _setterCSSStyle = function _setterCSSStyle(target, property, value) {
    return target.style[property] = value;
  },
  _setterCSSProp = function _setterCSSProp(target, property, value) {
    return target.style.setProperty(property, value);
  },
  _setterTransform = function _setterTransform(target, property, value) {
    return target._gsap[property] = value;
  },
  _setterScale = function _setterScale(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  },
  _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  },
  _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  },
  _transformProp = "transform",
  _transformOriginProp = _transformProp + "Origin",
  _saveStyle = function _saveStyle(property, isNotCSS) {
    var _this = this;
    var target = this.target,
      style = target.style;
    if (property in _transformProps) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function (a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.
      }

      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (target._gsap.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  },
  _removeIndependentTransforms = function _removeIndependentTransforms(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  },
  _revertStyle = function _revertStyle() {
    var props = this.props,
      target = this.target,
      style = target.style,
      cache = target._gsap,
      i,
      p;
    for (i = 0; i < props.length; i += 3) {
      // stored like this: property, isNotCSS, value
      props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i = _reverting();
      if (i && !i.isStart && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
      }
    }
  },
  _getStyleSaver = function _getStyleSaver(target, properties) {
    var saver = {
      target: target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    properties && properties.split(",").forEach(function (p) {
      return saver.save(p);
    });
    return saver;
  },
  _supports3D,
  _createElement = function _createElement(type, ns) {
    var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

    return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  },
  _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
  },
  _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
  _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
    var e = element || _tempDiv,
      s = e.style,
      i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {}
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  },
  _initCore = function _initCore() {
    if (_windowExists() && window.document) {
      _win = window;
      _doc = _win.document;
      _docElement = _doc.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

      _supports3D = !!_checkPropPrefix("perspective");
      _reverting = _gsapCore.gsap.core.reverting;
      _pluginInitted = 1;
    }
  },
  _getBBoxHack = function _getBBoxHack(swapIfPossible) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox; //store the original

        this.getBBox = _getBBoxHack;
      } catch (e) {}
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  },
  _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  },
  _getBBox = function _getBBox(target) {
    var bounds;
    try {
      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  },
  _isSVG = function _isSVG(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
  //reports if the element is an SVG on which getBBox() actually works
  _removeProperty = function _removeProperty(target, property) {
    if (property) {
      var style = target.style;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          property = "-" + property;
        }
        style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        style.removeAttribute(property);
      }
    }
  },
  _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  },
  _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  },
  _nonStandardLayouts = {
    grid: 1,
    flex: 1
  },
  //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
  _convertToUnit = function _convertToUnit(target, property, value, unit) {
    var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
      style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return (0, _gsapCore._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc || !parent.appendChild) {
      parent = _doc.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _gsapCore._ticker.time && !cache.uncache) {
      return (0, _gsapCore._round)(curValue / cache.width * amount);
    } else {
      (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
      parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

      parent.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent.removeChild(_tempDiv);
      style.position = "absolute";
      if (horizontal && toPercent) {
        cache = (0, _gsapCore._getCache)(parent);
        cache.time = _gsapCore._ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return (0, _gsapCore._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  },
  _get = function _get(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsapCore._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
      }
    }

    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  },
  _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    if (!start || start === "none") {
      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
      var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
      }
    }

    var pt = new _gsapCore.PropTween(this._pt, target.style, prop, 0, 1, _gsapCore._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
    pt.b = start;
    pt.e = end;
    start += ""; // ensure values are strings

    end += "";
    if (end === "auto") {
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      target.style[prop] = start;
    }
    a = [start, end];
    (0, _gsapCore._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().

    start = a[0];
    end = a[1];
    startValues = start.match(_gsapCore._numWithUnitExp) || [];
    endValues = end.match(_gsapCore._numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _gsapCore._numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = (0, _gsapCore._parseRelative)(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _gsapCore._numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            //if something like "perspective:300" is passed in and we must add a unit to the end
            endUnit = endUnit || _gsapCore._config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _gsapCore._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

    return pt;
  },
  _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  },
  _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
    var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      //the user provided them in the wrong order, so flip them
      value = x;
      x = y;
      y = value;
    }
    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  },
  _renderClearProps = function _renderClearProps(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.

          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  },
  // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
  _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  },
  /*
   * --------------------------------------------------------------------------------------
   * TRANSFORMS
   * --------------------------------------------------------------------------------------
   */
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
  _rotationalProperties = {},
  _isNullTransform = function _isNullTransform(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  },
  _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsapCore._numExp).map(_gsapCore._round);
  },
  _getMatrix = function _getMatrix(target, force2D) {
    var cache = target._gsap || (0, _gsapCore._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent) {
        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
        addedToDOM = 1; //flag

        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly
      }

      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  },
  _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  },
  _parseTransform = function _parseTransform(target, uncache) {
    var cache = target._gsap || new _gsapCore.GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      cs = getComputedStyle(target),
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      // accommodate independent transforms by combining them into normal ones.
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
      }

      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0]; //a11

      b = matrix[1]; //a21

      c = matrix[2]; //a31

      d = matrix[3]; //a41

      x = a12 = matrix[4];
      y = a22 = matrix[5]; //2D matrix

      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        } //3D matrix
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG; //rotationX

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        } //rotationY

        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        } //rotationZ

        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = (0, _gsapCore._round)(Math.sqrt(a * a + b * b + c * c));
        scaleY = (0, _gsapCore._round)(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = (0, _gsapCore._round)(scaleX);
    cache.scaleY = (0, _gsapCore._round)(scaleY);
    cache.rotation = (0, _gsapCore._round)(rotation) + deg;
    cache.rotationX = (0, _gsapCore._round)(rotationX) + deg;
    cache.rotationY = (0, _gsapCore._round)(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _gsapCore._config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  },
  _firstTwoOnly = function _firstTwoOnly(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  },
  //for handling transformOrigin values, stripping out the 3rd dimension
  _addPxTranslate = function _addPxTranslate(target, start, value) {
    var unit = (0, _gsapCore.getUnit)(start);
    return (0, _gsapCore._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  },
  _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  },
  _zeroDeg = "0deg",
  _zeroPx = "0px",
  _endParenthesis = ") ",
  _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
    var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)

    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  },
  _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
    var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = (0, _gsapCore._round)(a11);
      a21 = (0, _gsapCore._round)(a21);
      a12 = (0, _gsapCore._round)(a12);
      a22 = (0, _gsapCore._round)(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = (0, _gsapCore._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = (0, _gsapCore._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
      temp = target.getBBox();
      tx = (0, _gsapCore._round)(tx + xPercent / 100 * temp.width);
      ty = (0, _gsapCore._round)(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
  },
  _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
    var cap = 360,
      isString = (0, _gsapCore._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new _gsapCore.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  },
  _assign = function _assign(target, source) {
    // Internet Explorer doesn't have Object.assign(), so we recreate it here.
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  },
  _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
    var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        startUnit = (0, _gsapCore.getUnit)(startValue);
        endUnit = (0, _gsapCore.getUnit)(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new _gsapCore.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.
exports._getBBox = _getBBox;
exports.checkPrefix = _checkPropPrefix;
exports._createElement = _createElement;
(0, _gsapCore._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
    r = "Right",
    b = "Bottom",
    l = "Left",
    props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
      return index < 2 ? name + side : "border" + side + name;
    });
  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;
    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }
    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
      style = target.style,
      startAt = tween.vars.startAt,
      startValue,
      endValue,
      endNum,
      startNum,
      type,
      specialProp,
      p,
      startUnit,
      endUnit,
      relative,
      isTransformRelated,
      transformPropTween,
      cache,
      smooth,
      hasPriority,
      inlineProps;
    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

    this.styles = this.styles || _getStyleSaver(target);
    inlineProps = this.styles.props;
    this.tween = tween;
    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }
      endValue = vars[p];
      if (_gsapCore._plugins[p] && (0, _gsapCore._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }
      type = typeof endValue;
      specialProp = _specialProps[p];
      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }
      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0, _gsapCore._replaceRandom)(endValue);
      }
      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsapCore._colorExp.lastIndex = 0;
        if (!_gsapCore._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0, _gsapCore.getUnit)(startValue);
          endUnit = (0, _gsapCore.getUnit)(endValue);
        }
        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, 0, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0, _gsapCore._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsapCore._replaceRandom)(startValue));
          (0, _gsapCore.getUnit)(startValue + "") || (startValue += _gsapCore._config.units[p] || (0, _gsapCore.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);
        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }
            inlineProps.push("visibility", 0, style.visibility);
            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }
          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }
        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          this.styles.save(p);
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsapCore.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsapCore.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsapCore._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }
            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);
            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsapCore._parseRelative)(startNum, relative + endValue) : endValue);
            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);
            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }
        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0, _gsapCore.getUnit)(endValue) || (p in _gsapCore._config.units ? _gsapCore._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsapCore.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsapCore._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;
          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else if (p !== "parseTransform") {
            (0, _gsapCore._missingPlugin)(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }
        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
        props.push(p);
      }
    }
    hasPriority && (0, _gsapCore._sortPropTweensByPriority)(this);
  },
  render: function render(ratio, data) {
    if (data.tween._time || !_reverting()) {
      var pt = data._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsapCore._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsapCore._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
exports.default = exports.CSSPlugin = CSSPlugin;
_gsapCore.gsap.utils.checkPrefix = _checkPropPrefix;
_gsapCore.gsap.core.getStyleSaver = _getStyleSaver;
(function (positionAndScale, rotation, others, aliases) {
  var all = (0, _gsapCore._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });
  (0, _gsapCore._forEachName)(rotation, function (name) {
    _gsapCore._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  (0, _gsapCore._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
(0, _gsapCore._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsapCore._config.units[name] = "px";
});
_gsapCore.gsap.registerPlugin(CSSPlugin);
},{"./gsap-core.js":"node_modules/gsap/gsap-core.js"}],"node_modules/gsap/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Back", {
  enumerable: true,
  get: function () {
    return _gsapCore.Back;
  }
});
Object.defineProperty(exports, "Bounce", {
  enumerable: true,
  get: function () {
    return _gsapCore.Bounce;
  }
});
Object.defineProperty(exports, "CSSPlugin", {
  enumerable: true,
  get: function () {
    return _CSSPlugin.CSSPlugin;
  }
});
Object.defineProperty(exports, "Circ", {
  enumerable: true,
  get: function () {
    return _gsapCore.Circ;
  }
});
Object.defineProperty(exports, "Cubic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Cubic;
  }
});
Object.defineProperty(exports, "Elastic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Elastic;
  }
});
Object.defineProperty(exports, "Expo", {
  enumerable: true,
  get: function () {
    return _gsapCore.Expo;
  }
});
Object.defineProperty(exports, "Linear", {
  enumerable: true,
  get: function () {
    return _gsapCore.Linear;
  }
});
Object.defineProperty(exports, "Power0", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power0;
  }
});
Object.defineProperty(exports, "Power1", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power1;
  }
});
Object.defineProperty(exports, "Power2", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power2;
  }
});
Object.defineProperty(exports, "Power3", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power3;
  }
});
Object.defineProperty(exports, "Power4", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power4;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quad;
  }
});
Object.defineProperty(exports, "Quart", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quart;
  }
});
Object.defineProperty(exports, "Quint", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quint;
  }
});
Object.defineProperty(exports, "Sine", {
  enumerable: true,
  get: function () {
    return _gsapCore.Sine;
  }
});
Object.defineProperty(exports, "SteppedEase", {
  enumerable: true,
  get: function () {
    return _gsapCore.SteppedEase;
  }
});
Object.defineProperty(exports, "Strong", {
  enumerable: true,
  get: function () {
    return _gsapCore.Strong;
  }
});
Object.defineProperty(exports, "TimelineLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineLite;
  }
});
Object.defineProperty(exports, "TimelineMax", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineMax;
  }
});
Object.defineProperty(exports, "TweenLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TweenLite;
  }
});
exports.gsap = exports.default = exports.TweenMax = void 0;
var _gsapCore = require("./gsap-core.js");
var _CSSPlugin = require("./CSSPlugin.js");
var gsapWithCSS = _gsapCore.gsap.registerPlugin(_CSSPlugin.CSSPlugin) || _gsapCore.gsap,
  // to protect from tree shaking
  TweenMaxWithCSS = gsapWithCSS.core.Tween;
exports.TweenMax = TweenMaxWithCSS;
exports.default = exports.gsap = gsapWithCSS;
},{"./gsap-core.js":"node_modules/gsap/gsap-core.js","./CSSPlugin.js":"node_modules/gsap/CSSPlugin.js"}],"node_modules/gsap/Observer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports._vertical = exports._scrollers = exports._proxies = exports._isViewport = exports._horizontal = exports._getVelocityProp = exports._getTarget = exports._getScrollFunc = exports._getProxyProp = exports.Observer = void 0;
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/*!
 * Observer 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
  _coreInitted,
  _clamp,
  _win,
  _doc,
  _docEl,
  _body,
  _isTouch,
  _pointerType,
  ScrollTrigger,
  _root,
  _normalizer,
  _eventTypes,
  _context,
  _getGSAP = function _getGSAP() {
    return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
  _passThrough = function _passThrough(p) {
    return p;
  },
  _startup = 1,
  _observers = [],
  _scrollers = [],
  _proxies = [],
  _getTime = Date.now,
  _bridge = function _bridge(name, value) {
    return value;
  },
  _integrate = function _integrate() {
    var core = ScrollTrigger.core,
      data = core.bridge || {},
      scrollers = core._scrollers,
      proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    exports._scrollers = _scrollers = scrollers;
    exports._proxies = _proxies = proxies;
    _bridge = function _bridge(name, value) {
      return data[name](value);
    };
  },
  _getProxyProp = function _getProxyProp(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  },
  _isViewport = function _isViewport(el) {
    return !!~_root.indexOf(el);
  },
  _addListener = function _addListener(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  },
  _removeListener = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
  _scrollLeft = "scrollLeft",
  _scrollTop = "scrollTop",
  _onScroll = function _onScroll() {
    return _normalizer && _normalizer.isPressed || _scrollers.cache++;
  },
  _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
    var cachingFunc = function cachingFunc(value) {
      // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
      if (value || value === 0) {
        _startup && (_win.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

        f(value);
        cachingFunc.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
      } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
        cachingFunc.cacheID = _scrollers.cache;
        cachingFunc.v = f();
      }
      return cachingFunc.v + cachingFunc.offset;
    };
    cachingFunc.offset = 0;
    return f && cachingFunc;
  },
  _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    })
  },
  _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    })
  },
  _getTarget = function _getTarget(t) {
    return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  },
  _getScrollFunc = function _getScrollFunc(element, _ref) {
    var s = _ref.s,
      sc = _ref.sc;
    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
    _isViewport(element) && (element = _doc.scrollingElement || _docEl);
    var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;
    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || element.addEventListener("scroll", _onScroll); // clear the cache when a scroll occurs

    var prev = _scrollers[i + offset],
      func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
        return arguments.length ? element[s] = value : element[s];
      })));
    func.target = element;
    prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.

    return func;
  },
  _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
    var v1 = value,
      v2 = value,
      t1 = _getTime(),
      t2 = t1,
      min = minTimeRefresh || 50,
      dropToZeroTime = Math.max(500, min * 3),
      update = function update(value, force) {
        var t = _getTime();
        if (force || t - t1 > min) {
          v2 = v1;
          v1 = value;
          t2 = t1;
          t1 = t;
        } else if (useDelta) {
          v1 += value;
        } else {
          // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
          v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
        }
      },
      reset = function reset() {
        v2 = v1 = useDelta ? 0 : v1;
        t2 = t1 = 0;
      },
      getVelocity = function getVelocity(latestValue) {
        var tOld = t2,
          vOld = v2,
          t = _getTime();
        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
      };
    return {
      update: update,
      reset: reset,
      getVelocity: getVelocity
    };
  },
  _getEvent = function _getEvent(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  },
  _getAbsoluteMax = function _getAbsoluteMax(a) {
    var max = Math.max.apply(Math, a),
      min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  },
  _setScrollTrigger = function _setScrollTrigger() {
    ScrollTrigger = gsap.core.globals().ScrollTrigger;
    ScrollTrigger && ScrollTrigger.core && _integrate();
  },
  _initCore = function _initCore(core) {
    gsap = core || _getGSAP();
    if (gsap && typeof document !== "undefined" && document.body) {
      _win = window;
      _doc = document;
      _docEl = _doc.documentElement;
      _body = _doc.body;
      _root = [_win, _doc, _docEl, _body];
      _clamp = gsap.utils.clamp;
      _context = gsap.core.context || function () {};
      _pointerType = "onpointerenter" in _body ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

      _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function () {
        return _startup = 0;
      }, 500);
      _setScrollTrigger();
      _coreInitted = 1;
    }
    return _coreInitted;
  };
exports._getVelocityProp = _getVelocityProp;
exports._getScrollFunc = _getScrollFunc;
exports._getTarget = _getTarget;
exports._vertical = _vertical;
exports._horizontal = _horizontal;
exports._isViewport = _isViewport;
exports._getProxyProp = _getProxyProp;
exports._proxies = _proxies;
exports._scrollers = _scrollers;
_horizontal.op = _vertical;
_scrollers.cache = 0;
var Observer = /*#__PURE__*/function () {
  function Observer(vars) {
    this.init(vars);
  }
  var _proto = Observer.prototype;
  _proto.init = function init(vars) {
    _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
    ScrollTrigger || _setScrollTrigger();
    var tolerance = vars.tolerance,
      dragMinimum = vars.dragMinimum,
      type = vars.type,
      target = vars.target,
      lineHeight = vars.lineHeight,
      debounce = vars.debounce,
      preventDefault = vars.preventDefault,
      onStop = vars.onStop,
      onStopDelay = vars.onStopDelay,
      ignore = vars.ignore,
      wheelSpeed = vars.wheelSpeed,
      event = vars.event,
      onDragStart = vars.onDragStart,
      onDragEnd = vars.onDragEnd,
      onDrag = vars.onDrag,
      onPress = vars.onPress,
      onRelease = vars.onRelease,
      onRight = vars.onRight,
      onLeft = vars.onLeft,
      onUp = vars.onUp,
      onDown = vars.onDown,
      onChangeX = vars.onChangeX,
      onChangeY = vars.onChangeY,
      onChange = vars.onChange,
      onToggleX = vars.onToggleX,
      onToggleY = vars.onToggleY,
      onHover = vars.onHover,
      onHoverEnd = vars.onHoverEnd,
      onMove = vars.onMove,
      ignoreCheck = vars.ignoreCheck,
      isNormalizer = vars.isNormalizer,
      onGestureStart = vars.onGestureStart,
      onGestureEnd = vars.onGestureEnd,
      onWheel = vars.onWheel,
      onEnable = vars.onEnable,
      onDisable = vars.onDisable,
      onClick = vars.onClick,
      scrollSpeed = vars.scrollSpeed,
      capture = vars.capture,
      allowClicks = vars.allowClicks,
      lockAxis = vars.lockAxis,
      onLockAxis = vars.onLockAxis;
    this.target = target = _getTarget(target) || _docEl;
    this.vars = vars;
    ignore && (ignore = gsap.utils.toArray(ignore));
    tolerance = tolerance || 1e-9;
    dragMinimum = dragMinimum || 0;
    wheelSpeed = wheelSpeed || 1;
    scrollSpeed = scrollSpeed || 1;
    type = type || "wheel,touch,pointer";
    debounce = debounce !== false;
    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report "normal", so default to 22.

    var id,
      onStopDelayedCall,
      dragged,
      moved,
      wheeled,
      locked,
      axis,
      self = this,
      prevDeltaX = 0,
      prevDeltaY = 0,
      scrollFuncX = _getScrollFunc(target, _horizontal),
      scrollFuncY = _getScrollFunc(target, _vertical),
      scrollX = scrollFuncX(),
      scrollY = scrollFuncY(),
      limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
      // for devices that accommodate mouse events and touch events, we need to distinguish.
      isViewport = _isViewport(target),
      ownerDoc = target.ownerDocument || _doc,
      deltaX = [0, 0, 0],
      // wheel, scroll, pointer/touch
      deltaY = [0, 0, 0],
      onClickTime = 0,
      clickCapture = function clickCapture() {
        return onClickTime = _getTime();
      },
      _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
        return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      },
      onStopFunc = function onStopFunc() {
        self._vx.reset();
        self._vy.reset();
        onStopDelayedCall.pause();
        onStop && onStop(self);
      },
      update = function update() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX),
          dy = self.deltaY = _getAbsoluteMax(deltaY),
          changedX = Math.abs(dx) >= tolerance,
          changedY = Math.abs(dy) >= tolerance;
        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }
        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }
        if (moved || dragged) {
          onMove && onMove(self);
          if (dragged) {
            onDrag(self);
            dragged = false;
          }
          moved = false;
        }
        locked && !(locked = false) && onLockAxis && onLockAxis(self);
        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }
        id = 0;
      },
      onDelta = function onDelta(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;
        self._vx.update(x);
        self._vy.update(y);
        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
      onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }
        if (axis !== "y") {
          deltaX[2] += x;
          self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.
        }

        if (axis !== "x") {
          deltaY[2] += y;
          self._vy.update(y, true);
        }
        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
      _onDrag = function _onDrag(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y,
          isDragging = self.isDragging;
        self.x = x;
        self.y = y;
        if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
          onDrag && (dragged = true);
          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
          isDragging || onDragStart && onDragStart(self);
        }
      },
      _onPress = self.onPress = function (e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e.clientX;
        self.startY = self.y = e.clientY;
        self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.

        self._vy.reset();
        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
        self.deltaX = self.deltaY = 0;
        onPress && onPress(self);
      },
      _onRelease = function _onRelease(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        var isTrackingDrag = !isNaN(self.y - self.startY),
          wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
          eventData = _getEvent(e);
        if (!wasDragging && isTrackingDrag) {
          self._vx.reset();
          self._vy.reset();
          if (preventDefault && allowClicks) {
            gsap.delayedCall(0.08, function () {
              // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  //some browsers (like mobile Safari) don't properly trigger the click event
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }
        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, wasDragging);
      },
      _onGestureStart = function _onGestureStart(e) {
        return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
      },
      _onGestureEnd = function _onGestureEnd() {
        return (self.isGesturing = false) || onGestureEnd(self);
      },
      onScroll = function onScroll(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = scrollFuncX(),
          y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      },
      _onWheel = function _onWheel(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      },
      _onMove = function _onMove(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y;
        self.x = x;
        self.y = y;
        moved = true;
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      },
      _onHover = function _onHover(e) {
        self.event = e;
        onHover(self);
      },
      _onHoverEnd = function _onHoverEnd(e) {
        self.event = e;
        onHoverEnd(self);
      },
      _onClick = function _onClick(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
      };
    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
    self.deltaX = self.deltaY = 0;
    self._vx = _getVelocityProp(0, 50, true);
    self._vy = _getVelocityProp(0, 50, true);
    self.scrollX = scrollFuncX;
    self.scrollY = scrollFuncY;
    self.isDragging = self.isGesturing = self.isPressed = false;
    _context(this);
    self.enable = function (e) {
      if (!self.isEnabled) {
        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
          _addListener(ownerDoc, _eventTypes[2], _onRelease);
          _addListener(ownerDoc, _eventTypes[3], _onRelease);
          allowClicks && _addListener(target, "click", clickCapture, false, true);
          onClick && _addListener(target, "click", _onClick);
          onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
          onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
          onHover && _addListener(target, _pointerType + "enter", _onHover);
          onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
          onMove && _addListener(target, _pointerType + "move", _onMove);
        }
        self.isEnabled = true;
        e && e.type && _onPress(e);
        onEnable && onEnable(self);
      }
      return self;
    };
    self.disable = function () {
      if (self.isEnabled) {
        // only remove the _onScroll listener if there aren't any others that rely on the functionality.
        _observers.filter(function (o) {
          return o !== self && _isViewport(o.target);
        }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
        if (self.isPressed) {
          self._vx.reset();
          self._vy.reset();
          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        }
        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
        _removeListener(target, "wheel", _onWheel, capture);
        _removeListener(target, _eventTypes[0], _onPress, capture);
        _removeListener(ownerDoc, _eventTypes[2], _onRelease);
        _removeListener(ownerDoc, _eventTypes[3], _onRelease);
        _removeListener(target, "click", clickCapture, true);
        _removeListener(target, "click", _onClick);
        _removeListener(ownerDoc, "gesturestart", _onGestureStart);
        _removeListener(ownerDoc, "gestureend", _onGestureEnd);
        _removeListener(target, _pointerType + "enter", _onHover);
        _removeListener(target, _pointerType + "leave", _onHoverEnd);
        _removeListener(target, _pointerType + "move", _onMove);
        self.isEnabled = self.isPressed = self.isDragging = false;
        onDisable && onDisable(self);
      }
    };
    self.kill = self.revert = function () {
      self.disable();
      var i = _observers.indexOf(self);
      i >= 0 && _observers.splice(i, 1);
      _normalizer === self && (_normalizer = 0);
    };
    _observers.push(self);
    isNormalizer && _isViewport(target) && (_normalizer = self);
    self.enable(event);
  };
  _createClass(Observer, [{
    key: "velocityX",
    get: function get() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this._vy.getVelocity();
    }
  }]);
  return Observer;
}();
exports.default = exports.Observer = Observer;
Observer.version = "3.11.4";
Observer.create = function (vars) {
  return new Observer(vars);
};
Observer.register = _initCore;
Observer.getAll = function () {
  return _observers.slice();
};
Observer.getById = function (id) {
  return _observers.filter(function (o) {
    return o.vars.id === id;
  })[0];
};
_getGSAP() && gsap.registerPlugin(Observer);
},{}],"node_modules/gsap/ScrollTrigger.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScrollTrigger = void 0;
var _Observer = require("./Observer.js");
/*!
 * ScrollTrigger 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */

var gsap,
  _coreInitted,
  _win,
  _doc,
  _docEl,
  _body,
  _root,
  _resizeDelay,
  _toArray,
  _clamp,
  _time2,
  _syncInterval,
  _refreshing,
  _pointerIsDown,
  _transformProp,
  _i,
  _prevWidth,
  _prevHeight,
  _autoRefresh,
  _sort,
  _suppressOverwrites,
  _ignoreResize,
  _normalizer,
  _ignoreMobileResize,
  _baseScreenHeight,
  _baseScreenWidth,
  _fixIOSBug,
  _context,
  _scrollRestoration,
  _limitCallbacks,
  // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
  _startup = 1,
  _getTime = Date.now,
  _time1 = _getTime(),
  _lastScrollTime = 0,
  _enabled = 0,
  _pointerDownHandler = function _pointerDownHandler() {
    return _pointerIsDown = 1;
  },
  _pointerUpHandler = function _pointerUpHandler() {
    return _pointerIsDown = 0;
  },
  _passThrough = function _passThrough(v) {
    return v;
  },
  _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
  _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
  _getGSAP = function _getGSAP() {
    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
  _isViewport = function _isViewport(e) {
    return !!~_root.indexOf(e);
  },
  _getBoundsFunc = function _getBoundsFunc(element) {
    return (0, _Observer._getProxyProp)(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
      _winOffsets.width = _win.innerWidth;
      _winOffsets.height = _win.innerHeight;
      return _winOffsets;
    } : function () {
      return _getBounds(element);
    });
  },
  _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
    var d = _ref.d,
      d2 = _ref.d2,
      a = _ref.a;
    return (a = (0, _Observer._getProxyProp)(scroller, "getBoundingClientRect")) ? function () {
      return a()[d];
    } : function () {
      return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
    };
  },
  _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
    return !isViewport || ~_Observer._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
      return _winOffsets;
    };
  },
  _maxScroll = function _maxScroll(element, _ref2) {
    var s = _ref2.s,
      d2 = _ref2.d2,
      d = _ref2.d,
      a = _ref2.a;
    return (s = "scroll" + d2) && (a = (0, _Observer._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
  },
  _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  },
  _isString = function _isString(value) {
    return typeof value === "string";
  },
  _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
  _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
  _isObject = function _isObject(value) {
    return typeof value === "object";
  },
  _callIfFunc = function _callIfFunc(value) {
    return _isFunction(value) && value();
  },
  _combineFunc = function _combineFunc(f1, f2) {
    return function () {
      var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);
      return function () {
        _callIfFunc(result1);
        _callIfFunc(result2);
      };
    };
  },
  _endAnimation = function _endAnimation(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  },
  _callback = function _callback(self, func) {
    if (self.enabled) {
      var result = func(self);
      result && result.totalTime && (self.callbackAnimation = result);
    }
  },
  _abs = Math.abs,
  _scrollLeft = "scrollLeft",
  _scrollTop = "scrollTop",
  _left = "left",
  _top = "top",
  _right = "right",
  _bottom = "bottom",
  _width = "width",
  _height = "height",
  _Right = "Right",
  _Left = "Left",
  _Top = "Top",
  _Bottom = "Bottom",
  _padding = "padding",
  _margin = "margin",
  _Width = "Width",
  _Height = "Height",
  _px = "px",
  _getComputedStyle = function _getComputedStyle(element) {
    return _win.getComputedStyle(element);
  },
  _makePositionable = function _makePositionable(element) {
    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  },
  _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }
    return obj;
  },
  _getBounds = function _getBounds(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
      }).progress(1),
      bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  },
  _getSize = function _getSize(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  },
  _getLabelRatioArray = function _getLabelRatioArray(timeline) {
    var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;
    for (p in labels) {
      a.push(labels[p] / duration);
    }
    return a;
  },
  _getClosestLabel = function _getClosestLabel(animation) {
    return function (value) {
      return gsap.utils.snap(_getLabelRatioArray(animation), value);
    };
  },
  _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
    var snap = gsap.utils.snap(snapIncrementOrArray),
      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
        return a - b;
      });
    return a ? function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var i;
      if (!direction) {
        return snap(value);
      }
      if (direction > 0) {
        value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }
        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;
        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }
      return a[0];
    } : function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var snapped = snap(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  },
  _getLabelAtDirection = function _getLabelAtDirection(timeline) {
    return function (value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
    };
  },
  _multiListener = function _multiListener(func, element, types, callback) {
    return types.split(",").forEach(function (type) {
      return func(element, type, callback);
    });
  },
  _addListener = function _addListener(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  },
  _removeListener = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
  _wheelListener = function _wheelListener(func, el, scrollFunc) {
    return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
  },
  _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  },
  _defaults = {
    toggleActions: "play",
    anticipatePin: 0
  },
  _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  },
  _offsetToPx = function _offsetToPx(value, size) {
    if (_isString(value)) {
      var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }
    return value;
  },
  _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor,
      endColor = _ref4.endColor,
      fontSize = _ref4.fontSize,
      indent = _ref4.indent,
      fontWeight = _ref4.fontWeight;
    var e = _doc.createElement("div"),
      useFixedPosition = _isViewport(container) || (0, _Observer._getProxyProp)(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? _body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer._vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];
    _positionMarker(e, 0, direction, isStart);
    return e;
  },
  _positionMarker = function _positionMarker(marker, start, direction, flipped) {
    var vars = {
        display: "block"
      },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap.set(marker, vars);
  },
  _triggers = [],
  _ids = {},
  _rafID,
  _sync = function _sync() {
    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  },
  _onScroll = function _onScroll() {
    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {
      // if the user is dragging the scrollbar, allow it.
      _Observer._scrollers.cache++;
      if (_normalizer) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110
      }

      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    }
  },
  _setBaseDimensions = function _setBaseDimensions() {
    _baseScreenWidth = _win.innerWidth;
    _baseScreenHeight = _win.innerHeight;
  },
  _onResize = function _onResize() {
    _Observer._scrollers.cache++;
    !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);
  },
  // ignore resizes triggered by refresh()
  _listeners = {},
  _emptyArray = [],
  _softRefresh = function _softRefresh() {
    return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
  },
  _dispatch = function _dispatch(type) {
    return _listeners[type] && _listeners[type].map(function (f) {
      return f();
    }) || _emptyArray;
  },
  _savedStyles = [],
  // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
  _revertRecorded = function _revertRecorded(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  },
  _revertAll = function _revertAll(kill, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (trigger && (!media || trigger._ctx === media)) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }
    media && _revertRecorded(media);
    media || _dispatch("revert");
  },
  _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
    _Observer._scrollers.cache++;
    (force || !_refreshingAll) && _Observer._scrollers.forEach(function (obj) {
      return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  },
  _refreshingAll,
  _refreshID = 0,
  _queueRefreshID,
  _queueRefreshAll = function _queueRefreshAll() {
    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's "load" or "DOMContentLoaded" events to trigger it.
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function () {
        return id === _refreshID && _refreshAll(true);
      });
    }
  },
  _refreshAll = function _refreshAll(force, skipRevert) {
    if (_lastScrollTime && !force) {
      _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
      return;
    }
    _refreshingAll = ScrollTrigger.isRefreshing = true;
    _Observer._scrollers.forEach(function (obj) {
      return _isFunction(obj) && obj.cacheID++ && (obj.rec = obj());
    }); // force the clearing of the cache because some browsers take a little while to dispatch the "scroll" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away

    var refreshInits = _dispatch("refreshInit");
    _sort && ScrollTrigger.sort();
    skipRevert || _revertAll();
    _Observer._scrollers.forEach(function (obj) {
      if (_isFunction(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto"); // smooth scrolling interferes

        obj(0);
      }
    });
    _triggers.slice(0).forEach(function (t) {
      return t.refresh();
    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.

    _triggers.forEach(function (t, i) {
      // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
          original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.revert(false, 1);
      }
    });
    _triggers.forEach(function (t) {
      return t.vars.end === "max" && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)));
    }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".

    refreshInits.forEach(function (result) {
      return result && result.render && result.render(-1);
    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

    _Observer._scrollers.forEach(function (obj) {
      if (_isFunction(obj)) {
        obj.smooth && requestAnimationFrame(function () {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });
    _clearScrollMemory(_scrollRestoration, 1);
    _resizeDelay.pause();
    _refreshID++;
    _updateAll(2);
    _triggers.forEach(function (t) {
      return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
    });
    _refreshingAll = ScrollTrigger.isRefreshing = false;
    _dispatch("refresh");
  },
  _lastScroll = 0,
  _direction = 1,
  _primary,
  _updateAll = function _updateAll(force) {
    if (!_refreshingAll || force === 2) {
      ScrollTrigger.isUpdating = true;
      _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

      var l = _triggers.length,
        time = _getTime(),
        recordVelocity = time - _time1 >= 50,
        scroll = l && _triggers[0].scroll();
      _direction = _lastScroll > scroll ? -1 : 1;
      _lastScroll = scroll;
      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;
          _dispatch("scrollEnd");
        }
        _time2 = _time1;
        _time1 = time;
      }
      if (_direction < 0) {
        _i = l;
        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }
      ScrollTrigger.isUpdating = false;
    }
    _rafID = 0;
  },
  _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
  _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
  _swapPinOut = function _swapPinOut(pin, spacer, state) {
    _setState(state);
    var cache = pin._gsap;
    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;
      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }
    pin._gsap.swappedIn = false;
  },
  _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;
      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _Observer._horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _Observer._vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
      pin._gsap.swappedIn = true;
    }
  },
  _capsExp = /([A-Z])/g,
  _setState = function _setState(state) {
    if (state) {
      var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
      (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];
        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
        }
      }
    }
  },
  _getState = function _getState(element) {
    // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
    var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;
    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }
    state.t = element;
    return state;
  },
  _copyState = function _copyState(state, override, omitOffsets) {
    var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
      p;
    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }
    result.t = state.t;
    return result;
  },
  _winOffsets = {
    left: 0,
    top: 0
  },
  // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
  // _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
  // 	scroller = _getTarget(scroller || _win);
  // 	let direction = horizontal ? _horizontal : _vertical,
  // 		isViewport = _isViewport(scroller);
  // 	_getSizeFunc(scroller, isViewport, direction);
  // 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
  // },
  _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
    _isFunction(value) && (value = value(self));
    if (_isString(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    var time = containerAnimation ? containerAnimation.time() : 0,
      p1,
      p2,
      element;
    containerAnimation && containerAnimation.seek(0);
    if (!_isNumber(value)) {
      _isFunction(trigger) && (trigger = trigger(self));
      var offsets = (value || "0").split(" "),
        bounds,
        localOffset,
        globalOffset,
        display;
      element = (0, _Observer._getTarget)(trigger) || _body;
      bounds = _getBounds(element) || {};
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        // if display is "none", it won't report getBoundingClientRect() properly
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
    } else if (markerScroller) {
      _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (marker) {
      var position = value + scrollerSize,
        isStart = marker._isStart;
      p1 = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }
    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  },
  _prefixExp = /(webkit|moz|length|cssText|inset)/i,
  _reparent = function _reparent(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style,
        p,
        cs;
      if (parent === _body) {
        element._stOrig = style.cssText; // record original inline styles so we can revert them later

        cs = _getComputedStyle(element);
        for (p in cs) {
          // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  },
  // _mergeAnimations = animations => {
  // 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
  // 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
  // 	tl.smoothChildTiming = false;
  // 	return tl;
  // },
  // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
  _getTweenCreator = function _getTweenCreator(scroller, direction) {
    var getScroll = (0, _Observer._getScrollFunc)(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
      lastScroll1,
      lastScroll2,
      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
        var tween = getTween.tween,
          onComplete = vars.onComplete,
          modifiers = {};
        initialValue = initialValue || getScroll();
        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

        change1 = change1 || scrollTo - initialValue;
        tween && tween.kill();
        lastScroll1 = Math.round(initialValue);
        vars[prop] = scrollTo;
        vars.modifiers = modifiers;
        modifiers[prop] = function (value) {
          value = Math.round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

          if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 3 && Math.abs(value - lastScroll2) > 3) {
            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
            tween.kill();
            getTween.tween = 0;
          } else {
            value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
          }
          lastScroll2 = lastScroll1;
          return lastScroll1 = Math.round(value);
        };
        vars.onUpdate = function () {
          _Observer._scrollers.cache++;
          _updateAll();
        };
        vars.onComplete = function () {
          getTween.tween = 0;
          onComplete && onComplete.call(tween);
        };
        tween = getTween.tween = gsap.to(scroller, vars);
        return tween;
      };
    scroller[prop] = getScroll;
    getScroll.wheelHandler = function () {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };
    _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.

    return getTween;
  };
var ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }
  var _proto = ScrollTrigger.prototype;
  _proto.init = function init(vars, animation) {
    this.progress = this.start = 0;
    this.vars && this.kill(true, true); // in case it's being initted again

    if (!_enabled) {
      this.update = this.refresh = this.kill = _passThrough;
      return;
    }
    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
      trigger: vars
    } : vars, _defaults);
    var _vars = vars,
      onUpdate = _vars.onUpdate,
      toggleClass = _vars.toggleClass,
      id = _vars.id,
      onToggle = _vars.onToggle,
      onRefresh = _vars.onRefresh,
      scrub = _vars.scrub,
      trigger = _vars.trigger,
      pin = _vars.pin,
      pinSpacing = _vars.pinSpacing,
      invalidateOnRefresh = _vars.invalidateOnRefresh,
      anticipatePin = _vars.anticipatePin,
      onScrubComplete = _vars.onScrubComplete,
      onSnapComplete = _vars.onSnapComplete,
      once = _vars.once,
      snap = _vars.snap,
      pinReparent = _vars.pinReparent,
      pinSpacer = _vars.pinSpacer,
      containerAnimation = _vars.containerAnimation,
      fastScrollEnd = _vars.fastScrollEnd,
      preventOverlaps = _vars.preventOverlaps,
      direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer._horizontal : _Observer._vertical,
      isToggle = !scrub && scrub !== 0,
      scroller = (0, _Observer._getTarget)(vars.scroller || _win),
      scrollerCache = gsap.core.getCache(scroller),
      isViewport = _isViewport(scroller),
      useFixedPosition = ("pinType" in vars ? vars.pinType : (0, _Observer._getProxyProp)(scroller, "pinType") || isViewport && "fixed") === "fixed",
      callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
      toggleActions = isToggle && vars.toggleActions.split(" "),
      markers = "markers" in vars ? vars.markers : _defaults.markers,
      borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
      self = this,
      onRefreshInit = vars.onRefreshInit && function () {
        return vars.onRefreshInit(self);
      },
      getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
      getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
      lastSnap = 0,
      lastRefresh = 0,
      scrollFunc = (0, _Observer._getScrollFunc)(scroller, direction),
      tweenTo,
      pinCache,
      snapFunc,
      scroll1,
      scroll2,
      start,
      end,
      markerStart,
      markerEnd,
      markerStartTrigger,
      markerEndTrigger,
      markerVars,
      change,
      pinOriginalState,
      pinActiveState,
      pinState,
      spacer,
      offset,
      pinGetter,
      pinSetter,
      pinStart,
      pinChange,
      spacingStart,
      spacerState,
      markerStartSetter,
      pinMoves,
      markerEndSetter,
      cs,
      snap1,
      snap2,
      scrubTween,
      scrubSmooth,
      snapDurClamp,
      snapDelayedCall,
      prevProgress,
      prevScroll,
      prevAnimProgress,
      caMarkerSetter,
      customRevertReturn;
    _context(self);
    self._dir = direction;
    anticipatePin *= 45;
    self.scroller = scroller;
    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
    scroll1 = scrollFunc();
    self.vars = vars;
    animation = animation || vars.animation;
    if ("refreshPriority" in vars) {
      _sort = 1;
      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
    }

    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
      top: _getTweenCreator(scroller, _Observer._vertical),
      left: _getTweenCreator(scroller, _Observer._horizontal)
    };
    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
    self.scrubDuration = function (value) {
      scrubSmooth = _isNumber(value) && value;
      if (!scrubSmooth) {
        scrubTween && scrubTween.progress(1).kill();
        scrubTween = 0;
      } else {
        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
          ease: "expo",
          totalProgress: "+=0.001",
          duration: scrubSmooth,
          paused: true,
          onComplete: function onComplete() {
            return onScrubComplete && onScrubComplete(self);
          }
        });
      }
    };
    if (animation) {
      animation.vars.lazy = false;
      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
      self.animation = animation.pause();
      animation.scrollTrigger = self;
      self.scrubDuration(scrub);
      snap1 = 0;
      id || (id = animation.vars.id);
    }
    _triggers.push(self);
    if (snap) {
      // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.
      if (!_isObject(snap) || snap.push) {
        snap = {
          snapTo: snap
        };
      }
      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
        scrollBehavior: "auto"
      }); // smooth scrolling doesn't work with snap.

      _Observer._scrollers.forEach(function (o) {
        return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);
      }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters

      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
      } : gsap.utils.snap(snap.snapTo);
      snapDurClamp = snap.duration || {
        min: 0.1,
        max: 2
      };
      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
        var scroll = scrollFunc(),
          refreshedRecently = _getTime() - lastRefresh < 500,
          tween = tweenTo.tween;
        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
          var progress = (scroll - start) / change,
            totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
            velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
            change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
            naturalEnd = progress + (snap.inertia === false ? 0 : change1),
            endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
            endScroll = Math.round(start + endValue * change),
            _snap = snap,
            onStart = _snap.onStart,
            _onInterrupt = _snap.onInterrupt,
            _onComplete = _snap.onComplete;
          if (scroll <= end && scroll >= start && endScroll !== scroll) {
            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
              return;
            }
            if (snap.inertia === false) {
              change1 = endValue - progress;
            }
            tweenTo(endScroll, {
              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
              ease: snap.ease || "power3",
              data: _abs(endScroll - scroll),
              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
              onInterrupt: function onInterrupt() {
                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
              },
              onComplete: function onComplete() {
                self.update();
                lastSnap = scrollFunc();
                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                onSnapComplete && onSnapComplete(self);
                _onComplete && _onComplete(self);
              }
            }, scroll, change1 * change, endScroll - scroll - change1 * change);
            onStart && onStart(self, tweenTo.tween);
          }
        } else if (self.isActive && lastSnap !== scroll) {
          snapDelayedCall.restart(true);
        }
      }).pause();
    }
    id && (_ids[id] = self);
    trigger = self.trigger = (0, _Observer._getTarget)(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
    customRevertReturn && (customRevertReturn = customRevertReturn(self));
    pin = pin === true ? trigger : (0, _Observer._getTarget)(pin);
    _isString(toggleClass) && (toggleClass = {
      targets: trigger,
      className: toggleClass
    });
    if (pin) {
      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)

      self.pin = pin;
      pinCache = gsap.core.getCache(pin);
      if (!pinCache.spacer) {
        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
        if (pinSpacer) {
          pinSpacer = (0, _Observer._getTarget)(pinSpacer);
          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

          pinCache.spacerIsNative = !!pinSpacer;
          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
        }
        pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
        spacer.classList.add("pin-spacer");
        id && spacer.classList.add("pin-spacer-" + id);
        pinCache.pinState = pinOriginalState = _getState(pin);
      } else {
        pinOriginalState = pinCache.pinState;
      }
      vars.force3D !== false && gsap.set(pin, {
        force3D: true
      });
      self.spacer = spacer = pinCache.spacer;
      cs = _getComputedStyle(pin);
      spacingStart = cs[pinSpacing + direction.os2];
      pinGetter = gsap.getProperty(pin);
      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

      _swapPinIn(pin, spacer, cs);
      pinState = _getState(pin);
    }
    if (markers) {
      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
      offset = markerStartTrigger["offset" + direction.op.d2];
      var content = (0, _Observer._getTarget)((0, _Observer._getProxyProp)(scroller, "content") || scroller);
      markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
      markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));
      if (!useFixedPosition && !(_Observer._proxies.length && (0, _Observer._getProxyProp)(scroller, "fixedMarkers") === true)) {
        _makePositionable(isViewport ? _body : scroller);
        gsap.set([markerStartTrigger, markerEndTrigger], {
          force3D: true
        });
        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
      }
    }
    if (containerAnimation) {
      var oldOnUpdate = containerAnimation.vars.onUpdate,
        oldParams = containerAnimation.vars.onUpdateParams;
      containerAnimation.eventCallback("onUpdate", function () {
        self.update(0, 0, 1);
        oldOnUpdate && oldOnUpdate.apply(oldParams || []);
      });
    }
    self.previous = function () {
      return _triggers[_triggers.indexOf(self) - 1];
    };
    self.next = function () {
      return _triggers[_triggers.indexOf(self) + 1];
    };
    self.revert = function (revert, temp) {
      if (!temp) {
        return self.kill(true);
      } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()

      var r = revert !== false || !self.enabled,
        prevRefreshing = _refreshing;
      if (r !== self.isReverted) {
        if (r) {
          // if (!self.scroll.rec && (_refreshing || _refreshingAll)) {
          // 	self.scroll.rec = scrollFunc();
          // 	_refreshingAll && scrollFunc(0);
          // }
          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

          prevProgress = self.progress;
          prevAnimProgress = animation && animation.progress();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.style.display = r ? "none" : "block";
        });
        if (r) {
          _refreshing = 1;
          self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out
        }

        if (pin && (!pinReparent || !self.isActive)) {
          if (r) {
            _swapPinOut(pin, spacer, pinOriginalState);
          } else {
            _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
          }
        }
        r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.

        _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.

        self.isReverted = r;
      }
    };
    self.refresh = function (soft, force) {
      if ((_refreshing || !self.enabled) && !force) {
        return;
      }
      if (pin && soft && _lastScrollTime) {
        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
        return;
      }
      !_refreshingAll && onRefreshInit && onRefreshInit(self);
      _refreshing = 1;
      lastRefresh = _getTime();
      if (tweenTo.tween) {
        tweenTo.tween.kill();
        tweenTo.tween = 0;
      }
      scrubTween && scrubTween.pause();
      invalidateOnRefresh && animation && animation.revert({
        kill: false
      }).invalidate();
      self.isReverted || self.revert(true, true);
      self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any

      var size = getScrollerSize(),
        scrollerBounds = getScrollerOffsets(),
        max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
        offset = 0,
        otherPinOffset = 0,
        parsedEnd = vars.end,
        parsedEndTrigger = vars.endTrigger || trigger,
        parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
        pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0, _Observer._getTarget)(vars.pinnedContainer),
        triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
        i = triggerIndex,
        cs,
        bounds,
        scroll,
        isVertical,
        override,
        curTrigger,
        curPin,
        oppositeScroll,
        initted,
        revertedPins,
        forcedOverflow;
      while (i--) {
        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
        curTrigger = _triggers[i];
        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

        curPin = curTrigger.pin;
        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
          revertedPins || (revertedPins = []);
          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

          curTrigger.revert(true, true);
        }
        if (curTrigger !== _triggers[i]) {
          // in case it got removed.
          triggerIndex--;
          i--;
        }
      }
      _isFunction(parsedStart) && (parsedStart = parsedStart(self));
      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
        if (~parsedEnd.indexOf(" ")) {
          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
        } else {
          offset = _offsetToPx(parsedEnd.substr(2), size);
          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

          parsedEndTrigger = trigger;
        }
      }
      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
      change = end - start || (start -= 0.01) && 0.001;
      offset = 0;
      i = triggerIndex;
      while (i--) {
        curTrigger = _triggers[i];
        curPin = curTrigger.pin;
        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
          cs = curTrigger.end - curTrigger.start;
          if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
            // numeric start values shouldn't be offset at all - treat them as absolute
            offset += cs * (1 - curTrigger.progress);
          }
          curPin === pin && (otherPinOffset += cs);
        }
      }
      start += offset;
      end += offset;
      self._pinPush = otherPinOffset;
      if (markerStart && offset) {
        // offset the markers if necessary
        cs = {};
        cs[direction.a] = "+=" + offset;
        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
        gsap.set([markerStart, markerEnd], cs);
      }
      if (pin) {
        cs = _getComputedStyle(pin);
        isVertical = direction === _Observer._vertical;
        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
        if (!max && end > 1) {
          // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
          forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;
          forcedOverflow = {
            style: forcedOverflow,
            value: forcedOverflow["overflow" + direction.a.toUpperCase()]
          };
          forcedOverflow["overflow" + direction.a.toUpperCase()] = "scroll";
        }
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

        bounds = _getBounds(pin, true);
        oppositeScroll = useFixedPosition && (0, _Observer._getScrollFunc)(scroller, isVertical ? _Observer._horizontal : _Observer._vertical)();
        if (pinSpacing) {
          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
          spacerState.t = spacer;
          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

          _setState(spacerState);
          if (pinnedContainer) {
            // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.
            _triggers.forEach(function (t) {
              if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                t._subPinOffset = true;
              }
            });
          }
          useFixedPosition && scrollFunc(prevScroll);
        }
        if (useFixedPosition) {
          override = {
            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
            boxSizing: "border-box",
            position: "fixed"
          };
          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
          override[_padding] = cs[_padding];
          override[_padding + _Top] = cs[_padding + _Top];
          override[_padding + _Right] = cs[_padding + _Right];
          override[_padding + _Bottom] = cs[_padding + _Bottom];
          override[_padding + _Left] = cs[_padding + _Left];
          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
          _refreshingAll && scrollFunc(0);
        }
        if (animation) {
          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

          _suppressOverwrites(1);
          animation.render(animation.duration(), true, true);
          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
          pinMoves = Math.abs(change - pinChange) > 1;
          useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

          animation.render(0, true, true);
          initted || animation.invalidate(true);
          animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.

          _suppressOverwrites(0);
        } else {
          pinChange = change;
        }
        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
      } else if (trigger && scrollFunc() && !containerAnimation) {
        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
        bounds = trigger.parentNode;
        while (bounds && bounds !== _body) {
          if (bounds._pinOffset) {
            start -= bounds._pinOffset;
            end -= bounds._pinOffset;
          }
          bounds = bounds.parentNode;
        }
      }
      revertedPins && revertedPins.forEach(function (t) {
        return t.revert(false, true);
      });
      self.start = start;
      self.end = end;
      scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity

      if (!containerAnimation && !_refreshingAll) {
        scroll1 < prevScroll && scrollFunc(prevScroll);
        self.scroll.rec = 0;
      }
      self.revert(false, true);
      if (snapDelayedCall) {
        lastSnap = -1;
        self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value

        snapDelayedCall.restart(true);
      }
      _refreshing = 0;
      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

      if (prevProgress !== self.progress || containerAnimation) {
        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

        self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
      }
      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //			scrubTween && scrubTween.invalidate();

      onRefresh && !_refreshingAll && onRefresh(self); // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.
    };

    self.getVelocity = function () {
      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
    };
    self.endAnimation = function () {
      _endAnimation(self.callbackAnimation);
      if (animation) {
        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
      }
    };
    self.labelToScroll = function (label) {
      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
    };
    self.getTrailing = function (name) {
      var i = _triggers.indexOf(self),
        a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
      return (_isString(name) ? a.filter(function (t) {
        return t.vars.preventOverlaps === name;
      }) : a).filter(function (t) {
        return self.direction > 0 ? t.end <= start : t.start >= end;
      });
    };
    self.update = function (reset, recordVelocity, forceFake) {
      if (containerAnimation && !forceFake && !reset) {
        return;
      }
      var scroll = _refreshingAll ? prevScroll : self.scroll(),
        p = reset ? 0 : (scroll - start) / change,
        clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
        prevProgress = self.progress,
        isActive,
        wasActive,
        toggleState,
        action,
        stateChanged,
        toggled,
        isAtMax,
        isTakingAction;
      if (recordVelocity) {
        scroll2 = scroll1;
        scroll1 = containerAnimation ? scrollFunc() : scroll;
        if (snap) {
          snap2 = snap1;
          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
        }
      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).

      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);
      if (clipped !== prevProgress && self.enabled) {
        isActive = self.isActive = !!clipped && clipped < 1;
        wasActive = !!prevProgress && prevProgress < 1;
        toggled = isActive !== wasActive;
        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

        self.direction = clipped > prevProgress ? 1 : -1;
        self.progress = clipped;
        if (stateChanged && !_refreshing) {
          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

          if (isToggle) {
            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

            isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
          }
        }
        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
          return t.endAnimation();
        }));
        if (!isToggle) {
          if (scrubTween && !_refreshing && !_startup) {
            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

            if (scrubTween.resetTo) {
              scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
            } else {
              // legacy support (courtesy), before 3.10.0
              scrubTween.vars.totalProgress = clipped;
              scrubTween.invalidate().restart();
            }
          } else if (animation) {
            animation.totalProgress(clipped, !!_refreshing);
          }
        }
        if (pin) {
          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
          if (!useFixedPosition) {
            pinSetter(_round(pinStart + pinChange * clipped));
          } else if (stateChanged) {
            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

            if (pinReparent) {
              if (!reset && (isActive || isAtMax)) {
                var bounds = _getBounds(pin, true),
                  _offset = scroll - start;
                _reparent(pin, _body, bounds.top + (direction === _Observer._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer._vertical ? 0 : _offset) + _px);
              } else {
                _reparent(pin, spacer);
              }
            }
            _setState(isActive || isAtMax ? pinActiveState : pinState);
            pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
          }
        }
        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
        }); // classes could affect positioning, so do it even if reset or refreshing is true.

        onUpdate && !isToggle && !reset && onUpdate(self);
        if (stateChanged && !_refreshing) {
          if (isToggle) {
            if (isTakingAction) {
              if (action === "complete") {
                animation.pause().totalProgress(1);
              } else if (action === "reset") {
                animation.restart(true).pause();
              } else if (action === "restart") {
                animation.restart(true);
              } else {
                animation[action]();
              }
            }
            onUpdate && onUpdate(self);
          }
          if (toggled || !_limitCallbacks) {
            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
            onToggle && toggled && _callback(self, onToggle);
            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

            if (!toggled) {
              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
              toggleState = clipped === 1 ? 1 : 3;
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            }
          }
          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
            _endAnimation(self.callbackAnimation);
            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
          }
        } else if (isToggle && onUpdate && !_refreshing) {
          onUpdate(self);
        }
      } // update absolutely-positioned markers (only if the scroller isn't the viewport)

      if (markerEndSetter) {
        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
        markerEndSetter(n);
      }
      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
    };
    self.enable = function (reset, refresh) {
      if (!self.enabled) {
        self.enabled = true;
        _addListener(scroller, "resize", _onResize);
        _addListener(isViewport ? _doc : scroller, "scroll", _onScroll);
        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);
        if (reset !== false) {
          self.progress = prevProgress = 0;
          scroll1 = scroll2 = lastSnap = scrollFunc();
        }
        refresh !== false && self.refresh();
      }
    };
    self.getTween = function (snap) {
      return snap && tweenTo ? tweenTo.tween : scrubTween;
    };
    self.setPositions = function (newStart, newEnd) {
      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
      if (pin) {
        pinStart += newStart - start;
        pinChange += newEnd - newStart - change;
        pinSpacing === _padding && self.adjustPinSpacing(newEnd - newStart - change);
      }
      self.start = start = newStart;
      self.end = end = newEnd;
      change = newEnd - newStart;
      self.update();
    };
    self.adjustPinSpacing = function (amount) {
      if (spacerState) {
        var i = spacerState.indexOf(direction.d) + 1;
        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
        _setState(spacerState);
      }
    };
    self.disable = function (reset, allowAnimation) {
      if (self.enabled) {
        reset !== false && self.revert(true, true);
        self.enabled = self.isActive = false;
        allowAnimation || scrubTween && scrubTween.pause();
        prevScroll = 0;
        pinCache && (pinCache.uncache = 1);
        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
        if (snapDelayedCall) {
          snapDelayedCall.pause();
          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
        }
        if (!isViewport) {
          var i = _triggers.length;
          while (i--) {
            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
              return; //don't remove the listeners if there are still other triggers referencing it.
            }
          }

          _removeListener(scroller, "resize", _onResize);
          _removeListener(scroller, "scroll", _onScroll);
        }
      }
    };
    self.kill = function (revert, allowAnimation) {
      self.disable(revert, allowAnimation);
      scrubTween && !allowAnimation && scrubTween.kill();
      id && delete _ids[id];
      var i = _triggers.indexOf(self);
      i >= 0 && _triggers.splice(i, 1);
      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

      i = 0;
      _triggers.forEach(function (t) {
        return t.scroller === self.scroller && (i = 1);
      });
      i || _refreshingAll || (self.scroll.rec = 0);
      if (animation) {
        animation.scrollTrigger = null;
        revert && animation.revert({
          kill: false
        });
        allowAnimation || animation.kill();
      }
      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
        return m.parentNode && m.parentNode.removeChild(m);
      });
      _primary === self && (_primary = 0);
      if (pin) {
        pinCache && (pinCache.uncache = 1);
        i = 0;
        _triggers.forEach(function (t) {
          return t.pin === pin && i++;
        });
        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
      }

      vars.onKill && vars.onKill(self);
    };
    self.enable(false, false);
    customRevertReturn && customRevertReturn(self);
    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
      return start || end || self.refresh();
    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.

    pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()
  };

  ScrollTrigger.register = function register(core) {
    if (!_coreInitted) {
      gsap = core || _getGSAP();
      _windowExists() && window.document && ScrollTrigger.enable();
      _coreInitted = _enabled;
    }
    return _coreInitted;
  };
  ScrollTrigger.defaults = function defaults(config) {
    if (config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }
    return _defaults;
  };
  ScrollTrigger.disable = function disable(reset, kill) {
    _enabled = 0;
    _triggers.forEach(function (trigger) {
      return trigger[kill ? "kill" : "disable"](reset);
    });
    _removeListener(_win, "wheel", _onScroll);
    _removeListener(_doc, "scroll", _onScroll);
    clearInterval(_syncInterval);
    _removeListener(_doc, "touchcancel", _passThrough);
    _removeListener(_body, "touchstart", _passThrough);
    _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
    _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);
    _resizeDelay.kill();
    _iterateAutoRefresh(_removeListener);
    for (var i = 0; i < _Observer._scrollers.length; i += 3) {
      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);
      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
    }
  };
  ScrollTrigger.enable = function enable() {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;
    if (gsap) {
      _toArray = gsap.utils.toArray;
      _clamp = gsap.utils.clamp;
      _context = gsap.core.context || _passThrough;
      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
      _scrollRestoration = _win.history.scrollRestoration || "auto";
      gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

      if (_body) {
        _enabled = 1;
        _Observer.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

        ScrollTrigger.isTouch = _Observer.Observer.isTouch;
        _fixIOSBug = _Observer.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

        _addListener(_win, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.

        _root = [_win, _doc, _docEl, _body];
        if (gsap.matchMedia) {
          ScrollTrigger.matchMedia = function (vars) {
            var mm = gsap.matchMedia(),
              p;
            for (p in vars) {
              mm.add(p, vars[p]);
            }
            return mm;
          };
          gsap.addEventListener("matchMediaInit", function () {
            return _revertAll();
          });
          gsap.addEventListener("matchMediaRevert", function () {
            return _revertRecorded();
          });
          gsap.addEventListener("matchMedia", function () {
            _refreshAll(0, 1);
            _dispatch("matchMedia");
          });
          gsap.matchMedia("(orientation: portrait)", function () {
            // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
            _setBaseDimensions();
            return _setBaseDimensions;
          });
        } else {
          console.warn("Requires GSAP 3.11.0 or later");
        }
        _setBaseDimensions();
        _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!

        var bodyStyle = _body.style,
          border = bodyStyle.borderTopStyle,
          AnimationProto = gsap.core.Animation.prototype,
          bounds,
          i;
        AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
          value: function value() {
            return this.time(-0.01, true);
          }
        }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)

        bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

        bounds = _getBounds(_body);
        _Observer._vertical.m = Math.round(bounds.top + _Observer._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

        _Observer._horizontal.m = Math.round(bounds.left + _Observer._horizontal.sc()) || 0;
        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

        _syncInterval = setInterval(_sync, 250);
        gsap.delayedCall(0.5, function () {
          return _startup = 0;
        });
        _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.

        _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/

        _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
        _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);
        _transformProp = gsap.utils.checkPrefix("transform");
        _stateProps.push(_transformProp);
        _coreInitted = _getTime();
        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
        _autoRefresh = [_doc, "visibilitychange", function () {
          var w = _win.innerWidth,
            h = _win.innerHeight;
          if (_doc.hidden) {
            _prevWidth = w;
            _prevHeight = h;
          } else if (_prevWidth !== w || _prevHeight !== h) {
            _onResize();
          }
        }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];
        _iterateAutoRefresh(_addListener);
        _triggers.forEach(function (trigger) {
          return trigger.enable(0, 1);
        });
        for (i = 0; i < _Observer._scrollers.length; i += 3) {
          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);
          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
        }
      }
    }
  };
  ScrollTrigger.config = function config(vars) {
    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
    var ms = vars.syncInterval;
    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
    "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
    if ("autoRefreshEvents" in vars) {
      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
    }
  };
  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
    var t = (0, _Observer._getTarget)(target),
      i = _Observer._scrollers.indexOf(t),
      isViewport = _isViewport(t);
    if (~i) {
      _Observer._scrollers.splice(i, isViewport ? 6 : 2);
    }
    if (vars) {
      isViewport ? _Observer._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer._proxies.unshift(t, vars);
    }
  };
  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
    _triggers.forEach(function (t) {
      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
    });
  };
  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
    var bounds = (_isString(element) ? (0, _Observer._getTarget)(element) : element).getBoundingClientRect(),
      offset = bounds[horizontal ? _width : _height] * ratio || 0;
    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
  };
  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
    _isString(element) && (element = (0, _Observer._getTarget)(element));
    var bounds = element.getBoundingClientRect(),
      size = bounds[horizontal ? _width : _height],
      offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
  };
  ScrollTrigger.killAll = function killAll(allowListeners) {
    _triggers.slice(0).forEach(function (t) {
      return t.vars.id !== "ScrollSmoother" && t.kill();
    });
    if (allowListeners !== true) {
      var listeners = _listeners.killAll || [];
      _listeners = {};
      listeners.forEach(function (f) {
        return f();
      });
    }
  };
  return ScrollTrigger;
}();
exports.default = exports.ScrollTrigger = ScrollTrigger;
ScrollTrigger.version = "3.11.4";
ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);
      i >= 0 && _savedStyles.splice(i, 5);
      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _context());
    }
  }) : _savedStyles;
};
ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};
ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger(vars, animation);
};
ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
};
ScrollTrigger.update = function (force) {
  return ++_Observer._scrollers.cache && _updateAll(force === true ? 2 : 0);
};
ScrollTrigger.clearScrollMemory = _clearScrollMemory;
ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _Observer._horizontal : _Observer._vertical);
};
ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return (0, _Observer._getScrollFunc)((0, _Observer._getTarget)(element), horizontal ? _Observer._horizontal : _Observer._vertical);
};
ScrollTrigger.getById = function (id) {
  return _ids[id];
};
ScrollTrigger.getAll = function () {
  return _triggers.filter(function (t) {
    return t.vars.id !== "ScrollSmoother";
  });
}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.

ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};
ScrollTrigger.snapDirectional = _snapDirectional;
ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};
ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
    i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};
ScrollTrigger.batch = function (targets, vars) {
  var result = [],
    varsCopy = {},
    interval = vars.interval || 0.016,
    batchMax = vars.batchMax || 1e9,
    proxyCallback = function proxyCallback(type, callback) {
      var elements = [],
        triggers = [],
        delay = gsap.delayedCall(interval, function () {
          callback(elements, triggers);
          elements = [];
          triggers = [];
        }).pause();
      return function (self) {
        elements.length || delay.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay.progress(1);
      };
    },
    p;
  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }
  if (_isFunction(batchMax)) {
    batchMax = batchMax();
    _addListener(ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }
  _toArray(targets).forEach(function (target) {
    var config = {};
    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }
    config.trigger = target;
    result.push(ScrollTrigger.create(config));
  });
  return result;
}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).

var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  },
  _allowNativePanning = function _allowNativePanning(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (_Observer.Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
    }

    target === _docEl && _allowNativePanning(_body, direction);
  },
  _overflow = {
    auto: 1,
    scroll: 1
  },
  _nestedScroll = function _nestedScroll(_ref5) {
    var event = _ref5.event,
      target = _ref5.target,
      axis = _ref5.axis;
    var node = (event.changedTouches ? event.changedTouches[0] : event).target,
      cache = node._gsap || gsap.core.getCache(node),
      time = _getTime(),
      cs;
    if (!cache._isScrollT || time - cache._isScrollT > 2000) {
      // cache for 2 seconds to improve performance.
      while (node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }
      cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time;
    }
    if (cache._isScroll || axis === "x") {
      event.stopPropagation();
      event._gsapAllow = true;
    }
  },
  // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
  _inputObserver = function _inputObserver(target, type, inputs, nested) {
    return _Observer.Observer.create({
      target: target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type: type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, true);
      }
    });
  },
  _inputExp = /(input|label|select|textarea)/i,
  _inputIsFocused,
  _captureInputs = function _captureInputs(e) {
    var isInput = _inputExp.test(e.target.tagName);
    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  },
  _getScrollNormalizer = function _getScrollNormalizer(vars) {
    _isObject(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";
    var _vars2 = vars,
      normalizeScrollX = _vars2.normalizeScrollX,
      momentum = _vars2.momentum,
      allowNestedScroll = _vars2.allowNestedScroll,
      self,
      maxY,
      target = (0, _Observer._getTarget)(vars.target) || _docEl,
      smoother = gsap.core.globals().ScrollSmoother,
      smootherInstance = smoother && smoother.get(),
      content = _fixIOSBug && (vars.content && (0, _Observer._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
      scrollFuncY = (0, _Observer._getScrollFunc)(target, _Observer._vertical),
      scrollFuncX = (0, _Observer._getScrollFunc)(target, _Observer._horizontal),
      scale = 1,
      initialScale = (_Observer.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
      wheelRefresh = 0,
      resolveMomentumDuration = _isFunction(momentum) ? function () {
        return momentum(self);
      } : function () {
        return momentum || 2.8;
      },
      lastRefreshID,
      skipTouchMove,
      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
      resumeTouchMove = function resumeTouchMove() {
        return skipTouchMove = false;
      },
      scrollClampX = _passThrough,
      scrollClampY = _passThrough,
      updateClamps = function updateClamps() {
        maxY = _maxScroll(target, _Observer._vertical);
        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer._horizontal)));
        lastRefreshID = _refreshID;
      },
      removeContentOffset = function removeContentOffset() {
        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
        scrollFuncY.offset = scrollFuncY.cacheID = 0;
      },
      ignoreDrag = function ignoreDrag() {
        if (skipTouchMove) {
          requestAnimationFrame(resumeTouchMove);
          var offset = _round(self.deltaY / 2),
            scroll = scrollClampY(scrollFuncY.v - offset);
          if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
            scrollFuncY.offset = scroll - scrollFuncY.v;
            var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
            content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
            content._gsap.y = y + "px";
            scrollFuncY.cacheID = _Observer._scrollers.cache;
            _updateAll();
          }
          return true;
        }
        scrollFuncY.offset && removeContentOffset();
        skipTouchMove = true;
      },
      tween,
      startScrollX,
      startScrollY,
      onStopDelayedCall,
      onResize = function onResize() {
        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
        updateClamps();
        if (tween.isActive() && tween.vars.scrollY > maxY) {
          scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
        }
      };
    content && gsap.set(content, {
      y: "+=0"
    }); // to ensure there's a cache (element._gsap)

    vars.ignoreCheck = function (e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
    };
    vars.onPress = function () {
      var prevScale = scale;
      scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };
    vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
      scrollFuncY.offset && removeContentOffset();
      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _Observer._scrollers.cache++; // make sure we're pulling the non-cached value
        // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

        var dur = resolveMomentumDuration(),
          currentScroll,
          endScroll;
        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer._horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }
        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer._vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);
        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
          gsap.to({}, {
            onUpdate: onResize,
            duration: dur
          });
        }
      }
    };
    vars.onWheel = function () {
      tween._ts && tween.pause();
      if (_getTime() - wheelRefresh > 1000) {
        // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
        lastRefreshID = 0;
        wheelRefresh = _getTime();
      }
    };
    vars.onChange = function (self, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy,
          y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
          yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }
      (dy || dx) && _updateAll();
    };
    vars.onEnable = function () {
      _allowNativePanning(target, normalizeScrollX ? false : "x");
      ScrollTrigger.addEventListener("refresh", onResize);
      _addListener(_win, "resize", onResize);
      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }
      inputObserver.enable();
    };
    vars.onDisable = function () {
      _allowNativePanning(target, true);
      _removeListener(_win, "resize", onResize);
      ScrollTrigger.removeEventListener("refresh", onResize);
      inputObserver.kill();
    };
    vars.lockAxis = vars.lockAxis !== false;
    self = new _Observer.Observer(vars);
    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

    _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping

    onStopDelayedCall = self._dc;
    tween = gsap.to(self, {
      ease: "power4",
      paused: true,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      onComplete: onStopDelayedCall.vars.onComplete
    });
    return self;
  };
ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};
ScrollTrigger.observe = function (vars) {
  return new _Observer.Observer(vars);
};
ScrollTrigger.normalizeScroll = function (vars) {
  if (typeof vars === "undefined") {
    return _normalizer;
  }
  if (vars === true && _normalizer) {
    return _normalizer.enable();
  }
  if (vars === false) {
    return _normalizer && _normalizer.kill();
  }
  var normalizer = vars instanceof _Observer.Observer ? vars : _getScrollNormalizer(vars);
  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
  _isViewport(normalizer.target) && (_normalizer = normalizer);
  return normalizer;
};
ScrollTrigger.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: _Observer._getVelocityProp,
  _inputObserver: _inputObserver,
  _scrollers: _Observer._scrollers,
  _proxies: _Observer._proxies,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function ss() {
      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    },
    // a way to get the _refreshing value in Observer
    ref: function ref() {
      return _refreshing;
    }
  }
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);
},{"./Observer.js":"node_modules/gsap/Observer.js"}],"node_modules/tiny-emitter/index.js":[function(require,module,exports) {
function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;

},{}],"node_modules/virtual-scroll/lib/virtualscroll.js":[function(require,module,exports) {
var define;
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e||self).virtualScroll=t()}(this,function(){var e=0;function t(t){return"__private_"+e+++"_"+t}function i(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}function n(){}n.prototype={on:function(e,t,i){var n=this.e||(this.e={});return(n[e]||(n[e]=[])).push({fn:t,ctx:i}),this},once:function(e,t,i){var n=this;function o(){n.off(e,o),t.apply(i,arguments)}return o._=t,this.on(e,o,i)},emit:function(e){for(var t=[].slice.call(arguments,1),i=((this.e||(this.e={}))[e]||[]).slice(),n=0,o=i.length;n<o;n++)i[n].fn.apply(i[n].ctx,t);return this},off:function(e,t){var i=this.e||(this.e={}),n=i[e],o=[];if(n&&t)for(var s=0,h=n.length;s<h;s++)n[s].fn!==t&&n[s].fn._!==t&&o.push(n[s]);return o.length?i[e]=o:delete i[e],this}};var o=n;o.TinyEmitter=n;var s,h="virtualscroll",r=t("options"),a=t("el"),l=t("emitter"),u=t("event"),c=t("touchStart"),d=t("bodyTouchAction");return function(){function e(e){var t=this;Object.defineProperty(this,r,{writable:!0,value:void 0}),Object.defineProperty(this,a,{writable:!0,value:void 0}),Object.defineProperty(this,l,{writable:!0,value:void 0}),Object.defineProperty(this,u,{writable:!0,value:void 0}),Object.defineProperty(this,c,{writable:!0,value:void 0}),Object.defineProperty(this,d,{writable:!0,value:void 0}),this._onWheel=function(e){var n=i(t,r)[r],o=i(t,u)[u];o.deltaX=e.wheelDeltaX||-1*e.deltaX,o.deltaY=e.wheelDeltaY||-1*e.deltaY,s.isFirefox&&1===e.deltaMode&&(o.deltaX*=n.firefoxMultiplier,o.deltaY*=n.firefoxMultiplier),o.deltaX*=n.mouseMultiplier,o.deltaY*=n.mouseMultiplier,t._notify(e)},this._onMouseWheel=function(e){var n=i(t,u)[u];n.deltaX=e.wheelDeltaX?e.wheelDeltaX:0,n.deltaY=e.wheelDeltaY?e.wheelDeltaY:e.wheelDelta,t._notify(e)},this._onTouchStart=function(e){var n=e.targetTouches?e.targetTouches[0]:e;i(t,c)[c].x=n.pageX,i(t,c)[c].y=n.pageY},this._onTouchMove=function(e){var n=i(t,r)[r];n.preventTouch&&!e.target.classList.contains(n.unpreventTouchClass)&&e.preventDefault();var o=i(t,u)[u],s=e.targetTouches?e.targetTouches[0]:e;o.deltaX=(s.pageX-i(t,c)[c].x)*n.touchMultiplier,o.deltaY=(s.pageY-i(t,c)[c].y)*n.touchMultiplier,i(t,c)[c].x=s.pageX,i(t,c)[c].y=s.pageY,t._notify(e)},this._onKeyDown=function(e){var n=i(t,u)[u];n.deltaX=n.deltaY=0;var o=window.innerHeight-40;switch(e.keyCode){case 37:case 38:n.deltaY=i(t,r)[r].keyStep;break;case 39:case 40:n.deltaY=-i(t,r)[r].keyStep;break;case 32:n.deltaY=o*(e.shiftKey?1:-1);break;default:return}t._notify(e)},i(this,a)[a]=window,e&&e.el&&(i(this,a)[a]=e.el,delete e.el),s||(s={hasWheelEvent:"onwheel"in document,hasMouseWheelEvent:"onmousewheel"in document,hasTouch:"ontouchstart"in document,hasTouchWin:navigator.msMaxTouchPoints&&navigator.msMaxTouchPoints>1,hasPointer:!!window.navigator.msPointerEnabled,hasKeyDown:"onkeydown"in document,isFirefox:navigator.userAgent.indexOf("Firefox")>-1}),i(this,r)[r]=Object.assign({mouseMultiplier:1,touchMultiplier:2,firefoxMultiplier:15,keyStep:120,preventTouch:!1,unpreventTouchClass:"vs-touchmove-allowed",useKeyboard:!0,useTouch:!0},e),i(this,l)[l]=new o,i(this,u)[u]={y:0,x:0,deltaX:0,deltaY:0},i(this,c)[c]={x:null,y:null},i(this,d)[d]=null,void 0!==i(this,r)[r].passive&&(this.listenerOptions={passive:i(this,r)[r].passive})}var t=e.prototype;return t._notify=function(e){var t=i(this,u)[u];t.x+=t.deltaX,t.y+=t.deltaY,i(this,l)[l].emit(h,{x:t.x,y:t.y,deltaX:t.deltaX,deltaY:t.deltaY,originalEvent:e})},t._bind=function(){s.hasWheelEvent&&i(this,a)[a].addEventListener("wheel",this._onWheel,this.listenerOptions),s.hasMouseWheelEvent&&i(this,a)[a].addEventListener("mousewheel",this._onMouseWheel,this.listenerOptions),s.hasTouch&&i(this,r)[r].useTouch&&(i(this,a)[a].addEventListener("touchstart",this._onTouchStart,this.listenerOptions),i(this,a)[a].addEventListener("touchmove",this._onTouchMove,this.listenerOptions)),s.hasPointer&&s.hasTouchWin&&(i(this,d)[d]=document.body.style.msTouchAction,document.body.style.msTouchAction="none",i(this,a)[a].addEventListener("MSPointerDown",this._onTouchStart,!0),i(this,a)[a].addEventListener("MSPointerMove",this._onTouchMove,!0)),s.hasKeyDown&&i(this,r)[r].useKeyboard&&document.addEventListener("keydown",this._onKeyDown)},t._unbind=function(){s.hasWheelEvent&&i(this,a)[a].removeEventListener("wheel",this._onWheel),s.hasMouseWheelEvent&&i(this,a)[a].removeEventListener("mousewheel",this._onMouseWheel),s.hasTouch&&(i(this,a)[a].removeEventListener("touchstart",this._onTouchStart),i(this,a)[a].removeEventListener("touchmove",this._onTouchMove)),s.hasPointer&&s.hasTouchWin&&(document.body.style.msTouchAction=i(this,d)[d],i(this,a)[a].removeEventListener("MSPointerDown",this._onTouchStart,!0),i(this,a)[a].removeEventListener("MSPointerMove",this._onTouchMove,!0)),s.hasKeyDown&&i(this,r)[r].useKeyboard&&document.removeEventListener("keydown",this._onKeyDown)},t.on=function(e,t){i(this,l)[l].on(h,e,t);var n=i(this,l)[l].e;n&&n[h]&&1===n[h].length&&this._bind()},t.off=function(e,t){i(this,l)[l].off(h,e,t);var n=i(this,l)[l].e;(!n[h]||n[h].length<=0)&&this._unbind()},t.destroy=function(){i(this,l)[l].off(),this._unbind()},e}()});

},{}],"node_modules/@studio-freight/lenis/dist/lenis.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tinyEmitter = require("tiny-emitter");
var _virtualScroll = _interopRequireDefault(require("virtual-scroll"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function i(t, e) {
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
  }
}
function o(t, e, o) {
  return e && i(t.prototype, e), o && i(t, o), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function r() {
  return r = Object.assign ? Object.assign.bind() : function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, r.apply(this, arguments);
}
function n(t, e) {
  return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, n(t, e);
}
function s(t, e) {
  var i = t % e;
  return (e > 0 && i < 0 || e < 0 && i > 0) && (i += e), i;
}
var l = ["duration", "easing"],
  a = /*#__PURE__*/function () {
    function t() {}
    var e = t.prototype;
    return e.to = function (t, e) {
      var i = this,
        o = void 0 === e ? {} : e,
        n = o.duration,
        s = void 0 === n ? 1 : n,
        a = o.easing,
        c = void 0 === a ? function (t) {
          return t;
        } : a,
        h = function (t, e) {
          if (null == t) return {};
          var i,
            o,
            r = {},
            n = Object.keys(t);
          for (o = 0; o < n.length; o++) e.indexOf(i = n[o]) >= 0 || (r[i] = t[i]);
          return r;
        }(o, l);
      this.target = t, this.fromKeys = r({}, h), this.toKeys = r({}, h), this.keys = Object.keys(r({}, h)), this.keys.forEach(function (e) {
        i.fromKeys[e] = t[e];
      }), this.duration = s, this.easing = c, this.currentTime = 0, this.isRunning = !0;
    }, e.stop = function () {
      this.isRunning = !1;
    }, e.raf = function (t) {
      var e = this;
      if (this.isRunning) {
        this.currentTime = Math.min(this.currentTime + t, this.duration);
        var i = this.progress >= 1 ? 1 : this.easing(this.progress);
        this.keys.forEach(function (t) {
          var o = e.fromKeys[t];
          e.target[t] = o + (e.toKeys[t] - o) * i;
        }), 1 === i && this.stop();
      }
    }, o(t, [{
      key: "progress",
      get: function () {
        return this.currentTime / this.duration;
      }
    }]), t;
  }(),
  c = /*#__PURE__*/function (t) {
    var i, r;
    function l(i) {
      var o,
        r,
        n,
        s,
        l = void 0 === i ? {} : i,
        c = l.duration,
        h = void 0 === c ? 1.2 : c,
        p = l.easing,
        u = void 0 === p ? function (t) {
          return Math.min(1, 1.001 - Math.pow(2, -10 * t));
        } : p,
        d = l.smooth,
        f = void 0 === d || d,
        v = l.mouseMultiplier,
        w = void 0 === v ? 1 : v,
        g = l.smoothTouch,
        m = void 0 !== g && g,
        y = l.touchMultiplier,
        b = void 0 === y ? 2 : y,
        S = l.direction,
        N = void 0 === S ? "vertical" : S,
        O = l.gestureDirection,
        z = void 0 === O ? "vertical" : O,
        R = l.infinite,
        W = void 0 !== R && R,
        M = l.wrapper,
        T = void 0 === M ? window : M,
        k = l.content,
        j = void 0 === k ? document.body : k;
      (s = t.call(this) || this).onWindowResize = function () {
        s.wrapperWidth = window.innerWidth, s.wrapperHeight = window.innerHeight;
      }, s.onWrapperResize = function (t) {
        var e = t[0];
        if (e) {
          var i = e.contentRect;
          s.wrapperWidth = i.width, s.wrapperHeight = i.height;
        }
      }, s.onContentResize = function (t) {
        var e = t[0];
        if (e) {
          var i = e.contentRect;
          s.contentWidth = i.width, s.contentHeight = i.height;
        }
      }, s.onVirtualScroll = function (t) {
        var e = t.deltaY,
          i = t.deltaX,
          o = t.originalEvent;
        if (!("vertical" === s.gestureDirection && 0 === e || "horizontal" === s.gestureDirection && 0 === i)) {
          var r = !!o.composedPath().find(function (t) {
            return t.hasAttribute && t.hasAttribute("data-lenis-prevent");
          });
          o.ctrlKey || r || (s.smooth = o.changedTouches ? s.smoothTouch : s.options.smooth, s.stopped ? o.preventDefault() : s.smooth && 4 !== o.buttons && (s.smooth && o.preventDefault(), s.targetScroll -= "both" === s.gestureDirection ? i + e : "horizontal" === s.gestureDirection ? i : e, s.scrollTo(s.targetScroll)));
        }
      }, s.onScroll = function (t) {
        s.isScrolling && s.smooth || (s.targetScroll = s.scroll = s.lastScroll = s.wrapperNode[s.scrollProperty], s.notify());
      }, window.lenisVersion = "0.2.28", s.options = {
        duration: h,
        easing: u,
        smooth: f,
        mouseMultiplier: w,
        smoothTouch: m,
        touchMultiplier: b,
        direction: N,
        gestureDirection: z,
        infinite: W,
        wrapper: T,
        content: j
      }, s.duration = h, s.easing = u, s.smooth = f, s.mouseMultiplier = w, s.smoothTouch = m, s.touchMultiplier = b, s.direction = N, s.gestureDirection = z, s.infinite = W, s.wrapperNode = T, s.contentNode = j, s.wrapperNode.addEventListener("scroll", s.onScroll), s.wrapperNode === window ? (s.wrapperNode.addEventListener("resize", s.onWindowResize), s.onWindowResize()) : (s.wrapperHeight = s.wrapperNode.offsetHeight, s.wrapperWidth = s.wrapperNode.offsetWidth, s.wrapperObserver = new ResizeObserver(s.onWrapperResize), s.wrapperObserver.observe(s.wrapperNode)), s.contentHeight = s.contentNode.offsetHeight, s.contentWidth = s.contentNode.offsetWidth, s.contentObserver = new ResizeObserver(s.onContentResize), s.contentObserver.observe(s.contentNode), s.targetScroll = s.scroll = s.lastScroll = s.wrapperNode[s.scrollProperty], s.animate = new a();
      var D = (null == (o = navigator) || null == (r = o.userAgentData) ? void 0 : r.platform) || (null == (n = navigator) ? void 0 : n.platform) || "unknown";
      return s.virtualScroll = new _virtualScroll.default({
        el: s.wrapperNode,
        firefoxMultiplier: 50,
        mouseMultiplier: s.mouseMultiplier * (D.includes("Win") || D.includes("Linux") ? .84 : .4),
        touchMultiplier: s.touchMultiplier,
        passive: !1,
        useKeyboard: !1,
        useTouch: !0
      }), s.virtualScroll.on(s.onVirtualScroll), s;
    }
    r = t, (i = l).prototype = Object.create(r.prototype), i.prototype.constructor = i, n(i, r);
    var c = l.prototype;
    return c.start = function () {
      var t = this.wrapperNode;
      this.wrapperNode === window && (t = document.documentElement), t.classList.remove("lenis-stopped"), this.stopped = !1;
    }, c.stop = function () {
      var t = this.wrapperNode;
      this.wrapperNode === window && (t = document.documentElement), t.classList.add("lenis-stopped"), this.stopped = !0, this.animate.stop();
    }, c.destroy = function () {
      var t;
      this.wrapperNode === window && this.wrapperNode.removeEventListener("resize", this.onWindowResize), this.wrapperNode.removeEventListener("scroll", this.onScroll), this.virtualScroll.destroy(), null == (t = this.wrapperObserver) || t.disconnect(), this.contentObserver.disconnect();
    }, c.raf = function (t) {
      var e = t - (this.now || 0);
      this.now = t, !this.stopped && this.smooth && (this.lastScroll = this.scroll, this.animate.raf(.001 * e), this.scroll === this.targetScroll && (this.lastScroll = this.scroll), this.isScrolling && (this.setScroll(this.scroll), this.notify()), this.isScrolling = this.scroll !== this.targetScroll);
    }, c.setScroll = function (t) {
      var e = this.infinite ? s(t, this.limit) : t;
      "horizontal" === this.direction ? this.wrapperNode.scrollTo(e, 0) : this.wrapperNode.scrollTo(0, e);
    }, c.notify = function () {
      var t = this.infinite ? s(this.scroll, this.limit) : this.scroll;
      this.emit("scroll", {
        scroll: t,
        limit: this.limit,
        velocity: this.velocity,
        direction: 0 === this.velocity ? 0 : this.velocity > 0 ? 1 : -1,
        progress: t / this.limit
      });
    }, c.scrollTo = function (t, e) {
      var i = void 0 === e ? {} : e,
        o = i.offset,
        r = void 0 === o ? 0 : o,
        n = i.immediate,
        s = void 0 !== n && n,
        l = i.duration,
        a = void 0 === l ? this.duration : l,
        c = i.easing,
        h = void 0 === c ? this.easing : c;
      if (null != t && !this.stopped) {
        var p;
        if ("number" == typeof t) p = t;else if ("top" === t || "#top" === t) p = 0;else if ("bottom" === t) p = this.limit;else {
          var u;
          if ("string" == typeof t) u = document.querySelector(t);else {
            if (null == t || !t.nodeType) return;
            u = t;
          }
          if (!u) return;
          var d = 0;
          if (this.wrapperNode !== window) {
            var f = this.wrapperNode.getBoundingClientRect();
            d = "horizontal" === this.direction ? f.left : f.top;
          }
          var v = u.getBoundingClientRect();
          p = ("horizontal" === this.direction ? v.left : v.top) + this.scroll - d;
        }
        p += r, this.targetScroll = this.infinite ? p : Math.max(0, Math.min(p, this.limit)), !this.smooth || s ? (this.animate.stop(), this.scroll = this.lastScroll = this.targetScroll, this.setScroll(this.targetScroll)) : this.animate.to(this, {
          duration: a,
          easing: h,
          scroll: this.targetScroll
        });
      }
    }, o(l, [{
      key: "scrollProperty",
      get: function () {
        return this.wrapperNode === window ? "horizontal" === this.direction ? "scrollX" : "scrollY" : "horizontal" === this.direction ? "scrollLeft" : "scrollTop";
      }
    }, {
      key: "limit",
      get: function () {
        return "horizontal" === this.direction ? this.contentWidth - this.wrapperWidth : this.contentHeight - this.wrapperHeight;
      }
    }, {
      key: "velocity",
      get: function () {
        return this.scroll - this.lastScroll;
      }
    }]), l;
  }(_tinyEmitter.TinyEmitter);
exports.default = c;
},{"tiny-emitter":"node_modules/tiny-emitter/index.js","virtual-scroll":"node_modules/virtual-scroll/lib/virtualscroll.js"}],"src/index.ts":[function(require,module,exports) {
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var webgi_1 = require("webgi");
require("./styles.css");
var gsap_1 = __importDefault(require("gsap"));
var ScrollTrigger_1 = require("gsap/ScrollTrigger");
var lenis_1 = __importDefault(require("@studio-freight/lenis"));
var lenis = new lenis_1.default({
  duration: 1.2,
  easing: function easing(t) {
    return Math.min(1, 1.001 - Math.pow(2, -10 * t));
  },
  direction: 'vertical',
  gestureDirection: 'vertical',
  smooth: true,
  mouseMultiplier: 1,
  smoothTouch: false,
  touchMultiplier: 2,
  infinite: false
});
lenis.stop();
function raf(time) {
  lenis.raf(time);
  requestAnimationFrame(raf);
}
requestAnimationFrame(raf);
gsap_1.default.registerPlugin(ScrollTrigger_1.ScrollTrigger);
function setupViewer() {
  var _a, _b;
  return __awaiter(this, void 0, void 0, function () {
    function setupScrollanimation() {
      var tl = gsap_1.default.timeline();
      // FIRST SECTION
      tl.to(position, {
        x: isMobile ? 0.0418627019 : -6.3704870411,
        y: isMobile ? 0.0202326985 : 0.3476209261,
        z: isMobile ? 7.1833229412 : 8.2687543968,
        scrollTrigger: {
          trigger: ".view",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: isMobile ? -0.4745182352 : -0.5787707603,
        y: isMobile ? -0.1852581565 : 0.0490187597,
        z: isMobile ? 0.4694950004 : 3.4536311728,
        scrollTrigger: {
          trigger: ".view",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        }
      })
      // LAST SECTION
      .to(position, {
        x: isMobile ? 0.0418627019 : -0.342829813,
        y: isMobile ? 0.0202326985 : 0.1480815996,
        z: isMobile ? 7.1833229412 : 8.9495383738,
        scrollTrigger: {
          trigger: ".explore",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: isMobile ? -0.4745182352 : -1.7696163949,
        y: isMobile ? -0.1852581565 : -0.0967027417,
        z: isMobile ? 0.4694950004 : 1.5592421678,
        scrollTrigger: {
          trigger: ".explore",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        }
      })
      //more section
      .to("#webgi-canvas", {
        opacity: 0,
        scrollTrigger: {
          trigger: ".top-seller",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      });
    }
    function onUpdate() {
      needsUpdate = true;
      // viewer.renderer.resetShadows()
      viewer.setDirty();
    }
    function enableControlers() {
      exitButton.style.display = "block";
      customizerInterface.style.display = "block";
      viewer.scene.activeCamera.setCameraOptions({
        controlsEnabled: true
      });
    }
    var viewer, isMobile, manager, camera, position, target, exitButton, customizerInterface, importer, drillMaterial, needsUpdate, sections, footer, mainContainer;
    return __generator(this, function (_c) {
      switch (_c.label) {
        case 0:
          viewer = new webgi_1.ViewerApp({
            canvas: document.getElementById('webgi-canvas')
            // isAntialiased: true,
          });

          isMobile = (0, webgi_1.mobileAndTabletCheck)();
          return [4 /*yield*/, viewer.addPlugin(webgi_1.AssetManagerPlugin)];
        case 1:
          manager = _c.sent();
          camera = viewer.scene.activeCamera;
          position = camera.position;
          target = camera.target;
          exitButton = document.querySelector('.exit');
          customizerInterface = document.querySelector('.customizer--container');
          // Add plugins individually.
          return [4 /*yield*/, viewer.addPlugin(webgi_1.GBufferPlugin)];
        case 2:
          // Add plugins individually.
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(new webgi_1.ProgressivePlugin(32))];
        case 3:
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(new webgi_1.TonemapPlugin(true))];
        case 4:
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(webgi_1.GammaCorrectionPlugin)];
        case 5:
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(webgi_1.SSRPlugin)];
        case 6:
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(webgi_1.SSAOPlugin)];
        case 7:
          _c.sent();
          return [4 /*yield*/, viewer.addPlugin(webgi_1.BloomPlugin)
          // Loader
          ];

        case 8:
          _c.sent();
          importer = manager.importer;
          importer.addEventListener("onProgress", function (ev) {
            var _a;
            var progressRatio = ev.loaded / ev.total;
            // console.log(progressRatio)
            (_a = document.querySelector('.progress')) === null || _a === void 0 ? void 0 : _a.setAttribute('style', "transform: scaleX(" + progressRatio + ")");
          });
          importer.addEventListener("onLoad", function (ev) {
            gsap_1.default.to('.loader', {
              x: '100%',
              duration: 0.8,
              ease: 'power4.inOut',
              delay: 1,
              onComplete: function onComplete() {
                document.body.style.overflowY = 'auto';
                lenis.start();
              }
            });
          });
          viewer.renderer.refreshPipeline();
          return [4 /*yield*/, manager.addFromPath("./assets/scene2.glb")];
        case 9:
          _c.sent();
          drillMaterial = manager.materials.findMaterialsByName('Drill_01')[0];
          viewer.getPlugin(webgi_1.TonemapPlugin).config.clipBackground = true; // in case its set to false in the glb
          viewer.scene.activeCamera.setCameraOptions({
            controlsEnabled: false
          });
          if (isMobile) {
            position.set(-3.5, -1.1, 5.5);
            target.set(-0.8, 1.55, -0.7);
            camera.setCameraOptions({
              fov: 40
            });
          }
          onUpdate();
          window.scrollTo(0, 0);
          setupScrollanimation();
          needsUpdate = true;
          viewer.addEventListener('preFrame', function () {
            if (needsUpdate) {
              camera.positionTargetUpdated(true);
              needsUpdate = false;
            }
          });
          // KNOW MORE EVENT
          (_a = document.querySelector('.button--hero')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', function () {
            var element = document.querySelector('.second');
            window.scrollTo({
              top: element === null || element === void 0 ? void 0 : element.getBoundingClientRect().top,
              left: 0,
              behavior: 'smooth'
            });
          });
          sections = document.querySelector('.remove');
          footer = document.querySelector('.footer');
          mainContainer = document.getElementById('webgi-canvas-container');
          (_b = document.querySelector('.edit')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', function () {
            sections.style.display = "none";
            footer.style.display = "none";
            mainContainer.style.pointerEvents = "all";
            document.body.style.cursor = "grab";
            lenis.stop();
            gsap_1.default.to(position, {
              x: 0.0839237543,
              y: 0.1037008601,
              z: 8.7612671824,
              duration: 2,
              ease: "power3.inOut",
              onUpdate: onUpdate
            });
            gsap_1.default.to(target, {
              x: -0.090409699,
              y: -0.1412006725,
              z: 1.2365247667,
              duration: 2,
              ease: "power3.inOut",
              onUpdate: onUpdate,
              onComplete: enableControlers
            });
          });
          // EXIT CUSTOMIZER
          exitButton.addEventListener('click', function () {
            gsap_1.default.to(position, {
              x: 3.9316301915,
              y: 0.0214822679,
              z: 8.8170936667,
              duration: 1,
              ease: "power3.inOut",
              onUpdate: onUpdate
            });
            gsap_1.default.to(target, {
              x: -1.8924579969,
              y: -0.1001227761,
              z: 1.0390845144,
              duration: 1,
              ease: "power3.inOut",
              onUpdate: onUpdate
            });
            viewer.scene.activeCamera.setCameraOptions({
              controlsEnabled: false
            });
            sections.style.display = "contents";
            footer.style.display = "contents";
            mainContainer.style.pointerEvents = "none";
            document.body.style.cursor = "default";
            exitButton.style.display = "none";
            customizerInterface.style.display = "none";
            lenis.start();
          });
          return [2 /*return*/];
      }
    });
  });
}

setupViewer();
},{"webgi":"node_modules/webgi/dist/examples/runtime/bundle.m.js","./styles.css":"src/styles.css","gsap":"node_modules/gsap/index.js","gsap/ScrollTrigger":"node_modules/gsap/ScrollTrigger.js","@studio-freight/lenis":"node_modules/@studio-freight/lenis/dist/lenis.mjs"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "57555" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.ts"], null)
//# sourceMappingURL=/src.f10117fe.js.map